var qO = Object.defineProperty;
var NI = r => {
    throw TypeError(r)
};
var WO = (r, l, p) => l in r ? qO(r, l, {enumerable: !0, configurable: !0, writable: !0, value: p}) : r[l] = p;
var ec = (r, l, p) => WO(r, typeof l != "symbol" ? l + "" : l, p), Lw = (r, l, p) => l.has(r) || NI("Cannot " + p);
var Dt = (r, l, p) => (Lw(r, l, "read from private field"), p ? p.call(r) : l.get(r)),
    Wn = (r, l, p) => l.has(r) ? NI("Cannot add the same private member more than once") : l instanceof WeakSet ? l.add(r) : l.set(r, p),
    fn = (r, l, p, y) => (Lw(r, l, "write to private field"), y ? y.call(r, p) : l.set(r, p), p),
    jo = (r, l, p) => (Lw(r, l, "access private method"), p);
var D0 = (r, l, p, y) => ({
    set _(T) {
        fn(r, l, T, p)
    }, get _() {
        return Dt(r, l, y)
    }
});

function ZO(r, l) {
    for (var p = 0; p < l.length; p++) {
        const y = l[p];
        if (typeof y != "string" && !Array.isArray(y)) {
            for (const T in y) if (T !== "default" && !(T in r)) {
                const A = Object.getOwnPropertyDescriptor(y, T);
                A && Object.defineProperty(r, T, A.get ? A : {enumerable: !0, get: () => y[T]})
            }
        }
    }
    return Object.freeze(Object.defineProperty(r, Symbol.toStringTag, {value: "Module"}))
}

(function () {
    const l = document.createElement("link").relList;
    if (l && l.supports && l.supports("modulepreload")) return;
    for (const T of document.querySelectorAll('link[rel="modulepreload"]')) y(T);
    new MutationObserver(T => {
        for (const A of T) if (A.type === "childList") for (const D of A.addedNodes) D.tagName === "LINK" && D.rel === "modulepreload" && y(D)
    }).observe(document, {childList: !0, subtree: !0});

    function p(T) {
        const A = {};
        return T.integrity && (A.integrity = T.integrity), T.referrerPolicy && (A.referrerPolicy = T.referrerPolicy), T.crossOrigin === "use-credentials" ? A.credentials = "include" : T.crossOrigin === "anonymous" ? A.credentials = "omit" : A.credentials = "same-origin", A
    }

    function y(T) {
        if (T.ep) return;
        T.ep = !0;
        const A = p(T);
        fetch(T.href, A)
    }
})();
var XO = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function vp(r) {
    return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r
}

var $P = {exports: {}}, ox = {}, HP = {exports: {}}, Rn = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var E_ = Symbol.for("react.element"), YO = Symbol.for("react.portal"), KO = Symbol.for("react.fragment"),
    QO = Symbol.for("react.strict_mode"), JO = Symbol.for("react.profiler"), eF = Symbol.for("react.provider"),
    tF = Symbol.for("react.context"), iF = Symbol.for("react.forward_ref"), nF = Symbol.for("react.suspense"),
    rF = Symbol.for("react.memo"), oF = Symbol.for("react.lazy"), jI = Symbol.iterator;

function sF(r) {
    return r === null || typeof r != "object" ? null : (r = jI && r[jI] || r["@@iterator"], typeof r == "function" ? r : null)
}

var qP = {
    isMounted: function () {
        return !1
    }, enqueueForceUpdate: function () {
    }, enqueueReplaceState: function () {
    }, enqueueSetState: function () {
    }
}, WP = Object.assign, ZP = {};

function xp(r, l, p) {
    this.props = r, this.context = l, this.refs = ZP, this.updater = p || qP
}

xp.prototype.isReactComponent = {};
xp.prototype.setState = function (r, l) {
    if (typeof r != "object" && typeof r != "function" && r != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, r, l, "setState")
};
xp.prototype.forceUpdate = function (r) {
    this.updater.enqueueForceUpdate(this, r, "forceUpdate")
};

function XP() {
}

XP.prototype = xp.prototype;

function zT(r, l, p) {
    this.props = r, this.context = l, this.refs = ZP, this.updater = p || qP
}

var DT = zT.prototype = new XP;
DT.constructor = zT;
WP(DT, xp.prototype);
DT.isPureReactComponent = !0;
var VI = Array.isArray, YP = Object.prototype.hasOwnProperty, LT = {current: null},
    KP = {key: !0, ref: !0, __self: !0, __source: !0};

function QP(r, l, p) {
    var y, T = {}, A = null, D = null;
    if (l != null) for (y in l.ref !== void 0 && (D = l.ref), l.key !== void 0 && (A = "" + l.key), l) YP.call(l, y) && !KP.hasOwnProperty(y) && (T[y] = l[y]);
    var o = arguments.length - 2;
    if (o === 1) T.children = p; else if (1 < o) {
        for (var j = Array(o), q = 0; q < o; q++) j[q] = arguments[q + 2];
        T.children = j
    }
    if (r && r.defaultProps) for (y in o = r.defaultProps, o) T[y] === void 0 && (T[y] = o[y]);
    return {$$typeof: E_, type: r, key: A, ref: D, props: T, _owner: LT.current}
}

function aF(r, l) {
    return {$$typeof: E_, type: r.type, key: l, ref: r.ref, props: r.props, _owner: r._owner}
}

function kT(r) {
    return typeof r == "object" && r !== null && r.$$typeof === E_
}

function lF(r) {
    var l = {"=": "=0", ":": "=2"};
    return "$" + r.replace(/[=:]/g, function (p) {
        return l[p]
    })
}

var UI = /\/+/g;

function kw(r, l) {
    return typeof r == "object" && r !== null && r.key != null ? lF("" + r.key) : l.toString(36)
}

function rv(r, l, p, y, T) {
    var A = typeof r;
    (A === "undefined" || A === "boolean") && (r = null);
    var D = !1;
    if (r === null) D = !0; else switch (A) {
        case"string":
        case"number":
            D = !0;
            break;
        case"object":
            switch (r.$$typeof) {
                case E_:
                case YO:
                    D = !0
            }
    }
    if (D) return D = r, T = T(D), r = y === "" ? "." + kw(D, 0) : y, VI(T) ? (p = "", r != null && (p = r.replace(UI, "$&/") + "/"), rv(T, l, p, "", function (q) {
        return q
    })) : T != null && (kT(T) && (T = aF(T, p + (!T.key || D && D.key === T.key ? "" : ("" + T.key).replace(UI, "$&/") + "/") + r)), l.push(T)), 1;
    if (D = 0, y = y === "" ? "." : y + ":", VI(r)) for (var o = 0; o < r.length; o++) {
        A = r[o];
        var j = y + kw(A, o);
        D += rv(A, l, p, j, T)
    } else if (j = sF(r), typeof j == "function") for (r = j.call(r), o = 0; !(A = r.next()).done;) A = A.value, j = y + kw(A, o++), D += rv(A, l, p, j, T); else if (A === "object") throw l = String(r), Error("Objects are not valid as a React child (found: " + (l === "[object Object]" ? "object with keys {" + Object.keys(r).join(", ") + "}" : l) + "). If you meant to render a collection of children, use an array instead.");
    return D
}

function L0(r, l, p) {
    if (r == null) return r;
    var y = [], T = 0;
    return rv(r, y, "", "", function (A) {
        return l.call(p, A, T++)
    }), y
}

function cF(r) {
    if (r._status === -1) {
        var l = r._result;
        l = l(), l.then(function (p) {
            (r._status === 0 || r._status === -1) && (r._status = 1, r._result = p)
        }, function (p) {
            (r._status === 0 || r._status === -1) && (r._status = 2, r._result = p)
        }), r._status === -1 && (r._status = 0, r._result = l)
    }
    if (r._status === 1) return r._result.default;
    throw r._result
}

var hs = {current: null}, ov = {transition: null},
    uF = {ReactCurrentDispatcher: hs, ReactCurrentBatchConfig: ov, ReactCurrentOwner: LT};

function JP() {
    throw Error("act(...) is not supported in production builds of React.")
}

Rn.Children = {
    map: L0, forEach: function (r, l, p) {
        L0(r, function () {
            l.apply(this, arguments)
        }, p)
    }, count: function (r) {
        var l = 0;
        return L0(r, function () {
            l++
        }), l
    }, toArray: function (r) {
        return L0(r, function (l) {
            return l
        }) || []
    }, only: function (r) {
        if (!kT(r)) throw Error("React.Children.only expected to receive a single React element child.");
        return r
    }
};
Rn.Component = xp;
Rn.Fragment = KO;
Rn.Profiler = JO;
Rn.PureComponent = zT;
Rn.StrictMode = QO;
Rn.Suspense = nF;
Rn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = uF;
Rn.act = JP;
Rn.cloneElement = function (r, l, p) {
    if (r == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + r + ".");
    var y = WP({}, r.props), T = r.key, A = r.ref, D = r._owner;
    if (l != null) {
        if (l.ref !== void 0 && (A = l.ref, D = LT.current), l.key !== void 0 && (T = "" + l.key), r.type && r.type.defaultProps) var o = r.type.defaultProps;
        for (j in l) YP.call(l, j) && !KP.hasOwnProperty(j) && (y[j] = l[j] === void 0 && o !== void 0 ? o[j] : l[j])
    }
    var j = arguments.length - 2;
    if (j === 1) y.children = p; else if (1 < j) {
        o = Array(j);
        for (var q = 0; q < j; q++) o[q] = arguments[q + 2];
        y.children = o
    }
    return {$$typeof: E_, type: r.type, key: T, ref: A, props: y, _owner: D}
};
Rn.createContext = function (r) {
    return r = {
        $$typeof: tF,
        _currentValue: r,
        _currentValue2: r,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    }, r.Provider = {$$typeof: eF, _context: r}, r.Consumer = r
};
Rn.createElement = QP;
Rn.createFactory = function (r) {
    var l = QP.bind(null, r);
    return l.type = r, l
};
Rn.createRef = function () {
    return {current: null}
};
Rn.forwardRef = function (r) {
    return {$$typeof: iF, render: r}
};
Rn.isValidElement = kT;
Rn.lazy = function (r) {
    return {$$typeof: oF, _payload: {_status: -1, _result: r}, _init: cF}
};
Rn.memo = function (r, l) {
    return {$$typeof: rF, type: r, compare: l === void 0 ? null : l}
};
Rn.startTransition = function (r) {
    var l = ov.transition;
    ov.transition = {};
    try {
        r()
    } finally {
        ov.transition = l
    }
};
Rn.unstable_act = JP;
Rn.useCallback = function (r, l) {
    return hs.current.useCallback(r, l)
};
Rn.useContext = function (r) {
    return hs.current.useContext(r)
};
Rn.useDebugValue = function () {
};
Rn.useDeferredValue = function (r) {
    return hs.current.useDeferredValue(r)
};
Rn.useEffect = function (r, l) {
    return hs.current.useEffect(r, l)
};
Rn.useId = function () {
    return hs.current.useId()
};
Rn.useImperativeHandle = function (r, l, p) {
    return hs.current.useImperativeHandle(r, l, p)
};
Rn.useInsertionEffect = function (r, l) {
    return hs.current.useInsertionEffect(r, l)
};
Rn.useLayoutEffect = function (r, l) {
    return hs.current.useLayoutEffect(r, l)
};
Rn.useMemo = function (r, l) {
    return hs.current.useMemo(r, l)
};
Rn.useReducer = function (r, l, p) {
    return hs.current.useReducer(r, l, p)
};
Rn.useRef = function (r) {
    return hs.current.useRef(r)
};
Rn.useState = function (r) {
    return hs.current.useState(r)
};
Rn.useSyncExternalStore = function (r, l, p) {
    return hs.current.useSyncExternalStore(r, l, p)
};
Rn.useTransition = function () {
    return hs.current.useTransition()
};
Rn.version = "18.3.1";
HP.exports = Rn;
var Ce = HP.exports;
const jt = vp(Ce), OT = ZO({__proto__: null, default: jt}, [Ce]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hF = Ce, dF = Symbol.for("react.element"), fF = Symbol.for("react.fragment"),
    pF = Object.prototype.hasOwnProperty, mF = hF.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    gF = {key: !0, ref: !0, __self: !0, __source: !0};

function eM(r, l, p) {
    var y, T = {}, A = null, D = null;
    p !== void 0 && (A = "" + p), l.key !== void 0 && (A = "" + l.key), l.ref !== void 0 && (D = l.ref);
    for (y in l) pF.call(l, y) && !gF.hasOwnProperty(y) && (T[y] = l[y]);
    if (r && r.defaultProps) for (y in l = r.defaultProps, l) T[y] === void 0 && (T[y] = l[y]);
    return {$$typeof: dF, type: r, key: A, ref: D, props: T, _owner: mF.current}
}

ox.Fragment = fF;
ox.jsx = eM;
ox.jsxs = eM;
$P.exports = ox;
var K = $P.exports, tM = {exports: {}}, Zs = {}, iM = {exports: {}}, nM = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (r) {
    function l(Ct, Rt) {
        var ni = Ct.length;
        Ct.push(Rt);
        e:for (; 0 < ni;) {
            var ai = ni - 1 >>> 1, fi = Ct[ai];
            if (0 < T(fi, Rt)) Ct[ai] = Rt, Ct[ni] = fi, ni = ai; else break e
        }
    }

    function p(Ct) {
        return Ct.length === 0 ? null : Ct[0]
    }

    function y(Ct) {
        if (Ct.length === 0) return null;
        var Rt = Ct[0], ni = Ct.pop();
        if (ni !== Rt) {
            Ct[0] = ni;
            e:for (var ai = 0, fi = Ct.length, nn = fi >>> 1; ai < nn;) {
                var cn = 2 * (ai + 1) - 1, Zn = Ct[cn], Bi = cn + 1, Ii = Ct[Bi];
                if (0 > T(Zn, ni)) Bi < fi && 0 > T(Ii, Zn) ? (Ct[ai] = Ii, Ct[Bi] = ni, ai = Bi) : (Ct[ai] = Zn, Ct[cn] = ni, ai = cn); else if (Bi < fi && 0 > T(Ii, ni)) Ct[ai] = Ii, Ct[Bi] = ni, ai = Bi; else break e
            }
        }
        return Rt
    }

    function T(Ct, Rt) {
        var ni = Ct.sortIndex - Rt.sortIndex;
        return ni !== 0 ? ni : Ct.id - Rt.id
    }

    if (typeof performance == "object" && typeof performance.now == "function") {
        var A = performance;
        r.unstable_now = function () {
            return A.now()
        }
    } else {
        var D = Date, o = D.now();
        r.unstable_now = function () {
            return D.now() - o
        }
    }
    var j = [], q = [], ee = 1, oe = null, de = 3, ae = !1, Re = !1, fe = !1,
        Me = typeof setTimeout == "function" ? setTimeout : null,
        pe = typeof clearTimeout == "function" ? clearTimeout : null,
        le = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

    function be(Ct) {
        for (var Rt = p(q); Rt !== null;) {
            if (Rt.callback === null) y(q); else if (Rt.startTime <= Ct) y(q), Rt.sortIndex = Rt.expirationTime, l(j, Rt); else break;
            Rt = p(q)
        }
    }

    function Ue(Ct) {
        if (fe = !1, be(Ct), !Re) if (p(j) !== null) Re = !0, si(et); else {
            var Rt = p(q);
            Rt !== null && Ri(Ue, Rt.startTime - Ct)
        }
    }

    function et(Ct, Rt) {
        Re = !1, fe && (fe = !1, pe(Mt), Mt = -1), ae = !0;
        var ni = de;
        try {
            for (be(Rt), oe = p(j); oe !== null && (!(oe.expirationTime > Rt) || Ct && !Ht());) {
                var ai = oe.callback;
                if (typeof ai == "function") {
                    oe.callback = null, de = oe.priorityLevel;
                    var fi = ai(oe.expirationTime <= Rt);
                    Rt = r.unstable_now(), typeof fi == "function" ? oe.callback = fi : oe === p(j) && y(j), be(Rt)
                } else y(j);
                oe = p(j)
            }
            if (oe !== null) var nn = !0; else {
                var cn = p(q);
                cn !== null && Ri(Ue, cn.startTime - Rt), nn = !1
            }
            return nn
        } finally {
            oe = null, de = ni, ae = !1
        }
    }

    var _t = !1, xt = null, Mt = -1, Xt = 5, Zt = -1;

    function Ht() {
        return !(r.unstable_now() - Zt < Xt)
    }

    function hi() {
        if (xt !== null) {
            var Ct = r.unstable_now();
            Zt = Ct;
            var Rt = !0;
            try {
                Rt = xt(!0, Ct)
            } finally {
                Rt ? Mi() : (_t = !1, xt = null)
            }
        } else _t = !1
    }

    var Mi;
    if (typeof le == "function") Mi = function () {
        le(hi)
    }; else if (typeof MessageChannel < "u") {
        var $t = new MessageChannel, _i = $t.port2;
        $t.port1.onmessage = hi, Mi = function () {
            _i.postMessage(null)
        }
    } else Mi = function () {
        Me(hi, 0)
    };

    function si(Ct) {
        xt = Ct, _t || (_t = !0, Mi())
    }

    function Ri(Ct, Rt) {
        Mt = Me(function () {
            Ct(r.unstable_now())
        }, Rt)
    }

    r.unstable_IdlePriority = 5, r.unstable_ImmediatePriority = 1, r.unstable_LowPriority = 4, r.unstable_NormalPriority = 3, r.unstable_Profiling = null, r.unstable_UserBlockingPriority = 2, r.unstable_cancelCallback = function (Ct) {
        Ct.callback = null
    }, r.unstable_continueExecution = function () {
        Re || ae || (Re = !0, si(et))
    }, r.unstable_forceFrameRate = function (Ct) {
        0 > Ct || 125 < Ct ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Xt = 0 < Ct ? Math.floor(1e3 / Ct) : 5
    }, r.unstable_getCurrentPriorityLevel = function () {
        return de
    }, r.unstable_getFirstCallbackNode = function () {
        return p(j)
    }, r.unstable_next = function (Ct) {
        switch (de) {
            case 1:
            case 2:
            case 3:
                var Rt = 3;
                break;
            default:
                Rt = de
        }
        var ni = de;
        de = Rt;
        try {
            return Ct()
        } finally {
            de = ni
        }
    }, r.unstable_pauseExecution = function () {
    }, r.unstable_requestPaint = function () {
    }, r.unstable_runWithPriority = function (Ct, Rt) {
        switch (Ct) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                Ct = 3
        }
        var ni = de;
        de = Ct;
        try {
            return Rt()
        } finally {
            de = ni
        }
    }, r.unstable_scheduleCallback = function (Ct, Rt, ni) {
        var ai = r.unstable_now();
        switch (typeof ni == "object" && ni !== null ? (ni = ni.delay, ni = typeof ni == "number" && 0 < ni ? ai + ni : ai) : ni = ai, Ct) {
            case 1:
                var fi = -1;
                break;
            case 2:
                fi = 250;
                break;
            case 5:
                fi = 1073741823;
                break;
            case 4:
                fi = 1e4;
                break;
            default:
                fi = 5e3
        }
        return fi = ni + fi, Ct = {
            id: ee++,
            callback: Rt,
            priorityLevel: Ct,
            startTime: ni,
            expirationTime: fi,
            sortIndex: -1
        }, ni > ai ? (Ct.sortIndex = ni, l(q, Ct), p(j) === null && Ct === p(q) && (fe ? (pe(Mt), Mt = -1) : fe = !0, Ri(Ue, ni - ai))) : (Ct.sortIndex = fi, l(j, Ct), Re || ae || (Re = !0, si(et))), Ct
    }, r.unstable_shouldYield = Ht, r.unstable_wrapCallback = function (Ct) {
        var Rt = de;
        return function () {
            var ni = de;
            de = Rt;
            try {
                return Ct.apply(this, arguments)
            } finally {
                de = ni
            }
        }
    }
})(nM);
iM.exports = nM;
var _F = iM.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var yF = Ce, qs = _F;

function Wt(r) {
    for (var l = "https://reactjs.org/docs/error-decoder.html?invariant=" + r, p = 1; p < arguments.length; p++) l += "&args[]=" + encodeURIComponent(arguments[p]);
    return "Minified React error #" + r + "; visit " + l + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}

var rM = new Set, e_ = {};

function sd(r, l) {
    lp(r, l), lp(r + "Capture", l)
}

function lp(r, l) {
    for (e_[r] = l, r = 0; r < l.length; r++) rM.add(l[r])
}

var cc = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"),
    xb = Object.prototype.hasOwnProperty,
    vF = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    GI = {}, $I = {};

function xF(r) {
    return xb.call($I, r) ? !0 : xb.call(GI, r) ? !1 : vF.test(r) ? $I[r] = !0 : (GI[r] = !0, !1)
}

function wF(r, l, p, y) {
    if (p !== null && p.type === 0) return !1;
    switch (typeof l) {
        case"function":
        case"symbol":
            return !0;
        case"boolean":
            return y ? !1 : p !== null ? !p.acceptsBooleans : (r = r.toLowerCase().slice(0, 5), r !== "data-" && r !== "aria-");
        default:
            return !1
    }
}

function bF(r, l, p, y) {
    if (l === null || typeof l > "u" || wF(r, l, p, y)) return !0;
    if (y) return !1;
    if (p !== null) switch (p.type) {
        case 3:
            return !l;
        case 4:
            return l === !1;
        case 5:
            return isNaN(l);
        case 6:
            return isNaN(l) || 1 > l
    }
    return !1
}

function ds(r, l, p, y, T, A, D) {
    this.acceptsBooleans = l === 2 || l === 3 || l === 4, this.attributeName = y, this.attributeNamespace = T, this.mustUseProperty = p, this.propertyName = r, this.type = l, this.sanitizeURL = A, this.removeEmptyString = D
}

var zo = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (r) {
    zo[r] = new ds(r, 0, !1, r, null, !1, !1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (r) {
    var l = r[0];
    zo[l] = new ds(l, 1, !1, r[1], null, !1, !1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (r) {
    zo[r] = new ds(r, 2, !1, r.toLowerCase(), null, !1, !1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (r) {
    zo[r] = new ds(r, 2, !1, r, null, !1, !1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (r) {
    zo[r] = new ds(r, 3, !1, r.toLowerCase(), null, !1, !1)
});
["checked", "multiple", "muted", "selected"].forEach(function (r) {
    zo[r] = new ds(r, 3, !0, r, null, !1, !1)
});
["capture", "download"].forEach(function (r) {
    zo[r] = new ds(r, 4, !1, r, null, !1, !1)
});
["cols", "rows", "size", "span"].forEach(function (r) {
    zo[r] = new ds(r, 6, !1, r, null, !1, !1)
});
["rowSpan", "start"].forEach(function (r) {
    zo[r] = new ds(r, 5, !1, r.toLowerCase(), null, !1, !1)
});
var FT = /[\-:]([a-z])/g;

function BT(r) {
    return r[1].toUpperCase()
}

"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (r) {
    var l = r.replace(FT, BT);
    zo[l] = new ds(l, 1, !1, r, null, !1, !1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (r) {
    var l = r.replace(FT, BT);
    zo[l] = new ds(l, 1, !1, r, "http://www.w3.org/1999/xlink", !1, !1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function (r) {
    var l = r.replace(FT, BT);
    zo[l] = new ds(l, 1, !1, r, "http://www.w3.org/XML/1998/namespace", !1, !1)
});
["tabIndex", "crossOrigin"].forEach(function (r) {
    zo[r] = new ds(r, 1, !1, r.toLowerCase(), null, !1, !1)
});
zo.xlinkHref = new ds("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function (r) {
    zo[r] = new ds(r, 1, !1, r.toLowerCase(), null, !0, !0)
});

function NT(r, l, p, y) {
    var T = zo.hasOwnProperty(l) ? zo[l] : null;
    (T !== null ? T.type !== 0 : y || !(2 < l.length) || l[0] !== "o" && l[0] !== "O" || l[1] !== "n" && l[1] !== "N") && (bF(l, p, T, y) && (p = null), y || T === null ? xF(l) && (p === null ? r.removeAttribute(l) : r.setAttribute(l, "" + p)) : T.mustUseProperty ? r[T.propertyName] = p === null ? T.type === 3 ? !1 : "" : p : (l = T.attributeName, y = T.attributeNamespace, p === null ? r.removeAttribute(l) : (T = T.type, p = T === 3 || T === 4 && p === !0 ? "" : "" + p, y ? r.setAttributeNS(y, l, p) : r.setAttribute(l, p))))
}

var mc = yF.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, k0 = Symbol.for("react.element"),
    zf = Symbol.for("react.portal"), Df = Symbol.for("react.fragment"), jT = Symbol.for("react.strict_mode"),
    wb = Symbol.for("react.profiler"), oM = Symbol.for("react.provider"), sM = Symbol.for("react.context"),
    VT = Symbol.for("react.forward_ref"), bb = Symbol.for("react.suspense"), Tb = Symbol.for("react.suspense_list"),
    UT = Symbol.for("react.memo"), du = Symbol.for("react.lazy"), aM = Symbol.for("react.offscreen"),
    HI = Symbol.iterator;

function Ig(r) {
    return r === null || typeof r != "object" ? null : (r = HI && r[HI] || r["@@iterator"], typeof r == "function" ? r : null)
}

var Er = Object.assign, Ow;

function Ng(r) {
    if (Ow === void 0) try {
        throw Error()
    } catch (p) {
        var l = p.stack.trim().match(/\n( *(at )?)/);
        Ow = l && l[1] || ""
    }
    return `
` + Ow + r
}

var Fw = !1;

function Bw(r, l) {
    if (!r || Fw) return "";
    Fw = !0;
    var p = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (l) if (l = function () {
            throw Error()
        }, Object.defineProperty(l.prototype, "props", {
            set: function () {
                throw Error()
            }
        }), typeof Reflect == "object" && Reflect.construct) {
            try {
                Reflect.construct(l, [])
            } catch (q) {
                var y = q
            }
            Reflect.construct(r, [], l)
        } else {
            try {
                l.call()
            } catch (q) {
                y = q
            }
            r.call(l.prototype)
        } else {
            try {
                throw Error()
            } catch (q) {
                y = q
            }
            r()
        }
    } catch (q) {
        if (q && y && typeof q.stack == "string") {
            for (var T = q.stack.split(`
`), A = y.stack.split(`
`), D = T.length - 1, o = A.length - 1; 1 <= D && 0 <= o && T[D] !== A[o];) o--;
            for (; 1 <= D && 0 <= o; D--, o--) if (T[D] !== A[o]) {
                if (D !== 1 || o !== 1) do if (D--, o--, 0 > o || T[D] !== A[o]) {
                    var j = `
` + T[D].replace(" at new ", " at ");
                    return r.displayName && j.includes("<anonymous>") && (j = j.replace("<anonymous>", r.displayName)), j
                } while (1 <= D && 0 <= o);
                break
            }
        }
    } finally {
        Fw = !1, Error.prepareStackTrace = p
    }
    return (r = r ? r.displayName || r.name : "") ? Ng(r) : ""
}

function TF(r) {
    switch (r.tag) {
        case 5:
            return Ng(r.type);
        case 16:
            return Ng("Lazy");
        case 13:
            return Ng("Suspense");
        case 19:
            return Ng("SuspenseList");
        case 0:
        case 2:
        case 15:
            return r = Bw(r.type, !1), r;
        case 11:
            return r = Bw(r.type.render, !1), r;
        case 1:
            return r = Bw(r.type, !0), r;
        default:
            return ""
    }
}

function Sb(r) {
    if (r == null) return null;
    if (typeof r == "function") return r.displayName || r.name || null;
    if (typeof r == "string") return r;
    switch (r) {
        case Df:
            return "Fragment";
        case zf:
            return "Portal";
        case wb:
            return "Profiler";
        case jT:
            return "StrictMode";
        case bb:
            return "Suspense";
        case Tb:
            return "SuspenseList"
    }
    if (typeof r == "object") switch (r.$$typeof) {
        case sM:
            return (r.displayName || "Context") + ".Consumer";
        case oM:
            return (r._context.displayName || "Context") + ".Provider";
        case VT:
            var l = r.render;
            return r = r.displayName, r || (r = l.displayName || l.name || "", r = r !== "" ? "ForwardRef(" + r + ")" : "ForwardRef"), r;
        case UT:
            return l = r.displayName || null, l !== null ? l : Sb(r.type) || "Memo";
        case du:
            l = r._payload, r = r._init;
            try {
                return Sb(r(l))
            } catch {
            }
    }
    return null
}

function SF(r) {
    var l = r.type;
    switch (r.tag) {
        case 24:
            return "Cache";
        case 9:
            return (l.displayName || "Context") + ".Consumer";
        case 10:
            return (l._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return r = l.render, r = r.displayName || r.name || "", l.displayName || (r !== "" ? "ForwardRef(" + r + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return l;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return Sb(l);
        case 8:
            return l === jT ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof l == "function") return l.displayName || l.name || null;
            if (typeof l == "string") return l
    }
    return null
}

function Du(r) {
    switch (typeof r) {
        case"boolean":
        case"number":
        case"string":
        case"undefined":
            return r;
        case"object":
            return r;
        default:
            return ""
    }
}

function lM(r) {
    var l = r.type;
    return (r = r.nodeName) && r.toLowerCase() === "input" && (l === "checkbox" || l === "radio")
}

function EF(r) {
    var l = lM(r) ? "checked" : "value", p = Object.getOwnPropertyDescriptor(r.constructor.prototype, l), y = "" + r[l];
    if (!r.hasOwnProperty(l) && typeof p < "u" && typeof p.get == "function" && typeof p.set == "function") {
        var T = p.get, A = p.set;
        return Object.defineProperty(r, l, {
            configurable: !0, get: function () {
                return T.call(this)
            }, set: function (D) {
                y = "" + D, A.call(this, D)
            }
        }), Object.defineProperty(r, l, {enumerable: p.enumerable}), {
            getValue: function () {
                return y
            }, setValue: function (D) {
                y = "" + D
            }, stopTracking: function () {
                r._valueTracker = null, delete r[l]
            }
        }
    }
}

function O0(r) {
    r._valueTracker || (r._valueTracker = EF(r))
}

function cM(r) {
    if (!r) return !1;
    var l = r._valueTracker;
    if (!l) return !0;
    var p = l.getValue(), y = "";
    return r && (y = lM(r) ? r.checked ? "true" : "false" : r.value), r = y, r !== p ? (l.setValue(r), !0) : !1
}

function Sv(r) {
    if (r = r || (typeof document < "u" ? document : void 0), typeof r > "u") return null;
    try {
        return r.activeElement || r.body
    } catch {
        return r.body
    }
}

function Eb(r, l) {
    var p = l.checked;
    return Er({}, l, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: p ?? r._wrapperState.initialChecked
    })
}

function qI(r, l) {
    var p = l.defaultValue == null ? "" : l.defaultValue, y = l.checked != null ? l.checked : l.defaultChecked;
    p = Du(l.value != null ? l.value : p), r._wrapperState = {
        initialChecked: y,
        initialValue: p,
        controlled: l.type === "checkbox" || l.type === "radio" ? l.checked != null : l.value != null
    }
}

function uM(r, l) {
    l = l.checked, l != null && NT(r, "checked", l, !1)
}

function Ab(r, l) {
    uM(r, l);
    var p = Du(l.value), y = l.type;
    if (p != null) y === "number" ? (p === 0 && r.value === "" || r.value != p) && (r.value = "" + p) : r.value !== "" + p && (r.value = "" + p); else if (y === "submit" || y === "reset") {
        r.removeAttribute("value");
        return
    }
    l.hasOwnProperty("value") ? Ib(r, l.type, p) : l.hasOwnProperty("defaultValue") && Ib(r, l.type, Du(l.defaultValue)), l.checked == null && l.defaultChecked != null && (r.defaultChecked = !!l.defaultChecked)
}

function WI(r, l, p) {
    if (l.hasOwnProperty("value") || l.hasOwnProperty("defaultValue")) {
        var y = l.type;
        if (!(y !== "submit" && y !== "reset" || l.value !== void 0 && l.value !== null)) return;
        l = "" + r._wrapperState.initialValue, p || l === r.value || (r.value = l), r.defaultValue = l
    }
    p = r.name, p !== "" && (r.name = ""), r.defaultChecked = !!r._wrapperState.initialChecked, p !== "" && (r.name = p)
}

function Ib(r, l, p) {
    (l !== "number" || Sv(r.ownerDocument) !== r) && (p == null ? r.defaultValue = "" + r._wrapperState.initialValue : r.defaultValue !== "" + p && (r.defaultValue = "" + p))
}

var jg = Array.isArray;

function $f(r, l, p, y) {
    if (r = r.options, l) {
        l = {};
        for (var T = 0; T < p.length; T++) l["$" + p[T]] = !0;
        for (p = 0; p < r.length; p++) T = l.hasOwnProperty("$" + r[p].value), r[p].selected !== T && (r[p].selected = T), T && y && (r[p].defaultSelected = !0)
    } else {
        for (p = "" + Du(p), l = null, T = 0; T < r.length; T++) {
            if (r[T].value === p) {
                r[T].selected = !0, y && (r[T].defaultSelected = !0);
                return
            }
            l !== null || r[T].disabled || (l = r[T])
        }
        l !== null && (l.selected = !0)
    }
}

function Cb(r, l) {
    if (l.dangerouslySetInnerHTML != null) throw Error(Wt(91));
    return Er({}, l, {value: void 0, defaultValue: void 0, children: "" + r._wrapperState.initialValue})
}

function ZI(r, l) {
    var p = l.value;
    if (p == null) {
        if (p = l.children, l = l.defaultValue, p != null) {
            if (l != null) throw Error(Wt(92));
            if (jg(p)) {
                if (1 < p.length) throw Error(Wt(93));
                p = p[0]
            }
            l = p
        }
        l == null && (l = ""), p = l
    }
    r._wrapperState = {initialValue: Du(p)}
}

function hM(r, l) {
    var p = Du(l.value), y = Du(l.defaultValue);
    p != null && (p = "" + p, p !== r.value && (r.value = p), l.defaultValue == null && r.defaultValue !== p && (r.defaultValue = p)), y != null && (r.defaultValue = "" + y)
}

function XI(r) {
    var l = r.textContent;
    l === r._wrapperState.initialValue && l !== "" && l !== null && (r.value = l)
}

function dM(r) {
    switch (r) {
        case"svg":
            return "http://www.w3.org/2000/svg";
        case"math":
            return "http://www.w3.org/1998/Math/MathML";
        default:
            return "http://www.w3.org/1999/xhtml"
    }
}

function Pb(r, l) {
    return r == null || r === "http://www.w3.org/1999/xhtml" ? dM(l) : r === "http://www.w3.org/2000/svg" && l === "foreignObject" ? "http://www.w3.org/1999/xhtml" : r
}

var F0, fM = function (r) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (l, p, y, T) {
        MSApp.execUnsafeLocalFunction(function () {
            return r(l, p, y, T)
        })
    } : r
}(function (r, l) {
    if (r.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in r) r.innerHTML = l; else {
        for (F0 = F0 || document.createElement("div"), F0.innerHTML = "<svg>" + l.valueOf().toString() + "</svg>", l = F0.firstChild; r.firstChild;) r.removeChild(r.firstChild);
        for (; l.firstChild;) r.appendChild(l.firstChild)
    }
});

function t_(r, l) {
    if (l) {
        var p = r.firstChild;
        if (p && p === r.lastChild && p.nodeType === 3) {
            p.nodeValue = l;
            return
        }
    }
    r.textContent = l
}

var $g = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}, AF = ["Webkit", "ms", "Moz", "O"];
Object.keys($g).forEach(function (r) {
    AF.forEach(function (l) {
        l = l + r.charAt(0).toUpperCase() + r.substring(1), $g[l] = $g[r]
    })
});

function pM(r, l, p) {
    return l == null || typeof l == "boolean" || l === "" ? "" : p || typeof l != "number" || l === 0 || $g.hasOwnProperty(r) && $g[r] ? ("" + l).trim() : l + "px"
}

function mM(r, l) {
    r = r.style;
    for (var p in l) if (l.hasOwnProperty(p)) {
        var y = p.indexOf("--") === 0, T = pM(p, l[p], y);
        p === "float" && (p = "cssFloat"), y ? r.setProperty(p, T) : r[p] = T
    }
}

var IF = Er({menuitem: !0}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});

function Mb(r, l) {
    if (l) {
        if (IF[r] && (l.children != null || l.dangerouslySetInnerHTML != null)) throw Error(Wt(137, r));
        if (l.dangerouslySetInnerHTML != null) {
            if (l.children != null) throw Error(Wt(60));
            if (typeof l.dangerouslySetInnerHTML != "object" || !("__html" in l.dangerouslySetInnerHTML)) throw Error(Wt(61))
        }
        if (l.style != null && typeof l.style != "object") throw Error(Wt(62))
    }
}

function Rb(r, l) {
    if (r.indexOf("-") === -1) return typeof l.is == "string";
    switch (r) {
        case"annotation-xml":
        case"color-profile":
        case"font-face":
        case"font-face-src":
        case"font-face-uri":
        case"font-face-format":
        case"font-face-name":
        case"missing-glyph":
            return !1;
        default:
            return !0
    }
}

var zb = null;

function GT(r) {
    return r = r.target || r.srcElement || window, r.correspondingUseElement && (r = r.correspondingUseElement), r.nodeType === 3 ? r.parentNode : r
}

var Db = null, Hf = null, qf = null;

function YI(r) {
    if (r = C_(r)) {
        if (typeof Db != "function") throw Error(Wt(280));
        var l = r.stateNode;
        l && (l = ux(l), Db(r.stateNode, r.type, l))
    }
}

function gM(r) {
    Hf ? qf ? qf.push(r) : qf = [r] : Hf = r
}

function _M() {
    if (Hf) {
        var r = Hf, l = qf;
        if (qf = Hf = null, YI(r), l) for (r = 0; r < l.length; r++) YI(l[r])
    }
}

function yM(r, l) {
    return r(l)
}

function vM() {
}

var Nw = !1;

function xM(r, l, p) {
    if (Nw) return r(l, p);
    Nw = !0;
    try {
        return yM(r, l, p)
    } finally {
        Nw = !1, (Hf !== null || qf !== null) && (vM(), _M())
    }
}

function i_(r, l) {
    var p = r.stateNode;
    if (p === null) return null;
    var y = ux(p);
    if (y === null) return null;
    p = y[l];
    e:switch (l) {
        case"onClick":
        case"onClickCapture":
        case"onDoubleClick":
        case"onDoubleClickCapture":
        case"onMouseDown":
        case"onMouseDownCapture":
        case"onMouseMove":
        case"onMouseMoveCapture":
        case"onMouseUp":
        case"onMouseUpCapture":
        case"onMouseEnter":
            (y = !y.disabled) || (r = r.type, y = !(r === "button" || r === "input" || r === "select" || r === "textarea")), r = !y;
            break e;
        default:
            r = !1
    }
    if (r) return null;
    if (p && typeof p != "function") throw Error(Wt(231, l, typeof p));
    return p
}

var Lb = !1;
if (cc) try {
    var Cg = {};
    Object.defineProperty(Cg, "passive", {
        get: function () {
            Lb = !0
        }
    }), window.addEventListener("test", Cg, Cg), window.removeEventListener("test", Cg, Cg)
} catch {
    Lb = !1
}

function CF(r, l, p, y, T, A, D, o, j) {
    var q = Array.prototype.slice.call(arguments, 3);
    try {
        l.apply(p, q)
    } catch (ee) {
        this.onError(ee)
    }
}

var Hg = !1, Ev = null, Av = !1, kb = null, PF = {
    onError: function (r) {
        Hg = !0, Ev = r
    }
};

function MF(r, l, p, y, T, A, D, o, j) {
    Hg = !1, Ev = null, CF.apply(PF, arguments)
}

function RF(r, l, p, y, T, A, D, o, j) {
    if (MF.apply(this, arguments), Hg) {
        if (Hg) {
            var q = Ev;
            Hg = !1, Ev = null
        } else throw Error(Wt(198));
        Av || (Av = !0, kb = q)
    }
}

function ad(r) {
    var l = r, p = r;
    if (r.alternate) for (; l.return;) l = l.return; else {
        r = l;
        do l = r, l.flags & 4098 && (p = l.return), r = l.return; while (r)
    }
    return l.tag === 3 ? p : null
}

function wM(r) {
    if (r.tag === 13) {
        var l = r.memoizedState;
        if (l === null && (r = r.alternate, r !== null && (l = r.memoizedState)), l !== null) return l.dehydrated
    }
    return null
}

function KI(r) {
    if (ad(r) !== r) throw Error(Wt(188))
}

function zF(r) {
    var l = r.alternate;
    if (!l) {
        if (l = ad(r), l === null) throw Error(Wt(188));
        return l !== r ? null : r
    }
    for (var p = r, y = l; ;) {
        var T = p.return;
        if (T === null) break;
        var A = T.alternate;
        if (A === null) {
            if (y = T.return, y !== null) {
                p = y;
                continue
            }
            break
        }
        if (T.child === A.child) {
            for (A = T.child; A;) {
                if (A === p) return KI(T), r;
                if (A === y) return KI(T), l;
                A = A.sibling
            }
            throw Error(Wt(188))
        }
        if (p.return !== y.return) p = T, y = A; else {
            for (var D = !1, o = T.child; o;) {
                if (o === p) {
                    D = !0, p = T, y = A;
                    break
                }
                if (o === y) {
                    D = !0, y = T, p = A;
                    break
                }
                o = o.sibling
            }
            if (!D) {
                for (o = A.child; o;) {
                    if (o === p) {
                        D = !0, p = A, y = T;
                        break
                    }
                    if (o === y) {
                        D = !0, y = A, p = T;
                        break
                    }
                    o = o.sibling
                }
                if (!D) throw Error(Wt(189))
            }
        }
        if (p.alternate !== y) throw Error(Wt(190))
    }
    if (p.tag !== 3) throw Error(Wt(188));
    return p.stateNode.current === p ? r : l
}

function bM(r) {
    return r = zF(r), r !== null ? TM(r) : null
}

function TM(r) {
    if (r.tag === 5 || r.tag === 6) return r;
    for (r = r.child; r !== null;) {
        var l = TM(r);
        if (l !== null) return l;
        r = r.sibling
    }
    return null
}

var SM = qs.unstable_scheduleCallback, QI = qs.unstable_cancelCallback, DF = qs.unstable_shouldYield,
    LF = qs.unstable_requestPaint, jr = qs.unstable_now, kF = qs.unstable_getCurrentPriorityLevel,
    $T = qs.unstable_ImmediatePriority, EM = qs.unstable_UserBlockingPriority, Iv = qs.unstable_NormalPriority,
    OF = qs.unstable_LowPriority, AM = qs.unstable_IdlePriority, sx = null, Sl = null;

function FF(r) {
    if (Sl && typeof Sl.onCommitFiberRoot == "function") try {
        Sl.onCommitFiberRoot(sx, r, void 0, (r.current.flags & 128) === 128)
    } catch {
    }
}

var ka = Math.clz32 ? Math.clz32 : jF, BF = Math.log, NF = Math.LN2;

function jF(r) {
    return r >>>= 0, r === 0 ? 32 : 31 - (BF(r) / NF | 0) | 0
}

var B0 = 64, N0 = 4194304;

function Vg(r) {
    switch (r & -r) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return r & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return r & 130023424;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return r
    }
}

function Cv(r, l) {
    var p = r.pendingLanes;
    if (p === 0) return 0;
    var y = 0, T = r.suspendedLanes, A = r.pingedLanes, D = p & 268435455;
    if (D !== 0) {
        var o = D & ~T;
        o !== 0 ? y = Vg(o) : (A &= D, A !== 0 && (y = Vg(A)))
    } else D = p & ~T, D !== 0 ? y = Vg(D) : A !== 0 && (y = Vg(A));
    if (y === 0) return 0;
    if (l !== 0 && l !== y && !(l & T) && (T = y & -y, A = l & -l, T >= A || T === 16 && (A & 4194240) !== 0)) return l;
    if (y & 4 && (y |= p & 16), l = r.entangledLanes, l !== 0) for (r = r.entanglements, l &= y; 0 < l;) p = 31 - ka(l), T = 1 << p, y |= r[p], l &= ~T;
    return y
}

function VF(r, l) {
    switch (r) {
        case 1:
        case 2:
        case 4:
            return l + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return l + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
    }
}

function UF(r, l) {
    for (var p = r.suspendedLanes, y = r.pingedLanes, T = r.expirationTimes, A = r.pendingLanes; 0 < A;) {
        var D = 31 - ka(A), o = 1 << D, j = T[D];
        j === -1 ? (!(o & p) || o & y) && (T[D] = VF(o, l)) : j <= l && (r.expiredLanes |= o), A &= ~o
    }
}

function Ob(r) {
    return r = r.pendingLanes & -1073741825, r !== 0 ? r : r & 1073741824 ? 1073741824 : 0
}

function IM() {
    var r = B0;
    return B0 <<= 1, !(B0 & 4194240) && (B0 = 64), r
}

function jw(r) {
    for (var l = [], p = 0; 31 > p; p++) l.push(r);
    return l
}

function A_(r, l, p) {
    r.pendingLanes |= l, l !== 536870912 && (r.suspendedLanes = 0, r.pingedLanes = 0), r = r.eventTimes, l = 31 - ka(l), r[l] = p
}

function GF(r, l) {
    var p = r.pendingLanes & ~l;
    r.pendingLanes = l, r.suspendedLanes = 0, r.pingedLanes = 0, r.expiredLanes &= l, r.mutableReadLanes &= l, r.entangledLanes &= l, l = r.entanglements;
    var y = r.eventTimes;
    for (r = r.expirationTimes; 0 < p;) {
        var T = 31 - ka(p), A = 1 << T;
        l[T] = 0, y[T] = -1, r[T] = -1, p &= ~A
    }
}

function HT(r, l) {
    var p = r.entangledLanes |= l;
    for (r = r.entanglements; p;) {
        var y = 31 - ka(p), T = 1 << y;
        T & l | r[y] & l && (r[y] |= l), p &= ~T
    }
}

var nr = 0;

function CM(r) {
    return r &= -r, 1 < r ? 4 < r ? r & 268435455 ? 16 : 536870912 : 4 : 1
}

var PM, qT, MM, RM, zM, Fb = !1, j0 = [], Su = null, Eu = null, Au = null, n_ = new Map, r_ = new Map, pu = [],
    $F = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

function JI(r, l) {
    switch (r) {
        case"focusin":
        case"focusout":
            Su = null;
            break;
        case"dragenter":
        case"dragleave":
            Eu = null;
            break;
        case"mouseover":
        case"mouseout":
            Au = null;
            break;
        case"pointerover":
        case"pointerout":
            n_.delete(l.pointerId);
            break;
        case"gotpointercapture":
        case"lostpointercapture":
            r_.delete(l.pointerId)
    }
}

function Pg(r, l, p, y, T, A) {
    return r === null || r.nativeEvent !== A ? (r = {
        blockedOn: l,
        domEventName: p,
        eventSystemFlags: y,
        nativeEvent: A,
        targetContainers: [T]
    }, l !== null && (l = C_(l), l !== null && qT(l)), r) : (r.eventSystemFlags |= y, l = r.targetContainers, T !== null && l.indexOf(T) === -1 && l.push(T), r)
}

function HF(r, l, p, y, T) {
    switch (l) {
        case"focusin":
            return Su = Pg(Su, r, l, p, y, T), !0;
        case"dragenter":
            return Eu = Pg(Eu, r, l, p, y, T), !0;
        case"mouseover":
            return Au = Pg(Au, r, l, p, y, T), !0;
        case"pointerover":
            var A = T.pointerId;
            return n_.set(A, Pg(n_.get(A) || null, r, l, p, y, T)), !0;
        case"gotpointercapture":
            return A = T.pointerId, r_.set(A, Pg(r_.get(A) || null, r, l, p, y, T)), !0
    }
    return !1
}

function DM(r) {
    var l = Uh(r.target);
    if (l !== null) {
        var p = ad(l);
        if (p !== null) {
            if (l = p.tag, l === 13) {
                if (l = wM(p), l !== null) {
                    r.blockedOn = l, zM(r.priority, function () {
                        MM(p)
                    });
                    return
                }
            } else if (l === 3 && p.stateNode.current.memoizedState.isDehydrated) {
                r.blockedOn = p.tag === 3 ? p.stateNode.containerInfo : null;
                return
            }
        }
    }
    r.blockedOn = null
}

function sv(r) {
    if (r.blockedOn !== null) return !1;
    for (var l = r.targetContainers; 0 < l.length;) {
        var p = Bb(r.domEventName, r.eventSystemFlags, l[0], r.nativeEvent);
        if (p === null) {
            p = r.nativeEvent;
            var y = new p.constructor(p.type, p);
            zb = y, p.target.dispatchEvent(y), zb = null
        } else return l = C_(p), l !== null && qT(l), r.blockedOn = p, !1;
        l.shift()
    }
    return !0
}

function eC(r, l, p) {
    sv(r) && p.delete(l)
}

function qF() {
    Fb = !1, Su !== null && sv(Su) && (Su = null), Eu !== null && sv(Eu) && (Eu = null), Au !== null && sv(Au) && (Au = null), n_.forEach(eC), r_.forEach(eC)
}

function Mg(r, l) {
    r.blockedOn === l && (r.blockedOn = null, Fb || (Fb = !0, qs.unstable_scheduleCallback(qs.unstable_NormalPriority, qF)))
}

function o_(r) {
    function l(T) {
        return Mg(T, r)
    }

    if (0 < j0.length) {
        Mg(j0[0], r);
        for (var p = 1; p < j0.length; p++) {
            var y = j0[p];
            y.blockedOn === r && (y.blockedOn = null)
        }
    }
    for (Su !== null && Mg(Su, r), Eu !== null && Mg(Eu, r), Au !== null && Mg(Au, r), n_.forEach(l), r_.forEach(l), p = 0; p < pu.length; p++) y = pu[p], y.blockedOn === r && (y.blockedOn = null);
    for (; 0 < pu.length && (p = pu[0], p.blockedOn === null);) DM(p), p.blockedOn === null && pu.shift()
}

var Wf = mc.ReactCurrentBatchConfig, Pv = !0;

function WF(r, l, p, y) {
    var T = nr, A = Wf.transition;
    Wf.transition = null;
    try {
        nr = 1, WT(r, l, p, y)
    } finally {
        nr = T, Wf.transition = A
    }
}

function ZF(r, l, p, y) {
    var T = nr, A = Wf.transition;
    Wf.transition = null;
    try {
        nr = 4, WT(r, l, p, y)
    } finally {
        nr = T, Wf.transition = A
    }
}

function WT(r, l, p, y) {
    if (Pv) {
        var T = Bb(r, l, p, y);
        if (T === null) Yw(r, l, y, Mv, p), JI(r, y); else if (HF(T, r, l, p, y)) y.stopPropagation(); else if (JI(r, y), l & 4 && -1 < $F.indexOf(r)) {
            for (; T !== null;) {
                var A = C_(T);
                if (A !== null && PM(A), A = Bb(r, l, p, y), A === null && Yw(r, l, y, Mv, p), A === T) break;
                T = A
            }
            T !== null && y.stopPropagation()
        } else Yw(r, l, y, null, p)
    }
}

var Mv = null;

function Bb(r, l, p, y) {
    if (Mv = null, r = GT(y), r = Uh(r), r !== null) if (l = ad(r), l === null) r = null; else if (p = l.tag, p === 13) {
        if (r = wM(l), r !== null) return r;
        r = null
    } else if (p === 3) {
        if (l.stateNode.current.memoizedState.isDehydrated) return l.tag === 3 ? l.stateNode.containerInfo : null;
        r = null
    } else l !== r && (r = null);
    return Mv = r, null
}

function LM(r) {
    switch (r) {
        case"cancel":
        case"click":
        case"close":
        case"contextmenu":
        case"copy":
        case"cut":
        case"auxclick":
        case"dblclick":
        case"dragend":
        case"dragstart":
        case"drop":
        case"focusin":
        case"focusout":
        case"input":
        case"invalid":
        case"keydown":
        case"keypress":
        case"keyup":
        case"mousedown":
        case"mouseup":
        case"paste":
        case"pause":
        case"play":
        case"pointercancel":
        case"pointerdown":
        case"pointerup":
        case"ratechange":
        case"reset":
        case"resize":
        case"seeked":
        case"submit":
        case"touchcancel":
        case"touchend":
        case"touchstart":
        case"volumechange":
        case"change":
        case"selectionchange":
        case"textInput":
        case"compositionstart":
        case"compositionend":
        case"compositionupdate":
        case"beforeblur":
        case"afterblur":
        case"beforeinput":
        case"blur":
        case"fullscreenchange":
        case"focus":
        case"hashchange":
        case"popstate":
        case"select":
        case"selectstart":
            return 1;
        case"drag":
        case"dragenter":
        case"dragexit":
        case"dragleave":
        case"dragover":
        case"mousemove":
        case"mouseout":
        case"mouseover":
        case"pointermove":
        case"pointerout":
        case"pointerover":
        case"scroll":
        case"toggle":
        case"touchmove":
        case"wheel":
        case"mouseenter":
        case"mouseleave":
        case"pointerenter":
        case"pointerleave":
            return 4;
        case"message":
            switch (kF()) {
                case $T:
                    return 1;
                case EM:
                    return 4;
                case Iv:
                case OF:
                    return 16;
                case AM:
                    return 536870912;
                default:
                    return 16
            }
        default:
            return 16
    }
}

var wu = null, ZT = null, av = null;

function kM() {
    if (av) return av;
    var r, l = ZT, p = l.length, y, T = "value" in wu ? wu.value : wu.textContent, A = T.length;
    for (r = 0; r < p && l[r] === T[r]; r++) ;
    var D = p - r;
    for (y = 1; y <= D && l[p - y] === T[A - y]; y++) ;
    return av = T.slice(r, 1 < y ? 1 - y : void 0)
}

function lv(r) {
    var l = r.keyCode;
    return "charCode" in r ? (r = r.charCode, r === 0 && l === 13 && (r = 13)) : r = l, r === 10 && (r = 13), 32 <= r || r === 13 ? r : 0
}

function V0() {
    return !0
}

function tC() {
    return !1
}

function Xs(r) {
    function l(p, y, T, A, D) {
        this._reactName = p, this._targetInst = T, this.type = y, this.nativeEvent = A, this.target = D, this.currentTarget = null;
        for (var o in r) r.hasOwnProperty(o) && (p = r[o], this[o] = p ? p(A) : A[o]);
        return this.isDefaultPrevented = (A.defaultPrevented != null ? A.defaultPrevented : A.returnValue === !1) ? V0 : tC, this.isPropagationStopped = tC, this
    }

    return Er(l.prototype, {
        preventDefault: function () {
            this.defaultPrevented = !0;
            var p = this.nativeEvent;
            p && (p.preventDefault ? p.preventDefault() : typeof p.returnValue != "unknown" && (p.returnValue = !1), this.isDefaultPrevented = V0)
        }, stopPropagation: function () {
            var p = this.nativeEvent;
            p && (p.stopPropagation ? p.stopPropagation() : typeof p.cancelBubble != "unknown" && (p.cancelBubble = !0), this.isPropagationStopped = V0)
        }, persist: function () {
        }, isPersistent: V0
    }), l
}

var wp = {
        eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (r) {
            return r.timeStamp || Date.now()
        }, defaultPrevented: 0, isTrusted: 0
    }, XT = Xs(wp), I_ = Er({}, wp, {view: 0, detail: 0}), XF = Xs(I_), Vw, Uw, Rg, ax = Er({}, I_, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: YT,
        button: 0,
        buttons: 0,
        relatedTarget: function (r) {
            return r.relatedTarget === void 0 ? r.fromElement === r.srcElement ? r.toElement : r.fromElement : r.relatedTarget
        },
        movementX: function (r) {
            return "movementX" in r ? r.movementX : (r !== Rg && (Rg && r.type === "mousemove" ? (Vw = r.screenX - Rg.screenX, Uw = r.screenY - Rg.screenY) : Uw = Vw = 0, Rg = r), Vw)
        },
        movementY: function (r) {
            return "movementY" in r ? r.movementY : Uw
        }
    }), iC = Xs(ax), YF = Er({}, ax, {dataTransfer: 0}), KF = Xs(YF), QF = Er({}, I_, {relatedTarget: 0}), Gw = Xs(QF),
    JF = Er({}, wp, {animationName: 0, elapsedTime: 0, pseudoElement: 0}), eB = Xs(JF), tB = Er({}, wp, {
        clipboardData: function (r) {
            return "clipboardData" in r ? r.clipboardData : window.clipboardData
        }
    }), iB = Xs(tB), nB = Er({}, wp, {data: 0}), nC = Xs(nB), rB = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    }, oB = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    }, sB = {Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey"};

function aB(r) {
    var l = this.nativeEvent;
    return l.getModifierState ? l.getModifierState(r) : (r = sB[r]) ? !!l[r] : !1
}

function YT() {
    return aB
}

var lB = Er({}, I_, {
    key: function (r) {
        if (r.key) {
            var l = rB[r.key] || r.key;
            if (l !== "Unidentified") return l
        }
        return r.type === "keypress" ? (r = lv(r), r === 13 ? "Enter" : String.fromCharCode(r)) : r.type === "keydown" || r.type === "keyup" ? oB[r.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: YT,
    charCode: function (r) {
        return r.type === "keypress" ? lv(r) : 0
    },
    keyCode: function (r) {
        return r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0
    },
    which: function (r) {
        return r.type === "keypress" ? lv(r) : r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0
    }
}), cB = Xs(lB), uB = Er({}, ax, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
}), rC = Xs(uB), hB = Er({}, I_, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: YT
}), dB = Xs(hB), fB = Er({}, wp, {propertyName: 0, elapsedTime: 0, pseudoElement: 0}), pB = Xs(fB), mB = Er({}, ax, {
    deltaX: function (r) {
        return "deltaX" in r ? r.deltaX : "wheelDeltaX" in r ? -r.wheelDeltaX : 0
    }, deltaY: function (r) {
        return "deltaY" in r ? r.deltaY : "wheelDeltaY" in r ? -r.wheelDeltaY : "wheelDelta" in r ? -r.wheelDelta : 0
    }, deltaZ: 0, deltaMode: 0
}), gB = Xs(mB), _B = [9, 13, 27, 32], KT = cc && "CompositionEvent" in window, qg = null;
cc && "documentMode" in document && (qg = document.documentMode);
var yB = cc && "TextEvent" in window && !qg, OM = cc && (!KT || qg && 8 < qg && 11 >= qg), oC = " ", sC = !1;

function FM(r, l) {
    switch (r) {
        case"keyup":
            return _B.indexOf(l.keyCode) !== -1;
        case"keydown":
            return l.keyCode !== 229;
        case"keypress":
        case"mousedown":
        case"focusout":
            return !0;
        default:
            return !1
    }
}

function BM(r) {
    return r = r.detail, typeof r == "object" && "data" in r ? r.data : null
}

var Lf = !1;

function vB(r, l) {
    switch (r) {
        case"compositionend":
            return BM(l);
        case"keypress":
            return l.which !== 32 ? null : (sC = !0, oC);
        case"textInput":
            return r = l.data, r === oC && sC ? null : r;
        default:
            return null
    }
}

function xB(r, l) {
    if (Lf) return r === "compositionend" || !KT && FM(r, l) ? (r = kM(), av = ZT = wu = null, Lf = !1, r) : null;
    switch (r) {
        case"paste":
            return null;
        case"keypress":
            if (!(l.ctrlKey || l.altKey || l.metaKey) || l.ctrlKey && l.altKey) {
                if (l.char && 1 < l.char.length) return l.char;
                if (l.which) return String.fromCharCode(l.which)
            }
            return null;
        case"compositionend":
            return OM && l.locale !== "ko" ? null : l.data;
        default:
            return null
    }
}

var wB = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};

function aC(r) {
    var l = r && r.nodeName && r.nodeName.toLowerCase();
    return l === "input" ? !!wB[r.type] : l === "textarea"
}

function NM(r, l, p, y) {
    gM(y), l = Rv(l, "onChange"), 0 < l.length && (p = new XT("onChange", "change", null, p, y), r.push({
        event: p,
        listeners: l
    }))
}

var Wg = null, s_ = null;

function bB(r) {
    YM(r, 0)
}

function lx(r) {
    var l = Ff(r);
    if (cM(l)) return r
}

function TB(r, l) {
    if (r === "change") return l
}

var jM = !1;
if (cc) {
    var $w;
    if (cc) {
        var Hw = "oninput" in document;
        if (!Hw) {
            var lC = document.createElement("div");
            lC.setAttribute("oninput", "return;"), Hw = typeof lC.oninput == "function"
        }
        $w = Hw
    } else $w = !1;
    jM = $w && (!document.documentMode || 9 < document.documentMode)
}

function cC() {
    Wg && (Wg.detachEvent("onpropertychange", VM), s_ = Wg = null)
}

function VM(r) {
    if (r.propertyName === "value" && lx(s_)) {
        var l = [];
        NM(l, s_, r, GT(r)), xM(bB, l)
    }
}

function SB(r, l, p) {
    r === "focusin" ? (cC(), Wg = l, s_ = p, Wg.attachEvent("onpropertychange", VM)) : r === "focusout" && cC()
}

function EB(r) {
    if (r === "selectionchange" || r === "keyup" || r === "keydown") return lx(s_)
}

function AB(r, l) {
    if (r === "click") return lx(l)
}

function IB(r, l) {
    if (r === "input" || r === "change") return lx(l)
}

function CB(r, l) {
    return r === l && (r !== 0 || 1 / r === 1 / l) || r !== r && l !== l
}

var Fa = typeof Object.is == "function" ? Object.is : CB;

function a_(r, l) {
    if (Fa(r, l)) return !0;
    if (typeof r != "object" || r === null || typeof l != "object" || l === null) return !1;
    var p = Object.keys(r), y = Object.keys(l);
    if (p.length !== y.length) return !1;
    for (y = 0; y < p.length; y++) {
        var T = p[y];
        if (!xb.call(l, T) || !Fa(r[T], l[T])) return !1
    }
    return !0
}

function uC(r) {
    for (; r && r.firstChild;) r = r.firstChild;
    return r
}

function hC(r, l) {
    var p = uC(r);
    r = 0;
    for (var y; p;) {
        if (p.nodeType === 3) {
            if (y = r + p.textContent.length, r <= l && y >= l) return {node: p, offset: l - r};
            r = y
        }
        e:{
            for (; p;) {
                if (p.nextSibling) {
                    p = p.nextSibling;
                    break e
                }
                p = p.parentNode
            }
            p = void 0
        }
        p = uC(p)
    }
}

function UM(r, l) {
    return r && l ? r === l ? !0 : r && r.nodeType === 3 ? !1 : l && l.nodeType === 3 ? UM(r, l.parentNode) : "contains" in r ? r.contains(l) : r.compareDocumentPosition ? !!(r.compareDocumentPosition(l) & 16) : !1 : !1
}

function GM() {
    for (var r = window, l = Sv(); l instanceof r.HTMLIFrameElement;) {
        try {
            var p = typeof l.contentWindow.location.href == "string"
        } catch {
            p = !1
        }
        if (p) r = l.contentWindow; else break;
        l = Sv(r.document)
    }
    return l
}

function QT(r) {
    var l = r && r.nodeName && r.nodeName.toLowerCase();
    return l && (l === "input" && (r.type === "text" || r.type === "search" || r.type === "tel" || r.type === "url" || r.type === "password") || l === "textarea" || r.contentEditable === "true")
}

function PB(r) {
    var l = GM(), p = r.focusedElem, y = r.selectionRange;
    if (l !== p && p && p.ownerDocument && UM(p.ownerDocument.documentElement, p)) {
        if (y !== null && QT(p)) {
            if (l = y.start, r = y.end, r === void 0 && (r = l), "selectionStart" in p) p.selectionStart = l, p.selectionEnd = Math.min(r, p.value.length); else if (r = (l = p.ownerDocument || document) && l.defaultView || window, r.getSelection) {
                r = r.getSelection();
                var T = p.textContent.length, A = Math.min(y.start, T);
                y = y.end === void 0 ? A : Math.min(y.end, T), !r.extend && A > y && (T = y, y = A, A = T), T = hC(p, A);
                var D = hC(p, y);
                T && D && (r.rangeCount !== 1 || r.anchorNode !== T.node || r.anchorOffset !== T.offset || r.focusNode !== D.node || r.focusOffset !== D.offset) && (l = l.createRange(), l.setStart(T.node, T.offset), r.removeAllRanges(), A > y ? (r.addRange(l), r.extend(D.node, D.offset)) : (l.setEnd(D.node, D.offset), r.addRange(l)))
            }
        }
        for (l = [], r = p; r = r.parentNode;) r.nodeType === 1 && l.push({
            element: r,
            left: r.scrollLeft,
            top: r.scrollTop
        });
        for (typeof p.focus == "function" && p.focus(), p = 0; p < l.length; p++) r = l[p], r.element.scrollLeft = r.left, r.element.scrollTop = r.top
    }
}

var MB = cc && "documentMode" in document && 11 >= document.documentMode, kf = null, Nb = null, Zg = null, jb = !1;

function dC(r, l, p) {
    var y = p.window === p ? p.document : p.nodeType === 9 ? p : p.ownerDocument;
    jb || kf == null || kf !== Sv(y) || (y = kf, "selectionStart" in y && QT(y) ? y = {
        start: y.selectionStart,
        end: y.selectionEnd
    } : (y = (y.ownerDocument && y.ownerDocument.defaultView || window).getSelection(), y = {
        anchorNode: y.anchorNode,
        anchorOffset: y.anchorOffset,
        focusNode: y.focusNode,
        focusOffset: y.focusOffset
    }), Zg && a_(Zg, y) || (Zg = y, y = Rv(Nb, "onSelect"), 0 < y.length && (l = new XT("onSelect", "select", null, l, p), r.push({
        event: l,
        listeners: y
    }), l.target = kf)))
}

function U0(r, l) {
    var p = {};
    return p[r.toLowerCase()] = l.toLowerCase(), p["Webkit" + r] = "webkit" + l, p["Moz" + r] = "moz" + l, p
}

var Of = {
    animationend: U0("Animation", "AnimationEnd"),
    animationiteration: U0("Animation", "AnimationIteration"),
    animationstart: U0("Animation", "AnimationStart"),
    transitionend: U0("Transition", "TransitionEnd")
}, qw = {}, $M = {};
cc && ($M = document.createElement("div").style, "AnimationEvent" in window || (delete Of.animationend.animation, delete Of.animationiteration.animation, delete Of.animationstart.animation), "TransitionEvent" in window || delete Of.transitionend.transition);

function cx(r) {
    if (qw[r]) return qw[r];
    if (!Of[r]) return r;
    var l = Of[r], p;
    for (p in l) if (l.hasOwnProperty(p) && p in $M) return qw[r] = l[p];
    return r
}

var HM = cx("animationend"), qM = cx("animationiteration"), WM = cx("animationstart"), ZM = cx("transitionend"),
    XM = new Map,
    fC = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

function Bu(r, l) {
    XM.set(r, l), sd(l, [r])
}

for (var Ww = 0; Ww < fC.length; Ww++) {
    var Zw = fC[Ww], RB = Zw.toLowerCase(), zB = Zw[0].toUpperCase() + Zw.slice(1);
    Bu(RB, "on" + zB)
}
Bu(HM, "onAnimationEnd");
Bu(qM, "onAnimationIteration");
Bu(WM, "onAnimationStart");
Bu("dblclick", "onDoubleClick");
Bu("focusin", "onFocus");
Bu("focusout", "onBlur");
Bu(ZM, "onTransitionEnd");
lp("onMouseEnter", ["mouseout", "mouseover"]);
lp("onMouseLeave", ["mouseout", "mouseover"]);
lp("onPointerEnter", ["pointerout", "pointerover"]);
lp("onPointerLeave", ["pointerout", "pointerover"]);
sd("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
sd("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
sd("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
sd("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
sd("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
sd("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Ug = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
    DB = new Set("cancel close invalid load scroll toggle".split(" ").concat(Ug));

function pC(r, l, p) {
    var y = r.type || "unknown-event";
    r.currentTarget = p, RF(y, l, void 0, r), r.currentTarget = null
}

function YM(r, l) {
    l = (l & 4) !== 0;
    for (var p = 0; p < r.length; p++) {
        var y = r[p], T = y.event;
        y = y.listeners;
        e:{
            var A = void 0;
            if (l) for (var D = y.length - 1; 0 <= D; D--) {
                var o = y[D], j = o.instance, q = o.currentTarget;
                if (o = o.listener, j !== A && T.isPropagationStopped()) break e;
                pC(T, o, q), A = j
            } else for (D = 0; D < y.length; D++) {
                if (o = y[D], j = o.instance, q = o.currentTarget, o = o.listener, j !== A && T.isPropagationStopped()) break e;
                pC(T, o, q), A = j
            }
        }
    }
    if (Av) throw r = kb, Av = !1, kb = null, r
}

function yr(r, l) {
    var p = l[Hb];
    p === void 0 && (p = l[Hb] = new Set);
    var y = r + "__bubble";
    p.has(y) || (KM(l, r, 2, !1), p.add(y))
}

function Xw(r, l, p) {
    var y = 0;
    l && (y |= 4), KM(p, r, y, l)
}

var G0 = "_reactListening" + Math.random().toString(36).slice(2);

function l_(r) {
    if (!r[G0]) {
        r[G0] = !0, rM.forEach(function (p) {
            p !== "selectionchange" && (DB.has(p) || Xw(p, !1, r), Xw(p, !0, r))
        });
        var l = r.nodeType === 9 ? r : r.ownerDocument;
        l === null || l[G0] || (l[G0] = !0, Xw("selectionchange", !1, l))
    }
}

function KM(r, l, p, y) {
    switch (LM(l)) {
        case 1:
            var T = WF;
            break;
        case 4:
            T = ZF;
            break;
        default:
            T = WT
    }
    p = T.bind(null, l, p, r), T = void 0, !Lb || l !== "touchstart" && l !== "touchmove" && l !== "wheel" || (T = !0), y ? T !== void 0 ? r.addEventListener(l, p, {
        capture: !0,
        passive: T
    }) : r.addEventListener(l, p, !0) : T !== void 0 ? r.addEventListener(l, p, {passive: T}) : r.addEventListener(l, p, !1)
}

function Yw(r, l, p, y, T) {
    var A = y;
    if (!(l & 1) && !(l & 2) && y !== null) e:for (; ;) {
        if (y === null) return;
        var D = y.tag;
        if (D === 3 || D === 4) {
            var o = y.stateNode.containerInfo;
            if (o === T || o.nodeType === 8 && o.parentNode === T) break;
            if (D === 4) for (D = y.return; D !== null;) {
                var j = D.tag;
                if ((j === 3 || j === 4) && (j = D.stateNode.containerInfo, j === T || j.nodeType === 8 && j.parentNode === T)) return;
                D = D.return
            }
            for (; o !== null;) {
                if (D = Uh(o), D === null) return;
                if (j = D.tag, j === 5 || j === 6) {
                    y = A = D;
                    continue e
                }
                o = o.parentNode
            }
        }
        y = y.return
    }
    xM(function () {
        var q = A, ee = GT(p), oe = [];
        e:{
            var de = XM.get(r);
            if (de !== void 0) {
                var ae = XT, Re = r;
                switch (r) {
                    case"keypress":
                        if (lv(p) === 0) break e;
                    case"keydown":
                    case"keyup":
                        ae = cB;
                        break;
                    case"focusin":
                        Re = "focus", ae = Gw;
                        break;
                    case"focusout":
                        Re = "blur", ae = Gw;
                        break;
                    case"beforeblur":
                    case"afterblur":
                        ae = Gw;
                        break;
                    case"click":
                        if (p.button === 2) break e;
                    case"auxclick":
                    case"dblclick":
                    case"mousedown":
                    case"mousemove":
                    case"mouseup":
                    case"mouseout":
                    case"mouseover":
                    case"contextmenu":
                        ae = iC;
                        break;
                    case"drag":
                    case"dragend":
                    case"dragenter":
                    case"dragexit":
                    case"dragleave":
                    case"dragover":
                    case"dragstart":
                    case"drop":
                        ae = KF;
                        break;
                    case"touchcancel":
                    case"touchend":
                    case"touchmove":
                    case"touchstart":
                        ae = dB;
                        break;
                    case HM:
                    case qM:
                    case WM:
                        ae = eB;
                        break;
                    case ZM:
                        ae = pB;
                        break;
                    case"scroll":
                        ae = XF;
                        break;
                    case"wheel":
                        ae = gB;
                        break;
                    case"copy":
                    case"cut":
                    case"paste":
                        ae = iB;
                        break;
                    case"gotpointercapture":
                    case"lostpointercapture":
                    case"pointercancel":
                    case"pointerdown":
                    case"pointermove":
                    case"pointerout":
                    case"pointerover":
                    case"pointerup":
                        ae = rC
                }
                var fe = (l & 4) !== 0, Me = !fe && r === "scroll", pe = fe ? de !== null ? de + "Capture" : null : de;
                fe = [];
                for (var le = q, be; le !== null;) {
                    be = le;
                    var Ue = be.stateNode;
                    if (be.tag === 5 && Ue !== null && (be = Ue, pe !== null && (Ue = i_(le, pe), Ue != null && fe.push(c_(le, Ue, be)))), Me) break;
                    le = le.return
                }
                0 < fe.length && (de = new ae(de, Re, null, p, ee), oe.push({event: de, listeners: fe}))
            }
        }
        if (!(l & 7)) {
            e:{
                if (de = r === "mouseover" || r === "pointerover", ae = r === "mouseout" || r === "pointerout", de && p !== zb && (Re = p.relatedTarget || p.fromElement) && (Uh(Re) || Re[uc])) break e;
                if ((ae || de) && (de = ee.window === ee ? ee : (de = ee.ownerDocument) ? de.defaultView || de.parentWindow : window, ae ? (Re = p.relatedTarget || p.toElement, ae = q, Re = Re ? Uh(Re) : null, Re !== null && (Me = ad(Re), Re !== Me || Re.tag !== 5 && Re.tag !== 6) && (Re = null)) : (ae = null, Re = q), ae !== Re)) {
                    if (fe = iC, Ue = "onMouseLeave", pe = "onMouseEnter", le = "mouse", (r === "pointerout" || r === "pointerover") && (fe = rC, Ue = "onPointerLeave", pe = "onPointerEnter", le = "pointer"), Me = ae == null ? de : Ff(ae), be = Re == null ? de : Ff(Re), de = new fe(Ue, le + "leave", ae, p, ee), de.target = Me, de.relatedTarget = be, Ue = null, Uh(ee) === q && (fe = new fe(pe, le + "enter", Re, p, ee), fe.target = be, fe.relatedTarget = Me, Ue = fe), Me = Ue, ae && Re) t:{
                        for (fe = ae, pe = Re, le = 0, be = fe; be; be = Pf(be)) le++;
                        for (be = 0, Ue = pe; Ue; Ue = Pf(Ue)) be++;
                        for (; 0 < le - be;) fe = Pf(fe), le--;
                        for (; 0 < be - le;) pe = Pf(pe), be--;
                        for (; le--;) {
                            if (fe === pe || pe !== null && fe === pe.alternate) break t;
                            fe = Pf(fe), pe = Pf(pe)
                        }
                        fe = null
                    } else fe = null;
                    ae !== null && mC(oe, de, ae, fe, !1), Re !== null && Me !== null && mC(oe, Me, Re, fe, !0)
                }
            }
            e:{
                if (de = q ? Ff(q) : window, ae = de.nodeName && de.nodeName.toLowerCase(), ae === "select" || ae === "input" && de.type === "file") var et = TB; else if (aC(de)) if (jM) et = IB; else {
                    et = EB;
                    var _t = SB
                } else (ae = de.nodeName) && ae.toLowerCase() === "input" && (de.type === "checkbox" || de.type === "radio") && (et = AB);
                if (et && (et = et(r, q))) {
                    NM(oe, et, p, ee);
                    break e
                }
                _t && _t(r, de, q), r === "focusout" && (_t = de._wrapperState) && _t.controlled && de.type === "number" && Ib(de, "number", de.value)
            }
            switch (_t = q ? Ff(q) : window, r) {
                case"focusin":
                    (aC(_t) || _t.contentEditable === "true") && (kf = _t, Nb = q, Zg = null);
                    break;
                case"focusout":
                    Zg = Nb = kf = null;
                    break;
                case"mousedown":
                    jb = !0;
                    break;
                case"contextmenu":
                case"mouseup":
                case"dragend":
                    jb = !1, dC(oe, p, ee);
                    break;
                case"selectionchange":
                    if (MB) break;
                case"keydown":
                case"keyup":
                    dC(oe, p, ee)
            }
            var xt;
            if (KT) e:{
                switch (r) {
                    case"compositionstart":
                        var Mt = "onCompositionStart";
                        break e;
                    case"compositionend":
                        Mt = "onCompositionEnd";
                        break e;
                    case"compositionupdate":
                        Mt = "onCompositionUpdate";
                        break e
                }
                Mt = void 0
            } else Lf ? FM(r, p) && (Mt = "onCompositionEnd") : r === "keydown" && p.keyCode === 229 && (Mt = "onCompositionStart");
            Mt && (OM && p.locale !== "ko" && (Lf || Mt !== "onCompositionStart" ? Mt === "onCompositionEnd" && Lf && (xt = kM()) : (wu = ee, ZT = "value" in wu ? wu.value : wu.textContent, Lf = !0)), _t = Rv(q, Mt), 0 < _t.length && (Mt = new nC(Mt, r, null, p, ee), oe.push({
                event: Mt,
                listeners: _t
            }), xt ? Mt.data = xt : (xt = BM(p), xt !== null && (Mt.data = xt)))), (xt = yB ? vB(r, p) : xB(r, p)) && (q = Rv(q, "onBeforeInput"), 0 < q.length && (ee = new nC("onBeforeInput", "beforeinput", null, p, ee), oe.push({
                event: ee,
                listeners: q
            }), ee.data = xt))
        }
        YM(oe, l)
    })
}

function c_(r, l, p) {
    return {instance: r, listener: l, currentTarget: p}
}

function Rv(r, l) {
    for (var p = l + "Capture", y = []; r !== null;) {
        var T = r, A = T.stateNode;
        T.tag === 5 && A !== null && (T = A, A = i_(r, p), A != null && y.unshift(c_(r, A, T)), A = i_(r, l), A != null && y.push(c_(r, A, T))), r = r.return
    }
    return y
}

function Pf(r) {
    if (r === null) return null;
    do r = r.return; while (r && r.tag !== 5);
    return r || null
}

function mC(r, l, p, y, T) {
    for (var A = l._reactName, D = []; p !== null && p !== y;) {
        var o = p, j = o.alternate, q = o.stateNode;
        if (j !== null && j === y) break;
        o.tag === 5 && q !== null && (o = q, T ? (j = i_(p, A), j != null && D.unshift(c_(p, j, o))) : T || (j = i_(p, A), j != null && D.push(c_(p, j, o)))), p = p.return
    }
    D.length !== 0 && r.push({event: l, listeners: D})
}

var LB = /\r\n?/g, kB = /\u0000|\uFFFD/g;

function gC(r) {
    return (typeof r == "string" ? r : "" + r).replace(LB, `
`).replace(kB, "")
}

function $0(r, l, p) {
    if (l = gC(l), gC(r) !== l && p) throw Error(Wt(425))
}

function zv() {
}

var Vb = null, Ub = null;

function Gb(r, l) {
    return r === "textarea" || r === "noscript" || typeof l.children == "string" || typeof l.children == "number" || typeof l.dangerouslySetInnerHTML == "object" && l.dangerouslySetInnerHTML !== null && l.dangerouslySetInnerHTML.__html != null
}

var $b = typeof setTimeout == "function" ? setTimeout : void 0,
    OB = typeof clearTimeout == "function" ? clearTimeout : void 0,
    _C = typeof Promise == "function" ? Promise : void 0,
    FB = typeof queueMicrotask == "function" ? queueMicrotask : typeof _C < "u" ? function (r) {
        return _C.resolve(null).then(r).catch(BB)
    } : $b;

function BB(r) {
    setTimeout(function () {
        throw r
    })
}

function Kw(r, l) {
    var p = l, y = 0;
    do {
        var T = p.nextSibling;
        if (r.removeChild(p), T && T.nodeType === 8) if (p = T.data, p === "/$") {
            if (y === 0) {
                r.removeChild(T), o_(l);
                return
            }
            y--
        } else p !== "$" && p !== "$?" && p !== "$!" || y++;
        p = T
    } while (p);
    o_(l)
}

function Iu(r) {
    for (; r != null; r = r.nextSibling) {
        var l = r.nodeType;
        if (l === 1 || l === 3) break;
        if (l === 8) {
            if (l = r.data, l === "$" || l === "$!" || l === "$?") break;
            if (l === "/$") return null
        }
    }
    return r
}

function yC(r) {
    r = r.previousSibling;
    for (var l = 0; r;) {
        if (r.nodeType === 8) {
            var p = r.data;
            if (p === "$" || p === "$!" || p === "$?") {
                if (l === 0) return r;
                l--
            } else p === "/$" && l++
        }
        r = r.previousSibling
    }
    return null
}

var bp = Math.random().toString(36).slice(2), bl = "__reactFiber$" + bp, u_ = "__reactProps$" + bp,
    uc = "__reactContainer$" + bp, Hb = "__reactEvents$" + bp, NB = "__reactListeners$" + bp,
    jB = "__reactHandles$" + bp;

function Uh(r) {
    var l = r[bl];
    if (l) return l;
    for (var p = r.parentNode; p;) {
        if (l = p[uc] || p[bl]) {
            if (p = l.alternate, l.child !== null || p !== null && p.child !== null) for (r = yC(r); r !== null;) {
                if (p = r[bl]) return p;
                r = yC(r)
            }
            return l
        }
        r = p, p = r.parentNode
    }
    return null
}

function C_(r) {
    return r = r[bl] || r[uc], !r || r.tag !== 5 && r.tag !== 6 && r.tag !== 13 && r.tag !== 3 ? null : r
}

function Ff(r) {
    if (r.tag === 5 || r.tag === 6) return r.stateNode;
    throw Error(Wt(33))
}

function ux(r) {
    return r[u_] || null
}

var qb = [], Bf = -1;

function Nu(r) {
    return {current: r}
}

function vr(r) {
    0 > Bf || (r.current = qb[Bf], qb[Bf] = null, Bf--)
}

function pr(r, l) {
    Bf++, qb[Bf] = r.current, r.current = l
}

var Lu = {}, Wo = Nu(Lu), Cs = Nu(!1), ed = Lu;

function cp(r, l) {
    var p = r.type.contextTypes;
    if (!p) return Lu;
    var y = r.stateNode;
    if (y && y.__reactInternalMemoizedUnmaskedChildContext === l) return y.__reactInternalMemoizedMaskedChildContext;
    var T = {}, A;
    for (A in p) T[A] = l[A];
    return y && (r = r.stateNode, r.__reactInternalMemoizedUnmaskedChildContext = l, r.__reactInternalMemoizedMaskedChildContext = T), T
}

function Ps(r) {
    return r = r.childContextTypes, r != null
}

function Dv() {
    vr(Cs), vr(Wo)
}

function vC(r, l, p) {
    if (Wo.current !== Lu) throw Error(Wt(168));
    pr(Wo, l), pr(Cs, p)
}

function QM(r, l, p) {
    var y = r.stateNode;
    if (l = l.childContextTypes, typeof y.getChildContext != "function") return p;
    y = y.getChildContext();
    for (var T in y) if (!(T in l)) throw Error(Wt(108, SF(r) || "Unknown", T));
    return Er({}, p, y)
}

function Lv(r) {
    return r = (r = r.stateNode) && r.__reactInternalMemoizedMergedChildContext || Lu, ed = Wo.current, pr(Wo, r), pr(Cs, Cs.current), !0
}

function xC(r, l, p) {
    var y = r.stateNode;
    if (!y) throw Error(Wt(169));
    p ? (r = QM(r, l, ed), y.__reactInternalMemoizedMergedChildContext = r, vr(Cs), vr(Wo), pr(Wo, r)) : vr(Cs), pr(Cs, p)
}

var rc = null, hx = !1, Qw = !1;

function JM(r) {
    rc === null ? rc = [r] : rc.push(r)
}

function VB(r) {
    hx = !0, JM(r)
}

function ju() {
    if (!Qw && rc !== null) {
        Qw = !0;
        var r = 0, l = nr;
        try {
            var p = rc;
            for (nr = 1; r < p.length; r++) {
                var y = p[r];
                do y = y(!0); while (y !== null)
            }
            rc = null, hx = !1
        } catch (T) {
            throw rc !== null && (rc = rc.slice(r + 1)), SM($T, ju), T
        } finally {
            nr = l, Qw = !1
        }
    }
    return null
}

var Nf = [], jf = 0, kv = null, Ov = 0, sa = [], aa = 0, td = null, sc = 1, ac = "";

function jh(r, l) {
    Nf[jf++] = Ov, Nf[jf++] = kv, kv = r, Ov = l
}

function eR(r, l, p) {
    sa[aa++] = sc, sa[aa++] = ac, sa[aa++] = td, td = r;
    var y = sc;
    r = ac;
    var T = 32 - ka(y) - 1;
    y &= ~(1 << T), p += 1;
    var A = 32 - ka(l) + T;
    if (30 < A) {
        var D = T - T % 5;
        A = (y & (1 << D) - 1).toString(32), y >>= D, T -= D, sc = 1 << 32 - ka(l) + T | p << T | y, ac = A + r
    } else sc = 1 << A | p << T | y, ac = r
}

function JT(r) {
    r.return !== null && (jh(r, 1), eR(r, 1, 0))
}

function e2(r) {
    for (; r === kv;) kv = Nf[--jf], Nf[jf] = null, Ov = Nf[--jf], Nf[jf] = null;
    for (; r === td;) td = sa[--aa], sa[aa] = null, ac = sa[--aa], sa[aa] = null, sc = sa[--aa], sa[aa] = null
}

var $s = null, Gs = null, wr = !1, Da = null;

function tR(r, l) {
    var p = la(5, null, null, 0);
    p.elementType = "DELETED", p.stateNode = l, p.return = r, l = r.deletions, l === null ? (r.deletions = [p], r.flags |= 16) : l.push(p)
}

function wC(r, l) {
    switch (r.tag) {
        case 5:
            var p = r.type;
            return l = l.nodeType !== 1 || p.toLowerCase() !== l.nodeName.toLowerCase() ? null : l, l !== null ? (r.stateNode = l, $s = r, Gs = Iu(l.firstChild), !0) : !1;
        case 6:
            return l = r.pendingProps === "" || l.nodeType !== 3 ? null : l, l !== null ? (r.stateNode = l, $s = r, Gs = null, !0) : !1;
        case 13:
            return l = l.nodeType !== 8 ? null : l, l !== null ? (p = td !== null ? {
                id: sc,
                overflow: ac
            } : null, r.memoizedState = {
                dehydrated: l,
                treeContext: p,
                retryLane: 1073741824
            }, p = la(18, null, null, 0), p.stateNode = l, p.return = r, r.child = p, $s = r, Gs = null, !0) : !1;
        default:
            return !1
    }
}

function Wb(r) {
    return (r.mode & 1) !== 0 && (r.flags & 128) === 0
}

function Zb(r) {
    if (wr) {
        var l = Gs;
        if (l) {
            var p = l;
            if (!wC(r, l)) {
                if (Wb(r)) throw Error(Wt(418));
                l = Iu(p.nextSibling);
                var y = $s;
                l && wC(r, l) ? tR(y, p) : (r.flags = r.flags & -4097 | 2, wr = !1, $s = r)
            }
        } else {
            if (Wb(r)) throw Error(Wt(418));
            r.flags = r.flags & -4097 | 2, wr = !1, $s = r
        }
    }
}

function bC(r) {
    for (r = r.return; r !== null && r.tag !== 5 && r.tag !== 3 && r.tag !== 13;) r = r.return;
    $s = r
}

function H0(r) {
    if (r !== $s) return !1;
    if (!wr) return bC(r), wr = !0, !1;
    var l;
    if ((l = r.tag !== 3) && !(l = r.tag !== 5) && (l = r.type, l = l !== "head" && l !== "body" && !Gb(r.type, r.memoizedProps)), l && (l = Gs)) {
        if (Wb(r)) throw iR(), Error(Wt(418));
        for (; l;) tR(r, l), l = Iu(l.nextSibling)
    }
    if (bC(r), r.tag === 13) {
        if (r = r.memoizedState, r = r !== null ? r.dehydrated : null, !r) throw Error(Wt(317));
        e:{
            for (r = r.nextSibling, l = 0; r;) {
                if (r.nodeType === 8) {
                    var p = r.data;
                    if (p === "/$") {
                        if (l === 0) {
                            Gs = Iu(r.nextSibling);
                            break e
                        }
                        l--
                    } else p !== "$" && p !== "$!" && p !== "$?" || l++
                }
                r = r.nextSibling
            }
            Gs = null
        }
    } else Gs = $s ? Iu(r.stateNode.nextSibling) : null;
    return !0
}

function iR() {
    for (var r = Gs; r;) r = Iu(r.nextSibling)
}

function up() {
    Gs = $s = null, wr = !1
}

function t2(r) {
    Da === null ? Da = [r] : Da.push(r)
}

var UB = mc.ReactCurrentBatchConfig;

function zg(r, l, p) {
    if (r = p.ref, r !== null && typeof r != "function" && typeof r != "object") {
        if (p._owner) {
            if (p = p._owner, p) {
                if (p.tag !== 1) throw Error(Wt(309));
                var y = p.stateNode
            }
            if (!y) throw Error(Wt(147, r));
            var T = y, A = "" + r;
            return l !== null && l.ref !== null && typeof l.ref == "function" && l.ref._stringRef === A ? l.ref : (l = function (D) {
                var o = T.refs;
                D === null ? delete o[A] : o[A] = D
            }, l._stringRef = A, l)
        }
        if (typeof r != "string") throw Error(Wt(284));
        if (!p._owner) throw Error(Wt(290, r))
    }
    return r
}

function q0(r, l) {
    throw r = Object.prototype.toString.call(l), Error(Wt(31, r === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : r))
}

function TC(r) {
    var l = r._init;
    return l(r._payload)
}

function nR(r) {
    function l(pe, le) {
        if (r) {
            var be = pe.deletions;
            be === null ? (pe.deletions = [le], pe.flags |= 16) : be.push(le)
        }
    }

    function p(pe, le) {
        if (!r) return null;
        for (; le !== null;) l(pe, le), le = le.sibling;
        return null
    }

    function y(pe, le) {
        for (pe = new Map; le !== null;) le.key !== null ? pe.set(le.key, le) : pe.set(le.index, le), le = le.sibling;
        return pe
    }

    function T(pe, le) {
        return pe = Ru(pe, le), pe.index = 0, pe.sibling = null, pe
    }

    function A(pe, le, be) {
        return pe.index = be, r ? (be = pe.alternate, be !== null ? (be = be.index, be < le ? (pe.flags |= 2, le) : be) : (pe.flags |= 2, le)) : (pe.flags |= 1048576, le)
    }

    function D(pe) {
        return r && pe.alternate === null && (pe.flags |= 2), pe
    }

    function o(pe, le, be, Ue) {
        return le === null || le.tag !== 6 ? (le = ob(be, pe.mode, Ue), le.return = pe, le) : (le = T(le, be), le.return = pe, le)
    }

    function j(pe, le, be, Ue) {
        var et = be.type;
        return et === Df ? ee(pe, le, be.props.children, Ue, be.key) : le !== null && (le.elementType === et || typeof et == "object" && et !== null && et.$$typeof === du && TC(et) === le.type) ? (Ue = T(le, be.props), Ue.ref = zg(pe, le, be), Ue.return = pe, Ue) : (Ue = mv(be.type, be.key, be.props, null, pe.mode, Ue), Ue.ref = zg(pe, le, be), Ue.return = pe, Ue)
    }

    function q(pe, le, be, Ue) {
        return le === null || le.tag !== 4 || le.stateNode.containerInfo !== be.containerInfo || le.stateNode.implementation !== be.implementation ? (le = sb(be, pe.mode, Ue), le.return = pe, le) : (le = T(le, be.children || []), le.return = pe, le)
    }

    function ee(pe, le, be, Ue, et) {
        return le === null || le.tag !== 7 ? (le = Jh(be, pe.mode, Ue, et), le.return = pe, le) : (le = T(le, be), le.return = pe, le)
    }

    function oe(pe, le, be) {
        if (typeof le == "string" && le !== "" || typeof le == "number") return le = ob("" + le, pe.mode, be), le.return = pe, le;
        if (typeof le == "object" && le !== null) {
            switch (le.$$typeof) {
                case k0:
                    return be = mv(le.type, le.key, le.props, null, pe.mode, be), be.ref = zg(pe, null, le), be.return = pe, be;
                case zf:
                    return le = sb(le, pe.mode, be), le.return = pe, le;
                case du:
                    var Ue = le._init;
                    return oe(pe, Ue(le._payload), be)
            }
            if (jg(le) || Ig(le)) return le = Jh(le, pe.mode, be, null), le.return = pe, le;
            q0(pe, le)
        }
        return null
    }

    function de(pe, le, be, Ue) {
        var et = le !== null ? le.key : null;
        if (typeof be == "string" && be !== "" || typeof be == "number") return et !== null ? null : o(pe, le, "" + be, Ue);
        if (typeof be == "object" && be !== null) {
            switch (be.$$typeof) {
                case k0:
                    return be.key === et ? j(pe, le, be, Ue) : null;
                case zf:
                    return be.key === et ? q(pe, le, be, Ue) : null;
                case du:
                    return et = be._init, de(pe, le, et(be._payload), Ue)
            }
            if (jg(be) || Ig(be)) return et !== null ? null : ee(pe, le, be, Ue, null);
            q0(pe, be)
        }
        return null
    }

    function ae(pe, le, be, Ue, et) {
        if (typeof Ue == "string" && Ue !== "" || typeof Ue == "number") return pe = pe.get(be) || null, o(le, pe, "" + Ue, et);
        if (typeof Ue == "object" && Ue !== null) {
            switch (Ue.$$typeof) {
                case k0:
                    return pe = pe.get(Ue.key === null ? be : Ue.key) || null, j(le, pe, Ue, et);
                case zf:
                    return pe = pe.get(Ue.key === null ? be : Ue.key) || null, q(le, pe, Ue, et);
                case du:
                    var _t = Ue._init;
                    return ae(pe, le, be, _t(Ue._payload), et)
            }
            if (jg(Ue) || Ig(Ue)) return pe = pe.get(be) || null, ee(le, pe, Ue, et, null);
            q0(le, Ue)
        }
        return null
    }

    function Re(pe, le, be, Ue) {
        for (var et = null, _t = null, xt = le, Mt = le = 0, Xt = null; xt !== null && Mt < be.length; Mt++) {
            xt.index > Mt ? (Xt = xt, xt = null) : Xt = xt.sibling;
            var Zt = de(pe, xt, be[Mt], Ue);
            if (Zt === null) {
                xt === null && (xt = Xt);
                break
            }
            r && xt && Zt.alternate === null && l(pe, xt), le = A(Zt, le, Mt), _t === null ? et = Zt : _t.sibling = Zt, _t = Zt, xt = Xt
        }
        if (Mt === be.length) return p(pe, xt), wr && jh(pe, Mt), et;
        if (xt === null) {
            for (; Mt < be.length; Mt++) xt = oe(pe, be[Mt], Ue), xt !== null && (le = A(xt, le, Mt), _t === null ? et = xt : _t.sibling = xt, _t = xt);
            return wr && jh(pe, Mt), et
        }
        for (xt = y(pe, xt); Mt < be.length; Mt++) Xt = ae(xt, pe, Mt, be[Mt], Ue), Xt !== null && (r && Xt.alternate !== null && xt.delete(Xt.key === null ? Mt : Xt.key), le = A(Xt, le, Mt), _t === null ? et = Xt : _t.sibling = Xt, _t = Xt);
        return r && xt.forEach(function (Ht) {
            return l(pe, Ht)
        }), wr && jh(pe, Mt), et
    }

    function fe(pe, le, be, Ue) {
        var et = Ig(be);
        if (typeof et != "function") throw Error(Wt(150));
        if (be = et.call(be), be == null) throw Error(Wt(151));
        for (var _t = et = null, xt = le, Mt = le = 0, Xt = null, Zt = be.next(); xt !== null && !Zt.done; Mt++, Zt = be.next()) {
            xt.index > Mt ? (Xt = xt, xt = null) : Xt = xt.sibling;
            var Ht = de(pe, xt, Zt.value, Ue);
            if (Ht === null) {
                xt === null && (xt = Xt);
                break
            }
            r && xt && Ht.alternate === null && l(pe, xt), le = A(Ht, le, Mt), _t === null ? et = Ht : _t.sibling = Ht, _t = Ht, xt = Xt
        }
        if (Zt.done) return p(pe, xt), wr && jh(pe, Mt), et;
        if (xt === null) {
            for (; !Zt.done; Mt++, Zt = be.next()) Zt = oe(pe, Zt.value, Ue), Zt !== null && (le = A(Zt, le, Mt), _t === null ? et = Zt : _t.sibling = Zt, _t = Zt);
            return wr && jh(pe, Mt), et
        }
        for (xt = y(pe, xt); !Zt.done; Mt++, Zt = be.next()) Zt = ae(xt, pe, Mt, Zt.value, Ue), Zt !== null && (r && Zt.alternate !== null && xt.delete(Zt.key === null ? Mt : Zt.key), le = A(Zt, le, Mt), _t === null ? et = Zt : _t.sibling = Zt, _t = Zt);
        return r && xt.forEach(function (hi) {
            return l(pe, hi)
        }), wr && jh(pe, Mt), et
    }

    function Me(pe, le, be, Ue) {
        if (typeof be == "object" && be !== null && be.type === Df && be.key === null && (be = be.props.children), typeof be == "object" && be !== null) {
            switch (be.$$typeof) {
                case k0:
                    e:{
                        for (var et = be.key, _t = le; _t !== null;) {
                            if (_t.key === et) {
                                if (et = be.type, et === Df) {
                                    if (_t.tag === 7) {
                                        p(pe, _t.sibling), le = T(_t, be.props.children), le.return = pe, pe = le;
                                        break e
                                    }
                                } else if (_t.elementType === et || typeof et == "object" && et !== null && et.$$typeof === du && TC(et) === _t.type) {
                                    p(pe, _t.sibling), le = T(_t, be.props), le.ref = zg(pe, _t, be), le.return = pe, pe = le;
                                    break e
                                }
                                p(pe, _t);
                                break
                            } else l(pe, _t);
                            _t = _t.sibling
                        }
                        be.type === Df ? (le = Jh(be.props.children, pe.mode, Ue, be.key), le.return = pe, pe = le) : (Ue = mv(be.type, be.key, be.props, null, pe.mode, Ue), Ue.ref = zg(pe, le, be), Ue.return = pe, pe = Ue)
                    }
                    return D(pe);
                case zf:
                    e:{
                        for (_t = be.key; le !== null;) {
                            if (le.key === _t) if (le.tag === 4 && le.stateNode.containerInfo === be.containerInfo && le.stateNode.implementation === be.implementation) {
                                p(pe, le.sibling), le = T(le, be.children || []), le.return = pe, pe = le;
                                break e
                            } else {
                                p(pe, le);
                                break
                            } else l(pe, le);
                            le = le.sibling
                        }
                        le = sb(be, pe.mode, Ue), le.return = pe, pe = le
                    }
                    return D(pe);
                case du:
                    return _t = be._init, Me(pe, le, _t(be._payload), Ue)
            }
            if (jg(be)) return Re(pe, le, be, Ue);
            if (Ig(be)) return fe(pe, le, be, Ue);
            q0(pe, be)
        }
        return typeof be == "string" && be !== "" || typeof be == "number" ? (be = "" + be, le !== null && le.tag === 6 ? (p(pe, le.sibling), le = T(le, be), le.return = pe, pe = le) : (p(pe, le), le = ob(be, pe.mode, Ue), le.return = pe, pe = le), D(pe)) : p(pe, le)
    }

    return Me
}

var hp = nR(!0), rR = nR(!1), Fv = Nu(null), Bv = null, Vf = null, i2 = null;

function n2() {
    i2 = Vf = Bv = null
}

function r2(r) {
    var l = Fv.current;
    vr(Fv), r._currentValue = l
}

function Xb(r, l, p) {
    for (; r !== null;) {
        var y = r.alternate;
        if ((r.childLanes & l) !== l ? (r.childLanes |= l, y !== null && (y.childLanes |= l)) : y !== null && (y.childLanes & l) !== l && (y.childLanes |= l), r === p) break;
        r = r.return
    }
}

function Zf(r, l) {
    Bv = r, i2 = Vf = null, r = r.dependencies, r !== null && r.firstContext !== null && (r.lanes & l && (Is = !0), r.firstContext = null)
}

function ha(r) {
    var l = r._currentValue;
    if (i2 !== r) if (r = {context: r, memoizedValue: l, next: null}, Vf === null) {
        if (Bv === null) throw Error(Wt(308));
        Vf = r, Bv.dependencies = {lanes: 0, firstContext: r}
    } else Vf = Vf.next = r;
    return l
}

var Gh = null;

function o2(r) {
    Gh === null ? Gh = [r] : Gh.push(r)
}

function oR(r, l, p, y) {
    var T = l.interleaved;
    return T === null ? (p.next = p, o2(l)) : (p.next = T.next, T.next = p), l.interleaved = p, hc(r, y)
}

function hc(r, l) {
    r.lanes |= l;
    var p = r.alternate;
    for (p !== null && (p.lanes |= l), p = r, r = r.return; r !== null;) r.childLanes |= l, p = r.alternate, p !== null && (p.childLanes |= l), p = r, r = r.return;
    return p.tag === 3 ? p.stateNode : null
}

var fu = !1;

function s2(r) {
    r.updateQueue = {
        baseState: r.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {pending: null, interleaved: null, lanes: 0},
        effects: null
    }
}

function sR(r, l) {
    r = r.updateQueue, l.updateQueue === r && (l.updateQueue = {
        baseState: r.baseState,
        firstBaseUpdate: r.firstBaseUpdate,
        lastBaseUpdate: r.lastBaseUpdate,
        shared: r.shared,
        effects: r.effects
    })
}

function lc(r, l) {
    return {eventTime: r, lane: l, tag: 0, payload: null, callback: null, next: null}
}

function Cu(r, l, p) {
    var y = r.updateQueue;
    if (y === null) return null;
    if (y = y.shared, $n & 2) {
        var T = y.pending;
        return T === null ? l.next = l : (l.next = T.next, T.next = l), y.pending = l, hc(r, p)
    }
    return T = y.interleaved, T === null ? (l.next = l, o2(y)) : (l.next = T.next, T.next = l), y.interleaved = l, hc(r, p)
}

function cv(r, l, p) {
    if (l = l.updateQueue, l !== null && (l = l.shared, (p & 4194240) !== 0)) {
        var y = l.lanes;
        y &= r.pendingLanes, p |= y, l.lanes = p, HT(r, p)
    }
}

function SC(r, l) {
    var p = r.updateQueue, y = r.alternate;
    if (y !== null && (y = y.updateQueue, p === y)) {
        var T = null, A = null;
        if (p = p.firstBaseUpdate, p !== null) {
            do {
                var D = {
                    eventTime: p.eventTime,
                    lane: p.lane,
                    tag: p.tag,
                    payload: p.payload,
                    callback: p.callback,
                    next: null
                };
                A === null ? T = A = D : A = A.next = D, p = p.next
            } while (p !== null);
            A === null ? T = A = l : A = A.next = l
        } else T = A = l;
        p = {
            baseState: y.baseState,
            firstBaseUpdate: T,
            lastBaseUpdate: A,
            shared: y.shared,
            effects: y.effects
        }, r.updateQueue = p;
        return
    }
    r = p.lastBaseUpdate, r === null ? p.firstBaseUpdate = l : r.next = l, p.lastBaseUpdate = l
}

function Nv(r, l, p, y) {
    var T = r.updateQueue;
    fu = !1;
    var A = T.firstBaseUpdate, D = T.lastBaseUpdate, o = T.shared.pending;
    if (o !== null) {
        T.shared.pending = null;
        var j = o, q = j.next;
        j.next = null, D === null ? A = q : D.next = q, D = j;
        var ee = r.alternate;
        ee !== null && (ee = ee.updateQueue, o = ee.lastBaseUpdate, o !== D && (o === null ? ee.firstBaseUpdate = q : o.next = q, ee.lastBaseUpdate = j))
    }
    if (A !== null) {
        var oe = T.baseState;
        D = 0, ee = q = j = null, o = A;
        do {
            var de = o.lane, ae = o.eventTime;
            if ((y & de) === de) {
                ee !== null && (ee = ee.next = {
                    eventTime: ae,
                    lane: 0,
                    tag: o.tag,
                    payload: o.payload,
                    callback: o.callback,
                    next: null
                });
                e:{
                    var Re = r, fe = o;
                    switch (de = l, ae = p, fe.tag) {
                        case 1:
                            if (Re = fe.payload, typeof Re == "function") {
                                oe = Re.call(ae, oe, de);
                                break e
                            }
                            oe = Re;
                            break e;
                        case 3:
                            Re.flags = Re.flags & -65537 | 128;
                        case 0:
                            if (Re = fe.payload, de = typeof Re == "function" ? Re.call(ae, oe, de) : Re, de == null) break e;
                            oe = Er({}, oe, de);
                            break e;
                        case 2:
                            fu = !0
                    }
                }
                o.callback !== null && o.lane !== 0 && (r.flags |= 64, de = T.effects, de === null ? T.effects = [o] : de.push(o))
            } else ae = {
                eventTime: ae,
                lane: de,
                tag: o.tag,
                payload: o.payload,
                callback: o.callback,
                next: null
            }, ee === null ? (q = ee = ae, j = oe) : ee = ee.next = ae, D |= de;
            if (o = o.next, o === null) {
                if (o = T.shared.pending, o === null) break;
                de = o, o = de.next, de.next = null, T.lastBaseUpdate = de, T.shared.pending = null
            }
        } while (!0);
        if (ee === null && (j = oe), T.baseState = j, T.firstBaseUpdate = q, T.lastBaseUpdate = ee, l = T.shared.interleaved, l !== null) {
            T = l;
            do D |= T.lane, T = T.next; while (T !== l)
        } else A === null && (T.shared.lanes = 0);
        nd |= D, r.lanes = D, r.memoizedState = oe
    }
}

function EC(r, l, p) {
    if (r = l.effects, l.effects = null, r !== null) for (l = 0; l < r.length; l++) {
        var y = r[l], T = y.callback;
        if (T !== null) {
            if (y.callback = null, y = p, typeof T != "function") throw Error(Wt(191, T));
            T.call(y)
        }
    }
}

var P_ = {}, El = Nu(P_), h_ = Nu(P_), d_ = Nu(P_);

function $h(r) {
    if (r === P_) throw Error(Wt(174));
    return r
}

function a2(r, l) {
    switch (pr(d_, l), pr(h_, r), pr(El, P_), r = l.nodeType, r) {
        case 9:
        case 11:
            l = (l = l.documentElement) ? l.namespaceURI : Pb(null, "");
            break;
        default:
            r = r === 8 ? l.parentNode : l, l = r.namespaceURI || null, r = r.tagName, l = Pb(l, r)
    }
    vr(El), pr(El, l)
}

function dp() {
    vr(El), vr(h_), vr(d_)
}

function aR(r) {
    $h(d_.current);
    var l = $h(El.current), p = Pb(l, r.type);
    l !== p && (pr(h_, r), pr(El, p))
}

function l2(r) {
    h_.current === r && (vr(El), vr(h_))
}

var Tr = Nu(0);

function jv(r) {
    for (var l = r; l !== null;) {
        if (l.tag === 13) {
            var p = l.memoizedState;
            if (p !== null && (p = p.dehydrated, p === null || p.data === "$?" || p.data === "$!")) return l
        } else if (l.tag === 19 && l.memoizedProps.revealOrder !== void 0) {
            if (l.flags & 128) return l
        } else if (l.child !== null) {
            l.child.return = l, l = l.child;
            continue
        }
        if (l === r) break;
        for (; l.sibling === null;) {
            if (l.return === null || l.return === r) return null;
            l = l.return
        }
        l.sibling.return = l.return, l = l.sibling
    }
    return null
}

var Jw = [];

function c2() {
    for (var r = 0; r < Jw.length; r++) Jw[r]._workInProgressVersionPrimary = null;
    Jw.length = 0
}

var uv = mc.ReactCurrentDispatcher, eb = mc.ReactCurrentBatchConfig, id = 0, Sr = null, ro = null, vo = null, Vv = !1,
    Xg = !1, f_ = 0, GB = 0;

function Vo() {
    throw Error(Wt(321))
}

function u2(r, l) {
    if (l === null) return !1;
    for (var p = 0; p < l.length && p < r.length; p++) if (!Fa(r[p], l[p])) return !1;
    return !0
}

function h2(r, l, p, y, T, A) {
    if (id = A, Sr = l, l.memoizedState = null, l.updateQueue = null, l.lanes = 0, uv.current = r === null || r.memoizedState === null ? WB : ZB, r = p(y, T), Xg) {
        A = 0;
        do {
            if (Xg = !1, f_ = 0, 25 <= A) throw Error(Wt(301));
            A += 1, vo = ro = null, l.updateQueue = null, uv.current = XB, r = p(y, T)
        } while (Xg)
    }
    if (uv.current = Uv, l = ro !== null && ro.next !== null, id = 0, vo = ro = Sr = null, Vv = !1, l) throw Error(Wt(300));
    return r
}

function d2() {
    var r = f_ !== 0;
    return f_ = 0, r
}

function yl() {
    var r = {memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null};
    return vo === null ? Sr.memoizedState = vo = r : vo = vo.next = r, vo
}

function da() {
    if (ro === null) {
        var r = Sr.alternate;
        r = r !== null ? r.memoizedState : null
    } else r = ro.next;
    var l = vo === null ? Sr.memoizedState : vo.next;
    if (l !== null) vo = l, ro = r; else {
        if (r === null) throw Error(Wt(310));
        ro = r, r = {
            memoizedState: ro.memoizedState,
            baseState: ro.baseState,
            baseQueue: ro.baseQueue,
            queue: ro.queue,
            next: null
        }, vo === null ? Sr.memoizedState = vo = r : vo = vo.next = r
    }
    return vo
}

function p_(r, l) {
    return typeof l == "function" ? l(r) : l
}

function tb(r) {
    var l = da(), p = l.queue;
    if (p === null) throw Error(Wt(311));
    p.lastRenderedReducer = r;
    var y = ro, T = y.baseQueue, A = p.pending;
    if (A !== null) {
        if (T !== null) {
            var D = T.next;
            T.next = A.next, A.next = D
        }
        y.baseQueue = T = A, p.pending = null
    }
    if (T !== null) {
        A = T.next, y = y.baseState;
        var o = D = null, j = null, q = A;
        do {
            var ee = q.lane;
            if ((id & ee) === ee) j !== null && (j = j.next = {
                lane: 0,
                action: q.action,
                hasEagerState: q.hasEagerState,
                eagerState: q.eagerState,
                next: null
            }), y = q.hasEagerState ? q.eagerState : r(y, q.action); else {
                var oe = {
                    lane: ee,
                    action: q.action,
                    hasEagerState: q.hasEagerState,
                    eagerState: q.eagerState,
                    next: null
                };
                j === null ? (o = j = oe, D = y) : j = j.next = oe, Sr.lanes |= ee, nd |= ee
            }
            q = q.next
        } while (q !== null && q !== A);
        j === null ? D = y : j.next = o, Fa(y, l.memoizedState) || (Is = !0), l.memoizedState = y, l.baseState = D, l.baseQueue = j, p.lastRenderedState = y
    }
    if (r = p.interleaved, r !== null) {
        T = r;
        do A = T.lane, Sr.lanes |= A, nd |= A, T = T.next; while (T !== r)
    } else T === null && (p.lanes = 0);
    return [l.memoizedState, p.dispatch]
}

function ib(r) {
    var l = da(), p = l.queue;
    if (p === null) throw Error(Wt(311));
    p.lastRenderedReducer = r;
    var y = p.dispatch, T = p.pending, A = l.memoizedState;
    if (T !== null) {
        p.pending = null;
        var D = T = T.next;
        do A = r(A, D.action), D = D.next; while (D !== T);
        Fa(A, l.memoizedState) || (Is = !0), l.memoizedState = A, l.baseQueue === null && (l.baseState = A), p.lastRenderedState = A
    }
    return [A, y]
}

function lR() {
}

function cR(r, l) {
    var p = Sr, y = da(), T = l(), A = !Fa(y.memoizedState, T);
    if (A && (y.memoizedState = T, Is = !0), y = y.queue, f2(dR.bind(null, p, y, r), [r]), y.getSnapshot !== l || A || vo !== null && vo.memoizedState.tag & 1) {
        if (p.flags |= 2048, m_(9, hR.bind(null, p, y, T, l), void 0, null), xo === null) throw Error(Wt(349));
        id & 30 || uR(p, l, T)
    }
    return T
}

function uR(r, l, p) {
    r.flags |= 16384, r = {getSnapshot: l, value: p}, l = Sr.updateQueue, l === null ? (l = {
        lastEffect: null,
        stores: null
    }, Sr.updateQueue = l, l.stores = [r]) : (p = l.stores, p === null ? l.stores = [r] : p.push(r))
}

function hR(r, l, p, y) {
    l.value = p, l.getSnapshot = y, fR(l) && pR(r)
}

function dR(r, l, p) {
    return p(function () {
        fR(l) && pR(r)
    })
}

function fR(r) {
    var l = r.getSnapshot;
    r = r.value;
    try {
        var p = l();
        return !Fa(r, p)
    } catch {
        return !0
    }
}

function pR(r) {
    var l = hc(r, 1);
    l !== null && Oa(l, r, 1, -1)
}

function AC(r) {
    var l = yl();
    return typeof r == "function" && (r = r()), l.memoizedState = l.baseState = r, r = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: p_,
        lastRenderedState: r
    }, l.queue = r, r = r.dispatch = qB.bind(null, Sr, r), [l.memoizedState, r]
}

function m_(r, l, p, y) {
    return r = {
        tag: r,
        create: l,
        destroy: p,
        deps: y,
        next: null
    }, l = Sr.updateQueue, l === null ? (l = {
        lastEffect: null,
        stores: null
    }, Sr.updateQueue = l, l.lastEffect = r.next = r) : (p = l.lastEffect, p === null ? l.lastEffect = r.next = r : (y = p.next, p.next = r, r.next = y, l.lastEffect = r)), r
}

function mR() {
    return da().memoizedState
}

function hv(r, l, p, y) {
    var T = yl();
    Sr.flags |= r, T.memoizedState = m_(1 | l, p, void 0, y === void 0 ? null : y)
}

function dx(r, l, p, y) {
    var T = da();
    y = y === void 0 ? null : y;
    var A = void 0;
    if (ro !== null) {
        var D = ro.memoizedState;
        if (A = D.destroy, y !== null && u2(y, D.deps)) {
            T.memoizedState = m_(l, p, A, y);
            return
        }
    }
    Sr.flags |= r, T.memoizedState = m_(1 | l, p, A, y)
}

function IC(r, l) {
    return hv(8390656, 8, r, l)
}

function f2(r, l) {
    return dx(2048, 8, r, l)
}

function gR(r, l) {
    return dx(4, 2, r, l)
}

function _R(r, l) {
    return dx(4, 4, r, l)
}

function yR(r, l) {
    if (typeof l == "function") return r = r(), l(r), function () {
        l(null)
    };
    if (l != null) return r = r(), l.current = r, function () {
        l.current = null
    }
}

function vR(r, l, p) {
    return p = p != null ? p.concat([r]) : null, dx(4, 4, yR.bind(null, l, r), p)
}

function p2() {
}

function xR(r, l) {
    var p = da();
    l = l === void 0 ? null : l;
    var y = p.memoizedState;
    return y !== null && l !== null && u2(l, y[1]) ? y[0] : (p.memoizedState = [r, l], r)
}

function wR(r, l) {
    var p = da();
    l = l === void 0 ? null : l;
    var y = p.memoizedState;
    return y !== null && l !== null && u2(l, y[1]) ? y[0] : (r = r(), p.memoizedState = [r, l], r)
}

function bR(r, l, p) {
    return id & 21 ? (Fa(p, l) || (p = IM(), Sr.lanes |= p, nd |= p, r.baseState = !0), l) : (r.baseState && (r.baseState = !1, Is = !0), r.memoizedState = p)
}

function $B(r, l) {
    var p = nr;
    nr = p !== 0 && 4 > p ? p : 4, r(!0);
    var y = eb.transition;
    eb.transition = {};
    try {
        r(!1), l()
    } finally {
        nr = p, eb.transition = y
    }
}

function TR() {
    return da().memoizedState
}

function HB(r, l, p) {
    var y = Mu(r);
    if (p = {
        lane: y,
        action: p,
        hasEagerState: !1,
        eagerState: null,
        next: null
    }, SR(r)) ER(l, p); else if (p = oR(r, l, p, y), p !== null) {
        var T = us();
        Oa(p, r, y, T), AR(p, l, y)
    }
}

function qB(r, l, p) {
    var y = Mu(r), T = {lane: y, action: p, hasEagerState: !1, eagerState: null, next: null};
    if (SR(r)) ER(l, T); else {
        var A = r.alternate;
        if (r.lanes === 0 && (A === null || A.lanes === 0) && (A = l.lastRenderedReducer, A !== null)) try {
            var D = l.lastRenderedState, o = A(D, p);
            if (T.hasEagerState = !0, T.eagerState = o, Fa(o, D)) {
                var j = l.interleaved;
                j === null ? (T.next = T, o2(l)) : (T.next = j.next, j.next = T), l.interleaved = T;
                return
            }
        } catch {
        } finally {
        }
        p = oR(r, l, T, y), p !== null && (T = us(), Oa(p, r, y, T), AR(p, l, y))
    }
}

function SR(r) {
    var l = r.alternate;
    return r === Sr || l !== null && l === Sr
}

function ER(r, l) {
    Xg = Vv = !0;
    var p = r.pending;
    p === null ? l.next = l : (l.next = p.next, p.next = l), r.pending = l
}

function AR(r, l, p) {
    if (p & 4194240) {
        var y = l.lanes;
        y &= r.pendingLanes, p |= y, l.lanes = p, HT(r, p)
    }
}

var Uv = {
    readContext: ha,
    useCallback: Vo,
    useContext: Vo,
    useEffect: Vo,
    useImperativeHandle: Vo,
    useInsertionEffect: Vo,
    useLayoutEffect: Vo,
    useMemo: Vo,
    useReducer: Vo,
    useRef: Vo,
    useState: Vo,
    useDebugValue: Vo,
    useDeferredValue: Vo,
    useTransition: Vo,
    useMutableSource: Vo,
    useSyncExternalStore: Vo,
    useId: Vo,
    unstable_isNewReconciler: !1
}, WB = {
    readContext: ha, useCallback: function (r, l) {
        return yl().memoizedState = [r, l === void 0 ? null : l], r
    }, useContext: ha, useEffect: IC, useImperativeHandle: function (r, l, p) {
        return p = p != null ? p.concat([r]) : null, hv(4194308, 4, yR.bind(null, l, r), p)
    }, useLayoutEffect: function (r, l) {
        return hv(4194308, 4, r, l)
    }, useInsertionEffect: function (r, l) {
        return hv(4, 2, r, l)
    }, useMemo: function (r, l) {
        var p = yl();
        return l = l === void 0 ? null : l, r = r(), p.memoizedState = [r, l], r
    }, useReducer: function (r, l, p) {
        var y = yl();
        return l = p !== void 0 ? p(l) : l, y.memoizedState = y.baseState = l, r = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: r,
            lastRenderedState: l
        }, y.queue = r, r = r.dispatch = HB.bind(null, Sr, r), [y.memoizedState, r]
    }, useRef: function (r) {
        var l = yl();
        return r = {current: r}, l.memoizedState = r
    }, useState: AC, useDebugValue: p2, useDeferredValue: function (r) {
        return yl().memoizedState = r
    }, useTransition: function () {
        var r = AC(!1), l = r[0];
        return r = $B.bind(null, r[1]), yl().memoizedState = r, [l, r]
    }, useMutableSource: function () {
    }, useSyncExternalStore: function (r, l, p) {
        var y = Sr, T = yl();
        if (wr) {
            if (p === void 0) throw Error(Wt(407));
            p = p()
        } else {
            if (p = l(), xo === null) throw Error(Wt(349));
            id & 30 || uR(y, l, p)
        }
        T.memoizedState = p;
        var A = {value: p, getSnapshot: l};
        return T.queue = A, IC(dR.bind(null, y, A, r), [r]), y.flags |= 2048, m_(9, hR.bind(null, y, A, p, l), void 0, null), p
    }, useId: function () {
        var r = yl(), l = xo.identifierPrefix;
        if (wr) {
            var p = ac, y = sc;
            p = (y & ~(1 << 32 - ka(y) - 1)).toString(32) + p, l = ":" + l + "R" + p, p = f_++, 0 < p && (l += "H" + p.toString(32)), l += ":"
        } else p = GB++, l = ":" + l + "r" + p.toString(32) + ":";
        return r.memoizedState = l
    }, unstable_isNewReconciler: !1
}, ZB = {
    readContext: ha,
    useCallback: xR,
    useContext: ha,
    useEffect: f2,
    useImperativeHandle: vR,
    useInsertionEffect: gR,
    useLayoutEffect: _R,
    useMemo: wR,
    useReducer: tb,
    useRef: mR,
    useState: function () {
        return tb(p_)
    },
    useDebugValue: p2,
    useDeferredValue: function (r) {
        var l = da();
        return bR(l, ro.memoizedState, r)
    },
    useTransition: function () {
        var r = tb(p_)[0], l = da().memoizedState;
        return [r, l]
    },
    useMutableSource: lR,
    useSyncExternalStore: cR,
    useId: TR,
    unstable_isNewReconciler: !1
}, XB = {
    readContext: ha,
    useCallback: xR,
    useContext: ha,
    useEffect: f2,
    useImperativeHandle: vR,
    useInsertionEffect: gR,
    useLayoutEffect: _R,
    useMemo: wR,
    useReducer: ib,
    useRef: mR,
    useState: function () {
        return ib(p_)
    },
    useDebugValue: p2,
    useDeferredValue: function (r) {
        var l = da();
        return ro === null ? l.memoizedState = r : bR(l, ro.memoizedState, r)
    },
    useTransition: function () {
        var r = ib(p_)[0], l = da().memoizedState;
        return [r, l]
    },
    useMutableSource: lR,
    useSyncExternalStore: cR,
    useId: TR,
    unstable_isNewReconciler: !1
};

function Ca(r, l) {
    if (r && r.defaultProps) {
        l = Er({}, l), r = r.defaultProps;
        for (var p in r) l[p] === void 0 && (l[p] = r[p]);
        return l
    }
    return l
}

function Yb(r, l, p, y) {
    l = r.memoizedState, p = p(y, l), p = p == null ? l : Er({}, l, p), r.memoizedState = p, r.lanes === 0 && (r.updateQueue.baseState = p)
}

var fx = {
    isMounted: function (r) {
        return (r = r._reactInternals) ? ad(r) === r : !1
    }, enqueueSetState: function (r, l, p) {
        r = r._reactInternals;
        var y = us(), T = Mu(r), A = lc(y, T);
        A.payload = l, p != null && (A.callback = p), l = Cu(r, A, T), l !== null && (Oa(l, r, T, y), cv(l, r, T))
    }, enqueueReplaceState: function (r, l, p) {
        r = r._reactInternals;
        var y = us(), T = Mu(r), A = lc(y, T);
        A.tag = 1, A.payload = l, p != null && (A.callback = p), l = Cu(r, A, T), l !== null && (Oa(l, r, T, y), cv(l, r, T))
    }, enqueueForceUpdate: function (r, l) {
        r = r._reactInternals;
        var p = us(), y = Mu(r), T = lc(p, y);
        T.tag = 2, l != null && (T.callback = l), l = Cu(r, T, y), l !== null && (Oa(l, r, y, p), cv(l, r, y))
    }
};

function CC(r, l, p, y, T, A, D) {
    return r = r.stateNode, typeof r.shouldComponentUpdate == "function" ? r.shouldComponentUpdate(y, A, D) : l.prototype && l.prototype.isPureReactComponent ? !a_(p, y) || !a_(T, A) : !0
}

function IR(r, l, p) {
    var y = !1, T = Lu, A = l.contextType;
    return typeof A == "object" && A !== null ? A = ha(A) : (T = Ps(l) ? ed : Wo.current, y = l.contextTypes, A = (y = y != null) ? cp(r, T) : Lu), l = new l(p, A), r.memoizedState = l.state !== null && l.state !== void 0 ? l.state : null, l.updater = fx, r.stateNode = l, l._reactInternals = r, y && (r = r.stateNode, r.__reactInternalMemoizedUnmaskedChildContext = T, r.__reactInternalMemoizedMaskedChildContext = A), l
}

function PC(r, l, p, y) {
    r = l.state, typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(p, y), typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(p, y), l.state !== r && fx.enqueueReplaceState(l, l.state, null)
}

function Kb(r, l, p, y) {
    var T = r.stateNode;
    T.props = p, T.state = r.memoizedState, T.refs = {}, s2(r);
    var A = l.contextType;
    typeof A == "object" && A !== null ? T.context = ha(A) : (A = Ps(l) ? ed : Wo.current, T.context = cp(r, A)), T.state = r.memoizedState, A = l.getDerivedStateFromProps, typeof A == "function" && (Yb(r, l, A, p), T.state = r.memoizedState), typeof l.getDerivedStateFromProps == "function" || typeof T.getSnapshotBeforeUpdate == "function" || typeof T.UNSAFE_componentWillMount != "function" && typeof T.componentWillMount != "function" || (l = T.state, typeof T.componentWillMount == "function" && T.componentWillMount(), typeof T.UNSAFE_componentWillMount == "function" && T.UNSAFE_componentWillMount(), l !== T.state && fx.enqueueReplaceState(T, T.state, null), Nv(r, p, T, y), T.state = r.memoizedState), typeof T.componentDidMount == "function" && (r.flags |= 4194308)
}

function fp(r, l) {
    try {
        var p = "", y = l;
        do p += TF(y), y = y.return; while (y);
        var T = p
    } catch (A) {
        T = `
Error generating stack: ` + A.message + `
` + A.stack
    }
    return {value: r, source: l, stack: T, digest: null}
}

function nb(r, l, p) {
    return {value: r, source: null, stack: p ?? null, digest: l ?? null}
}

function Qb(r, l) {
    try {
        console.error(l.value)
    } catch (p) {
        setTimeout(function () {
            throw p
        })
    }
}

var YB = typeof WeakMap == "function" ? WeakMap : Map;

function CR(r, l, p) {
    p = lc(-1, p), p.tag = 3, p.payload = {element: null};
    var y = l.value;
    return p.callback = function () {
        $v || ($v = !0, lT = y), Qb(r, l)
    }, p
}

function PR(r, l, p) {
    p = lc(-1, p), p.tag = 3;
    var y = r.type.getDerivedStateFromError;
    if (typeof y == "function") {
        var T = l.value;
        p.payload = function () {
            return y(T)
        }, p.callback = function () {
            Qb(r, l)
        }
    }
    var A = r.stateNode;
    return A !== null && typeof A.componentDidCatch == "function" && (p.callback = function () {
        Qb(r, l), typeof y != "function" && (Pu === null ? Pu = new Set([this]) : Pu.add(this));
        var D = l.stack;
        this.componentDidCatch(l.value, {componentStack: D !== null ? D : ""})
    }), p
}

function MC(r, l, p) {
    var y = r.pingCache;
    if (y === null) {
        y = r.pingCache = new YB;
        var T = new Set;
        y.set(l, T)
    } else T = y.get(l), T === void 0 && (T = new Set, y.set(l, T));
    T.has(p) || (T.add(p), r = uN.bind(null, r, l, p), l.then(r, r))
}

function RC(r) {
    do {
        var l;
        if ((l = r.tag === 13) && (l = r.memoizedState, l = l !== null ? l.dehydrated !== null : !0), l) return r;
        r = r.return
    } while (r !== null);
    return null
}

function zC(r, l, p, y, T) {
    return r.mode & 1 ? (r.flags |= 65536, r.lanes = T, r) : (r === l ? r.flags |= 65536 : (r.flags |= 128, p.flags |= 131072, p.flags &= -52805, p.tag === 1 && (p.alternate === null ? p.tag = 17 : (l = lc(-1, 1), l.tag = 2, Cu(p, l, 1))), p.lanes |= 1), r)
}

var KB = mc.ReactCurrentOwner, Is = !1;

function ls(r, l, p, y) {
    l.child = r === null ? rR(l, null, p, y) : hp(l, r.child, p, y)
}

function DC(r, l, p, y, T) {
    p = p.render;
    var A = l.ref;
    return Zf(l, T), y = h2(r, l, p, y, A, T), p = d2(), r !== null && !Is ? (l.updateQueue = r.updateQueue, l.flags &= -2053, r.lanes &= ~T, dc(r, l, T)) : (wr && p && JT(l), l.flags |= 1, ls(r, l, y, T), l.child)
}

function LC(r, l, p, y, T) {
    if (r === null) {
        var A = p.type;
        return typeof A == "function" && !b2(A) && A.defaultProps === void 0 && p.compare === null && p.defaultProps === void 0 ? (l.tag = 15, l.type = A, MR(r, l, A, y, T)) : (r = mv(p.type, null, y, l, l.mode, T), r.ref = l.ref, r.return = l, l.child = r)
    }
    if (A = r.child, !(r.lanes & T)) {
        var D = A.memoizedProps;
        if (p = p.compare, p = p !== null ? p : a_, p(D, y) && r.ref === l.ref) return dc(r, l, T)
    }
    return l.flags |= 1, r = Ru(A, y), r.ref = l.ref, r.return = l, l.child = r
}

function MR(r, l, p, y, T) {
    if (r !== null) {
        var A = r.memoizedProps;
        if (a_(A, y) && r.ref === l.ref) if (Is = !1, l.pendingProps = y = A, (r.lanes & T) !== 0) r.flags & 131072 && (Is = !0); else return l.lanes = r.lanes, dc(r, l, T)
    }
    return Jb(r, l, p, y, T)
}

function RR(r, l, p) {
    var y = l.pendingProps, T = y.children, A = r !== null ? r.memoizedState : null;
    if (y.mode === "hidden") if (!(l.mode & 1)) l.memoizedState = {
        baseLanes: 0,
        cachePool: null,
        transitions: null
    }, pr(Gf, Vs), Vs |= p; else {
        if (!(p & 1073741824)) return r = A !== null ? A.baseLanes | p : p, l.lanes = l.childLanes = 1073741824, l.memoizedState = {
            baseLanes: r,
            cachePool: null,
            transitions: null
        }, l.updateQueue = null, pr(Gf, Vs), Vs |= r, null;
        l.memoizedState = {
            baseLanes: 0,
            cachePool: null,
            transitions: null
        }, y = A !== null ? A.baseLanes : p, pr(Gf, Vs), Vs |= y
    } else A !== null ? (y = A.baseLanes | p, l.memoizedState = null) : y = p, pr(Gf, Vs), Vs |= y;
    return ls(r, l, T, p), l.child
}

function zR(r, l) {
    var p = l.ref;
    (r === null && p !== null || r !== null && r.ref !== p) && (l.flags |= 512, l.flags |= 2097152)
}

function Jb(r, l, p, y, T) {
    var A = Ps(p) ? ed : Wo.current;
    return A = cp(l, A), Zf(l, T), p = h2(r, l, p, y, A, T), y = d2(), r !== null && !Is ? (l.updateQueue = r.updateQueue, l.flags &= -2053, r.lanes &= ~T, dc(r, l, T)) : (wr && y && JT(l), l.flags |= 1, ls(r, l, p, T), l.child)
}

function kC(r, l, p, y, T) {
    if (Ps(p)) {
        var A = !0;
        Lv(l)
    } else A = !1;
    if (Zf(l, T), l.stateNode === null) dv(r, l), IR(l, p, y), Kb(l, p, y, T), y = !0; else if (r === null) {
        var D = l.stateNode, o = l.memoizedProps;
        D.props = o;
        var j = D.context, q = p.contextType;
        typeof q == "object" && q !== null ? q = ha(q) : (q = Ps(p) ? ed : Wo.current, q = cp(l, q));
        var ee = p.getDerivedStateFromProps,
            oe = typeof ee == "function" || typeof D.getSnapshotBeforeUpdate == "function";
        oe || typeof D.UNSAFE_componentWillReceiveProps != "function" && typeof D.componentWillReceiveProps != "function" || (o !== y || j !== q) && PC(l, D, y, q), fu = !1;
        var de = l.memoizedState;
        D.state = de, Nv(l, y, D, T), j = l.memoizedState, o !== y || de !== j || Cs.current || fu ? (typeof ee == "function" && (Yb(l, p, ee, y), j = l.memoizedState), (o = fu || CC(l, p, o, y, de, j, q)) ? (oe || typeof D.UNSAFE_componentWillMount != "function" && typeof D.componentWillMount != "function" || (typeof D.componentWillMount == "function" && D.componentWillMount(), typeof D.UNSAFE_componentWillMount == "function" && D.UNSAFE_componentWillMount()), typeof D.componentDidMount == "function" && (l.flags |= 4194308)) : (typeof D.componentDidMount == "function" && (l.flags |= 4194308), l.memoizedProps = y, l.memoizedState = j), D.props = y, D.state = j, D.context = q, y = o) : (typeof D.componentDidMount == "function" && (l.flags |= 4194308), y = !1)
    } else {
        D = l.stateNode, sR(r, l), o = l.memoizedProps, q = l.type === l.elementType ? o : Ca(l.type, o), D.props = q, oe = l.pendingProps, de = D.context, j = p.contextType, typeof j == "object" && j !== null ? j = ha(j) : (j = Ps(p) ? ed : Wo.current, j = cp(l, j));
        var ae = p.getDerivedStateFromProps;
        (ee = typeof ae == "function" || typeof D.getSnapshotBeforeUpdate == "function") || typeof D.UNSAFE_componentWillReceiveProps != "function" && typeof D.componentWillReceiveProps != "function" || (o !== oe || de !== j) && PC(l, D, y, j), fu = !1, de = l.memoizedState, D.state = de, Nv(l, y, D, T);
        var Re = l.memoizedState;
        o !== oe || de !== Re || Cs.current || fu ? (typeof ae == "function" && (Yb(l, p, ae, y), Re = l.memoizedState), (q = fu || CC(l, p, q, y, de, Re, j) || !1) ? (ee || typeof D.UNSAFE_componentWillUpdate != "function" && typeof D.componentWillUpdate != "function" || (typeof D.componentWillUpdate == "function" && D.componentWillUpdate(y, Re, j), typeof D.UNSAFE_componentWillUpdate == "function" && D.UNSAFE_componentWillUpdate(y, Re, j)), typeof D.componentDidUpdate == "function" && (l.flags |= 4), typeof D.getSnapshotBeforeUpdate == "function" && (l.flags |= 1024)) : (typeof D.componentDidUpdate != "function" || o === r.memoizedProps && de === r.memoizedState || (l.flags |= 4), typeof D.getSnapshotBeforeUpdate != "function" || o === r.memoizedProps && de === r.memoizedState || (l.flags |= 1024), l.memoizedProps = y, l.memoizedState = Re), D.props = y, D.state = Re, D.context = j, y = q) : (typeof D.componentDidUpdate != "function" || o === r.memoizedProps && de === r.memoizedState || (l.flags |= 4), typeof D.getSnapshotBeforeUpdate != "function" || o === r.memoizedProps && de === r.memoizedState || (l.flags |= 1024), y = !1)
    }
    return eT(r, l, p, y, A, T)
}

function eT(r, l, p, y, T, A) {
    zR(r, l);
    var D = (l.flags & 128) !== 0;
    if (!y && !D) return T && xC(l, p, !1), dc(r, l, A);
    y = l.stateNode, KB.current = l;
    var o = D && typeof p.getDerivedStateFromError != "function" ? null : y.render();
    return l.flags |= 1, r !== null && D ? (l.child = hp(l, r.child, null, A), l.child = hp(l, null, o, A)) : ls(r, l, o, A), l.memoizedState = y.state, T && xC(l, p, !0), l.child
}

function DR(r) {
    var l = r.stateNode;
    l.pendingContext ? vC(r, l.pendingContext, l.pendingContext !== l.context) : l.context && vC(r, l.context, !1), a2(r, l.containerInfo)
}

function OC(r, l, p, y, T) {
    return up(), t2(T), l.flags |= 256, ls(r, l, p, y), l.child
}

var tT = {dehydrated: null, treeContext: null, retryLane: 0};

function iT(r) {
    return {baseLanes: r, cachePool: null, transitions: null}
}

function LR(r, l, p) {
    var y = l.pendingProps, T = Tr.current, A = !1, D = (l.flags & 128) !== 0, o;
    if ((o = D) || (o = r !== null && r.memoizedState === null ? !1 : (T & 2) !== 0), o ? (A = !0, l.flags &= -129) : (r === null || r.memoizedState !== null) && (T |= 1), pr(Tr, T & 1), r === null) return Zb(l), r = l.memoizedState, r !== null && (r = r.dehydrated, r !== null) ? (l.mode & 1 ? r.data === "$!" ? l.lanes = 8 : l.lanes = 1073741824 : l.lanes = 1, null) : (D = y.children, r = y.fallback, A ? (y = l.mode, A = l.child, D = {
        mode: "hidden",
        children: D
    }, !(y & 1) && A !== null ? (A.childLanes = 0, A.pendingProps = D) : A = gx(D, y, 0, null), r = Jh(r, y, p, null), A.return = l, r.return = l, A.sibling = r, l.child = A, l.child.memoizedState = iT(p), l.memoizedState = tT, r) : m2(l, D));
    if (T = r.memoizedState, T !== null && (o = T.dehydrated, o !== null)) return QB(r, l, D, y, o, T, p);
    if (A) {
        A = y.fallback, D = l.mode, T = r.child, o = T.sibling;
        var j = {mode: "hidden", children: y.children};
        return !(D & 1) && l.child !== T ? (y = l.child, y.childLanes = 0, y.pendingProps = j, l.deletions = null) : (y = Ru(T, j), y.subtreeFlags = T.subtreeFlags & 14680064), o !== null ? A = Ru(o, A) : (A = Jh(A, D, p, null), A.flags |= 2), A.return = l, y.return = l, y.sibling = A, l.child = y, y = A, A = l.child, D = r.child.memoizedState, D = D === null ? iT(p) : {
            baseLanes: D.baseLanes | p,
            cachePool: null,
            transitions: D.transitions
        }, A.memoizedState = D, A.childLanes = r.childLanes & ~p, l.memoizedState = tT, y
    }
    return A = r.child, r = A.sibling, y = Ru(A, {
        mode: "visible",
        children: y.children
    }), !(l.mode & 1) && (y.lanes = p), y.return = l, y.sibling = null, r !== null && (p = l.deletions, p === null ? (l.deletions = [r], l.flags |= 16) : p.push(r)), l.child = y, l.memoizedState = null, y
}

function m2(r, l) {
    return l = gx({mode: "visible", children: l}, r.mode, 0, null), l.return = r, r.child = l
}

function W0(r, l, p, y) {
    return y !== null && t2(y), hp(l, r.child, null, p), r = m2(l, l.pendingProps.children), r.flags |= 2, l.memoizedState = null, r
}

function QB(r, l, p, y, T, A, D) {
    if (p) return l.flags & 256 ? (l.flags &= -257, y = nb(Error(Wt(422))), W0(r, l, D, y)) : l.memoizedState !== null ? (l.child = r.child, l.flags |= 128, null) : (A = y.fallback, T = l.mode, y = gx({
        mode: "visible",
        children: y.children
    }, T, 0, null), A = Jh(A, T, D, null), A.flags |= 2, y.return = l, A.return = l, y.sibling = A, l.child = y, l.mode & 1 && hp(l, r.child, null, D), l.child.memoizedState = iT(D), l.memoizedState = tT, A);
    if (!(l.mode & 1)) return W0(r, l, D, null);
    if (T.data === "$!") {
        if (y = T.nextSibling && T.nextSibling.dataset, y) var o = y.dgst;
        return y = o, A = Error(Wt(419)), y = nb(A, y, void 0), W0(r, l, D, y)
    }
    if (o = (D & r.childLanes) !== 0, Is || o) {
        if (y = xo, y !== null) {
            switch (D & -D) {
                case 4:
                    T = 2;
                    break;
                case 16:
                    T = 8;
                    break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                    T = 32;
                    break;
                case 536870912:
                    T = 268435456;
                    break;
                default:
                    T = 0
            }
            T = T & (y.suspendedLanes | D) ? 0 : T, T !== 0 && T !== A.retryLane && (A.retryLane = T, hc(r, T), Oa(y, r, T, -1))
        }
        return w2(), y = nb(Error(Wt(421))), W0(r, l, D, y)
    }
    return T.data === "$?" ? (l.flags |= 128, l.child = r.child, l = hN.bind(null, r), T._reactRetry = l, null) : (r = A.treeContext, Gs = Iu(T.nextSibling), $s = l, wr = !0, Da = null, r !== null && (sa[aa++] = sc, sa[aa++] = ac, sa[aa++] = td, sc = r.id, ac = r.overflow, td = l), l = m2(l, y.children), l.flags |= 4096, l)
}

function FC(r, l, p) {
    r.lanes |= l;
    var y = r.alternate;
    y !== null && (y.lanes |= l), Xb(r.return, l, p)
}

function rb(r, l, p, y, T) {
    var A = r.memoizedState;
    A === null ? r.memoizedState = {
        isBackwards: l,
        rendering: null,
        renderingStartTime: 0,
        last: y,
        tail: p,
        tailMode: T
    } : (A.isBackwards = l, A.rendering = null, A.renderingStartTime = 0, A.last = y, A.tail = p, A.tailMode = T)
}

function kR(r, l, p) {
    var y = l.pendingProps, T = y.revealOrder, A = y.tail;
    if (ls(r, l, y.children, p), y = Tr.current, y & 2) y = y & 1 | 2, l.flags |= 128; else {
        if (r !== null && r.flags & 128) e:for (r = l.child; r !== null;) {
            if (r.tag === 13) r.memoizedState !== null && FC(r, p, l); else if (r.tag === 19) FC(r, p, l); else if (r.child !== null) {
                r.child.return = r, r = r.child;
                continue
            }
            if (r === l) break e;
            for (; r.sibling === null;) {
                if (r.return === null || r.return === l) break e;
                r = r.return
            }
            r.sibling.return = r.return, r = r.sibling
        }
        y &= 1
    }
    if (pr(Tr, y), !(l.mode & 1)) l.memoizedState = null; else switch (T) {
        case"forwards":
            for (p = l.child, T = null; p !== null;) r = p.alternate, r !== null && jv(r) === null && (T = p), p = p.sibling;
            p = T, p === null ? (T = l.child, l.child = null) : (T = p.sibling, p.sibling = null), rb(l, !1, T, p, A);
            break;
        case"backwards":
            for (p = null, T = l.child, l.child = null; T !== null;) {
                if (r = T.alternate, r !== null && jv(r) === null) {
                    l.child = T;
                    break
                }
                r = T.sibling, T.sibling = p, p = T, T = r
            }
            rb(l, !0, p, null, A);
            break;
        case"together":
            rb(l, !1, null, null, void 0);
            break;
        default:
            l.memoizedState = null
    }
    return l.child
}

function dv(r, l) {
    !(l.mode & 1) && r !== null && (r.alternate = null, l.alternate = null, l.flags |= 2)
}

function dc(r, l, p) {
    if (r !== null && (l.dependencies = r.dependencies), nd |= l.lanes, !(p & l.childLanes)) return null;
    if (r !== null && l.child !== r.child) throw Error(Wt(153));
    if (l.child !== null) {
        for (r = l.child, p = Ru(r, r.pendingProps), l.child = p, p.return = l; r.sibling !== null;) r = r.sibling, p = p.sibling = Ru(r, r.pendingProps), p.return = l;
        p.sibling = null
    }
    return l.child
}

function JB(r, l, p) {
    switch (l.tag) {
        case 3:
            DR(l), up();
            break;
        case 5:
            aR(l);
            break;
        case 1:
            Ps(l.type) && Lv(l);
            break;
        case 4:
            a2(l, l.stateNode.containerInfo);
            break;
        case 10:
            var y = l.type._context, T = l.memoizedProps.value;
            pr(Fv, y._currentValue), y._currentValue = T;
            break;
        case 13:
            if (y = l.memoizedState, y !== null) return y.dehydrated !== null ? (pr(Tr, Tr.current & 1), l.flags |= 128, null) : p & l.child.childLanes ? LR(r, l, p) : (pr(Tr, Tr.current & 1), r = dc(r, l, p), r !== null ? r.sibling : null);
            pr(Tr, Tr.current & 1);
            break;
        case 19:
            if (y = (p & l.childLanes) !== 0, r.flags & 128) {
                if (y) return kR(r, l, p);
                l.flags |= 128
            }
            if (T = l.memoizedState, T !== null && (T.rendering = null, T.tail = null, T.lastEffect = null), pr(Tr, Tr.current), y) break;
            return null;
        case 22:
        case 23:
            return l.lanes = 0, RR(r, l, p)
    }
    return dc(r, l, p)
}

var OR, nT, FR, BR;
OR = function (r, l) {
    for (var p = l.child; p !== null;) {
        if (p.tag === 5 || p.tag === 6) r.appendChild(p.stateNode); else if (p.tag !== 4 && p.child !== null) {
            p.child.return = p, p = p.child;
            continue
        }
        if (p === l) break;
        for (; p.sibling === null;) {
            if (p.return === null || p.return === l) return;
            p = p.return
        }
        p.sibling.return = p.return, p = p.sibling
    }
};
nT = function () {
};
FR = function (r, l, p, y) {
    var T = r.memoizedProps;
    if (T !== y) {
        r = l.stateNode, $h(El.current);
        var A = null;
        switch (p) {
            case"input":
                T = Eb(r, T), y = Eb(r, y), A = [];
                break;
            case"select":
                T = Er({}, T, {value: void 0}), y = Er({}, y, {value: void 0}), A = [];
                break;
            case"textarea":
                T = Cb(r, T), y = Cb(r, y), A = [];
                break;
            default:
                typeof T.onClick != "function" && typeof y.onClick == "function" && (r.onclick = zv)
        }
        Mb(p, y);
        var D;
        p = null;
        for (q in T) if (!y.hasOwnProperty(q) && T.hasOwnProperty(q) && T[q] != null) if (q === "style") {
            var o = T[q];
            for (D in o) o.hasOwnProperty(D) && (p || (p = {}), p[D] = "")
        } else q !== "dangerouslySetInnerHTML" && q !== "children" && q !== "suppressContentEditableWarning" && q !== "suppressHydrationWarning" && q !== "autoFocus" && (e_.hasOwnProperty(q) ? A || (A = []) : (A = A || []).push(q, null));
        for (q in y) {
            var j = y[q];
            if (o = T != null ? T[q] : void 0, y.hasOwnProperty(q) && j !== o && (j != null || o != null)) if (q === "style") if (o) {
                for (D in o) !o.hasOwnProperty(D) || j && j.hasOwnProperty(D) || (p || (p = {}), p[D] = "");
                for (D in j) j.hasOwnProperty(D) && o[D] !== j[D] && (p || (p = {}), p[D] = j[D])
            } else p || (A || (A = []), A.push(q, p)), p = j; else q === "dangerouslySetInnerHTML" ? (j = j ? j.__html : void 0, o = o ? o.__html : void 0, j != null && o !== j && (A = A || []).push(q, j)) : q === "children" ? typeof j != "string" && typeof j != "number" || (A = A || []).push(q, "" + j) : q !== "suppressContentEditableWarning" && q !== "suppressHydrationWarning" && (e_.hasOwnProperty(q) ? (j != null && q === "onScroll" && yr("scroll", r), A || o === j || (A = [])) : (A = A || []).push(q, j))
        }
        p && (A = A || []).push("style", p);
        var q = A;
        (l.updateQueue = q) && (l.flags |= 4)
    }
};
BR = function (r, l, p, y) {
    p !== y && (l.flags |= 4)
};

function Dg(r, l) {
    if (!wr) switch (r.tailMode) {
        case"hidden":
            l = r.tail;
            for (var p = null; l !== null;) l.alternate !== null && (p = l), l = l.sibling;
            p === null ? r.tail = null : p.sibling = null;
            break;
        case"collapsed":
            p = r.tail;
            for (var y = null; p !== null;) p.alternate !== null && (y = p), p = p.sibling;
            y === null ? l || r.tail === null ? r.tail = null : r.tail.sibling = null : y.sibling = null
    }
}

function Uo(r) {
    var l = r.alternate !== null && r.alternate.child === r.child, p = 0, y = 0;
    if (l) for (var T = r.child; T !== null;) p |= T.lanes | T.childLanes, y |= T.subtreeFlags & 14680064, y |= T.flags & 14680064, T.return = r, T = T.sibling; else for (T = r.child; T !== null;) p |= T.lanes | T.childLanes, y |= T.subtreeFlags, y |= T.flags, T.return = r, T = T.sibling;
    return r.subtreeFlags |= y, r.childLanes = p, l
}

function eN(r, l, p) {
    var y = l.pendingProps;
    switch (e2(l), l.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return Uo(l), null;
        case 1:
            return Ps(l.type) && Dv(), Uo(l), null;
        case 3:
            return y = l.stateNode, dp(), vr(Cs), vr(Wo), c2(), y.pendingContext && (y.context = y.pendingContext, y.pendingContext = null), (r === null || r.child === null) && (H0(l) ? l.flags |= 4 : r === null || r.memoizedState.isDehydrated && !(l.flags & 256) || (l.flags |= 1024, Da !== null && (hT(Da), Da = null))), nT(r, l), Uo(l), null;
        case 5:
            l2(l);
            var T = $h(d_.current);
            if (p = l.type, r !== null && l.stateNode != null) FR(r, l, p, y, T), r.ref !== l.ref && (l.flags |= 512, l.flags |= 2097152); else {
                if (!y) {
                    if (l.stateNode === null) throw Error(Wt(166));
                    return Uo(l), null
                }
                if (r = $h(El.current), H0(l)) {
                    y = l.stateNode, p = l.type;
                    var A = l.memoizedProps;
                    switch (y[bl] = l, y[u_] = A, r = (l.mode & 1) !== 0, p) {
                        case"dialog":
                            yr("cancel", y), yr("close", y);
                            break;
                        case"iframe":
                        case"object":
                        case"embed":
                            yr("load", y);
                            break;
                        case"video":
                        case"audio":
                            for (T = 0; T < Ug.length; T++) yr(Ug[T], y);
                            break;
                        case"source":
                            yr("error", y);
                            break;
                        case"img":
                        case"image":
                        case"link":
                            yr("error", y), yr("load", y);
                            break;
                        case"details":
                            yr("toggle", y);
                            break;
                        case"input":
                            qI(y, A), yr("invalid", y);
                            break;
                        case"select":
                            y._wrapperState = {wasMultiple: !!A.multiple}, yr("invalid", y);
                            break;
                        case"textarea":
                            ZI(y, A), yr("invalid", y)
                    }
                    Mb(p, A), T = null;
                    for (var D in A) if (A.hasOwnProperty(D)) {
                        var o = A[D];
                        D === "children" ? typeof o == "string" ? y.textContent !== o && (A.suppressHydrationWarning !== !0 && $0(y.textContent, o, r), T = ["children", o]) : typeof o == "number" && y.textContent !== "" + o && (A.suppressHydrationWarning !== !0 && $0(y.textContent, o, r), T = ["children", "" + o]) : e_.hasOwnProperty(D) && o != null && D === "onScroll" && yr("scroll", y)
                    }
                    switch (p) {
                        case"input":
                            O0(y), WI(y, A, !0);
                            break;
                        case"textarea":
                            O0(y), XI(y);
                            break;
                        case"select":
                        case"option":
                            break;
                        default:
                            typeof A.onClick == "function" && (y.onclick = zv)
                    }
                    y = T, l.updateQueue = y, y !== null && (l.flags |= 4)
                } else {
                    D = T.nodeType === 9 ? T : T.ownerDocument, r === "http://www.w3.org/1999/xhtml" && (r = dM(p)), r === "http://www.w3.org/1999/xhtml" ? p === "script" ? (r = D.createElement("div"), r.innerHTML = "<script><\/script>", r = r.removeChild(r.firstChild)) : typeof y.is == "string" ? r = D.createElement(p, {is: y.is}) : (r = D.createElement(p), p === "select" && (D = r, y.multiple ? D.multiple = !0 : y.size && (D.size = y.size))) : r = D.createElementNS(r, p), r[bl] = l, r[u_] = y, OR(r, l, !1, !1), l.stateNode = r;
                    e:{
                        switch (D = Rb(p, y), p) {
                            case"dialog":
                                yr("cancel", r), yr("close", r), T = y;
                                break;
                            case"iframe":
                            case"object":
                            case"embed":
                                yr("load", r), T = y;
                                break;
                            case"video":
                            case"audio":
                                for (T = 0; T < Ug.length; T++) yr(Ug[T], r);
                                T = y;
                                break;
                            case"source":
                                yr("error", r), T = y;
                                break;
                            case"img":
                            case"image":
                            case"link":
                                yr("error", r), yr("load", r), T = y;
                                break;
                            case"details":
                                yr("toggle", r), T = y;
                                break;
                            case"input":
                                qI(r, y), T = Eb(r, y), yr("invalid", r);
                                break;
                            case"option":
                                T = y;
                                break;
                            case"select":
                                r._wrapperState = {wasMultiple: !!y.multiple}, T = Er({}, y, {value: void 0}), yr("invalid", r);
                                break;
                            case"textarea":
                                ZI(r, y), T = Cb(r, y), yr("invalid", r);
                                break;
                            default:
                                T = y
                        }
                        Mb(p, T), o = T;
                        for (A in o) if (o.hasOwnProperty(A)) {
                            var j = o[A];
                            A === "style" ? mM(r, j) : A === "dangerouslySetInnerHTML" ? (j = j ? j.__html : void 0, j != null && fM(r, j)) : A === "children" ? typeof j == "string" ? (p !== "textarea" || j !== "") && t_(r, j) : typeof j == "number" && t_(r, "" + j) : A !== "suppressContentEditableWarning" && A !== "suppressHydrationWarning" && A !== "autoFocus" && (e_.hasOwnProperty(A) ? j != null && A === "onScroll" && yr("scroll", r) : j != null && NT(r, A, j, D))
                        }
                        switch (p) {
                            case"input":
                                O0(r), WI(r, y, !1);
                                break;
                            case"textarea":
                                O0(r), XI(r);
                                break;
                            case"option":
                                y.value != null && r.setAttribute("value", "" + Du(y.value));
                                break;
                            case"select":
                                r.multiple = !!y.multiple, A = y.value, A != null ? $f(r, !!y.multiple, A, !1) : y.defaultValue != null && $f(r, !!y.multiple, y.defaultValue, !0);
                                break;
                            default:
                                typeof T.onClick == "function" && (r.onclick = zv)
                        }
                        switch (p) {
                            case"button":
                            case"input":
                            case"select":
                            case"textarea":
                                y = !!y.autoFocus;
                                break e;
                            case"img":
                                y = !0;
                                break e;
                            default:
                                y = !1
                        }
                    }
                    y && (l.flags |= 4)
                }
                l.ref !== null && (l.flags |= 512, l.flags |= 2097152)
            }
            return Uo(l), null;
        case 6:
            if (r && l.stateNode != null) BR(r, l, r.memoizedProps, y); else {
                if (typeof y != "string" && l.stateNode === null) throw Error(Wt(166));
                if (p = $h(d_.current), $h(El.current), H0(l)) {
                    if (y = l.stateNode, p = l.memoizedProps, y[bl] = l, (A = y.nodeValue !== p) && (r = $s, r !== null)) switch (r.tag) {
                        case 3:
                            $0(y.nodeValue, p, (r.mode & 1) !== 0);
                            break;
                        case 5:
                            r.memoizedProps.suppressHydrationWarning !== !0 && $0(y.nodeValue, p, (r.mode & 1) !== 0)
                    }
                    A && (l.flags |= 4)
                } else y = (p.nodeType === 9 ? p : p.ownerDocument).createTextNode(y), y[bl] = l, l.stateNode = y
            }
            return Uo(l), null;
        case 13:
            if (vr(Tr), y = l.memoizedState, r === null || r.memoizedState !== null && r.memoizedState.dehydrated !== null) {
                if (wr && Gs !== null && l.mode & 1 && !(l.flags & 128)) iR(), up(), l.flags |= 98560, A = !1; else if (A = H0(l), y !== null && y.dehydrated !== null) {
                    if (r === null) {
                        if (!A) throw Error(Wt(318));
                        if (A = l.memoizedState, A = A !== null ? A.dehydrated : null, !A) throw Error(Wt(317));
                        A[bl] = l
                    } else up(), !(l.flags & 128) && (l.memoizedState = null), l.flags |= 4;
                    Uo(l), A = !1
                } else Da !== null && (hT(Da), Da = null), A = !0;
                if (!A) return l.flags & 65536 ? l : null
            }
            return l.flags & 128 ? (l.lanes = p, l) : (y = y !== null, y !== (r !== null && r.memoizedState !== null) && y && (l.child.flags |= 8192, l.mode & 1 && (r === null || Tr.current & 1 ? oo === 0 && (oo = 3) : w2())), l.updateQueue !== null && (l.flags |= 4), Uo(l), null);
        case 4:
            return dp(), nT(r, l), r === null && l_(l.stateNode.containerInfo), Uo(l), null;
        case 10:
            return r2(l.type._context), Uo(l), null;
        case 17:
            return Ps(l.type) && Dv(), Uo(l), null;
        case 19:
            if (vr(Tr), A = l.memoizedState, A === null) return Uo(l), null;
            if (y = (l.flags & 128) !== 0, D = A.rendering, D === null) if (y) Dg(A, !1); else {
                if (oo !== 0 || r !== null && r.flags & 128) for (r = l.child; r !== null;) {
                    if (D = jv(r), D !== null) {
                        for (l.flags |= 128, Dg(A, !1), y = D.updateQueue, y !== null && (l.updateQueue = y, l.flags |= 4), l.subtreeFlags = 0, y = p, p = l.child; p !== null;) A = p, r = y, A.flags &= 14680066, D = A.alternate, D === null ? (A.childLanes = 0, A.lanes = r, A.child = null, A.subtreeFlags = 0, A.memoizedProps = null, A.memoizedState = null, A.updateQueue = null, A.dependencies = null, A.stateNode = null) : (A.childLanes = D.childLanes, A.lanes = D.lanes, A.child = D.child, A.subtreeFlags = 0, A.deletions = null, A.memoizedProps = D.memoizedProps, A.memoizedState = D.memoizedState, A.updateQueue = D.updateQueue, A.type = D.type, r = D.dependencies, A.dependencies = r === null ? null : {
                            lanes: r.lanes,
                            firstContext: r.firstContext
                        }), p = p.sibling;
                        return pr(Tr, Tr.current & 1 | 2), l.child
                    }
                    r = r.sibling
                }
                A.tail !== null && jr() > pp && (l.flags |= 128, y = !0, Dg(A, !1), l.lanes = 4194304)
            } else {
                if (!y) if (r = jv(D), r !== null) {
                    if (l.flags |= 128, y = !0, p = r.updateQueue, p !== null && (l.updateQueue = p, l.flags |= 4), Dg(A, !0), A.tail === null && A.tailMode === "hidden" && !D.alternate && !wr) return Uo(l), null
                } else 2 * jr() - A.renderingStartTime > pp && p !== 1073741824 && (l.flags |= 128, y = !0, Dg(A, !1), l.lanes = 4194304);
                A.isBackwards ? (D.sibling = l.child, l.child = D) : (p = A.last, p !== null ? p.sibling = D : l.child = D, A.last = D)
            }
            return A.tail !== null ? (l = A.tail, A.rendering = l, A.tail = l.sibling, A.renderingStartTime = jr(), l.sibling = null, p = Tr.current, pr(Tr, y ? p & 1 | 2 : p & 1), l) : (Uo(l), null);
        case 22:
        case 23:
            return x2(), y = l.memoizedState !== null, r !== null && r.memoizedState !== null !== y && (l.flags |= 8192), y && l.mode & 1 ? Vs & 1073741824 && (Uo(l), l.subtreeFlags & 6 && (l.flags |= 8192)) : Uo(l), null;
        case 24:
            return null;
        case 25:
            return null
    }
    throw Error(Wt(156, l.tag))
}

function tN(r, l) {
    switch (e2(l), l.tag) {
        case 1:
            return Ps(l.type) && Dv(), r = l.flags, r & 65536 ? (l.flags = r & -65537 | 128, l) : null;
        case 3:
            return dp(), vr(Cs), vr(Wo), c2(), r = l.flags, r & 65536 && !(r & 128) ? (l.flags = r & -65537 | 128, l) : null;
        case 5:
            return l2(l), null;
        case 13:
            if (vr(Tr), r = l.memoizedState, r !== null && r.dehydrated !== null) {
                if (l.alternate === null) throw Error(Wt(340));
                up()
            }
            return r = l.flags, r & 65536 ? (l.flags = r & -65537 | 128, l) : null;
        case 19:
            return vr(Tr), null;
        case 4:
            return dp(), null;
        case 10:
            return r2(l.type._context), null;
        case 22:
        case 23:
            return x2(), null;
        case 24:
            return null;
        default:
            return null
    }
}

var Z0 = !1, qo = !1, iN = typeof WeakSet == "function" ? WeakSet : Set, xi = null;

function Uf(r, l) {
    var p = r.ref;
    if (p !== null) if (typeof p == "function") try {
        p(null)
    } catch (y) {
        kr(r, l, y)
    } else p.current = null
}

function rT(r, l, p) {
    try {
        p()
    } catch (y) {
        kr(r, l, y)
    }
}

var BC = !1;

function nN(r, l) {
    if (Vb = Pv, r = GM(), QT(r)) {
        if ("selectionStart" in r) var p = {start: r.selectionStart, end: r.selectionEnd}; else e:{
            p = (p = r.ownerDocument) && p.defaultView || window;
            var y = p.getSelection && p.getSelection();
            if (y && y.rangeCount !== 0) {
                p = y.anchorNode;
                var T = y.anchorOffset, A = y.focusNode;
                y = y.focusOffset;
                try {
                    p.nodeType, A.nodeType
                } catch {
                    p = null;
                    break e
                }
                var D = 0, o = -1, j = -1, q = 0, ee = 0, oe = r, de = null;
                t:for (; ;) {
                    for (var ae; oe !== p || T !== 0 && oe.nodeType !== 3 || (o = D + T), oe !== A || y !== 0 && oe.nodeType !== 3 || (j = D + y), oe.nodeType === 3 && (D += oe.nodeValue.length), (ae = oe.firstChild) !== null;) de = oe, oe = ae;
                    for (; ;) {
                        if (oe === r) break t;
                        if (de === p && ++q === T && (o = D), de === A && ++ee === y && (j = D), (ae = oe.nextSibling) !== null) break;
                        oe = de, de = oe.parentNode
                    }
                    oe = ae
                }
                p = o === -1 || j === -1 ? null : {start: o, end: j}
            } else p = null
        }
        p = p || {start: 0, end: 0}
    } else p = null;
    for (Ub = {
        focusedElem: r,
        selectionRange: p
    }, Pv = !1, xi = l; xi !== null;) if (l = xi, r = l.child, (l.subtreeFlags & 1028) !== 0 && r !== null) r.return = l, xi = r; else for (; xi !== null;) {
        l = xi;
        try {
            var Re = l.alternate;
            if (l.flags & 1024) switch (l.tag) {
                case 0:
                case 11:
                case 15:
                    break;
                case 1:
                    if (Re !== null) {
                        var fe = Re.memoizedProps, Me = Re.memoizedState, pe = l.stateNode,
                            le = pe.getSnapshotBeforeUpdate(l.elementType === l.type ? fe : Ca(l.type, fe), Me);
                        pe.__reactInternalSnapshotBeforeUpdate = le
                    }
                    break;
                case 3:
                    var be = l.stateNode.containerInfo;
                    be.nodeType === 1 ? be.textContent = "" : be.nodeType === 9 && be.documentElement && be.removeChild(be.documentElement);
                    break;
                case 5:
                case 6:
                case 4:
                case 17:
                    break;
                default:
                    throw Error(Wt(163))
            }
        } catch (Ue) {
            kr(l, l.return, Ue)
        }
        if (r = l.sibling, r !== null) {
            r.return = l.return, xi = r;
            break
        }
        xi = l.return
    }
    return Re = BC, BC = !1, Re
}

function Yg(r, l, p) {
    var y = l.updateQueue;
    if (y = y !== null ? y.lastEffect : null, y !== null) {
        var T = y = y.next;
        do {
            if ((T.tag & r) === r) {
                var A = T.destroy;
                T.destroy = void 0, A !== void 0 && rT(l, p, A)
            }
            T = T.next
        } while (T !== y)
    }
}

function px(r, l) {
    if (l = l.updateQueue, l = l !== null ? l.lastEffect : null, l !== null) {
        var p = l = l.next;
        do {
            if ((p.tag & r) === r) {
                var y = p.create;
                p.destroy = y()
            }
            p = p.next
        } while (p !== l)
    }
}

function oT(r) {
    var l = r.ref;
    if (l !== null) {
        var p = r.stateNode;
        switch (r.tag) {
            case 5:
                r = p;
                break;
            default:
                r = p
        }
        typeof l == "function" ? l(r) : l.current = r
    }
}

function NR(r) {
    var l = r.alternate;
    l !== null && (r.alternate = null, NR(l)), r.child = null, r.deletions = null, r.sibling = null, r.tag === 5 && (l = r.stateNode, l !== null && (delete l[bl], delete l[u_], delete l[Hb], delete l[NB], delete l[jB])), r.stateNode = null, r.return = null, r.dependencies = null, r.memoizedProps = null, r.memoizedState = null, r.pendingProps = null, r.stateNode = null, r.updateQueue = null
}

function jR(r) {
    return r.tag === 5 || r.tag === 3 || r.tag === 4
}

function NC(r) {
    e:for (; ;) {
        for (; r.sibling === null;) {
            if (r.return === null || jR(r.return)) return null;
            r = r.return
        }
        for (r.sibling.return = r.return, r = r.sibling; r.tag !== 5 && r.tag !== 6 && r.tag !== 18;) {
            if (r.flags & 2 || r.child === null || r.tag === 4) continue e;
            r.child.return = r, r = r.child
        }
        if (!(r.flags & 2)) return r.stateNode
    }
}

function sT(r, l, p) {
    var y = r.tag;
    if (y === 5 || y === 6) r = r.stateNode, l ? p.nodeType === 8 ? p.parentNode.insertBefore(r, l) : p.insertBefore(r, l) : (p.nodeType === 8 ? (l = p.parentNode, l.insertBefore(r, p)) : (l = p, l.appendChild(r)), p = p._reactRootContainer, p != null || l.onclick !== null || (l.onclick = zv)); else if (y !== 4 && (r = r.child, r !== null)) for (sT(r, l, p), r = r.sibling; r !== null;) sT(r, l, p), r = r.sibling
}

function aT(r, l, p) {
    var y = r.tag;
    if (y === 5 || y === 6) r = r.stateNode, l ? p.insertBefore(r, l) : p.appendChild(r); else if (y !== 4 && (r = r.child, r !== null)) for (aT(r, l, p), r = r.sibling; r !== null;) aT(r, l, p), r = r.sibling
}

var Mo = null, za = !1;

function lu(r, l, p) {
    for (p = p.child; p !== null;) VR(r, l, p), p = p.sibling
}

function VR(r, l, p) {
    if (Sl && typeof Sl.onCommitFiberUnmount == "function") try {
        Sl.onCommitFiberUnmount(sx, p)
    } catch {
    }
    switch (p.tag) {
        case 5:
            qo || Uf(p, l);
        case 6:
            var y = Mo, T = za;
            Mo = null, lu(r, l, p), Mo = y, za = T, Mo !== null && (za ? (r = Mo, p = p.stateNode, r.nodeType === 8 ? r.parentNode.removeChild(p) : r.removeChild(p)) : Mo.removeChild(p.stateNode));
            break;
        case 18:
            Mo !== null && (za ? (r = Mo, p = p.stateNode, r.nodeType === 8 ? Kw(r.parentNode, p) : r.nodeType === 1 && Kw(r, p), o_(r)) : Kw(Mo, p.stateNode));
            break;
        case 4:
            y = Mo, T = za, Mo = p.stateNode.containerInfo, za = !0, lu(r, l, p), Mo = y, za = T;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            if (!qo && (y = p.updateQueue, y !== null && (y = y.lastEffect, y !== null))) {
                T = y = y.next;
                do {
                    var A = T, D = A.destroy;
                    A = A.tag, D !== void 0 && (A & 2 || A & 4) && rT(p, l, D), T = T.next
                } while (T !== y)
            }
            lu(r, l, p);
            break;
        case 1:
            if (!qo && (Uf(p, l), y = p.stateNode, typeof y.componentWillUnmount == "function")) try {
                y.props = p.memoizedProps, y.state = p.memoizedState, y.componentWillUnmount()
            } catch (o) {
                kr(p, l, o)
            }
            lu(r, l, p);
            break;
        case 21:
            lu(r, l, p);
            break;
        case 22:
            p.mode & 1 ? (qo = (y = qo) || p.memoizedState !== null, lu(r, l, p), qo = y) : lu(r, l, p);
            break;
        default:
            lu(r, l, p)
    }
}

function jC(r) {
    var l = r.updateQueue;
    if (l !== null) {
        r.updateQueue = null;
        var p = r.stateNode;
        p === null && (p = r.stateNode = new iN), l.forEach(function (y) {
            var T = dN.bind(null, r, y);
            p.has(y) || (p.add(y), y.then(T, T))
        })
    }
}

function Aa(r, l) {
    var p = l.deletions;
    if (p !== null) for (var y = 0; y < p.length; y++) {
        var T = p[y];
        try {
            var A = r, D = l, o = D;
            e:for (; o !== null;) {
                switch (o.tag) {
                    case 5:
                        Mo = o.stateNode, za = !1;
                        break e;
                    case 3:
                        Mo = o.stateNode.containerInfo, za = !0;
                        break e;
                    case 4:
                        Mo = o.stateNode.containerInfo, za = !0;
                        break e
                }
                o = o.return
            }
            if (Mo === null) throw Error(Wt(160));
            VR(A, D, T), Mo = null, za = !1;
            var j = T.alternate;
            j !== null && (j.return = null), T.return = null
        } catch (q) {
            kr(T, l, q)
        }
    }
    if (l.subtreeFlags & 12854) for (l = l.child; l !== null;) UR(l, r), l = l.sibling
}

function UR(r, l) {
    var p = r.alternate, y = r.flags;
    switch (r.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (Aa(l, r), _l(r), y & 4) {
                try {
                    Yg(3, r, r.return), px(3, r)
                } catch (fe) {
                    kr(r, r.return, fe)
                }
                try {
                    Yg(5, r, r.return)
                } catch (fe) {
                    kr(r, r.return, fe)
                }
            }
            break;
        case 1:
            Aa(l, r), _l(r), y & 512 && p !== null && Uf(p, p.return);
            break;
        case 5:
            if (Aa(l, r), _l(r), y & 512 && p !== null && Uf(p, p.return), r.flags & 32) {
                var T = r.stateNode;
                try {
                    t_(T, "")
                } catch (fe) {
                    kr(r, r.return, fe)
                }
            }
            if (y & 4 && (T = r.stateNode, T != null)) {
                var A = r.memoizedProps, D = p !== null ? p.memoizedProps : A, o = r.type, j = r.updateQueue;
                if (r.updateQueue = null, j !== null) try {
                    o === "input" && A.type === "radio" && A.name != null && uM(T, A), Rb(o, D);
                    var q = Rb(o, A);
                    for (D = 0; D < j.length; D += 2) {
                        var ee = j[D], oe = j[D + 1];
                        ee === "style" ? mM(T, oe) : ee === "dangerouslySetInnerHTML" ? fM(T, oe) : ee === "children" ? t_(T, oe) : NT(T, ee, oe, q)
                    }
                    switch (o) {
                        case"input":
                            Ab(T, A);
                            break;
                        case"textarea":
                            hM(T, A);
                            break;
                        case"select":
                            var de = T._wrapperState.wasMultiple;
                            T._wrapperState.wasMultiple = !!A.multiple;
                            var ae = A.value;
                            ae != null ? $f(T, !!A.multiple, ae, !1) : de !== !!A.multiple && (A.defaultValue != null ? $f(T, !!A.multiple, A.defaultValue, !0) : $f(T, !!A.multiple, A.multiple ? [] : "", !1))
                    }
                    T[u_] = A
                } catch (fe) {
                    kr(r, r.return, fe)
                }
            }
            break;
        case 6:
            if (Aa(l, r), _l(r), y & 4) {
                if (r.stateNode === null) throw Error(Wt(162));
                T = r.stateNode, A = r.memoizedProps;
                try {
                    T.nodeValue = A
                } catch (fe) {
                    kr(r, r.return, fe)
                }
            }
            break;
        case 3:
            if (Aa(l, r), _l(r), y & 4 && p !== null && p.memoizedState.isDehydrated) try {
                o_(l.containerInfo)
            } catch (fe) {
                kr(r, r.return, fe)
            }
            break;
        case 4:
            Aa(l, r), _l(r);
            break;
        case 13:
            Aa(l, r), _l(r), T = r.child, T.flags & 8192 && (A = T.memoizedState !== null, T.stateNode.isHidden = A, !A || T.alternate !== null && T.alternate.memoizedState !== null || (y2 = jr())), y & 4 && jC(r);
            break;
        case 22:
            if (ee = p !== null && p.memoizedState !== null, r.mode & 1 ? (qo = (q = qo) || ee, Aa(l, r), qo = q) : Aa(l, r), _l(r), y & 8192) {
                if (q = r.memoizedState !== null, (r.stateNode.isHidden = q) && !ee && r.mode & 1) for (xi = r, ee = r.child; ee !== null;) {
                    for (oe = xi = ee; xi !== null;) {
                        switch (de = xi, ae = de.child, de.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                                Yg(4, de, de.return);
                                break;
                            case 1:
                                Uf(de, de.return);
                                var Re = de.stateNode;
                                if (typeof Re.componentWillUnmount == "function") {
                                    y = de, p = de.return;
                                    try {
                                        l = y, Re.props = l.memoizedProps, Re.state = l.memoizedState, Re.componentWillUnmount()
                                    } catch (fe) {
                                        kr(y, p, fe)
                                    }
                                }
                                break;
                            case 5:
                                Uf(de, de.return);
                                break;
                            case 22:
                                if (de.memoizedState !== null) {
                                    UC(oe);
                                    continue
                                }
                        }
                        ae !== null ? (ae.return = de, xi = ae) : UC(oe)
                    }
                    ee = ee.sibling
                }
                e:for (ee = null, oe = r; ;) {
                    if (oe.tag === 5) {
                        if (ee === null) {
                            ee = oe;
                            try {
                                T = oe.stateNode, q ? (A = T.style, typeof A.setProperty == "function" ? A.setProperty("display", "none", "important") : A.display = "none") : (o = oe.stateNode, j = oe.memoizedProps.style, D = j != null && j.hasOwnProperty("display") ? j.display : null, o.style.display = pM("display", D))
                            } catch (fe) {
                                kr(r, r.return, fe)
                            }
                        }
                    } else if (oe.tag === 6) {
                        if (ee === null) try {
                            oe.stateNode.nodeValue = q ? "" : oe.memoizedProps
                        } catch (fe) {
                            kr(r, r.return, fe)
                        }
                    } else if ((oe.tag !== 22 && oe.tag !== 23 || oe.memoizedState === null || oe === r) && oe.child !== null) {
                        oe.child.return = oe, oe = oe.child;
                        continue
                    }
                    if (oe === r) break e;
                    for (; oe.sibling === null;) {
                        if (oe.return === null || oe.return === r) break e;
                        ee === oe && (ee = null), oe = oe.return
                    }
                    ee === oe && (ee = null), oe.sibling.return = oe.return, oe = oe.sibling
                }
            }
            break;
        case 19:
            Aa(l, r), _l(r), y & 4 && jC(r);
            break;
        case 21:
            break;
        default:
            Aa(l, r), _l(r)
    }
}

function _l(r) {
    var l = r.flags;
    if (l & 2) {
        try {
            e:{
                for (var p = r.return; p !== null;) {
                    if (jR(p)) {
                        var y = p;
                        break e
                    }
                    p = p.return
                }
                throw Error(Wt(160))
            }
            switch (y.tag) {
                case 5:
                    var T = y.stateNode;
                    y.flags & 32 && (t_(T, ""), y.flags &= -33);
                    var A = NC(r);
                    aT(r, A, T);
                    break;
                case 3:
                case 4:
                    var D = y.stateNode.containerInfo, o = NC(r);
                    sT(r, o, D);
                    break;
                default:
                    throw Error(Wt(161))
            }
        } catch (j) {
            kr(r, r.return, j)
        }
        r.flags &= -3
    }
    l & 4096 && (r.flags &= -4097)
}

function rN(r, l, p) {
    xi = r, GR(r)
}

function GR(r, l, p) {
    for (var y = (r.mode & 1) !== 0; xi !== null;) {
        var T = xi, A = T.child;
        if (T.tag === 22 && y) {
            var D = T.memoizedState !== null || Z0;
            if (!D) {
                var o = T.alternate, j = o !== null && o.memoizedState !== null || qo;
                o = Z0;
                var q = qo;
                if (Z0 = D, (qo = j) && !q) for (xi = T; xi !== null;) D = xi, j = D.child, D.tag === 22 && D.memoizedState !== null ? GC(T) : j !== null ? (j.return = D, xi = j) : GC(T);
                for (; A !== null;) xi = A, GR(A), A = A.sibling;
                xi = T, Z0 = o, qo = q
            }
            VC(r)
        } else T.subtreeFlags & 8772 && A !== null ? (A.return = T, xi = A) : VC(r)
    }
}

function VC(r) {
    for (; xi !== null;) {
        var l = xi;
        if (l.flags & 8772) {
            var p = l.alternate;
            try {
                if (l.flags & 8772) switch (l.tag) {
                    case 0:
                    case 11:
                    case 15:
                        qo || px(5, l);
                        break;
                    case 1:
                        var y = l.stateNode;
                        if (l.flags & 4 && !qo) if (p === null) y.componentDidMount(); else {
                            var T = l.elementType === l.type ? p.memoizedProps : Ca(l.type, p.memoizedProps);
                            y.componentDidUpdate(T, p.memoizedState, y.__reactInternalSnapshotBeforeUpdate)
                        }
                        var A = l.updateQueue;
                        A !== null && EC(l, A, y);
                        break;
                    case 3:
                        var D = l.updateQueue;
                        if (D !== null) {
                            if (p = null, l.child !== null) switch (l.child.tag) {
                                case 5:
                                    p = l.child.stateNode;
                                    break;
                                case 1:
                                    p = l.child.stateNode
                            }
                            EC(l, D, p)
                        }
                        break;
                    case 5:
                        var o = l.stateNode;
                        if (p === null && l.flags & 4) {
                            p = o;
                            var j = l.memoizedProps;
                            switch (l.type) {
                                case"button":
                                case"input":
                                case"select":
                                case"textarea":
                                    j.autoFocus && p.focus();
                                    break;
                                case"img":
                                    j.src && (p.src = j.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (l.memoizedState === null) {
                            var q = l.alternate;
                            if (q !== null) {
                                var ee = q.memoizedState;
                                if (ee !== null) {
                                    var oe = ee.dehydrated;
                                    oe !== null && o_(oe)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(Wt(163))
                }
                qo || l.flags & 512 && oT(l)
            } catch (de) {
                kr(l, l.return, de)
            }
        }
        if (l === r) {
            xi = null;
            break
        }
        if (p = l.sibling, p !== null) {
            p.return = l.return, xi = p;
            break
        }
        xi = l.return
    }
}

function UC(r) {
    for (; xi !== null;) {
        var l = xi;
        if (l === r) {
            xi = null;
            break
        }
        var p = l.sibling;
        if (p !== null) {
            p.return = l.return, xi = p;
            break
        }
        xi = l.return
    }
}

function GC(r) {
    for (; xi !== null;) {
        var l = xi;
        try {
            switch (l.tag) {
                case 0:
                case 11:
                case 15:
                    var p = l.return;
                    try {
                        px(4, l)
                    } catch (j) {
                        kr(l, p, j)
                    }
                    break;
                case 1:
                    var y = l.stateNode;
                    if (typeof y.componentDidMount == "function") {
                        var T = l.return;
                        try {
                            y.componentDidMount()
                        } catch (j) {
                            kr(l, T, j)
                        }
                    }
                    var A = l.return;
                    try {
                        oT(l)
                    } catch (j) {
                        kr(l, A, j)
                    }
                    break;
                case 5:
                    var D = l.return;
                    try {
                        oT(l)
                    } catch (j) {
                        kr(l, D, j)
                    }
            }
        } catch (j) {
            kr(l, l.return, j)
        }
        if (l === r) {
            xi = null;
            break
        }
        var o = l.sibling;
        if (o !== null) {
            o.return = l.return, xi = o;
            break
        }
        xi = l.return
    }
}

var oN = Math.ceil, Gv = mc.ReactCurrentDispatcher, g2 = mc.ReactCurrentOwner, ua = mc.ReactCurrentBatchConfig, $n = 0,
    xo = null, Wr = null, Ro = 0, Vs = 0, Gf = Nu(0), oo = 0, g_ = null, nd = 0, mx = 0, _2 = 0, Kg = null, As = null,
    y2 = 0, pp = 1 / 0, nc = null, $v = !1, lT = null, Pu = null, X0 = !1, bu = null, Hv = 0, Qg = 0, cT = null,
    fv = -1, pv = 0;

function us() {
    return $n & 6 ? jr() : fv !== -1 ? fv : fv = jr()
}

function Mu(r) {
    return r.mode & 1 ? $n & 2 && Ro !== 0 ? Ro & -Ro : UB.transition !== null ? (pv === 0 && (pv = IM()), pv) : (r = nr, r !== 0 || (r = window.event, r = r === void 0 ? 16 : LM(r.type)), r) : 1
}

function Oa(r, l, p, y) {
    if (50 < Qg) throw Qg = 0, cT = null, Error(Wt(185));
    A_(r, p, y), (!($n & 2) || r !== xo) && (r === xo && (!($n & 2) && (mx |= p), oo === 4 && mu(r, Ro)), Ms(r, y), p === 1 && $n === 0 && !(l.mode & 1) && (pp = jr() + 500, hx && ju()))
}

function Ms(r, l) {
    var p = r.callbackNode;
    UF(r, l);
    var y = Cv(r, r === xo ? Ro : 0);
    if (y === 0) p !== null && QI(p), r.callbackNode = null, r.callbackPriority = 0; else if (l = y & -y, r.callbackPriority !== l) {
        if (p != null && QI(p), l === 1) r.tag === 0 ? VB($C.bind(null, r)) : JM($C.bind(null, r)), FB(function () {
            !($n & 6) && ju()
        }), p = null; else {
            switch (CM(y)) {
                case 1:
                    p = $T;
                    break;
                case 4:
                    p = EM;
                    break;
                case 16:
                    p = Iv;
                    break;
                case 536870912:
                    p = AM;
                    break;
                default:
                    p = Iv
            }
            p = KR(p, $R.bind(null, r))
        }
        r.callbackPriority = l, r.callbackNode = p
    }
}

function $R(r, l) {
    if (fv = -1, pv = 0, $n & 6) throw Error(Wt(327));
    var p = r.callbackNode;
    if (Xf() && r.callbackNode !== p) return null;
    var y = Cv(r, r === xo ? Ro : 0);
    if (y === 0) return null;
    if (y & 30 || y & r.expiredLanes || l) l = qv(r, y); else {
        l = y;
        var T = $n;
        $n |= 2;
        var A = qR();
        (xo !== r || Ro !== l) && (nc = null, pp = jr() + 500, Qh(r, l));
        do try {
            lN();
            break
        } catch (o) {
            HR(r, o)
        } while (!0);
        n2(), Gv.current = A, $n = T, Wr !== null ? l = 0 : (xo = null, Ro = 0, l = oo)
    }
    if (l !== 0) {
        if (l === 2 && (T = Ob(r), T !== 0 && (y = T, l = uT(r, T))), l === 1) throw p = g_, Qh(r, 0), mu(r, y), Ms(r, jr()), p;
        if (l === 6) mu(r, y); else {
            if (T = r.current.alternate, !(y & 30) && !sN(T) && (l = qv(r, y), l === 2 && (A = Ob(r), A !== 0 && (y = A, l = uT(r, A))), l === 1)) throw p = g_, Qh(r, 0), mu(r, y), Ms(r, jr()), p;
            switch (r.finishedWork = T, r.finishedLanes = y, l) {
                case 0:
                case 1:
                    throw Error(Wt(345));
                case 2:
                    Vh(r, As, nc);
                    break;
                case 3:
                    if (mu(r, y), (y & 130023424) === y && (l = y2 + 500 - jr(), 10 < l)) {
                        if (Cv(r, 0) !== 0) break;
                        if (T = r.suspendedLanes, (T & y) !== y) {
                            us(), r.pingedLanes |= r.suspendedLanes & T;
                            break
                        }
                        r.timeoutHandle = $b(Vh.bind(null, r, As, nc), l);
                        break
                    }
                    Vh(r, As, nc);
                    break;
                case 4:
                    if (mu(r, y), (y & 4194240) === y) break;
                    for (l = r.eventTimes, T = -1; 0 < y;) {
                        var D = 31 - ka(y);
                        A = 1 << D, D = l[D], D > T && (T = D), y &= ~A
                    }
                    if (y = T, y = jr() - y, y = (120 > y ? 120 : 480 > y ? 480 : 1080 > y ? 1080 : 1920 > y ? 1920 : 3e3 > y ? 3e3 : 4320 > y ? 4320 : 1960 * oN(y / 1960)) - y, 10 < y) {
                        r.timeoutHandle = $b(Vh.bind(null, r, As, nc), y);
                        break
                    }
                    Vh(r, As, nc);
                    break;
                case 5:
                    Vh(r, As, nc);
                    break;
                default:
                    throw Error(Wt(329))
            }
        }
    }
    return Ms(r, jr()), r.callbackNode === p ? $R.bind(null, r) : null
}

function uT(r, l) {
    var p = Kg;
    return r.current.memoizedState.isDehydrated && (Qh(r, l).flags |= 256), r = qv(r, l), r !== 2 && (l = As, As = p, l !== null && hT(l)), r
}

function hT(r) {
    As === null ? As = r : As.push.apply(As, r)
}

function sN(r) {
    for (var l = r; ;) {
        if (l.flags & 16384) {
            var p = l.updateQueue;
            if (p !== null && (p = p.stores, p !== null)) for (var y = 0; y < p.length; y++) {
                var T = p[y], A = T.getSnapshot;
                T = T.value;
                try {
                    if (!Fa(A(), T)) return !1
                } catch {
                    return !1
                }
            }
        }
        if (p = l.child, l.subtreeFlags & 16384 && p !== null) p.return = l, l = p; else {
            if (l === r) break;
            for (; l.sibling === null;) {
                if (l.return === null || l.return === r) return !0;
                l = l.return
            }
            l.sibling.return = l.return, l = l.sibling
        }
    }
    return !0
}

function mu(r, l) {
    for (l &= ~_2, l &= ~mx, r.suspendedLanes |= l, r.pingedLanes &= ~l, r = r.expirationTimes; 0 < l;) {
        var p = 31 - ka(l), y = 1 << p;
        r[p] = -1, l &= ~y
    }
}

function $C(r) {
    if ($n & 6) throw Error(Wt(327));
    Xf();
    var l = Cv(r, 0);
    if (!(l & 1)) return Ms(r, jr()), null;
    var p = qv(r, l);
    if (r.tag !== 0 && p === 2) {
        var y = Ob(r);
        y !== 0 && (l = y, p = uT(r, y))
    }
    if (p === 1) throw p = g_, Qh(r, 0), mu(r, l), Ms(r, jr()), p;
    if (p === 6) throw Error(Wt(345));
    return r.finishedWork = r.current.alternate, r.finishedLanes = l, Vh(r, As, nc), Ms(r, jr()), null
}

function v2(r, l) {
    var p = $n;
    $n |= 1;
    try {
        return r(l)
    } finally {
        $n = p, $n === 0 && (pp = jr() + 500, hx && ju())
    }
}

function rd(r) {
    bu !== null && bu.tag === 0 && !($n & 6) && Xf();
    var l = $n;
    $n |= 1;
    var p = ua.transition, y = nr;
    try {
        if (ua.transition = null, nr = 1, r) return r()
    } finally {
        nr = y, ua.transition = p, $n = l, !($n & 6) && ju()
    }
}

function x2() {
    Vs = Gf.current, vr(Gf)
}

function Qh(r, l) {
    r.finishedWork = null, r.finishedLanes = 0;
    var p = r.timeoutHandle;
    if (p !== -1 && (r.timeoutHandle = -1, OB(p)), Wr !== null) for (p = Wr.return; p !== null;) {
        var y = p;
        switch (e2(y), y.tag) {
            case 1:
                y = y.type.childContextTypes, y != null && Dv();
                break;
            case 3:
                dp(), vr(Cs), vr(Wo), c2();
                break;
            case 5:
                l2(y);
                break;
            case 4:
                dp();
                break;
            case 13:
                vr(Tr);
                break;
            case 19:
                vr(Tr);
                break;
            case 10:
                r2(y.type._context);
                break;
            case 22:
            case 23:
                x2()
        }
        p = p.return
    }
    if (xo = r, Wr = r = Ru(r.current, null), Ro = Vs = l, oo = 0, g_ = null, _2 = mx = nd = 0, As = Kg = null, Gh !== null) {
        for (l = 0; l < Gh.length; l++) if (p = Gh[l], y = p.interleaved, y !== null) {
            p.interleaved = null;
            var T = y.next, A = p.pending;
            if (A !== null) {
                var D = A.next;
                A.next = T, y.next = D
            }
            p.pending = y
        }
        Gh = null
    }
    return r
}

function HR(r, l) {
    do {
        var p = Wr;
        try {
            if (n2(), uv.current = Uv, Vv) {
                for (var y = Sr.memoizedState; y !== null;) {
                    var T = y.queue;
                    T !== null && (T.pending = null), y = y.next
                }
                Vv = !1
            }
            if (id = 0, vo = ro = Sr = null, Xg = !1, f_ = 0, g2.current = null, p === null || p.return === null) {
                oo = 1, g_ = l, Wr = null;
                break
            }
            e:{
                var A = r, D = p.return, o = p, j = l;
                if (l = Ro, o.flags |= 32768, j !== null && typeof j == "object" && typeof j.then == "function") {
                    var q = j, ee = o, oe = ee.tag;
                    if (!(ee.mode & 1) && (oe === 0 || oe === 11 || oe === 15)) {
                        var de = ee.alternate;
                        de ? (ee.updateQueue = de.updateQueue, ee.memoizedState = de.memoizedState, ee.lanes = de.lanes) : (ee.updateQueue = null, ee.memoizedState = null)
                    }
                    var ae = RC(D);
                    if (ae !== null) {
                        ae.flags &= -257, zC(ae, D, o, A, l), ae.mode & 1 && MC(A, q, l), l = ae, j = q;
                        var Re = l.updateQueue;
                        if (Re === null) {
                            var fe = new Set;
                            fe.add(j), l.updateQueue = fe
                        } else Re.add(j);
                        break e
                    } else {
                        if (!(l & 1)) {
                            MC(A, q, l), w2();
                            break e
                        }
                        j = Error(Wt(426))
                    }
                } else if (wr && o.mode & 1) {
                    var Me = RC(D);
                    if (Me !== null) {
                        !(Me.flags & 65536) && (Me.flags |= 256), zC(Me, D, o, A, l), t2(fp(j, o));
                        break e
                    }
                }
                A = j = fp(j, o), oo !== 4 && (oo = 2), Kg === null ? Kg = [A] : Kg.push(A), A = D;
                do {
                    switch (A.tag) {
                        case 3:
                            A.flags |= 65536, l &= -l, A.lanes |= l;
                            var pe = CR(A, j, l);
                            SC(A, pe);
                            break e;
                        case 1:
                            o = j;
                            var le = A.type, be = A.stateNode;
                            if (!(A.flags & 128) && (typeof le.getDerivedStateFromError == "function" || be !== null && typeof be.componentDidCatch == "function" && (Pu === null || !Pu.has(be)))) {
                                A.flags |= 65536, l &= -l, A.lanes |= l;
                                var Ue = PR(A, o, l);
                                SC(A, Ue);
                                break e
                            }
                    }
                    A = A.return
                } while (A !== null)
            }
            ZR(p)
        } catch (et) {
            l = et, Wr === p && p !== null && (Wr = p = p.return);
            continue
        }
        break
    } while (!0)
}

function qR() {
    var r = Gv.current;
    return Gv.current = Uv, r === null ? Uv : r
}

function w2() {
    (oo === 0 || oo === 3 || oo === 2) && (oo = 4), xo === null || !(nd & 268435455) && !(mx & 268435455) || mu(xo, Ro)
}

function qv(r, l) {
    var p = $n;
    $n |= 2;
    var y = qR();
    (xo !== r || Ro !== l) && (nc = null, Qh(r, l));
    do try {
        aN();
        break
    } catch (T) {
        HR(r, T)
    } while (!0);
    if (n2(), $n = p, Gv.current = y, Wr !== null) throw Error(Wt(261));
    return xo = null, Ro = 0, oo
}

function aN() {
    for (; Wr !== null;) WR(Wr)
}

function lN() {
    for (; Wr !== null && !DF();) WR(Wr)
}

function WR(r) {
    var l = YR(r.alternate, r, Vs);
    r.memoizedProps = r.pendingProps, l === null ? ZR(r) : Wr = l, g2.current = null
}

function ZR(r) {
    var l = r;
    do {
        var p = l.alternate;
        if (r = l.return, l.flags & 32768) {
            if (p = tN(p, l), p !== null) {
                p.flags &= 32767, Wr = p;
                return
            }
            if (r !== null) r.flags |= 32768, r.subtreeFlags = 0, r.deletions = null; else {
                oo = 6, Wr = null;
                return
            }
        } else if (p = eN(p, l, Vs), p !== null) {
            Wr = p;
            return
        }
        if (l = l.sibling, l !== null) {
            Wr = l;
            return
        }
        Wr = l = r
    } while (l !== null);
    oo === 0 && (oo = 5)
}

function Vh(r, l, p) {
    var y = nr, T = ua.transition;
    try {
        ua.transition = null, nr = 1, cN(r, l, p, y)
    } finally {
        ua.transition = T, nr = y
    }
    return null
}

function cN(r, l, p, y) {
    do Xf(); while (bu !== null);
    if ($n & 6) throw Error(Wt(327));
    p = r.finishedWork;
    var T = r.finishedLanes;
    if (p === null) return null;
    if (r.finishedWork = null, r.finishedLanes = 0, p === r.current) throw Error(Wt(177));
    r.callbackNode = null, r.callbackPriority = 0;
    var A = p.lanes | p.childLanes;
    if (GF(r, A), r === xo && (Wr = xo = null, Ro = 0), !(p.subtreeFlags & 2064) && !(p.flags & 2064) || X0 || (X0 = !0, KR(Iv, function () {
        return Xf(), null
    })), A = (p.flags & 15990) !== 0, p.subtreeFlags & 15990 || A) {
        A = ua.transition, ua.transition = null;
        var D = nr;
        nr = 1;
        var o = $n;
        $n |= 4, g2.current = null, nN(r, p), UR(p, r), PB(Ub), Pv = !!Vb, Ub = Vb = null, r.current = p, rN(p), LF(), $n = o, nr = D, ua.transition = A
    } else r.current = p;
    if (X0 && (X0 = !1, bu = r, Hv = T), A = r.pendingLanes, A === 0 && (Pu = null), FF(p.stateNode), Ms(r, jr()), l !== null) for (y = r.onRecoverableError, p = 0; p < l.length; p++) T = l[p], y(T.value, {
        componentStack: T.stack,
        digest: T.digest
    });
    if ($v) throw $v = !1, r = lT, lT = null, r;
    return Hv & 1 && r.tag !== 0 && Xf(), A = r.pendingLanes, A & 1 ? r === cT ? Qg++ : (Qg = 0, cT = r) : Qg = 0, ju(), null
}

function Xf() {
    if (bu !== null) {
        var r = CM(Hv), l = ua.transition, p = nr;
        try {
            if (ua.transition = null, nr = 16 > r ? 16 : r, bu === null) var y = !1; else {
                if (r = bu, bu = null, Hv = 0, $n & 6) throw Error(Wt(331));
                var T = $n;
                for ($n |= 4, xi = r.current; xi !== null;) {
                    var A = xi, D = A.child;
                    if (xi.flags & 16) {
                        var o = A.deletions;
                        if (o !== null) {
                            for (var j = 0; j < o.length; j++) {
                                var q = o[j];
                                for (xi = q; xi !== null;) {
                                    var ee = xi;
                                    switch (ee.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Yg(8, ee, A)
                                    }
                                    var oe = ee.child;
                                    if (oe !== null) oe.return = ee, xi = oe; else for (; xi !== null;) {
                                        ee = xi;
                                        var de = ee.sibling, ae = ee.return;
                                        if (NR(ee), ee === q) {
                                            xi = null;
                                            break
                                        }
                                        if (de !== null) {
                                            de.return = ae, xi = de;
                                            break
                                        }
                                        xi = ae
                                    }
                                }
                            }
                            var Re = A.alternate;
                            if (Re !== null) {
                                var fe = Re.child;
                                if (fe !== null) {
                                    Re.child = null;
                                    do {
                                        var Me = fe.sibling;
                                        fe.sibling = null, fe = Me
                                    } while (fe !== null)
                                }
                            }
                            xi = A
                        }
                    }
                    if (A.subtreeFlags & 2064 && D !== null) D.return = A, xi = D; else e:for (; xi !== null;) {
                        if (A = xi, A.flags & 2048) switch (A.tag) {
                            case 0:
                            case 11:
                            case 15:
                                Yg(9, A, A.return)
                        }
                        var pe = A.sibling;
                        if (pe !== null) {
                            pe.return = A.return, xi = pe;
                            break e
                        }
                        xi = A.return
                    }
                }
                var le = r.current;
                for (xi = le; xi !== null;) {
                    D = xi;
                    var be = D.child;
                    if (D.subtreeFlags & 2064 && be !== null) be.return = D, xi = be; else e:for (D = le; xi !== null;) {
                        if (o = xi, o.flags & 2048) try {
                            switch (o.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    px(9, o)
                            }
                        } catch (et) {
                            kr(o, o.return, et)
                        }
                        if (o === D) {
                            xi = null;
                            break e
                        }
                        var Ue = o.sibling;
                        if (Ue !== null) {
                            Ue.return = o.return, xi = Ue;
                            break e
                        }
                        xi = o.return
                    }
                }
                if ($n = T, ju(), Sl && typeof Sl.onPostCommitFiberRoot == "function") try {
                    Sl.onPostCommitFiberRoot(sx, r)
                } catch {
                }
                y = !0
            }
            return y
        } finally {
            nr = p, ua.transition = l
        }
    }
    return !1
}

function HC(r, l, p) {
    l = fp(p, l), l = CR(r, l, 1), r = Cu(r, l, 1), l = us(), r !== null && (A_(r, 1, l), Ms(r, l))
}

function kr(r, l, p) {
    if (r.tag === 3) HC(r, r, p); else for (; l !== null;) {
        if (l.tag === 3) {
            HC(l, r, p);
            break
        } else if (l.tag === 1) {
            var y = l.stateNode;
            if (typeof l.type.getDerivedStateFromError == "function" || typeof y.componentDidCatch == "function" && (Pu === null || !Pu.has(y))) {
                r = fp(p, r), r = PR(l, r, 1), l = Cu(l, r, 1), r = us(), l !== null && (A_(l, 1, r), Ms(l, r));
                break
            }
        }
        l = l.return
    }
}

function uN(r, l, p) {
    var y = r.pingCache;
    y !== null && y.delete(l), l = us(), r.pingedLanes |= r.suspendedLanes & p, xo === r && (Ro & p) === p && (oo === 4 || oo === 3 && (Ro & 130023424) === Ro && 500 > jr() - y2 ? Qh(r, 0) : _2 |= p), Ms(r, l)
}

function XR(r, l) {
    l === 0 && (r.mode & 1 ? (l = N0, N0 <<= 1, !(N0 & 130023424) && (N0 = 4194304)) : l = 1);
    var p = us();
    r = hc(r, l), r !== null && (A_(r, l, p), Ms(r, p))
}

function hN(r) {
    var l = r.memoizedState, p = 0;
    l !== null && (p = l.retryLane), XR(r, p)
}

function dN(r, l) {
    var p = 0;
    switch (r.tag) {
        case 13:
            var y = r.stateNode, T = r.memoizedState;
            T !== null && (p = T.retryLane);
            break;
        case 19:
            y = r.stateNode;
            break;
        default:
            throw Error(Wt(314))
    }
    y !== null && y.delete(l), XR(r, p)
}

var YR;
YR = function (r, l, p) {
    if (r !== null) if (r.memoizedProps !== l.pendingProps || Cs.current) Is = !0; else {
        if (!(r.lanes & p) && !(l.flags & 128)) return Is = !1, JB(r, l, p);
        Is = !!(r.flags & 131072)
    } else Is = !1, wr && l.flags & 1048576 && eR(l, Ov, l.index);
    switch (l.lanes = 0, l.tag) {
        case 2:
            var y = l.type;
            dv(r, l), r = l.pendingProps;
            var T = cp(l, Wo.current);
            Zf(l, p), T = h2(null, l, y, r, T, p);
            var A = d2();
            return l.flags |= 1, typeof T == "object" && T !== null && typeof T.render == "function" && T.$$typeof === void 0 ? (l.tag = 1, l.memoizedState = null, l.updateQueue = null, Ps(y) ? (A = !0, Lv(l)) : A = !1, l.memoizedState = T.state !== null && T.state !== void 0 ? T.state : null, s2(l), T.updater = fx, l.stateNode = T, T._reactInternals = l, Kb(l, y, r, p), l = eT(null, l, y, !0, A, p)) : (l.tag = 0, wr && A && JT(l), ls(null, l, T, p), l = l.child), l;
        case 16:
            y = l.elementType;
            e:{
                switch (dv(r, l), r = l.pendingProps, T = y._init, y = T(y._payload), l.type = y, T = l.tag = pN(y), r = Ca(y, r), T) {
                    case 0:
                        l = Jb(null, l, y, r, p);
                        break e;
                    case 1:
                        l = kC(null, l, y, r, p);
                        break e;
                    case 11:
                        l = DC(null, l, y, r, p);
                        break e;
                    case 14:
                        l = LC(null, l, y, Ca(y.type, r), p);
                        break e
                }
                throw Error(Wt(306, y, ""))
            }
            return l;
        case 0:
            return y = l.type, T = l.pendingProps, T = l.elementType === y ? T : Ca(y, T), Jb(r, l, y, T, p);
        case 1:
            return y = l.type, T = l.pendingProps, T = l.elementType === y ? T : Ca(y, T), kC(r, l, y, T, p);
        case 3:
            e:{
                if (DR(l), r === null) throw Error(Wt(387));
                y = l.pendingProps, A = l.memoizedState, T = A.element, sR(r, l), Nv(l, y, null, p);
                var D = l.memoizedState;
                if (y = D.element, A.isDehydrated) if (A = {
                    element: y,
                    isDehydrated: !1,
                    cache: D.cache,
                    pendingSuspenseBoundaries: D.pendingSuspenseBoundaries,
                    transitions: D.transitions
                }, l.updateQueue.baseState = A, l.memoizedState = A, l.flags & 256) {
                    T = fp(Error(Wt(423)), l), l = OC(r, l, y, p, T);
                    break e
                } else if (y !== T) {
                    T = fp(Error(Wt(424)), l), l = OC(r, l, y, p, T);
                    break e
                } else for (Gs = Iu(l.stateNode.containerInfo.firstChild), $s = l, wr = !0, Da = null, p = rR(l, null, y, p), l.child = p; p;) p.flags = p.flags & -3 | 4096, p = p.sibling; else {
                    if (up(), y === T) {
                        l = dc(r, l, p);
                        break e
                    }
                    ls(r, l, y, p)
                }
                l = l.child
            }
            return l;
        case 5:
            return aR(l), r === null && Zb(l), y = l.type, T = l.pendingProps, A = r !== null ? r.memoizedProps : null, D = T.children, Gb(y, T) ? D = null : A !== null && Gb(y, A) && (l.flags |= 32), zR(r, l), ls(r, l, D, p), l.child;
        case 6:
            return r === null && Zb(l), null;
        case 13:
            return LR(r, l, p);
        case 4:
            return a2(l, l.stateNode.containerInfo), y = l.pendingProps, r === null ? l.child = hp(l, null, y, p) : ls(r, l, y, p), l.child;
        case 11:
            return y = l.type, T = l.pendingProps, T = l.elementType === y ? T : Ca(y, T), DC(r, l, y, T, p);
        case 7:
            return ls(r, l, l.pendingProps, p), l.child;
        case 8:
            return ls(r, l, l.pendingProps.children, p), l.child;
        case 12:
            return ls(r, l, l.pendingProps.children, p), l.child;
        case 10:
            e:{
                if (y = l.type._context, T = l.pendingProps, A = l.memoizedProps, D = T.value, pr(Fv, y._currentValue), y._currentValue = D, A !== null) if (Fa(A.value, D)) {
                    if (A.children === T.children && !Cs.current) {
                        l = dc(r, l, p);
                        break e
                    }
                } else for (A = l.child, A !== null && (A.return = l); A !== null;) {
                    var o = A.dependencies;
                    if (o !== null) {
                        D = A.child;
                        for (var j = o.firstContext; j !== null;) {
                            if (j.context === y) {
                                if (A.tag === 1) {
                                    j = lc(-1, p & -p), j.tag = 2;
                                    var q = A.updateQueue;
                                    if (q !== null) {
                                        q = q.shared;
                                        var ee = q.pending;
                                        ee === null ? j.next = j : (j.next = ee.next, ee.next = j), q.pending = j
                                    }
                                }
                                A.lanes |= p, j = A.alternate, j !== null && (j.lanes |= p), Xb(A.return, p, l), o.lanes |= p;
                                break
                            }
                            j = j.next
                        }
                    } else if (A.tag === 10) D = A.type === l.type ? null : A.child; else if (A.tag === 18) {
                        if (D = A.return, D === null) throw Error(Wt(341));
                        D.lanes |= p, o = D.alternate, o !== null && (o.lanes |= p), Xb(D, p, l), D = A.sibling
                    } else D = A.child;
                    if (D !== null) D.return = A; else for (D = A; D !== null;) {
                        if (D === l) {
                            D = null;
                            break
                        }
                        if (A = D.sibling, A !== null) {
                            A.return = D.return, D = A;
                            break
                        }
                        D = D.return
                    }
                    A = D
                }
                ls(r, l, T.children, p), l = l.child
            }
            return l;
        case 9:
            return T = l.type, y = l.pendingProps.children, Zf(l, p), T = ha(T), y = y(T), l.flags |= 1, ls(r, l, y, p), l.child;
        case 14:
            return y = l.type, T = Ca(y, l.pendingProps), T = Ca(y.type, T), LC(r, l, y, T, p);
        case 15:
            return MR(r, l, l.type, l.pendingProps, p);
        case 17:
            return y = l.type, T = l.pendingProps, T = l.elementType === y ? T : Ca(y, T), dv(r, l), l.tag = 1, Ps(y) ? (r = !0, Lv(l)) : r = !1, Zf(l, p), IR(l, y, T), Kb(l, y, T, p), eT(null, l, y, !0, r, p);
        case 19:
            return kR(r, l, p);
        case 22:
            return RR(r, l, p)
    }
    throw Error(Wt(156, l.tag))
};

function KR(r, l) {
    return SM(r, l)
}

function fN(r, l, p, y) {
    this.tag = r, this.key = p, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = l, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = y, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
}

function la(r, l, p, y) {
    return new fN(r, l, p, y)
}

function b2(r) {
    return r = r.prototype, !(!r || !r.isReactComponent)
}

function pN(r) {
    if (typeof r == "function") return b2(r) ? 1 : 0;
    if (r != null) {
        if (r = r.$$typeof, r === VT) return 11;
        if (r === UT) return 14
    }
    return 2
}

function Ru(r, l) {
    var p = r.alternate;
    return p === null ? (p = la(r.tag, l, r.key, r.mode), p.elementType = r.elementType, p.type = r.type, p.stateNode = r.stateNode, p.alternate = r, r.alternate = p) : (p.pendingProps = l, p.type = r.type, p.flags = 0, p.subtreeFlags = 0, p.deletions = null), p.flags = r.flags & 14680064, p.childLanes = r.childLanes, p.lanes = r.lanes, p.child = r.child, p.memoizedProps = r.memoizedProps, p.memoizedState = r.memoizedState, p.updateQueue = r.updateQueue, l = r.dependencies, p.dependencies = l === null ? null : {
        lanes: l.lanes,
        firstContext: l.firstContext
    }, p.sibling = r.sibling, p.index = r.index, p.ref = r.ref, p
}

function mv(r, l, p, y, T, A) {
    var D = 2;
    if (y = r, typeof r == "function") b2(r) && (D = 1); else if (typeof r == "string") D = 5; else e:switch (r) {
        case Df:
            return Jh(p.children, T, A, l);
        case jT:
            D = 8, T |= 8;
            break;
        case wb:
            return r = la(12, p, l, T | 2), r.elementType = wb, r.lanes = A, r;
        case bb:
            return r = la(13, p, l, T), r.elementType = bb, r.lanes = A, r;
        case Tb:
            return r = la(19, p, l, T), r.elementType = Tb, r.lanes = A, r;
        case aM:
            return gx(p, T, A, l);
        default:
            if (typeof r == "object" && r !== null) switch (r.$$typeof) {
                case oM:
                    D = 10;
                    break e;
                case sM:
                    D = 9;
                    break e;
                case VT:
                    D = 11;
                    break e;
                case UT:
                    D = 14;
                    break e;
                case du:
                    D = 16, y = null;
                    break e
            }
            throw Error(Wt(130, r == null ? r : typeof r, ""))
    }
    return l = la(D, p, l, T), l.elementType = r, l.type = y, l.lanes = A, l
}

function Jh(r, l, p, y) {
    return r = la(7, r, y, l), r.lanes = p, r
}

function gx(r, l, p, y) {
    return r = la(22, r, y, l), r.elementType = aM, r.lanes = p, r.stateNode = {isHidden: !1}, r
}

function ob(r, l, p) {
    return r = la(6, r, null, l), r.lanes = p, r
}

function sb(r, l, p) {
    return l = la(4, r.children !== null ? r.children : [], r.key, l), l.lanes = p, l.stateNode = {
        containerInfo: r.containerInfo,
        pendingChildren: null,
        implementation: r.implementation
    }, l
}

function mN(r, l, p, y, T) {
    this.tag = l, this.containerInfo = r, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = jw(0), this.expirationTimes = jw(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = jw(0), this.identifierPrefix = y, this.onRecoverableError = T, this.mutableSourceEagerHydrationData = null
}

function T2(r, l, p, y, T, A, D, o, j) {
    return r = new mN(r, l, p, o, j), l === 1 ? (l = 1, A === !0 && (l |= 8)) : l = 0, A = la(3, null, null, l), r.current = A, A.stateNode = r, A.memoizedState = {
        element: y,
        isDehydrated: p,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    }, s2(A), r
}

function gN(r, l, p) {
    var y = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {$$typeof: zf, key: y == null ? null : "" + y, children: r, containerInfo: l, implementation: p}
}

function QR(r) {
    if (!r) return Lu;
    r = r._reactInternals;
    e:{
        if (ad(r) !== r || r.tag !== 1) throw Error(Wt(170));
        var l = r;
        do {
            switch (l.tag) {
                case 3:
                    l = l.stateNode.context;
                    break e;
                case 1:
                    if (Ps(l.type)) {
                        l = l.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                    }
            }
            l = l.return
        } while (l !== null);
        throw Error(Wt(171))
    }
    if (r.tag === 1) {
        var p = r.type;
        if (Ps(p)) return QM(r, p, l)
    }
    return l
}

function JR(r, l, p, y, T, A, D, o, j) {
    return r = T2(p, y, !0, r, T, A, D, o, j), r.context = QR(null), p = r.current, y = us(), T = Mu(p), A = lc(y, T), A.callback = l ?? null, Cu(p, A, T), r.current.lanes = T, A_(r, T, y), Ms(r, y), r
}

function _x(r, l, p, y) {
    var T = l.current, A = us(), D = Mu(T);
    return p = QR(p), l.context === null ? l.context = p : l.pendingContext = p, l = lc(A, D), l.payload = {element: r}, y = y === void 0 ? null : y, y !== null && (l.callback = y), r = Cu(T, l, D), r !== null && (Oa(r, T, D, A), cv(r, T, D)), D
}

function Wv(r) {
    if (r = r.current, !r.child) return null;
    switch (r.child.tag) {
        case 5:
            return r.child.stateNode;
        default:
            return r.child.stateNode
    }
}

function qC(r, l) {
    if (r = r.memoizedState, r !== null && r.dehydrated !== null) {
        var p = r.retryLane;
        r.retryLane = p !== 0 && p < l ? p : l
    }
}

function S2(r, l) {
    qC(r, l), (r = r.alternate) && qC(r, l)
}

function _N() {
    return null
}

var ez = typeof reportError == "function" ? reportError : function (r) {
    console.error(r)
};

function E2(r) {
    this._internalRoot = r
}

yx.prototype.render = E2.prototype.render = function (r) {
    var l = this._internalRoot;
    if (l === null) throw Error(Wt(409));
    _x(r, l, null, null)
};
yx.prototype.unmount = E2.prototype.unmount = function () {
    var r = this._internalRoot;
    if (r !== null) {
        this._internalRoot = null;
        var l = r.containerInfo;
        rd(function () {
            _x(null, r, null, null)
        }), l[uc] = null
    }
};

function yx(r) {
    this._internalRoot = r
}

yx.prototype.unstable_scheduleHydration = function (r) {
    if (r) {
        var l = RM();
        r = {blockedOn: null, target: r, priority: l};
        for (var p = 0; p < pu.length && l !== 0 && l < pu[p].priority; p++) ;
        pu.splice(p, 0, r), p === 0 && DM(r)
    }
};

function A2(r) {
    return !(!r || r.nodeType !== 1 && r.nodeType !== 9 && r.nodeType !== 11)
}

function vx(r) {
    return !(!r || r.nodeType !== 1 && r.nodeType !== 9 && r.nodeType !== 11 && (r.nodeType !== 8 || r.nodeValue !== " react-mount-point-unstable "))
}

function WC() {
}

function yN(r, l, p, y, T) {
    if (T) {
        if (typeof y == "function") {
            var A = y;
            y = function () {
                var q = Wv(D);
                A.call(q)
            }
        }
        var D = JR(l, y, r, 0, null, !1, !1, "", WC);
        return r._reactRootContainer = D, r[uc] = D.current, l_(r.nodeType === 8 ? r.parentNode : r), rd(), D
    }
    for (; T = r.lastChild;) r.removeChild(T);
    if (typeof y == "function") {
        var o = y;
        y = function () {
            var q = Wv(j);
            o.call(q)
        }
    }
    var j = T2(r, 0, !1, null, null, !1, !1, "", WC);
    return r._reactRootContainer = j, r[uc] = j.current, l_(r.nodeType === 8 ? r.parentNode : r), rd(function () {
        _x(l, j, p, y)
    }), j
}

function xx(r, l, p, y, T) {
    var A = p._reactRootContainer;
    if (A) {
        var D = A;
        if (typeof T == "function") {
            var o = T;
            T = function () {
                var j = Wv(D);
                o.call(j)
            }
        }
        _x(l, D, r, T)
    } else D = yN(p, l, r, T, y);
    return Wv(D)
}

PM = function (r) {
    switch (r.tag) {
        case 3:
            var l = r.stateNode;
            if (l.current.memoizedState.isDehydrated) {
                var p = Vg(l.pendingLanes);
                p !== 0 && (HT(l, p | 1), Ms(l, jr()), !($n & 6) && (pp = jr() + 500, ju()))
            }
            break;
        case 13:
            rd(function () {
                var y = hc(r, 1);
                if (y !== null) {
                    var T = us();
                    Oa(y, r, 1, T)
                }
            }), S2(r, 1)
    }
};
qT = function (r) {
    if (r.tag === 13) {
        var l = hc(r, 134217728);
        if (l !== null) {
            var p = us();
            Oa(l, r, 134217728, p)
        }
        S2(r, 134217728)
    }
};
MM = function (r) {
    if (r.tag === 13) {
        var l = Mu(r), p = hc(r, l);
        if (p !== null) {
            var y = us();
            Oa(p, r, l, y)
        }
        S2(r, l)
    }
};
RM = function () {
    return nr
};
zM = function (r, l) {
    var p = nr;
    try {
        return nr = r, l()
    } finally {
        nr = p
    }
};
Db = function (r, l, p) {
    switch (l) {
        case"input":
            if (Ab(r, p), l = p.name, p.type === "radio" && l != null) {
                for (p = r; p.parentNode;) p = p.parentNode;
                for (p = p.querySelectorAll("input[name=" + JSON.stringify("" + l) + '][type="radio"]'), l = 0; l < p.length; l++) {
                    var y = p[l];
                    if (y !== r && y.form === r.form) {
                        var T = ux(y);
                        if (!T) throw Error(Wt(90));
                        cM(y), Ab(y, T)
                    }
                }
            }
            break;
        case"textarea":
            hM(r, p);
            break;
        case"select":
            l = p.value, l != null && $f(r, !!p.multiple, l, !1)
    }
};
yM = v2;
vM = rd;
var vN = {usingClientEntryPoint: !1, Events: [C_, Ff, ux, gM, _M, v2]},
    Lg = {findFiberByHostInstance: Uh, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom"}, xN = {
        bundleType: Lg.bundleType,
        version: Lg.version,
        rendererPackageName: Lg.rendererPackageName,
        rendererConfig: Lg.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setErrorHandler: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: mc.ReactCurrentDispatcher,
        findHostInstanceByFiber: function (r) {
            return r = bM(r), r === null ? null : r.stateNode
        },
        findFiberByHostInstance: Lg.findFiberByHostInstance || _N,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null,
        reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
    };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Y0 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Y0.isDisabled && Y0.supportsFiber) try {
        sx = Y0.inject(xN), Sl = Y0
    } catch {
    }
}
Zs.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vN;
Zs.createPortal = function (r, l) {
    var p = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!A2(l)) throw Error(Wt(200));
    return gN(r, l, null, p)
};
Zs.createRoot = function (r, l) {
    if (!A2(r)) throw Error(Wt(299));
    var p = !1, y = "", T = ez;
    return l != null && (l.unstable_strictMode === !0 && (p = !0), l.identifierPrefix !== void 0 && (y = l.identifierPrefix), l.onRecoverableError !== void 0 && (T = l.onRecoverableError)), l = T2(r, 1, !1, null, null, p, !1, y, T), r[uc] = l.current, l_(r.nodeType === 8 ? r.parentNode : r), new E2(l)
};
Zs.findDOMNode = function (r) {
    if (r == null) return null;
    if (r.nodeType === 1) return r;
    var l = r._reactInternals;
    if (l === void 0) throw typeof r.render == "function" ? Error(Wt(188)) : (r = Object.keys(r).join(","), Error(Wt(268, r)));
    return r = bM(l), r = r === null ? null : r.stateNode, r
};
Zs.flushSync = function (r) {
    return rd(r)
};
Zs.hydrate = function (r, l, p) {
    if (!vx(l)) throw Error(Wt(200));
    return xx(null, r, l, !0, p)
};
Zs.hydrateRoot = function (r, l, p) {
    if (!A2(r)) throw Error(Wt(405));
    var y = p != null && p.hydratedSources || null, T = !1, A = "", D = ez;
    if (p != null && (p.unstable_strictMode === !0 && (T = !0), p.identifierPrefix !== void 0 && (A = p.identifierPrefix), p.onRecoverableError !== void 0 && (D = p.onRecoverableError)), l = JR(l, null, r, 1, p ?? null, T, !1, A, D), r[uc] = l.current, l_(r), y) for (r = 0; r < y.length; r++) p = y[r], T = p._getVersion, T = T(p._source), l.mutableSourceEagerHydrationData == null ? l.mutableSourceEagerHydrationData = [p, T] : l.mutableSourceEagerHydrationData.push(p, T);
    return new yx(l)
};
Zs.render = function (r, l, p) {
    if (!vx(l)) throw Error(Wt(200));
    return xx(null, r, l, !1, p)
};
Zs.unmountComponentAtNode = function (r) {
    if (!vx(r)) throw Error(Wt(40));
    return r._reactRootContainer ? (rd(function () {
        xx(null, null, r, !1, function () {
            r._reactRootContainer = null, r[uc] = null
        })
    }), !0) : !1
};
Zs.unstable_batchedUpdates = v2;
Zs.unstable_renderSubtreeIntoContainer = function (r, l, p, y) {
    if (!vx(p)) throw Error(Wt(200));
    if (r == null || r._reactInternals === void 0) throw Error(Wt(38));
    return xx(r, l, p, !1, y)
};
Zs.version = "18.3.1-next-f1338f8080-20240426";

function tz() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(tz)
    } catch (r) {
        console.error(r)
    }
}

tz(), tM.exports = Zs;
var M_ = tM.exports;
const iz = vp(M_);
var nz, ZC = M_;
nz = ZC.createRoot, ZC.hydrateRoot;
const wN = 1, bN = 1e6;
let ab = 0;

function TN() {
    return ab = (ab + 1) % Number.MAX_SAFE_INTEGER, ab.toString()
}

const lb = new Map, XC = r => {
    if (lb.has(r)) return;
    const l = setTimeout(() => {
        lb.delete(r), Jg({type: "REMOVE_TOAST", toastId: r})
    }, bN);
    lb.set(r, l)
}, SN = (r, l) => {
    switch (l.type) {
        case"ADD_TOAST":
            return {...r, toasts: [l.toast, ...r.toasts].slice(0, wN)};
        case"UPDATE_TOAST":
            return {...r, toasts: r.toasts.map(p => p.id === l.toast.id ? {...p, ...l.toast} : p)};
        case"DISMISS_TOAST": {
            const {toastId: p} = l;
            return p ? XC(p) : r.toasts.forEach(y => {
                XC(y.id)
            }), {...r, toasts: r.toasts.map(y => y.id === p || p === void 0 ? {...y, open: !1} : y)}
        }
        case"REMOVE_TOAST":
            return l.toastId === void 0 ? {...r, toasts: []} : {...r, toasts: r.toasts.filter(p => p.id !== l.toastId)}
    }
}, gv = [];
let _v = {toasts: []};

function Jg(r) {
    _v = SN(_v, r), gv.forEach(l => {
        l(_v)
    })
}

function EN({...r}) {
    const l = TN(), p = T => Jg({type: "UPDATE_TOAST", toast: {...T, id: l}}),
        y = () => Jg({type: "DISMISS_TOAST", toastId: l});
    return Jg({
        type: "ADD_TOAST", toast: {
            ...r, id: l, open: !0, onOpenChange: T => {
                T || y()
            }
        }
    }), {id: l, dismiss: y, update: p}
}

function rz() {
    const [r, l] = Ce.useState(_v);
    return Ce.useEffect(() => (gv.push(l), () => {
        const p = gv.indexOf(l);
        p > -1 && gv.splice(p, 1)
    }), [r]), {...r, toast: EN, dismiss: p => Jg({type: "DISMISS_TOAST", toastId: p})}
}

function Vr(r, l, {checkForDefaultPrevented: p = !0} = {}) {
    return function (T) {
        if (r == null || r(T), p === !1 || !T.defaultPrevented) return l == null ? void 0 : l(T)
    }
}

function YC(r, l) {
    if (typeof r == "function") return r(l);
    r != null && (r.current = l)
}

function oz(...r) {
    return l => {
        let p = !1;
        const y = r.map(T => {
            const A = YC(T, l);
            return !p && typeof A == "function" && (p = !0), A
        });
        if (p) return () => {
            for (let T = 0; T < y.length; T++) {
                const A = y[T];
                typeof A == "function" ? A() : YC(r[T], null)
            }
        }
    }
}

function Ws(...r) {
    return Ce.useCallback(oz(...r), r)
}

function Tp(r, l = []) {
    let p = [];

    function y(A, D) {
        const o = Ce.createContext(D), j = p.length;
        p = [...p, D];
        const q = oe => {
            var pe;
            const {scope: de, children: ae, ...Re} = oe,
                fe = ((pe = de == null ? void 0 : de[r]) == null ? void 0 : pe[j]) || o,
                Me = Ce.useMemo(() => Re, Object.values(Re));
            return K.jsx(fe.Provider, {value: Me, children: ae})
        };
        q.displayName = A + "Provider";

        function ee(oe, de) {
            var fe;
            const ae = ((fe = de == null ? void 0 : de[r]) == null ? void 0 : fe[j]) || o, Re = Ce.useContext(ae);
            if (Re) return Re;
            if (D !== void 0) return D;
            throw new Error(`\`${oe}\` must be used within \`${A}\``)
        }

        return [q, ee]
    }

    const T = () => {
        const A = p.map(D => Ce.createContext(D));
        return function (o) {
            const j = (o == null ? void 0 : o[r]) || A;
            return Ce.useMemo(() => ({[`__scope${r}`]: {...o, [r]: j}}), [o, j])
        }
    };
    return T.scopeName = r, [y, AN(T, ...l)]
}

function AN(...r) {
    const l = r[0];
    if (r.length === 1) return l;
    const p = () => {
        const y = r.map(T => ({useScope: T(), scopeName: T.scopeName}));
        return function (A) {
            const D = y.reduce((o, {useScope: j, scopeName: q}) => {
                const oe = j(A)[`__scope${q}`];
                return {...o, ...oe}
            }, {});
            return Ce.useMemo(() => ({[`__scope${l.scopeName}`]: D}), [D])
        }
    };
    return p.scopeName = l.scopeName, p
}

function Zv(r) {
    const l = CN(r), p = Ce.forwardRef((y, T) => {
        const {children: A, ...D} = y, o = Ce.Children.toArray(A), j = o.find(MN);
        if (j) {
            const q = j.props.children,
                ee = o.map(oe => oe === j ? Ce.Children.count(q) > 1 ? Ce.Children.only(null) : Ce.isValidElement(q) ? q.props.children : null : oe);
            return K.jsx(l, {...D, ref: T, children: Ce.isValidElement(q) ? Ce.cloneElement(q, void 0, ee) : null})
        }
        return K.jsx(l, {...D, ref: T, children: A})
    });
    return p.displayName = `${r}.Slot`, p
}

var IN = Zv("Slot");

function CN(r) {
    const l = Ce.forwardRef((p, y) => {
        const {children: T, ...A} = p;
        if (Ce.isValidElement(T)) {
            const D = zN(T), o = RN(A, T.props);
            return T.type !== Ce.Fragment && (o.ref = y ? oz(y, D) : D), Ce.cloneElement(T, o)
        }
        return Ce.Children.count(T) > 1 ? Ce.Children.only(null) : null
    });
    return l.displayName = `${r}.SlotClone`, l
}

var sz = Symbol("radix.slottable");

function PN(r) {
    const l = ({children: p}) => K.jsx(K.Fragment, {children: p});
    return l.displayName = `${r}.Slottable`, l.__radixId = sz, l
}

function MN(r) {
    return Ce.isValidElement(r) && typeof r.type == "function" && "__radixId" in r.type && r.type.__radixId === sz
}

function RN(r, l) {
    const p = {...l};
    for (const y in l) {
        const T = r[y], A = l[y];
        /^on[A-Z]/.test(y) ? T && A ? p[y] = (...o) => {
            const j = A(...o);
            return T(...o), j
        } : T && (p[y] = T) : y === "style" ? p[y] = {...T, ...A} : y === "className" && (p[y] = [T, A].filter(Boolean).join(" "))
    }
    return {...r, ...p}
}

function zN(r) {
    var y, T;
    let l = (y = Object.getOwnPropertyDescriptor(r.props, "ref")) == null ? void 0 : y.get,
        p = l && "isReactWarning" in l && l.isReactWarning;
    return p ? r.ref : (l = (T = Object.getOwnPropertyDescriptor(r, "ref")) == null ? void 0 : T.get, p = l && "isReactWarning" in l && l.isReactWarning, p ? r.props.ref : r.props.ref || r.ref)
}

function az(r) {
    const l = r + "CollectionProvider", [p, y] = Tp(l), [T, A] = p(l, {
        collectionRef: {current: null},
        itemMap: new Map
    }), D = fe => {
        const {scope: Me, children: pe} = fe, le = jt.useRef(null), be = jt.useRef(new Map).current;
        return K.jsx(T, {scope: Me, itemMap: be, collectionRef: le, children: pe})
    };
    D.displayName = l;
    const o = r + "CollectionSlot", j = Zv(o), q = jt.forwardRef((fe, Me) => {
        const {scope: pe, children: le} = fe, be = A(o, pe), Ue = Ws(Me, be.collectionRef);
        return K.jsx(j, {ref: Ue, children: le})
    });
    q.displayName = o;
    const ee = r + "CollectionItemSlot", oe = "data-radix-collection-item", de = Zv(ee),
        ae = jt.forwardRef((fe, Me) => {
            const {scope: pe, children: le, ...be} = fe, Ue = jt.useRef(null), et = Ws(Me, Ue), _t = A(ee, pe);
            return jt.useEffect(() => (_t.itemMap.set(Ue, {ref: Ue, ...be}), () => void _t.itemMap.delete(Ue))), K.jsx(de, {
                [oe]: "",
                ref: et,
                children: le
            })
        });
    ae.displayName = ee;

    function Re(fe) {
        const Me = A(r + "CollectionConsumer", fe);
        return jt.useCallback(() => {
            const le = Me.collectionRef.current;
            if (!le) return [];
            const be = Array.from(le.querySelectorAll(`[${oe}]`));
            return Array.from(Me.itemMap.values()).sort((_t, xt) => be.indexOf(_t.ref.current) - be.indexOf(xt.ref.current))
        }, [Me.collectionRef, Me.itemMap])
    }

    return [{Provider: D, Slot: q, ItemSlot: ae}, Re, y]
}

var DN = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "select", "span", "svg", "ul"],
    so = DN.reduce((r, l) => {
        const p = Zv(`Primitive.${l}`), y = Ce.forwardRef((T, A) => {
            const {asChild: D, ...o} = T, j = D ? p : l;
            return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), K.jsx(j, {...o, ref: A})
        });
        return y.displayName = `Primitive.${l}`, {...r, [l]: y}
    }, {});

function lz(r, l) {
    r && M_.flushSync(() => r.dispatchEvent(l))
}

function ku(r) {
    const l = Ce.useRef(r);
    return Ce.useEffect(() => {
        l.current = r
    }), Ce.useMemo(() => (...p) => {
        var y;
        return (y = l.current) == null ? void 0 : y.call(l, ...p)
    }, [])
}

function LN(r, l = globalThis == null ? void 0 : globalThis.document) {
    const p = ku(r);
    Ce.useEffect(() => {
        const y = T => {
            T.key === "Escape" && p(T)
        };
        return l.addEventListener("keydown", y, {capture: !0}), () => l.removeEventListener("keydown", y, {capture: !0})
    }, [p, l])
}

var kN = "DismissableLayer", dT = "dismissableLayer.update", ON = "dismissableLayer.pointerDownOutside",
    FN = "dismissableLayer.focusOutside", KC,
    cz = Ce.createContext({layers: new Set, layersWithOutsidePointerEventsDisabled: new Set, branches: new Set}),
    I2 = Ce.forwardRef((r, l) => {
        const {
                disableOutsidePointerEvents: p = !1,
                onEscapeKeyDown: y,
                onPointerDownOutside: T,
                onFocusOutside: A,
                onInteractOutside: D,
                onDismiss: o,
                ...j
            } = r, q = Ce.useContext(cz), [ee, oe] = Ce.useState(null),
            de = (ee == null ? void 0 : ee.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, ae] = Ce.useState({}),
            Re = Ws(l, xt => oe(xt)),
            fe = Array.from(q.layers), [Me] = [...q.layersWithOutsidePointerEventsDisabled].slice(-1),
            pe = fe.indexOf(Me), le = ee ? fe.indexOf(ee) : -1, be = q.layersWithOutsidePointerEventsDisabled.size > 0,
            Ue = le >= pe, et = NN(xt => {
                const Mt = xt.target, Xt = [...q.branches].some(Zt => Zt.contains(Mt));
                !Ue || Xt || (T == null || T(xt), D == null || D(xt), xt.defaultPrevented || o == null || o())
            }, de), _t = jN(xt => {
                const Mt = xt.target;
                [...q.branches].some(Zt => Zt.contains(Mt)) || (A == null || A(xt), D == null || D(xt), xt.defaultPrevented || o == null || o())
            }, de);
        return LN(xt => {
            le === q.layers.size - 1 && (y == null || y(xt), !xt.defaultPrevented && o && (xt.preventDefault(), o()))
        }, de), Ce.useEffect(() => {
            if (ee) return p && (q.layersWithOutsidePointerEventsDisabled.size === 0 && (KC = de.body.style.pointerEvents, de.body.style.pointerEvents = "none"), q.layersWithOutsidePointerEventsDisabled.add(ee)), q.layers.add(ee), QC(), () => {
                p && q.layersWithOutsidePointerEventsDisabled.size === 1 && (de.body.style.pointerEvents = KC)
            }
        }, [ee, de, p, q]), Ce.useEffect(() => () => {
            ee && (q.layers.delete(ee), q.layersWithOutsidePointerEventsDisabled.delete(ee), QC())
        }, [ee, q]), Ce.useEffect(() => {
            const xt = () => ae({});
            return document.addEventListener(dT, xt), () => document.removeEventListener(dT, xt)
        }, []), K.jsx(so.div, {
            ...j,
            ref: Re,
            style: {pointerEvents: be ? Ue ? "auto" : "none" : void 0, ...r.style},
            onFocusCapture: Vr(r.onFocusCapture, _t.onFocusCapture),
            onBlurCapture: Vr(r.onBlurCapture, _t.onBlurCapture),
            onPointerDownCapture: Vr(r.onPointerDownCapture, et.onPointerDownCapture)
        })
    });
I2.displayName = kN;
var BN = "DismissableLayerBranch", uz = Ce.forwardRef((r, l) => {
    const p = Ce.useContext(cz), y = Ce.useRef(null), T = Ws(l, y);
    return Ce.useEffect(() => {
        const A = y.current;
        if (A) return p.branches.add(A), () => {
            p.branches.delete(A)
        }
    }, [p.branches]), K.jsx(so.div, {...r, ref: T})
});
uz.displayName = BN;

function NN(r, l = globalThis == null ? void 0 : globalThis.document) {
    const p = ku(r), y = Ce.useRef(!1), T = Ce.useRef(() => {
    });
    return Ce.useEffect(() => {
        const A = o => {
            if (o.target && !y.current) {
                let j = function () {
                    hz(ON, p, q, {discrete: !0})
                };
                const q = {originalEvent: o};
                o.pointerType === "touch" ? (l.removeEventListener("click", T.current), T.current = j, l.addEventListener("click", T.current, {once: !0})) : j()
            } else l.removeEventListener("click", T.current);
            y.current = !1
        }, D = window.setTimeout(() => {
            l.addEventListener("pointerdown", A)
        }, 0);
        return () => {
            window.clearTimeout(D), l.removeEventListener("pointerdown", A), l.removeEventListener("click", T.current)
        }
    }, [l, p]), {onPointerDownCapture: () => y.current = !0}
}

function jN(r, l = globalThis == null ? void 0 : globalThis.document) {
    const p = ku(r), y = Ce.useRef(!1);
    return Ce.useEffect(() => {
        const T = A => {
            A.target && !y.current && hz(FN, p, {originalEvent: A}, {discrete: !1})
        };
        return l.addEventListener("focusin", T), () => l.removeEventListener("focusin", T)
    }, [l, p]), {onFocusCapture: () => y.current = !0, onBlurCapture: () => y.current = !1}
}

function QC() {
    const r = new CustomEvent(dT);
    document.dispatchEvent(r)
}

function hz(r, l, p, {discrete: y}) {
    const T = p.originalEvent.target, A = new CustomEvent(r, {bubbles: !1, cancelable: !0, detail: p});
    l && T.addEventListener(r, l, {once: !0}), y ? lz(T, A) : T.dispatchEvent(A)
}

var VN = I2, UN = uz, Il = globalThis != null && globalThis.document ? Ce.useLayoutEffect : () => {
}, GN = "Portal", dz = Ce.forwardRef((r, l) => {
    var o;
    const {container: p, ...y} = r, [T, A] = Ce.useState(!1);
    Il(() => A(!0), []);
    const D = p || T && ((o = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : o.body);
    return D ? iz.createPortal(K.jsx(so.div, {...y, ref: l}), D) : null
});
dz.displayName = GN;

function $N(r, l) {
    return Ce.useReducer((p, y) => l[p][y] ?? p, r)
}

var wx = r => {
    const {present: l, children: p} = r, y = HN(l),
        T = typeof p == "function" ? p({present: y.isPresent}) : Ce.Children.only(p), A = Ws(y.ref, qN(T));
    return typeof p == "function" || y.isPresent ? Ce.cloneElement(T, {ref: A}) : null
};
wx.displayName = "Presence";

function HN(r) {
    const [l, p] = Ce.useState(), y = Ce.useRef(null), T = Ce.useRef(r), A = Ce.useRef("none"),
        D = r ? "mounted" : "unmounted", [o, j] = $N(D, {
            mounted: {
                UNMOUNT: "unmounted",
                ANIMATION_OUT: "unmountSuspended"
            }, unmountSuspended: {MOUNT: "mounted", ANIMATION_END: "unmounted"}, unmounted: {MOUNT: "mounted"}
        });
    return Ce.useEffect(() => {
        const q = K0(y.current);
        A.current = o === "mounted" ? q : "none"
    }, [o]), Il(() => {
        const q = y.current, ee = T.current;
        if (ee !== r) {
            const de = A.current, ae = K0(q);
            r ? j("MOUNT") : ae === "none" || (q == null ? void 0 : q.display) === "none" ? j("UNMOUNT") : j(ee && de !== ae ? "ANIMATION_OUT" : "UNMOUNT"), T.current = r
        }
    }, [r, j]), Il(() => {
        if (l) {
            let q;
            const ee = l.ownerDocument.defaultView ?? window, oe = ae => {
                const fe = K0(y.current).includes(ae.animationName);
                if (ae.target === l && fe && (j("ANIMATION_END"), !T.current)) {
                    const Me = l.style.animationFillMode;
                    l.style.animationFillMode = "forwards", q = ee.setTimeout(() => {
                        l.style.animationFillMode === "forwards" && (l.style.animationFillMode = Me)
                    })
                }
            }, de = ae => {
                ae.target === l && (A.current = K0(y.current))
            };
            return l.addEventListener("animationstart", de), l.addEventListener("animationcancel", oe), l.addEventListener("animationend", oe), () => {
                ee.clearTimeout(q), l.removeEventListener("animationstart", de), l.removeEventListener("animationcancel", oe), l.removeEventListener("animationend", oe)
            }
        } else j("ANIMATION_END")
    }, [l, j]), {
        isPresent: ["mounted", "unmountSuspended"].includes(o), ref: Ce.useCallback(q => {
            y.current = q ? getComputedStyle(q) : null, p(q)
        }, [])
    }
}

function K0(r) {
    return (r == null ? void 0 : r.animationName) || "none"
}

function qN(r) {
    var y, T;
    let l = (y = Object.getOwnPropertyDescriptor(r.props, "ref")) == null ? void 0 : y.get,
        p = l && "isReactWarning" in l && l.isReactWarning;
    return p ? r.ref : (l = (T = Object.getOwnPropertyDescriptor(r, "ref")) == null ? void 0 : T.get, p = l && "isReactWarning" in l && l.isReactWarning, p ? r.props.ref : r.props.ref || r.ref)
}

var WN = OT[" useInsertionEffect ".trim().toString()] || Il;

function bx({
                prop: r, defaultProp: l, onChange: p = () => {
    }, caller: y
            }) {
    const [T, A, D] = ZN({defaultProp: l, onChange: p}), o = r !== void 0, j = o ? r : T;
    {
        const ee = Ce.useRef(r !== void 0);
        Ce.useEffect(() => {
            const oe = ee.current;
            oe !== o && console.warn(`${y} is changing from ${oe ? "controlled" : "uncontrolled"} to ${o ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`), ee.current = o
        }, [o, y])
    }
    const q = Ce.useCallback(ee => {
        var oe;
        if (o) {
            const de = XN(ee) ? ee(r) : ee;
            de !== r && ((oe = D.current) == null || oe.call(D, de))
        } else A(ee)
    }, [o, r, A, D]);
    return [j, q]
}

function ZN({defaultProp: r, onChange: l}) {
    const [p, y] = Ce.useState(r), T = Ce.useRef(p), A = Ce.useRef(l);
    return WN(() => {
        A.current = l
    }, [l]), Ce.useEffect(() => {
        var D;
        T.current !== p && ((D = A.current) == null || D.call(A, p), T.current = p)
    }, [p, T]), [p, y, A]
}

function XN(r) {
    return typeof r == "function"
}

var YN = Object.freeze({
    position: "absolute",
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal"
}), KN = "VisuallyHidden", Tx = Ce.forwardRef((r, l) => K.jsx(so.span, {...r, ref: l, style: {...YN, ...r.style}}));
Tx.displayName = KN;
var QN = Tx, C2 = "ToastProvider", [P2, JN, e5] = az("Toast"), [fz, d8] = Tp("Toast", [e5]), [t5, Sx] = fz(C2),
    pz = r => {
        const {
            __scopeToast: l,
            label: p = "Notification",
            duration: y = 5e3,
            swipeDirection: T = "right",
            swipeThreshold: A = 50,
            children: D
        } = r, [o, j] = Ce.useState(null), [q, ee] = Ce.useState(0), oe = Ce.useRef(!1), de = Ce.useRef(!1);
        return p.trim() || console.error(`Invalid prop \`label\` supplied to \`${C2}\`. Expected non-empty \`string\`.`), K.jsx(P2.Provider, {
            scope: l,
            children: K.jsx(t5, {
                scope: l,
                label: p,
                duration: y,
                swipeDirection: T,
                swipeThreshold: A,
                toastCount: q,
                viewport: o,
                onViewportChange: j,
                onToastAdd: Ce.useCallback(() => ee(ae => ae + 1), []),
                onToastRemove: Ce.useCallback(() => ee(ae => ae - 1), []),
                isFocusedToastEscapeKeyDownRef: oe,
                isClosePausedRef: de,
                children: D
            })
        })
    };
pz.displayName = C2;
var mz = "ToastViewport", i5 = ["F8"], fT = "toast.viewportPause", pT = "toast.viewportResume",
    gz = Ce.forwardRef((r, l) => {
        const {__scopeToast: p, hotkey: y = i5, label: T = "Notifications ({hotkey})", ...A} = r, D = Sx(mz, p),
            o = JN(p), j = Ce.useRef(null), q = Ce.useRef(null), ee = Ce.useRef(null), oe = Ce.useRef(null),
            de = Ws(l, oe, D.onViewportChange), ae = y.join("+").replace(/Key/g, "").replace(/Digit/g, ""),
            Re = D.toastCount > 0;
        Ce.useEffect(() => {
            const Me = pe => {
                var be;
                y.length !== 0 && y.every(Ue => pe[Ue] || pe.code === Ue) && ((be = oe.current) == null || be.focus())
            };
            return document.addEventListener("keydown", Me), () => document.removeEventListener("keydown", Me)
        }, [y]), Ce.useEffect(() => {
            const Me = j.current, pe = oe.current;
            if (Re && Me && pe) {
                const le = () => {
                    if (!D.isClosePausedRef.current) {
                        const _t = new CustomEvent(fT);
                        pe.dispatchEvent(_t), D.isClosePausedRef.current = !0
                    }
                }, be = () => {
                    if (D.isClosePausedRef.current) {
                        const _t = new CustomEvent(pT);
                        pe.dispatchEvent(_t), D.isClosePausedRef.current = !1
                    }
                }, Ue = _t => {
                    !Me.contains(_t.relatedTarget) && be()
                }, et = () => {
                    Me.contains(document.activeElement) || be()
                };
                return Me.addEventListener("focusin", le), Me.addEventListener("focusout", Ue), Me.addEventListener("pointermove", le), Me.addEventListener("pointerleave", et), window.addEventListener("blur", le), window.addEventListener("focus", be), () => {
                    Me.removeEventListener("focusin", le), Me.removeEventListener("focusout", Ue), Me.removeEventListener("pointermove", le), Me.removeEventListener("pointerleave", et), window.removeEventListener("blur", le), window.removeEventListener("focus", be)
                }
            }
        }, [Re, D.isClosePausedRef]);
        const fe = Ce.useCallback(({tabbingDirection: Me}) => {
            const le = o().map(be => {
                const Ue = be.ref.current, et = [Ue, ...m5(Ue)];
                return Me === "forwards" ? et : et.reverse()
            });
            return (Me === "forwards" ? le.reverse() : le).flat()
        }, [o]);
        return Ce.useEffect(() => {
            const Me = oe.current;
            if (Me) {
                const pe = le => {
                    var et, _t, xt;
                    const be = le.altKey || le.ctrlKey || le.metaKey;
                    if (le.key === "Tab" && !be) {
                        const Mt = document.activeElement, Xt = le.shiftKey;
                        if (le.target === Me && Xt) {
                            (et = q.current) == null || et.focus();
                            return
                        }
                        const hi = fe({tabbingDirection: Xt ? "backwards" : "forwards"}),
                            Mi = hi.findIndex($t => $t === Mt);
                        cb(hi.slice(Mi + 1)) ? le.preventDefault() : Xt ? (_t = q.current) == null || _t.focus() : (xt = ee.current) == null || xt.focus()
                    }
                };
                return Me.addEventListener("keydown", pe), () => Me.removeEventListener("keydown", pe)
            }
        }, [o, fe]), K.jsxs(UN, {
            ref: j,
            role: "region",
            "aria-label": T.replace("{hotkey}", ae),
            tabIndex: -1,
            style: {pointerEvents: Re ? void 0 : "none"},
            children: [Re && K.jsx(mT, {
                ref: q, onFocusFromOutsideViewport: () => {
                    const Me = fe({tabbingDirection: "forwards"});
                    cb(Me)
                }
            }), K.jsx(P2.Slot, {
                scope: p,
                children: K.jsx(so.ol, {tabIndex: -1, ...A, ref: de})
            }), Re && K.jsx(mT, {
                ref: ee, onFocusFromOutsideViewport: () => {
                    const Me = fe({tabbingDirection: "backwards"});
                    cb(Me)
                }
            })]
        })
    });
gz.displayName = mz;
var _z = "ToastFocusProxy", mT = Ce.forwardRef((r, l) => {
    const {__scopeToast: p, onFocusFromOutsideViewport: y, ...T} = r, A = Sx(_z, p);
    return K.jsx(Tx, {
        "aria-hidden": !0, tabIndex: 0, ...T, ref: l, style: {position: "fixed"}, onFocus: D => {
            var q;
            const o = D.relatedTarget;
            !((q = A.viewport) != null && q.contains(o)) && y()
        }
    })
});
mT.displayName = _z;
var R_ = "Toast", n5 = "toast.swipeStart", r5 = "toast.swipeMove", o5 = "toast.swipeCancel", s5 = "toast.swipeEnd",
    yz = Ce.forwardRef((r, l) => {
        const {forceMount: p, open: y, defaultOpen: T, onOpenChange: A, ...D} = r, [o, j] = bx({
            prop: y,
            defaultProp: T ?? !0,
            onChange: A,
            caller: R_
        });
        return K.jsx(wx, {
            present: p || o, children: K.jsx(c5, {
                open: o, ...D,
                ref: l,
                onClose: () => j(!1),
                onPause: ku(r.onPause),
                onResume: ku(r.onResume),
                onSwipeStart: Vr(r.onSwipeStart, q => {
                    q.currentTarget.setAttribute("data-swipe", "start")
                }),
                onSwipeMove: Vr(r.onSwipeMove, q => {
                    const {x: ee, y: oe} = q.detail.delta;
                    q.currentTarget.setAttribute("data-swipe", "move"), q.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${ee}px`), q.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${oe}px`)
                }),
                onSwipeCancel: Vr(r.onSwipeCancel, q => {
                    q.currentTarget.setAttribute("data-swipe", "cancel"), q.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), q.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), q.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), q.currentTarget.style.removeProperty("--radix-toast-swipe-end-y")
                }),
                onSwipeEnd: Vr(r.onSwipeEnd, q => {
                    const {x: ee, y: oe} = q.detail.delta;
                    q.currentTarget.setAttribute("data-swipe", "end"), q.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), q.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), q.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${ee}px`), q.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${oe}px`), j(!1)
                })
            })
        })
    });
yz.displayName = R_;
var [a5, l5] = fz(R_, {
    onClose() {
    }
}), c5 = Ce.forwardRef((r, l) => {
    const {
            __scopeToast: p,
            type: y = "foreground",
            duration: T,
            open: A,
            onClose: D,
            onEscapeKeyDown: o,
            onPause: j,
            onResume: q,
            onSwipeStart: ee,
            onSwipeMove: oe,
            onSwipeCancel: de,
            onSwipeEnd: ae,
            ...Re
        } = r, fe = Sx(R_, p), [Me, pe] = Ce.useState(null), le = Ws(l, $t => pe($t)), be = Ce.useRef(null),
        Ue = Ce.useRef(null), et = T || fe.duration, _t = Ce.useRef(0), xt = Ce.useRef(et),
        Mt = Ce.useRef(0), {onToastAdd: Xt, onToastRemove: Zt} = fe, Ht = ku(() => {
            var _i;
            (Me == null ? void 0 : Me.contains(document.activeElement)) && ((_i = fe.viewport) == null || _i.focus()), D()
        }), hi = Ce.useCallback($t => {
            !$t || $t === 1 / 0 || (window.clearTimeout(Mt.current), _t.current = new Date().getTime(), Mt.current = window.setTimeout(Ht, $t))
        }, [Ht]);
    Ce.useEffect(() => {
        const $t = fe.viewport;
        if ($t) {
            const _i = () => {
                hi(xt.current), q == null || q()
            }, si = () => {
                const Ri = new Date().getTime() - _t.current;
                xt.current = xt.current - Ri, window.clearTimeout(Mt.current), j == null || j()
            };
            return $t.addEventListener(fT, si), $t.addEventListener(pT, _i), () => {
                $t.removeEventListener(fT, si), $t.removeEventListener(pT, _i)
            }
        }
    }, [fe.viewport, et, j, q, hi]), Ce.useEffect(() => {
        A && !fe.isClosePausedRef.current && hi(et)
    }, [A, et, fe.isClosePausedRef, hi]), Ce.useEffect(() => (Xt(), () => Zt()), [Xt, Zt]);
    const Mi = Ce.useMemo(() => Me ? Ez(Me) : null, [Me]);
    return fe.viewport ? K.jsxs(K.Fragment, {
        children: [Mi && K.jsx(u5, {
            __scopeToast: p,
            role: "status",
            "aria-live": y === "foreground" ? "assertive" : "polite",
            "aria-atomic": !0,
            children: Mi
        }), K.jsx(a5, {
            scope: p, onClose: Ht, children: M_.createPortal(K.jsx(P2.ItemSlot, {
                scope: p, children: K.jsx(VN, {
                    asChild: !0, onEscapeKeyDown: Vr(o, () => {
                        fe.isFocusedToastEscapeKeyDownRef.current || Ht(), fe.isFocusedToastEscapeKeyDownRef.current = !1
                    }), children: K.jsx(so.li, {
                        role: "status",
                        "aria-live": "off",
                        "aria-atomic": !0,
                        tabIndex: 0,
                        "data-state": A ? "open" : "closed",
                        "data-swipe-direction": fe.swipeDirection, ...Re,
                        ref: le,
                        style: {userSelect: "none", touchAction: "none", ...r.style},
                        onKeyDown: Vr(r.onKeyDown, $t => {
                            $t.key === "Escape" && (o == null || o($t.nativeEvent), $t.nativeEvent.defaultPrevented || (fe.isFocusedToastEscapeKeyDownRef.current = !0, Ht()))
                        }),
                        onPointerDown: Vr(r.onPointerDown, $t => {
                            $t.button === 0 && (be.current = {x: $t.clientX, y: $t.clientY})
                        }),
                        onPointerMove: Vr(r.onPointerMove, $t => {
                            if (!be.current) return;
                            const _i = $t.clientX - be.current.x, si = $t.clientY - be.current.y, Ri = !!Ue.current,
                                Ct = ["left", "right"].includes(fe.swipeDirection),
                                Rt = ["left", "up"].includes(fe.swipeDirection) ? Math.min : Math.max,
                                ni = Ct ? Rt(0, _i) : 0, ai = Ct ? 0 : Rt(0, si),
                                fi = $t.pointerType === "touch" ? 10 : 2, nn = {x: ni, y: ai},
                                cn = {originalEvent: $t, delta: nn};
                            Ri ? (Ue.current = nn, Q0(r5, oe, cn, {discrete: !1})) : JC(nn, fe.swipeDirection, fi) ? (Ue.current = nn, Q0(n5, ee, cn, {discrete: !1}), $t.target.setPointerCapture($t.pointerId)) : (Math.abs(_i) > fi || Math.abs(si) > fi) && (be.current = null)
                        }),
                        onPointerUp: Vr(r.onPointerUp, $t => {
                            const _i = Ue.current, si = $t.target;
                            if (si.hasPointerCapture($t.pointerId) && si.releasePointerCapture($t.pointerId), Ue.current = null, be.current = null, _i) {
                                const Ri = $t.currentTarget, Ct = {originalEvent: $t, delta: _i};
                                JC(_i, fe.swipeDirection, fe.swipeThreshold) ? Q0(s5, ae, Ct, {discrete: !0}) : Q0(o5, de, Ct, {discrete: !0}), Ri.addEventListener("click", Rt => Rt.preventDefault(), {once: !0})
                            }
                        })
                    })
                })
            }), fe.viewport)
        })]
    }) : null
}), u5 = r => {
    const {__scopeToast: l, children: p, ...y} = r, T = Sx(R_, l), [A, D] = Ce.useState(!1), [o, j] = Ce.useState(!1);
    return f5(() => D(!0)), Ce.useEffect(() => {
        const q = window.setTimeout(() => j(!0), 1e3);
        return () => window.clearTimeout(q)
    }, []), o ? null : K.jsx(dz, {
        asChild: !0,
        children: K.jsx(Tx, {...y, children: A && K.jsxs(K.Fragment, {children: [T.label, " ", p]})})
    })
}, h5 = "ToastTitle", vz = Ce.forwardRef((r, l) => {
    const {__scopeToast: p, ...y} = r;
    return K.jsx(so.div, {...y, ref: l})
});
vz.displayName = h5;
var d5 = "ToastDescription", xz = Ce.forwardRef((r, l) => {
    const {__scopeToast: p, ...y} = r;
    return K.jsx(so.div, {...y, ref: l})
});
xz.displayName = d5;
var wz = "ToastAction", bz = Ce.forwardRef((r, l) => {
    const {altText: p, ...y} = r;
    return p.trim() ? K.jsx(Sz, {
        altText: p,
        asChild: !0,
        children: K.jsx(M2, {...y, ref: l})
    }) : (console.error(`Invalid prop \`altText\` supplied to \`${wz}\`. Expected non-empty \`string\`.`), null)
});
bz.displayName = wz;
var Tz = "ToastClose", M2 = Ce.forwardRef((r, l) => {
    const {__scopeToast: p, ...y} = r, T = l5(Tz, p);
    return K.jsx(Sz, {
        asChild: !0,
        children: K.jsx(so.button, {type: "button", ...y, ref: l, onClick: Vr(r.onClick, T.onClose)})
    })
});
M2.displayName = Tz;
var Sz = Ce.forwardRef((r, l) => {
    const {__scopeToast: p, altText: y, ...T} = r;
    return K.jsx(so.div, {
        "data-radix-toast-announce-exclude": "",
        "data-radix-toast-announce-alt": y || void 0, ...T,
        ref: l
    })
});

function Ez(r) {
    const l = [];
    return Array.from(r.childNodes).forEach(y => {
        if (y.nodeType === y.TEXT_NODE && y.textContent && l.push(y.textContent), p5(y)) {
            const T = y.ariaHidden || y.hidden || y.style.display === "none",
                A = y.dataset.radixToastAnnounceExclude === "";
            if (!T) if (A) {
                const D = y.dataset.radixToastAnnounceAlt;
                D && l.push(D)
            } else l.push(...Ez(y))
        }
    }), l
}

function Q0(r, l, p, {discrete: y}) {
    const T = p.originalEvent.currentTarget, A = new CustomEvent(r, {bubbles: !0, cancelable: !0, detail: p});
    l && T.addEventListener(r, l, {once: !0}), y ? lz(T, A) : T.dispatchEvent(A)
}

var JC = (r, l, p = 0) => {
    const y = Math.abs(r.x), T = Math.abs(r.y), A = y > T;
    return l === "left" || l === "right" ? A && y > p : !A && T > p
};

function f5(r = () => {
}) {
    const l = ku(r);
    Il(() => {
        let p = 0, y = 0;
        return p = window.requestAnimationFrame(() => y = window.requestAnimationFrame(l)), () => {
            window.cancelAnimationFrame(p), window.cancelAnimationFrame(y)
        }
    }, [l])
}

function p5(r) {
    return r.nodeType === r.ELEMENT_NODE
}

function m5(r) {
    const l = [], p = document.createTreeWalker(r, NodeFilter.SHOW_ELEMENT, {
        acceptNode: y => {
            const T = y.tagName === "INPUT" && y.type === "hidden";
            return y.disabled || y.hidden || T ? NodeFilter.FILTER_SKIP : y.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
        }
    });
    for (; p.nextNode();) l.push(p.currentNode);
    return l
}

function cb(r) {
    const l = document.activeElement;
    return r.some(p => p === l ? !0 : (p.focus(), document.activeElement !== l))
}

var g5 = pz, Az = gz, Iz = yz, Cz = vz, Pz = xz, Mz = bz, Rz = M2;

function zz(r) {
    var l, p, y = "";
    if (typeof r == "string" || typeof r == "number") y += r; else if (typeof r == "object") if (Array.isArray(r)) {
        var T = r.length;
        for (l = 0; l < T; l++) r[l] && (p = zz(r[l])) && (y && (y += " "), y += p)
    } else for (p in r) r[p] && (y && (y += " "), y += p);
    return y
}

function Dz() {
    for (var r, l, p = 0, y = "", T = arguments.length; p < T; p++) (r = arguments[p]) && (l = zz(r)) && (y && (y += " "), y += l);
    return y
}

const eP = r => typeof r == "boolean" ? `${r}` : r === 0 ? "0" : r, tP = Dz, Lz = (r, l) => p => {
    var y;
    if ((l == null ? void 0 : l.variants) == null) return tP(r, p == null ? void 0 : p.class, p == null ? void 0 : p.className);
    const {variants: T, defaultVariants: A} = l, D = Object.keys(T).map(q => {
        const ee = p == null ? void 0 : p[q], oe = A == null ? void 0 : A[q];
        if (ee === null) return null;
        const de = eP(ee) || eP(oe);
        return T[q][de]
    }), o = p && Object.entries(p).reduce((q, ee) => {
        let [oe, de] = ee;
        return de === void 0 || (q[oe] = de), q
    }, {}), j = l == null || (y = l.compoundVariants) === null || y === void 0 ? void 0 : y.reduce((q, ee) => {
        let {class: oe, className: de, ...ae} = ee;
        return Object.entries(ae).every(Re => {
            let [fe, Me] = Re;
            return Array.isArray(Me) ? Me.includes({...A, ...o}[fe]) : {...A, ...o}[fe] === Me
        }) ? [...q, oe, de] : q
    }, []);
    return tP(r, D, j, p == null ? void 0 : p.class, p == null ? void 0 : p.className)
};
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const _5 = r => r.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(),
    kz = (...r) => r.filter((l, p, y) => !!l && l.trim() !== "" && y.indexOf(l) === p).join(" ").trim();
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var y5 = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const v5 = Ce.forwardRef(({
                                 color: r = "currentColor",
                                 size: l = 24,
                                 strokeWidth: p = 2,
                                 absoluteStrokeWidth: y,
                                 className: T = "",
                                 children: A,
                                 iconNode: D,
                                 ...o
                             }, j) => Ce.createElement("svg", {
    ref: j, ...y5,
    width: l,
    height: l,
    stroke: r,
    strokeWidth: y ? Number(p) * 24 / Number(l) : p,
    className: kz("lucide", T), ...o
}, [...D.map(([q, ee]) => Ce.createElement(q, ee)), ...Array.isArray(A) ? A : [A]]));
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Vu = (r, l) => {
    const p = Ce.forwardRef(({className: y, ...T}, A) => Ce.createElement(v5, {
        ref: A,
        iconNode: l,
        className: kz(`lucide-${_5(r)}`, y), ...T
    }));
    return p.displayName = `${r}`, p
};
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Oz = Vu("BadgeCheck", [["path", {
    d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z",
    key: "3c2336"
}], ["path", {d: "m9 12 2 2 4-4", key: "dzmm74"}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Fz = Vu("Building2", [["path", {
    d: "M6 22V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v18Z",
    key: "1b4qmf"
}], ["path", {
    d: "M6 12H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2",
    key: "i71pzd"
}], ["path", {d: "M18 9h2a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-2", key: "10jefs"}], ["path", {
    d: "M10 6h4",
    key: "1itunk"
}], ["path", {d: "M10 10h4", key: "tcdvrf"}], ["path", {d: "M10 14h4", key: "kelpxr"}], ["path", {
    d: "M10 18h4",
    key: "1ulq68"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const x5 = Vu("ChartNoAxesColumnIncreasing", [["line", {
    x1: "12",
    x2: "12",
    y1: "20",
    y2: "10",
    key: "1vz5eb"
}], ["line", {x1: "18", x2: "18", y1: "20", y2: "4", key: "cun8e5"}], ["line", {
    x1: "6",
    x2: "6",
    y1: "20",
    y2: "16",
    key: "hq0ia6"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const w5 = Vu("ChevronDown", [["path", {d: "m6 9 6 6 6-6", key: "qrunsl"}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Bz = Vu("ClipboardList", [["rect", {
    width: "8",
    height: "4",
    x: "8",
    y: "2",
    rx: "1",
    ry: "1",
    key: "tgr4d6"
}], ["path", {
    d: "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2",
    key: "116196"
}], ["path", {d: "M12 11h4", key: "1jrz19"}], ["path", {d: "M12 16h4", key: "n85exb"}], ["path", {
    d: "M8 11h.01",
    key: "1dfujw"
}], ["path", {d: "M8 16h.01", key: "18s6g9"}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const b5 = Vu("Globe", [["circle", {
    cx: "12",
    cy: "12",
    r: "10",
    key: "1mglay"
}], ["path", {d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20", key: "13o1zl"}], ["path", {
    d: "M2 12h20",
    key: "9i4pu4"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const iP = Vu("HeartHandshake", [["path", {
    d: "M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z",
    key: "c3ymky"
}], ["path", {
    d: "M12 5 9.04 7.96a2.17 2.17 0 0 0 0 3.08c.82.82 2.13.85 3 .07l2.07-1.9a2.82 2.82 0 0 1 3.79 0l2.96 2.66",
    key: "4oyue0"
}], ["path", {d: "m18 15-2-2", key: "60u0ii"}], ["path", {d: "m15 18-2-2", key: "6p76be"}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const T5 = Vu("X", [["path", {d: "M18 6 6 18", key: "1bl5f8"}], ["path", {d: "m6 6 12 12", key: "d8bk6v"}]]),
    R2 = "-", S5 = r => {
        const l = A5(r), {conflictingClassGroups: p, conflictingClassGroupModifiers: y} = r;
        return {
            getClassGroupId: D => {
                const o = D.split(R2);
                return o[0] === "" && o.length !== 1 && o.shift(), Nz(o, l) || E5(D)
            }, getConflictingClassGroupIds: (D, o) => {
                const j = p[D] || [];
                return o && y[D] ? [...j, ...y[D]] : j
            }
        }
    }, Nz = (r, l) => {
        var D;
        if (r.length === 0) return l.classGroupId;
        const p = r[0], y = l.nextPart.get(p), T = y ? Nz(r.slice(1), y) : void 0;
        if (T) return T;
        if (l.validators.length === 0) return;
        const A = r.join(R2);
        return (D = l.validators.find(({validator: o}) => o(A))) == null ? void 0 : D.classGroupId
    }, nP = /^\[(.+)\]$/, E5 = r => {
        if (nP.test(r)) {
            const l = nP.exec(r)[1], p = l == null ? void 0 : l.substring(0, l.indexOf(":"));
            if (p) return "arbitrary.." + p
        }
    }, A5 = r => {
        const {theme: l, prefix: p} = r, y = {nextPart: new Map, validators: []};
        return C5(Object.entries(r.classGroups), p).forEach(([A, D]) => {
            gT(D, y, A, l)
        }), y
    }, gT = (r, l, p, y) => {
        r.forEach(T => {
            if (typeof T == "string") {
                const A = T === "" ? l : rP(l, T);
                A.classGroupId = p;
                return
            }
            if (typeof T == "function") {
                if (I5(T)) {
                    gT(T(y), l, p, y);
                    return
                }
                l.validators.push({validator: T, classGroupId: p});
                return
            }
            Object.entries(T).forEach(([A, D]) => {
                gT(D, rP(l, A), p, y)
            })
        })
    }, rP = (r, l) => {
        let p = r;
        return l.split(R2).forEach(y => {
            p.nextPart.has(y) || p.nextPart.set(y, {nextPart: new Map, validators: []}), p = p.nextPart.get(y)
        }), p
    }, I5 = r => r.isThemeGetter, C5 = (r, l) => l ? r.map(([p, y]) => {
        const T = y.map(A => typeof A == "string" ? l + A : typeof A == "object" ? Object.fromEntries(Object.entries(A).map(([D, o]) => [l + D, o])) : A);
        return [p, T]
    }) : r, P5 = r => {
        if (r < 1) return {
            get: () => {
            }, set: () => {
            }
        };
        let l = 0, p = new Map, y = new Map;
        const T = (A, D) => {
            p.set(A, D), l++, l > r && (l = 0, y = p, p = new Map)
        };
        return {
            get(A) {
                let D = p.get(A);
                if (D !== void 0) return D;
                if ((D = y.get(A)) !== void 0) return T(A, D), D
            }, set(A, D) {
                p.has(A) ? p.set(A, D) : T(A, D)
            }
        }
    }, jz = "!", M5 = r => {
        const {separator: l, experimentalParseClassName: p} = r, y = l.length === 1, T = l[0], A = l.length, D = o => {
            const j = [];
            let q = 0, ee = 0, oe;
            for (let Me = 0; Me < o.length; Me++) {
                let pe = o[Me];
                if (q === 0) {
                    if (pe === T && (y || o.slice(Me, Me + A) === l)) {
                        j.push(o.slice(ee, Me)), ee = Me + A;
                        continue
                    }
                    if (pe === "/") {
                        oe = Me;
                        continue
                    }
                }
                pe === "[" ? q++ : pe === "]" && q--
            }
            const de = j.length === 0 ? o : o.substring(ee), ae = de.startsWith(jz), Re = ae ? de.substring(1) : de,
                fe = oe && oe > ee ? oe - ee : void 0;
            return {modifiers: j, hasImportantModifier: ae, baseClassName: Re, maybePostfixModifierPosition: fe}
        };
        return p ? o => p({className: o, parseClassName: D}) : D
    }, R5 = r => {
        if (r.length <= 1) return r;
        const l = [];
        let p = [];
        return r.forEach(y => {
            y[0] === "[" ? (l.push(...p.sort(), y), p = []) : p.push(y)
        }), l.push(...p.sort()), l
    }, z5 = r => ({cache: P5(r.cacheSize), parseClassName: M5(r), ...S5(r)}), D5 = /\s+/, L5 = (r, l) => {
        const {parseClassName: p, getClassGroupId: y, getConflictingClassGroupIds: T} = l, A = [], D = r.trim().split(D5);
        let o = "";
        for (let j = D.length - 1; j >= 0; j -= 1) {
            const q = D[j], {
                modifiers: ee,
                hasImportantModifier: oe,
                baseClassName: de,
                maybePostfixModifierPosition: ae
            } = p(q);
            let Re = !!ae, fe = y(Re ? de.substring(0, ae) : de);
            if (!fe) {
                if (!Re) {
                    o = q + (o.length > 0 ? " " + o : o);
                    continue
                }
                if (fe = y(de), !fe) {
                    o = q + (o.length > 0 ? " " + o : o);
                    continue
                }
                Re = !1
            }
            const Me = R5(ee).join(":"), pe = oe ? Me + jz : Me, le = pe + fe;
            if (A.includes(le)) continue;
            A.push(le);
            const be = T(fe, Re);
            for (let Ue = 0; Ue < be.length; ++Ue) {
                const et = be[Ue];
                A.push(pe + et)
            }
            o = q + (o.length > 0 ? " " + o : o)
        }
        return o
    };

function k5() {
    let r = 0, l, p, y = "";
    for (; r < arguments.length;) (l = arguments[r++]) && (p = Vz(l)) && (y && (y += " "), y += p);
    return y
}

const Vz = r => {
    if (typeof r == "string") return r;
    let l, p = "";
    for (let y = 0; y < r.length; y++) r[y] && (l = Vz(r[y])) && (p && (p += " "), p += l);
    return p
};

function O5(r, ...l) {
    let p, y, T, A = D;

    function D(j) {
        const q = l.reduce((ee, oe) => oe(ee), r());
        return p = z5(q), y = p.cache.get, T = p.cache.set, A = o, o(j)
    }

    function o(j) {
        const q = y(j);
        if (q) return q;
        const ee = L5(j, p);
        return T(j, ee), ee
    }

    return function () {
        return A(k5.apply(null, arguments))
    }
}

const _r = r => {
        const l = p => p[r] || [];
        return l.isThemeGetter = !0, l
    }, Uz = /^\[(?:([a-z-]+):)?(.+)\]$/i, F5 = /^\d+\/\d+$/, B5 = new Set(["px", "full", "screen"]),
    N5 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/,
    j5 = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/,
    V5 = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/,
    U5 = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/,
    G5 = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/,
    tc = r => Yf(r) || B5.has(r) || F5.test(r), cu = r => Sp(r, "length", K5),
    Yf = r => !!r && !Number.isNaN(Number(r)), ub = r => Sp(r, "number", Yf),
    kg = r => !!r && Number.isInteger(Number(r)), $5 = r => r.endsWith("%") && Yf(r.slice(0, -1)), vn = r => Uz.test(r),
    uu = r => N5.test(r), H5 = new Set(["length", "size", "percentage"]), q5 = r => Sp(r, H5, Gz),
    W5 = r => Sp(r, "position", Gz), Z5 = new Set(["image", "url"]), X5 = r => Sp(r, Z5, J5), Y5 = r => Sp(r, "", Q5),
    Og = () => !0, Sp = (r, l, p) => {
        const y = Uz.exec(r);
        return y ? y[1] ? typeof l == "string" ? y[1] === l : l.has(y[1]) : p(y[2]) : !1
    }, K5 = r => j5.test(r) && !V5.test(r), Gz = () => !1, Q5 = r => U5.test(r), J5 = r => G5.test(r), e4 = () => {
        const r = _r("colors"), l = _r("spacing"), p = _r("blur"), y = _r("brightness"), T = _r("borderColor"),
            A = _r("borderRadius"), D = _r("borderSpacing"), o = _r("borderWidth"), j = _r("contrast"), q = _r("grayscale"),
            ee = _r("hueRotate"), oe = _r("invert"), de = _r("gap"), ae = _r("gradientColorStops"),
            Re = _r("gradientColorStopPositions"), fe = _r("inset"), Me = _r("margin"), pe = _r("opacity"),
            le = _r("padding"), be = _r("saturate"), Ue = _r("scale"), et = _r("sepia"), _t = _r("skew"), xt = _r("space"),
            Mt = _r("translate"), Xt = () => ["auto", "contain", "none"],
            Zt = () => ["auto", "hidden", "clip", "visible", "scroll"], Ht = () => ["auto", vn, l], hi = () => [vn, l],
            Mi = () => ["", tc, cu], $t = () => ["auto", Yf, vn],
            _i = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"],
            si = () => ["solid", "dashed", "dotted", "double", "none"],
            Ri = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"],
            Ct = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], Rt = () => ["", "0", vn],
            ni = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], ai = () => [Yf, vn];
        return {
            cacheSize: 500,
            separator: ":",
            theme: {
                colors: [Og],
                spacing: [tc, cu],
                blur: ["none", "", uu, vn],
                brightness: ai(),
                borderColor: [r],
                borderRadius: ["none", "", "full", uu, vn],
                borderSpacing: hi(),
                borderWidth: Mi(),
                contrast: ai(),
                grayscale: Rt(),
                hueRotate: ai(),
                invert: Rt(),
                gap: hi(),
                gradientColorStops: [r],
                gradientColorStopPositions: [$5, cu],
                inset: Ht(),
                margin: Ht(),
                opacity: ai(),
                padding: hi(),
                saturate: ai(),
                scale: ai(),
                sepia: Rt(),
                skew: ai(),
                space: hi(),
                translate: hi()
            },
            classGroups: {
                aspect: [{aspect: ["auto", "square", "video", vn]}],
                container: ["container"],
                columns: [{columns: [uu]}],
                "break-after": [{"break-after": ni()}],
                "break-before": [{"break-before": ni()}],
                "break-inside": [{"break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]}],
                "box-decoration": [{"box-decoration": ["slice", "clone"]}],
                box: [{box: ["border", "content"]}],
                display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
                float: [{float: ["right", "left", "none", "start", "end"]}],
                clear: [{clear: ["left", "right", "both", "none", "start", "end"]}],
                isolation: ["isolate", "isolation-auto"],
                "object-fit": [{object: ["contain", "cover", "fill", "none", "scale-down"]}],
                "object-position": [{object: [..._i(), vn]}],
                overflow: [{overflow: Zt()}],
                "overflow-x": [{"overflow-x": Zt()}],
                "overflow-y": [{"overflow-y": Zt()}],
                overscroll: [{overscroll: Xt()}],
                "overscroll-x": [{"overscroll-x": Xt()}],
                "overscroll-y": [{"overscroll-y": Xt()}],
                position: ["static", "fixed", "absolute", "relative", "sticky"],
                inset: [{inset: [fe]}],
                "inset-x": [{"inset-x": [fe]}],
                "inset-y": [{"inset-y": [fe]}],
                start: [{start: [fe]}],
                end: [{end: [fe]}],
                top: [{top: [fe]}],
                right: [{right: [fe]}],
                bottom: [{bottom: [fe]}],
                left: [{left: [fe]}],
                visibility: ["visible", "invisible", "collapse"],
                z: [{z: ["auto", kg, vn]}],
                basis: [{basis: Ht()}],
                "flex-direction": [{flex: ["row", "row-reverse", "col", "col-reverse"]}],
                "flex-wrap": [{flex: ["wrap", "wrap-reverse", "nowrap"]}],
                flex: [{flex: ["1", "auto", "initial", "none", vn]}],
                grow: [{grow: Rt()}],
                shrink: [{shrink: Rt()}],
                order: [{order: ["first", "last", "none", kg, vn]}],
                "grid-cols": [{"grid-cols": [Og]}],
                "col-start-end": [{col: ["auto", {span: ["full", kg, vn]}, vn]}],
                "col-start": [{"col-start": $t()}],
                "col-end": [{"col-end": $t()}],
                "grid-rows": [{"grid-rows": [Og]}],
                "row-start-end": [{row: ["auto", {span: [kg, vn]}, vn]}],
                "row-start": [{"row-start": $t()}],
                "row-end": [{"row-end": $t()}],
                "grid-flow": [{"grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]}],
                "auto-cols": [{"auto-cols": ["auto", "min", "max", "fr", vn]}],
                "auto-rows": [{"auto-rows": ["auto", "min", "max", "fr", vn]}],
                gap: [{gap: [de]}],
                "gap-x": [{"gap-x": [de]}],
                "gap-y": [{"gap-y": [de]}],
                "justify-content": [{justify: ["normal", ...Ct()]}],
                "justify-items": [{"justify-items": ["start", "end", "center", "stretch"]}],
                "justify-self": [{"justify-self": ["auto", "start", "end", "center", "stretch"]}],
                "align-content": [{content: ["normal", ...Ct(), "baseline"]}],
                "align-items": [{items: ["start", "end", "center", "baseline", "stretch"]}],
                "align-self": [{self: ["auto", "start", "end", "center", "stretch", "baseline"]}],
                "place-content": [{"place-content": [...Ct(), "baseline"]}],
                "place-items": [{"place-items": ["start", "end", "center", "baseline", "stretch"]}],
                "place-self": [{"place-self": ["auto", "start", "end", "center", "stretch"]}],
                p: [{p: [le]}],
                px: [{px: [le]}],
                py: [{py: [le]}],
                ps: [{ps: [le]}],
                pe: [{pe: [le]}],
                pt: [{pt: [le]}],
                pr: [{pr: [le]}],
                pb: [{pb: [le]}],
                pl: [{pl: [le]}],
                m: [{m: [Me]}],
                mx: [{mx: [Me]}],
                my: [{my: [Me]}],
                ms: [{ms: [Me]}],
                me: [{me: [Me]}],
                mt: [{mt: [Me]}],
                mr: [{mr: [Me]}],
                mb: [{mb: [Me]}],
                ml: [{ml: [Me]}],
                "space-x": [{"space-x": [xt]}],
                "space-x-reverse": ["space-x-reverse"],
                "space-y": [{"space-y": [xt]}],
                "space-y-reverse": ["space-y-reverse"],
                w: [{w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", vn, l]}],
                "min-w": [{"min-w": [vn, l, "min", "max", "fit"]}],
                "max-w": [{"max-w": [vn, l, "none", "full", "min", "max", "fit", "prose", {screen: [uu]}, uu]}],
                h: [{h: [vn, l, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]}],
                "min-h": [{"min-h": [vn, l, "min", "max", "fit", "svh", "lvh", "dvh"]}],
                "max-h": [{"max-h": [vn, l, "min", "max", "fit", "svh", "lvh", "dvh"]}],
                size: [{size: [vn, l, "auto", "min", "max", "fit"]}],
                "font-size": [{text: ["base", uu, cu]}],
                "font-smoothing": ["antialiased", "subpixel-antialiased"],
                "font-style": ["italic", "not-italic"],
                "font-weight": [{font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", ub]}],
                "font-family": [{font: [Og]}],
                "fvn-normal": ["normal-nums"],
                "fvn-ordinal": ["ordinal"],
                "fvn-slashed-zero": ["slashed-zero"],
                "fvn-figure": ["lining-nums", "oldstyle-nums"],
                "fvn-spacing": ["proportional-nums", "tabular-nums"],
                "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
                tracking: [{tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", vn]}],
                "line-clamp": [{"line-clamp": ["none", Yf, ub]}],
                leading: [{leading: ["none", "tight", "snug", "normal", "relaxed", "loose", tc, vn]}],
                "list-image": [{"list-image": ["none", vn]}],
                "list-style-type": [{list: ["none", "disc", "decimal", vn]}],
                "list-style-position": [{list: ["inside", "outside"]}],
                "placeholder-color": [{placeholder: [r]}],
                "placeholder-opacity": [{"placeholder-opacity": [pe]}],
                "text-alignment": [{text: ["left", "center", "right", "justify", "start", "end"]}],
                "text-color": [{text: [r]}],
                "text-opacity": [{"text-opacity": [pe]}],
                "text-decoration": ["underline", "overline", "line-through", "no-underline"],
                "text-decoration-style": [{decoration: [...si(), "wavy"]}],
                "text-decoration-thickness": [{decoration: ["auto", "from-font", tc, cu]}],
                "underline-offset": [{"underline-offset": ["auto", tc, vn]}],
                "text-decoration-color": [{decoration: [r]}],
                "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
                "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
                "text-wrap": [{text: ["wrap", "nowrap", "balance", "pretty"]}],
                indent: [{indent: hi()}],
                "vertical-align": [{align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", vn]}],
                whitespace: [{whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]}],
                break: [{break: ["normal", "words", "all", "keep"]}],
                hyphens: [{hyphens: ["none", "manual", "auto"]}],
                content: [{content: ["none", vn]}],
                "bg-attachment": [{bg: ["fixed", "local", "scroll"]}],
                "bg-clip": [{"bg-clip": ["border", "padding", "content", "text"]}],
                "bg-opacity": [{"bg-opacity": [pe]}],
                "bg-origin": [{"bg-origin": ["border", "padding", "content"]}],
                "bg-position": [{bg: [..._i(), W5]}],
                "bg-repeat": [{bg: ["no-repeat", {repeat: ["", "x", "y", "round", "space"]}]}],
                "bg-size": [{bg: ["auto", "cover", "contain", q5]}],
                "bg-image": [{bg: ["none", {"gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]}, X5]}],
                "bg-color": [{bg: [r]}],
                "gradient-from-pos": [{from: [Re]}],
                "gradient-via-pos": [{via: [Re]}],
                "gradient-to-pos": [{to: [Re]}],
                "gradient-from": [{from: [ae]}],
                "gradient-via": [{via: [ae]}],
                "gradient-to": [{to: [ae]}],
                rounded: [{rounded: [A]}],
                "rounded-s": [{"rounded-s": [A]}],
                "rounded-e": [{"rounded-e": [A]}],
                "rounded-t": [{"rounded-t": [A]}],
                "rounded-r": [{"rounded-r": [A]}],
                "rounded-b": [{"rounded-b": [A]}],
                "rounded-l": [{"rounded-l": [A]}],
                "rounded-ss": [{"rounded-ss": [A]}],
                "rounded-se": [{"rounded-se": [A]}],
                "rounded-ee": [{"rounded-ee": [A]}],
                "rounded-es": [{"rounded-es": [A]}],
                "rounded-tl": [{"rounded-tl": [A]}],
                "rounded-tr": [{"rounded-tr": [A]}],
                "rounded-br": [{"rounded-br": [A]}],
                "rounded-bl": [{"rounded-bl": [A]}],
                "border-w": [{border: [o]}],
                "border-w-x": [{"border-x": [o]}],
                "border-w-y": [{"border-y": [o]}],
                "border-w-s": [{"border-s": [o]}],
                "border-w-e": [{"border-e": [o]}],
                "border-w-t": [{"border-t": [o]}],
                "border-w-r": [{"border-r": [o]}],
                "border-w-b": [{"border-b": [o]}],
                "border-w-l": [{"border-l": [o]}],
                "border-opacity": [{"border-opacity": [pe]}],
                "border-style": [{border: [...si(), "hidden"]}],
                "divide-x": [{"divide-x": [o]}],
                "divide-x-reverse": ["divide-x-reverse"],
                "divide-y": [{"divide-y": [o]}],
                "divide-y-reverse": ["divide-y-reverse"],
                "divide-opacity": [{"divide-opacity": [pe]}],
                "divide-style": [{divide: si()}],
                "border-color": [{border: [T]}],
                "border-color-x": [{"border-x": [T]}],
                "border-color-y": [{"border-y": [T]}],
                "border-color-s": [{"border-s": [T]}],
                "border-color-e": [{"border-e": [T]}],
                "border-color-t": [{"border-t": [T]}],
                "border-color-r": [{"border-r": [T]}],
                "border-color-b": [{"border-b": [T]}],
                "border-color-l": [{"border-l": [T]}],
                "divide-color": [{divide: [T]}],
                "outline-style": [{outline: ["", ...si()]}],
                "outline-offset": [{"outline-offset": [tc, vn]}],
                "outline-w": [{outline: [tc, cu]}],
                "outline-color": [{outline: [r]}],
                "ring-w": [{ring: Mi()}],
                "ring-w-inset": ["ring-inset"],
                "ring-color": [{ring: [r]}],
                "ring-opacity": [{"ring-opacity": [pe]}],
                "ring-offset-w": [{"ring-offset": [tc, cu]}],
                "ring-offset-color": [{"ring-offset": [r]}],
                shadow: [{shadow: ["", "inner", "none", uu, Y5]}],
                "shadow-color": [{shadow: [Og]}],
                opacity: [{opacity: [pe]}],
                "mix-blend": [{"mix-blend": [...Ri(), "plus-lighter", "plus-darker"]}],
                "bg-blend": [{"bg-blend": Ri()}],
                filter: [{filter: ["", "none"]}],
                blur: [{blur: [p]}],
                brightness: [{brightness: [y]}],
                contrast: [{contrast: [j]}],
                "drop-shadow": [{"drop-shadow": ["", "none", uu, vn]}],
                grayscale: [{grayscale: [q]}],
                "hue-rotate": [{"hue-rotate": [ee]}],
                invert: [{invert: [oe]}],
                saturate: [{saturate: [be]}],
                sepia: [{sepia: [et]}],
                "backdrop-filter": [{"backdrop-filter": ["", "none"]}],
                "backdrop-blur": [{"backdrop-blur": [p]}],
                "backdrop-brightness": [{"backdrop-brightness": [y]}],
                "backdrop-contrast": [{"backdrop-contrast": [j]}],
                "backdrop-grayscale": [{"backdrop-grayscale": [q]}],
                "backdrop-hue-rotate": [{"backdrop-hue-rotate": [ee]}],
                "backdrop-invert": [{"backdrop-invert": [oe]}],
                "backdrop-opacity": [{"backdrop-opacity": [pe]}],
                "backdrop-saturate": [{"backdrop-saturate": [be]}],
                "backdrop-sepia": [{"backdrop-sepia": [et]}],
                "border-collapse": [{border: ["collapse", "separate"]}],
                "border-spacing": [{"border-spacing": [D]}],
                "border-spacing-x": [{"border-spacing-x": [D]}],
                "border-spacing-y": [{"border-spacing-y": [D]}],
                "table-layout": [{table: ["auto", "fixed"]}],
                caption: [{caption: ["top", "bottom"]}],
                transition: [{transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", vn]}],
                duration: [{duration: ai()}],
                ease: [{ease: ["linear", "in", "out", "in-out", vn]}],
                delay: [{delay: ai()}],
                animate: [{animate: ["none", "spin", "ping", "pulse", "bounce", vn]}],
                transform: [{transform: ["", "gpu", "none"]}],
                scale: [{scale: [Ue]}],
                "scale-x": [{"scale-x": [Ue]}],
                "scale-y": [{"scale-y": [Ue]}],
                rotate: [{rotate: [kg, vn]}],
                "translate-x": [{"translate-x": [Mt]}],
                "translate-y": [{"translate-y": [Mt]}],
                "skew-x": [{"skew-x": [_t]}],
                "skew-y": [{"skew-y": [_t]}],
                "transform-origin": [{origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", vn]}],
                accent: [{accent: ["auto", r]}],
                appearance: [{appearance: ["none", "auto"]}],
                cursor: [{cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", vn]}],
                "caret-color": [{caret: [r]}],
                "pointer-events": [{"pointer-events": ["none", "auto"]}],
                resize: [{resize: ["none", "y", "x", ""]}],
                "scroll-behavior": [{scroll: ["auto", "smooth"]}],
                "scroll-m": [{"scroll-m": hi()}],
                "scroll-mx": [{"scroll-mx": hi()}],
                "scroll-my": [{"scroll-my": hi()}],
                "scroll-ms": [{"scroll-ms": hi()}],
                "scroll-me": [{"scroll-me": hi()}],
                "scroll-mt": [{"scroll-mt": hi()}],
                "scroll-mr": [{"scroll-mr": hi()}],
                "scroll-mb": [{"scroll-mb": hi()}],
                "scroll-ml": [{"scroll-ml": hi()}],
                "scroll-p": [{"scroll-p": hi()}],
                "scroll-px": [{"scroll-px": hi()}],
                "scroll-py": [{"scroll-py": hi()}],
                "scroll-ps": [{"scroll-ps": hi()}],
                "scroll-pe": [{"scroll-pe": hi()}],
                "scroll-pt": [{"scroll-pt": hi()}],
                "scroll-pr": [{"scroll-pr": hi()}],
                "scroll-pb": [{"scroll-pb": hi()}],
                "scroll-pl": [{"scroll-pl": hi()}],
                "snap-align": [{snap: ["start", "end", "center", "align-none"]}],
                "snap-stop": [{snap: ["normal", "always"]}],
                "snap-type": [{snap: ["none", "x", "y", "both"]}],
                "snap-strictness": [{snap: ["mandatory", "proximity"]}],
                touch: [{touch: ["auto", "none", "manipulation"]}],
                "touch-x": [{"touch-pan": ["x", "left", "right"]}],
                "touch-y": [{"touch-pan": ["y", "up", "down"]}],
                "touch-pz": ["touch-pinch-zoom"],
                select: [{select: ["none", "text", "all", "auto"]}],
                "will-change": [{"will-change": ["auto", "scroll", "contents", "transform", vn]}],
                fill: [{fill: [r, "none"]}],
                "stroke-w": [{stroke: [tc, cu, ub]}],
                stroke: [{stroke: [r, "none"]}],
                sr: ["sr-only", "not-sr-only"],
                "forced-color-adjust": [{"forced-color-adjust": ["auto", "none"]}]
            },
            conflictingClassGroups: {
                overflow: ["overflow-x", "overflow-y"],
                overscroll: ["overscroll-x", "overscroll-y"],
                inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
                "inset-x": ["right", "left"],
                "inset-y": ["top", "bottom"],
                flex: ["basis", "grow", "shrink"],
                gap: ["gap-x", "gap-y"],
                p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
                px: ["pr", "pl"],
                py: ["pt", "pb"],
                m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
                mx: ["mr", "ml"],
                my: ["mt", "mb"],
                size: ["w", "h"],
                "font-size": ["leading"],
                "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
                "fvn-ordinal": ["fvn-normal"],
                "fvn-slashed-zero": ["fvn-normal"],
                "fvn-figure": ["fvn-normal"],
                "fvn-spacing": ["fvn-normal"],
                "fvn-fraction": ["fvn-normal"],
                "line-clamp": ["display", "overflow"],
                rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
                "rounded-s": ["rounded-ss", "rounded-es"],
                "rounded-e": ["rounded-se", "rounded-ee"],
                "rounded-t": ["rounded-tl", "rounded-tr"],
                "rounded-r": ["rounded-tr", "rounded-br"],
                "rounded-b": ["rounded-br", "rounded-bl"],
                "rounded-l": ["rounded-tl", "rounded-bl"],
                "border-spacing": ["border-spacing-x", "border-spacing-y"],
                "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
                "border-w-x": ["border-w-r", "border-w-l"],
                "border-w-y": ["border-w-t", "border-w-b"],
                "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
                "border-color-x": ["border-color-r", "border-color-l"],
                "border-color-y": ["border-color-t", "border-color-b"],
                "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
                "scroll-mx": ["scroll-mr", "scroll-ml"],
                "scroll-my": ["scroll-mt", "scroll-mb"],
                "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
                "scroll-px": ["scroll-pr", "scroll-pl"],
                "scroll-py": ["scroll-pt", "scroll-pb"],
                touch: ["touch-x", "touch-y", "touch-pz"],
                "touch-x": ["touch"],
                "touch-y": ["touch"],
                "touch-pz": ["touch"]
            },
            conflictingClassGroupModifiers: {"font-size": ["leading"]}
        }
    }, t4 = O5(e4);

function ao(...r) {
    return t4(Dz(r))
}

const i4 = g5, $z = Ce.forwardRef(({className: r, ...l}, p) => K.jsx(Az, {
    ref: p,
    className: ao("fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]", r), ...l
}));
$z.displayName = Az.displayName;
const n4 = Lz("group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full", {
    variants: {
        variant: {
            default: "border bg-background text-foreground",
            destructive: "destructive group border-destructive bg-destructive text-destructive-foreground"
        }
    }, defaultVariants: {variant: "default"}
}), Hz = Ce.forwardRef(({className: r, variant: l, ...p}, y) => K.jsx(Iz, {
    ref: y,
    className: ao(n4({variant: l}), r), ...p
}));
Hz.displayName = Iz.displayName;
const r4 = Ce.forwardRef(({className: r, ...l}, p) => K.jsx(Mz, {
    ref: p,
    className: ao("inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive", r), ...l
}));
r4.displayName = Mz.displayName;
const qz = Ce.forwardRef(({className: r, ...l}, p) => K.jsx(Rz, {
    ref: p,
    className: ao("absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600", r),
    "toast-close": "", ...l,
    children: K.jsx(T5, {className: "h-4 w-4"})
}));
qz.displayName = Rz.displayName;
const Wz = Ce.forwardRef(({className: r, ...l}, p) => K.jsx(Cz, {
    ref: p,
    className: ao("text-sm font-semibold", r), ...l
}));
Wz.displayName = Cz.displayName;
const Zz = Ce.forwardRef(({className: r, ...l}, p) => K.jsx(Pz, {
    ref: p,
    className: ao("text-sm opacity-90", r), ...l
}));
Zz.displayName = Pz.displayName;

function o4() {
    const {toasts: r} = rz();
    return K.jsxs(i4, {
        children: [r.map(function ({id: l, title: p, description: y, action: T, ...A}) {
            return K.jsxs(Hz, {
                ...A,
                children: [K.jsxs("div", {
                    className: "grid gap-1",
                    children: [p && K.jsx(Wz, {children: p}), y && K.jsx(Zz, {children: y})]
                }), T, K.jsx(qz, {})]
            }, l)
        }), K.jsx($z, {})]
    })
}

var oP = ["light", "dark"], s4 = "(prefers-color-scheme: dark)", a4 = Ce.createContext(void 0), l4 = {
    setTheme: r => {
    }, themes: []
}, c4 = () => {
    var r;
    return (r = Ce.useContext(a4)) != null ? r : l4
};
Ce.memo(({
             forcedTheme: r,
             storageKey: l,
             attribute: p,
             enableSystem: y,
             enableColorScheme: T,
             defaultTheme: A,
             value: D,
             attrs: o,
             nonce: j
         }) => {
    let q = A === "system",
        ee = p === "class" ? `var d=document.documentElement,c=d.classList;${`c.remove(${o.map(Re => `'${Re}'`).join(",")})`};` : `var d=document.documentElement,n='${p}',s='setAttribute';`,
        oe = T ? oP.includes(A) && A ? `if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'${A}'` : "if(e==='light'||e==='dark')d.style.colorScheme=e" : "",
        de = (Re, fe = !1, Me = !0) => {
            let pe = D ? D[Re] : Re, le = fe ? Re + "|| ''" : `'${pe}'`, be = "";
            return T && Me && !fe && oP.includes(Re) && (be += `d.style.colorScheme = '${Re}';`), p === "class" ? fe || pe ? be += `c.add(${le})` : be += "null" : pe && (be += `d[s](n,${le})`), be
        },
        ae = r ? `!function(){${ee}${de(r)}}()` : y ? `!function(){try{${ee}var e=localStorage.getItem('${l}');if('system'===e||(!e&&${q})){var t='${s4}',m=window.matchMedia(t);if(m.media!==t||m.matches){${de("dark")}}else{${de("light")}}}else if(e){${D ? `var x=${JSON.stringify(D)};` : ""}${de(D ? "x[e]" : "e", !0)}}${q ? "" : "else{" + de(A, !1, !1) + "}"}${oe}}catch(e){}}()` : `!function(){try{${ee}var e=localStorage.getItem('${l}');if(e){${D ? `var x=${JSON.stringify(D)};` : ""}${de(D ? "x[e]" : "e", !0)}}else{${de(A, !1, !1)};}${oe}}catch(t){}}();`;
    return Ce.createElement("script", {nonce: j, dangerouslySetInnerHTML: {__html: ae}})
});
var u4 = r => {
        switch (r) {
            case"success":
                return f4;
            case"info":
                return m4;
            case"warning":
                return p4;
            case"error":
                return g4;
            default:
                return null
        }
    }, h4 = Array(12).fill(0), d4 = ({
                                         visible: r,
                                         className: l
                                     }) => jt.createElement("div", {
        className: ["sonner-loading-wrapper", l].filter(Boolean).join(" "),
        "data-visible": r
    }, jt.createElement("div", {className: "sonner-spinner"}, h4.map((p, y) => jt.createElement("div", {
        className: "sonner-loading-bar",
        key: `spinner-bar-${y}`
    })))), f4 = jt.createElement("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 20 20",
        fill: "currentColor",
        height: "20",
        width: "20"
    }, jt.createElement("path", {
        fillRule: "evenodd",
        d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
        clipRule: "evenodd"
    })), p4 = jt.createElement("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        height: "20",
        width: "20"
    }, jt.createElement("path", {
        fillRule: "evenodd",
        d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
        clipRule: "evenodd"
    })), m4 = jt.createElement("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 20 20",
        fill: "currentColor",
        height: "20",
        width: "20"
    }, jt.createElement("path", {
        fillRule: "evenodd",
        d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
        clipRule: "evenodd"
    })), g4 = jt.createElement("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 20 20",
        fill: "currentColor",
        height: "20",
        width: "20"
    }, jt.createElement("path", {
        fillRule: "evenodd",
        d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
        clipRule: "evenodd"
    })), _4 = jt.createElement("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: "12",
        height: "12",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "1.5",
        strokeLinecap: "round",
        strokeLinejoin: "round"
    }, jt.createElement("line", {x1: "18", y1: "6", x2: "6", y2: "18"}), jt.createElement("line", {
        x1: "6",
        y1: "6",
        x2: "18",
        y2: "18"
    })), y4 = () => {
        let [r, l] = jt.useState(document.hidden);
        return jt.useEffect(() => {
            let p = () => {
                l(document.hidden)
            };
            return document.addEventListener("visibilitychange", p), () => window.removeEventListener("visibilitychange", p)
        }, []), r
    }, _T = 1, v4 = class {
        constructor() {
            this.subscribe = r => (this.subscribers.push(r), () => {
                let l = this.subscribers.indexOf(r);
                this.subscribers.splice(l, 1)
            }), this.publish = r => {
                this.subscribers.forEach(l => l(r))
            }, this.addToast = r => {
                this.publish(r), this.toasts = [...this.toasts, r]
            }, this.create = r => {
                var l;
                let {message: p, ...y} = r,
                    T = typeof (r == null ? void 0 : r.id) == "number" || ((l = r.id) == null ? void 0 : l.length) > 0 ? r.id : _T++,
                    A = this.toasts.find(o => o.id === T), D = r.dismissible === void 0 ? !0 : r.dismissible;
                return this.dismissedToasts.has(T) && this.dismissedToasts.delete(T), A ? this.toasts = this.toasts.map(o => o.id === T ? (this.publish({
                    ...o, ...r,
                    id: T,
                    title: p
                }), {...o, ...r, id: T, dismissible: D, title: p}) : o) : this.addToast({
                    title: p, ...y,
                    dismissible: D,
                    id: T
                }), T
            }, this.dismiss = r => (this.dismissedToasts.add(r), r || this.toasts.forEach(l => {
                this.subscribers.forEach(p => p({id: l.id, dismiss: !0}))
            }), this.subscribers.forEach(l => l({id: r, dismiss: !0})), r), this.message = (r, l) => this.create({
                ...l,
                message: r
            }), this.error = (r, l) => this.create({
                ...l,
                message: r,
                type: "error"
            }), this.success = (r, l) => this.create({
                ...l,
                type: "success",
                message: r
            }), this.info = (r, l) => this.create({
                ...l,
                type: "info",
                message: r
            }), this.warning = (r, l) => this.create({
                ...l,
                type: "warning",
                message: r
            }), this.loading = (r, l) => this.create({...l, type: "loading", message: r}), this.promise = (r, l) => {
                if (!l) return;
                let p;
                l.loading !== void 0 && (p = this.create({
                    ...l,
                    promise: r,
                    type: "loading",
                    message: l.loading,
                    description: typeof l.description != "function" ? l.description : void 0
                }));
                let y = r instanceof Promise ? r : r(), T = p !== void 0, A, D = y.then(async j => {
                    if (A = ["resolve", j], jt.isValidElement(j)) T = !1, this.create({
                        id: p,
                        type: "default",
                        message: j
                    }); else if (w4(j) && !j.ok) {
                        T = !1;
                        let q = typeof l.error == "function" ? await l.error(`HTTP error! status: ${j.status}`) : l.error,
                            ee = typeof l.description == "function" ? await l.description(`HTTP error! status: ${j.status}`) : l.description;
                        this.create({id: p, type: "error", message: q, description: ee})
                    } else if (l.success !== void 0) {
                        T = !1;
                        let q = typeof l.success == "function" ? await l.success(j) : l.success,
                            ee = typeof l.description == "function" ? await l.description(j) : l.description;
                        this.create({id: p, type: "success", message: q, description: ee})
                    }
                }).catch(async j => {
                    if (A = ["reject", j], l.error !== void 0) {
                        T = !1;
                        let q = typeof l.error == "function" ? await l.error(j) : l.error,
                            ee = typeof l.description == "function" ? await l.description(j) : l.description;
                        this.create({id: p, type: "error", message: q, description: ee})
                    }
                }).finally(() => {
                    var j;
                    T && (this.dismiss(p), p = void 0), (j = l.finally) == null || j.call(l)
                }), o = () => new Promise((j, q) => D.then(() => A[0] === "reject" ? q(A[1]) : j(A[1])).catch(q));
                return typeof p != "string" && typeof p != "number" ? {unwrap: o} : Object.assign(p, {unwrap: o})
            }, this.custom = (r, l) => {
                let p = (l == null ? void 0 : l.id) || _T++;
                return this.create({jsx: r(p), id: p, ...l}), p
            }, this.getActiveToasts = () => this.toasts.filter(r => !this.dismissedToasts.has(r.id)), this.subscribers = [], this.toasts = [], this.dismissedToasts = new Set
        }
    }, Es = new v4, x4 = (r, l) => {
        let p = (l == null ? void 0 : l.id) || _T++;
        return Es.addToast({title: r, ...l, id: p}), p
    },
    w4 = r => r && typeof r == "object" && "ok" in r && typeof r.ok == "boolean" && "status" in r && typeof r.status == "number",
    b4 = x4, T4 = () => Es.toasts, S4 = () => Es.getActiveToasts();
Object.assign(b4, {
    success: Es.success,
    info: Es.info,
    warning: Es.warning,
    error: Es.error,
    custom: Es.custom,
    message: Es.message,
    promise: Es.promise,
    dismiss: Es.dismiss,
    loading: Es.loading
}, {getHistory: T4, getToasts: S4});

function E4(r, {insertAt: l} = {}) {
    if (typeof document > "u") return;
    let p = document.head || document.getElementsByTagName("head")[0], y = document.createElement("style");
    y.type = "text/css", l === "top" && p.firstChild ? p.insertBefore(y, p.firstChild) : p.appendChild(y), y.styleSheet ? y.styleSheet.cssText = r : y.appendChild(document.createTextNode(r))
}

E4(`:where(html[dir="ltr"]),:where([data-sonner-toaster][dir="ltr"]){--toast-icon-margin-start: -3px;--toast-icon-margin-end: 4px;--toast-svg-margin-start: -1px;--toast-svg-margin-end: 0px;--toast-button-margin-start: auto;--toast-button-margin-end: 0;--toast-close-button-start: 0;--toast-close-button-end: unset;--toast-close-button-transform: translate(-35%, -35%)}:where(html[dir="rtl"]),:where([data-sonner-toaster][dir="rtl"]){--toast-icon-margin-start: 4px;--toast-icon-margin-end: -3px;--toast-svg-margin-start: 0px;--toast-svg-margin-end: -1px;--toast-button-margin-start: 0;--toast-button-margin-end: auto;--toast-close-button-start: unset;--toast-close-button-end: 0;--toast-close-button-transform: translate(35%, -35%)}:where([data-sonner-toaster]){position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1: hsl(0, 0%, 99%);--gray2: hsl(0, 0%, 97.3%);--gray3: hsl(0, 0%, 95.1%);--gray4: hsl(0, 0%, 93%);--gray5: hsl(0, 0%, 90.9%);--gray6: hsl(0, 0%, 88.7%);--gray7: hsl(0, 0%, 85.8%);--gray8: hsl(0, 0%, 78%);--gray9: hsl(0, 0%, 56.1%);--gray10: hsl(0, 0%, 52.3%);--gray11: hsl(0, 0%, 43.5%);--gray12: hsl(0, 0%, 9%);--border-radius: 8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999;transition:transform .4s ease}:where([data-sonner-toaster][data-lifted="true"]){transform:translateY(-10px)}@media (hover: none) and (pointer: coarse){:where([data-sonner-toaster][data-lifted="true"]){transform:none}}:where([data-sonner-toaster][data-x-position="right"]){right:var(--offset-right)}:where([data-sonner-toaster][data-x-position="left"]){left:var(--offset-left)}:where([data-sonner-toaster][data-x-position="center"]){left:50%;transform:translate(-50%)}:where([data-sonner-toaster][data-y-position="top"]){top:var(--offset-top)}:where([data-sonner-toaster][data-y-position="bottom"]){bottom:var(--offset-bottom)}:where([data-sonner-toast]){--y: translateY(100%);--lift-amount: calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);filter:blur(0);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:none;overflow-wrap:anywhere}:where([data-sonner-toast][data-styled="true"]){padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px #0000001a;width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}:where([data-sonner-toast]:focus-visible){box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast][data-y-position="top"]){top:0;--y: translateY(-100%);--lift: 1;--lift-amount: calc(1 * var(--gap))}:where([data-sonner-toast][data-y-position="bottom"]){bottom:0;--y: translateY(100%);--lift: -1;--lift-amount: calc(var(--lift) * var(--gap))}:where([data-sonner-toast]) :where([data-description]){font-weight:400;line-height:1.4;color:inherit}:where([data-sonner-toast]) :where([data-title]){font-weight:500;line-height:1.5;color:inherit}:where([data-sonner-toast]) :where([data-icon]){display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}:where([data-sonner-toast][data-promise="true"]) :where([data-icon])>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}:where([data-sonner-toast]) :where([data-icon])>*{flex-shrink:0}:where([data-sonner-toast]) :where([data-icon]) svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}:where([data-sonner-toast]) :where([data-content]){display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:none;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}:where([data-sonner-toast]) :where([data-button]):focus-visible{box-shadow:0 0 0 2px #0006}:where([data-sonner-toast]) :where([data-button]):first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}:where([data-sonner-toast]) :where([data-cancel]){color:var(--normal-text);background:rgba(0,0,0,.08)}:where([data-sonner-toast][data-theme="dark"]) :where([data-cancel]){background:rgba(255,255,255,.3)}:where([data-sonner-toast]) :where([data-close-button]){position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast] [data-close-button]{background:var(--gray1)}:where([data-sonner-toast]) :where([data-close-button]):focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast]) :where([data-disabled="true"]){cursor:not-allowed}:where([data-sonner-toast]):hover :where([data-close-button]):hover{background:var(--gray2);border-color:var(--gray5)}:where([data-sonner-toast][data-swiping="true"]):before{content:"";position:absolute;left:-50%;right:-50%;height:100%;z-index:-1}:where([data-sonner-toast][data-y-position="top"][data-swiping="true"]):before{bottom:50%;transform:scaleY(3) translateY(50%)}:where([data-sonner-toast][data-y-position="bottom"][data-swiping="true"]):before{top:50%;transform:scaleY(3) translateY(-50%)}:where([data-sonner-toast][data-swiping="false"][data-removed="true"]):before{content:"";position:absolute;inset:0;transform:scaleY(2)}:where([data-sonner-toast]):after{content:"";position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}:where([data-sonner-toast][data-mounted="true"]){--y: translateY(0);opacity:1}:where([data-sonner-toast][data-expanded="false"][data-front="false"]){--scale: var(--toasts-before) * .05 + 1;--y: translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}:where([data-sonner-toast])>*{transition:opacity .4s}:where([data-sonner-toast][data-expanded="false"][data-front="false"][data-styled="true"])>*{opacity:0}:where([data-sonner-toast][data-visible="false"]){opacity:0;pointer-events:none}:where([data-sonner-toast][data-mounted="true"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}:where([data-sonner-toast][data-removed="true"][data-front="true"][data-swipe-out="false"]){--y: translateY(calc(var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="false"]){--y: translateY(40%);opacity:0;transition:transform .5s,opacity .2s}:where([data-sonner-toast][data-removed="true"][data-front="false"]):before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y, 0px)) translate(var(--swipe-amount-x, 0px));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width: 600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg: #fff;--normal-border: var(--gray4);--normal-text: var(--gray12);--success-bg: hsl(143, 85%, 96%);--success-border: hsl(145, 92%, 91%);--success-text: hsl(140, 100%, 27%);--info-bg: hsl(208, 100%, 97%);--info-border: hsl(221, 91%, 91%);--info-text: hsl(210, 92%, 45%);--warning-bg: hsl(49, 100%, 97%);--warning-border: hsl(49, 91%, 91%);--warning-text: hsl(31, 92%, 45%);--error-bg: hsl(359, 100%, 97%);--error-border: hsl(359, 100%, 94%);--error-text: hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg: #fff;--normal-border: var(--gray3);--normal-text: var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg: #000;--normal-bg-hover: hsl(0, 0%, 12%);--normal-border: hsl(0, 0%, 20%);--normal-border-hover: hsl(0, 0%, 25%);--normal-text: var(--gray1);--success-bg: hsl(150, 100%, 6%);--success-border: hsl(147, 100%, 12%);--success-text: hsl(150, 86%, 65%);--info-bg: hsl(215, 100%, 6%);--info-border: hsl(223, 100%, 12%);--info-text: hsl(216, 87%, 65%);--warning-bg: hsl(64, 100%, 6%);--warning-border: hsl(60, 100%, 12%);--warning-text: hsl(46, 87%, 65%);--error-bg: hsl(358, 76%, 10%);--error-border: hsl(357, 89%, 16%);--error-text: hsl(358, 100%, 81%)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success],[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info],[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning],[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error],[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size: 16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}to{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}to{opacity:.15}}@media (prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}
`);

function J0(r) {
    return r.label !== void 0
}

var A4 = 3, I4 = "32px", C4 = "16px", sP = 4e3, P4 = 356, M4 = 14, R4 = 20, z4 = 200;

function Ia(...r) {
    return r.filter(Boolean).join(" ")
}

function D4(r) {
    let [l, p] = r.split("-"), y = [];
    return l && y.push(l), p && y.push(p), y
}

var L4 = r => {
    var l, p, y, T, A, D, o, j, q, ee, oe;
    let {
            invert: de,
            toast: ae,
            unstyled: Re,
            interacting: fe,
            setHeights: Me,
            visibleToasts: pe,
            heights: le,
            index: be,
            toasts: Ue,
            expanded: et,
            removeToast: _t,
            defaultRichColors: xt,
            closeButton: Mt,
            style: Xt,
            cancelButtonStyle: Zt,
            actionButtonStyle: Ht,
            className: hi = "",
            descriptionClassName: Mi = "",
            duration: $t,
            position: _i,
            gap: si,
            loadingIcon: Ri,
            expandByDefault: Ct,
            classNames: Rt,
            icons: ni,
            closeButtonAriaLabel: ai = "Close toast",
            pauseWhenPageIsHidden: fi
        } = r, [nn, cn] = jt.useState(null), [Zn, Bi] = jt.useState(null), [Ii, Bn] = jt.useState(!1), [ar, An] = jt.useState(!1), [Zr, wo] = jt.useState(!1), [Do, Xr] = jt.useState(!1), [Nn, Ar] = jt.useState(!1), [fs, Rs] = jt.useState(0), [lo, co] = jt.useState(0),
        Ir = jt.useRef(ae.duration || $t || sP), ps = jt.useRef(null), Yr = jt.useRef(null), fa = be === 0,
        Va = be + 1 <= pe, Qn = ae.type, Cr = ae.dismissible !== !1, Ml = ae.className || "",
        zs = ae.descriptionClassName || "",
        Ds = jt.useMemo(() => le.findIndex(Ze => Ze.toastId === ae.id) || 0, [le, ae.id]), Fr = jt.useMemo(() => {
            var Ze;
            return (Ze = ae.closeButton) != null ? Ze : Mt
        }, [ae.closeButton, Mt]), uo = jt.useMemo(() => ae.duration || $t || sP, [ae.duration, $t]), ms = jt.useRef(0),
        ho = jt.useRef(0), Ls = jt.useRef(0), bo = jt.useRef(null), [Ua, bn] = _i.split("-"),
        Ga = jt.useMemo(() => le.reduce((Ze, xn, Jn) => Jn >= Ds ? Ze : Ze + xn.height, 0), [le, Ds]), $a = y4(),
        To = ae.invert || de, pa = Qn === "loading";
    ho.current = jt.useMemo(() => Ds * si + Ga, [Ds, Ga]), jt.useEffect(() => {
        Ir.current = uo
    }, [uo]), jt.useEffect(() => {
        Bn(!0)
    }, []), jt.useEffect(() => {
        let Ze = Yr.current;
        if (Ze) {
            let xn = Ze.getBoundingClientRect().height;
            return co(xn), Me(Jn => [{
                toastId: ae.id,
                height: xn,
                position: ae.position
            }, ...Jn]), () => Me(Jn => Jn.filter(Kr => Kr.toastId !== ae.id))
        }
    }, [Me, ae.id]), jt.useLayoutEffect(() => {
        if (!Ii) return;
        let Ze = Yr.current, xn = Ze.style.height;
        Ze.style.height = "auto";
        let Jn = Ze.getBoundingClientRect().height;
        Ze.style.height = xn, co(Jn), Me(Kr => Kr.find(Ai => Ai.toastId === ae.id) ? Kr.map(Ai => Ai.toastId === ae.id ? {
            ...Ai,
            height: Jn
        } : Ai) : [{toastId: ae.id, height: Jn, position: ae.position}, ...Kr])
    }, [Ii, ae.title, ae.description, Me, ae.id]);
    let gs = jt.useCallback(() => {
        An(!0), Rs(ho.current), Me(Ze => Ze.filter(xn => xn.toastId !== ae.id)), setTimeout(() => {
            _t(ae)
        }, z4)
    }, [ae, _t, Me, ho]);
    jt.useEffect(() => {
        if (ae.promise && Qn === "loading" || ae.duration === 1 / 0 || ae.type === "loading") return;
        let Ze;
        return et || fe || fi && $a ? (() => {
            if (Ls.current < ms.current) {
                let xn = new Date().getTime() - ms.current;
                Ir.current = Ir.current - xn
            }
            Ls.current = new Date().getTime()
        })() : Ir.current !== 1 / 0 && (ms.current = new Date().getTime(), Ze = setTimeout(() => {
            var xn;
            (xn = ae.onAutoClose) == null || xn.call(ae, ae), gs()
        }, Ir.current)), () => clearTimeout(Ze)
    }, [et, fe, ae, Qn, fi, $a, gs]), jt.useEffect(() => {
        ae.delete && gs()
    }, [gs, ae.delete]);

    function Ha() {
        var Ze, xn, Jn;
        return ni != null && ni.loading ? jt.createElement("div", {
            className: Ia(Rt == null ? void 0 : Rt.loader, (Ze = ae == null ? void 0 : ae.classNames) == null ? void 0 : Ze.loader, "sonner-loader"),
            "data-visible": Qn === "loading"
        }, ni.loading) : Ri ? jt.createElement("div", {
            className: Ia(Rt == null ? void 0 : Rt.loader, (xn = ae == null ? void 0 : ae.classNames) == null ? void 0 : xn.loader, "sonner-loader"),
            "data-visible": Qn === "loading"
        }, Ri) : jt.createElement(d4, {
            className: Ia(Rt == null ? void 0 : Rt.loader, (Jn = ae == null ? void 0 : ae.classNames) == null ? void 0 : Jn.loader),
            visible: Qn === "loading"
        })
    }

    return jt.createElement("li", {
        tabIndex: 0,
        ref: Yr,
        className: Ia(hi, Ml, Rt == null ? void 0 : Rt.toast, (l = ae == null ? void 0 : ae.classNames) == null ? void 0 : l.toast, Rt == null ? void 0 : Rt.default, Rt == null ? void 0 : Rt[Qn], (p = ae == null ? void 0 : ae.classNames) == null ? void 0 : p[Qn]),
        "data-sonner-toast": "",
        "data-rich-colors": (y = ae.richColors) != null ? y : xt,
        "data-styled": !(ae.jsx || ae.unstyled || Re),
        "data-mounted": Ii,
        "data-promise": !!ae.promise,
        "data-swiped": Nn,
        "data-removed": ar,
        "data-visible": Va,
        "data-y-position": Ua,
        "data-x-position": bn,
        "data-index": be,
        "data-front": fa,
        "data-swiping": Zr,
        "data-dismissible": Cr,
        "data-type": Qn,
        "data-invert": To,
        "data-swipe-out": Do,
        "data-swipe-direction": Zn,
        "data-expanded": !!(et || Ct && Ii),
        style: {
            "--index": be,
            "--toasts-before": be,
            "--z-index": Ue.length - be,
            "--offset": `${ar ? fs : ho.current}px`,
            "--initial-height": Ct ? "auto" : `${lo}px`, ...Xt, ...ae.style
        },
        onDragEnd: () => {
            wo(!1), cn(null), bo.current = null
        },
        onPointerDown: Ze => {
            pa || !Cr || (ps.current = new Date, Rs(ho.current), Ze.target.setPointerCapture(Ze.pointerId), Ze.target.tagName !== "BUTTON" && (wo(!0), bo.current = {
                x: Ze.clientX,
                y: Ze.clientY
            }))
        },
        onPointerUp: () => {
            var Ze, xn, Jn, Kr;
            if (Do || !Cr) return;
            bo.current = null;
            let Ai = Number(((Ze = Yr.current) == null ? void 0 : Ze.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0),
                Le = Number(((xn = Yr.current) == null ? void 0 : xn.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0),
                $ = new Date().getTime() - ((Jn = ps.current) == null ? void 0 : Jn.getTime()),
                W = nn === "x" ? Ai : Le, ie = Math.abs(W) / $;
            if (Math.abs(W) >= R4 || ie > .11) {
                Rs(ho.current), (Kr = ae.onDismiss) == null || Kr.call(ae, ae), Bi(nn === "x" ? Ai > 0 ? "right" : "left" : Le > 0 ? "down" : "up"), gs(), Xr(!0), Ar(!1);
                return
            }
            wo(!1), cn(null)
        },
        onPointerMove: Ze => {
            var xn, Jn, Kr, Ai;
            if (!bo.current || !Cr || ((xn = window.getSelection()) == null ? void 0 : xn.toString().length) > 0) return;
            let Le = Ze.clientY - bo.current.y, $ = Ze.clientX - bo.current.x,
                W = (Jn = r.swipeDirections) != null ? Jn : D4(_i);
            !nn && (Math.abs($) > 1 || Math.abs(Le) > 1) && cn(Math.abs($) > Math.abs(Le) ? "x" : "y");
            let ie = {x: 0, y: 0};
            nn === "y" ? (W.includes("top") || W.includes("bottom")) && (W.includes("top") && Le < 0 || W.includes("bottom") && Le > 0) && (ie.y = Le) : nn === "x" && (W.includes("left") || W.includes("right")) && (W.includes("left") && $ < 0 || W.includes("right") && $ > 0) && (ie.x = $), (Math.abs(ie.x) > 0 || Math.abs(ie.y) > 0) && Ar(!0), (Kr = Yr.current) == null || Kr.style.setProperty("--swipe-amount-x", `${ie.x}px`), (Ai = Yr.current) == null || Ai.style.setProperty("--swipe-amount-y", `${ie.y}px`)
        }
    }, Fr && !ae.jsx ? jt.createElement("button", {
        "aria-label": ai,
        "data-disabled": pa,
        "data-close-button": !0,
        onClick: pa || !Cr ? () => {
        } : () => {
            var Ze;
            gs(), (Ze = ae.onDismiss) == null || Ze.call(ae, ae)
        },
        className: Ia(Rt == null ? void 0 : Rt.closeButton, (T = ae == null ? void 0 : ae.classNames) == null ? void 0 : T.closeButton)
    }, (A = ni == null ? void 0 : ni.close) != null ? A : _4) : null, ae.jsx || Ce.isValidElement(ae.title) ? ae.jsx ? ae.jsx : typeof ae.title == "function" ? ae.title() : ae.title : jt.createElement(jt.Fragment, null, Qn || ae.icon || ae.promise ? jt.createElement("div", {
        "data-icon": "",
        className: Ia(Rt == null ? void 0 : Rt.icon, (D = ae == null ? void 0 : ae.classNames) == null ? void 0 : D.icon)
    }, ae.promise || ae.type === "loading" && !ae.icon ? ae.icon || Ha() : null, ae.type !== "loading" ? ae.icon || (ni == null ? void 0 : ni[Qn]) || u4(Qn) : null) : null, jt.createElement("div", {
        "data-content": "",
        className: Ia(Rt == null ? void 0 : Rt.content, (o = ae == null ? void 0 : ae.classNames) == null ? void 0 : o.content)
    }, jt.createElement("div", {
        "data-title": "",
        className: Ia(Rt == null ? void 0 : Rt.title, (j = ae == null ? void 0 : ae.classNames) == null ? void 0 : j.title)
    }, typeof ae.title == "function" ? ae.title() : ae.title), ae.description ? jt.createElement("div", {
        "data-description": "",
        className: Ia(Mi, zs, Rt == null ? void 0 : Rt.description, (q = ae == null ? void 0 : ae.classNames) == null ? void 0 : q.description)
    }, typeof ae.description == "function" ? ae.description() : ae.description) : null), Ce.isValidElement(ae.cancel) ? ae.cancel : ae.cancel && J0(ae.cancel) ? jt.createElement("button", {
        "data-button": !0,
        "data-cancel": !0,
        style: ae.cancelButtonStyle || Zt,
        onClick: Ze => {
            var xn, Jn;
            J0(ae.cancel) && Cr && ((Jn = (xn = ae.cancel).onClick) == null || Jn.call(xn, Ze), gs())
        },
        className: Ia(Rt == null ? void 0 : Rt.cancelButton, (ee = ae == null ? void 0 : ae.classNames) == null ? void 0 : ee.cancelButton)
    }, ae.cancel.label) : null, Ce.isValidElement(ae.action) ? ae.action : ae.action && J0(ae.action) ? jt.createElement("button", {
        "data-button": !0,
        "data-action": !0,
        style: ae.actionButtonStyle || Ht,
        onClick: Ze => {
            var xn, Jn;
            J0(ae.action) && ((Jn = (xn = ae.action).onClick) == null || Jn.call(xn, Ze), !Ze.defaultPrevented && gs())
        },
        className: Ia(Rt == null ? void 0 : Rt.actionButton, (oe = ae == null ? void 0 : ae.classNames) == null ? void 0 : oe.actionButton)
    }, ae.action.label) : null))
};

function aP() {
    if (typeof window > "u" || typeof document > "u") return "ltr";
    let r = document.documentElement.getAttribute("dir");
    return r === "auto" || !r ? window.getComputedStyle(document.documentElement).direction : r
}

function k4(r, l) {
    let p = {};
    return [r, l].forEach((y, T) => {
        let A = T === 1, D = A ? "--mobile-offset" : "--offset", o = A ? C4 : I4;

        function j(q) {
            ["top", "right", "bottom", "left"].forEach(ee => {
                p[`${D}-${ee}`] = typeof q == "number" ? `${q}px` : q
            })
        }

        typeof y == "number" || typeof y == "string" ? j(y) : typeof y == "object" ? ["top", "right", "bottom", "left"].forEach(q => {
            y[q] === void 0 ? p[`${D}-${q}`] = o : p[`${D}-${q}`] = typeof y[q] == "number" ? `${y[q]}px` : y[q]
        }) : j(o)
    }), p
}

var O4 = Ce.forwardRef(function (r, l) {
    let {
            invert: p,
            position: y = "bottom-right",
            hotkey: T = ["altKey", "KeyT"],
            expand: A,
            closeButton: D,
            className: o,
            offset: j,
            mobileOffset: q,
            theme: ee = "light",
            richColors: oe,
            duration: de,
            style: ae,
            visibleToasts: Re = A4,
            toastOptions: fe,
            dir: Me = aP(),
            gap: pe = M4,
            loadingIcon: le,
            icons: be,
            containerAriaLabel: Ue = "Notifications",
            pauseWhenPageIsHidden: et
        } = r, [_t, xt] = jt.useState([]),
        Mt = jt.useMemo(() => Array.from(new Set([y].concat(_t.filter(fi => fi.position).map(fi => fi.position)))), [_t, y]), [Xt, Zt] = jt.useState([]), [Ht, hi] = jt.useState(!1), [Mi, $t] = jt.useState(!1), [_i, si] = jt.useState(ee !== "system" ? ee : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"),
        Ri = jt.useRef(null), Ct = T.join("+").replace(/Key/g, "").replace(/Digit/g, ""), Rt = jt.useRef(null),
        ni = jt.useRef(!1), ai = jt.useCallback(fi => {
            xt(nn => {
                var cn;
                return (cn = nn.find(Zn => Zn.id === fi.id)) != null && cn.delete || Es.dismiss(fi.id), nn.filter(({id: Zn}) => Zn !== fi.id)
            })
        }, []);
    return jt.useEffect(() => Es.subscribe(fi => {
        if (fi.dismiss) {
            xt(nn => nn.map(cn => cn.id === fi.id ? {...cn, delete: !0} : cn));
            return
        }
        setTimeout(() => {
            iz.flushSync(() => {
                xt(nn => {
                    let cn = nn.findIndex(Zn => Zn.id === fi.id);
                    return cn !== -1 ? [...nn.slice(0, cn), {...nn[cn], ...fi}, ...nn.slice(cn + 1)] : [fi, ...nn]
                })
            })
        })
    }), []), jt.useEffect(() => {
        if (ee !== "system") {
            si(ee);
            return
        }
        if (ee === "system" && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? si("dark") : si("light")), typeof window > "u") return;
        let fi = window.matchMedia("(prefers-color-scheme: dark)");
        try {
            fi.addEventListener("change", ({matches: nn}) => {
                si(nn ? "dark" : "light")
            })
        } catch {
            fi.addListener(({matches: cn}) => {
                try {
                    si(cn ? "dark" : "light")
                } catch (Zn) {
                    console.error(Zn)
                }
            })
        }
    }, [ee]), jt.useEffect(() => {
        _t.length <= 1 && hi(!1)
    }, [_t]), jt.useEffect(() => {
        let fi = nn => {
            var cn, Zn;
            T.every(Bi => nn[Bi] || nn.code === Bi) && (hi(!0), (cn = Ri.current) == null || cn.focus()), nn.code === "Escape" && (document.activeElement === Ri.current || (Zn = Ri.current) != null && Zn.contains(document.activeElement)) && hi(!1)
        };
        return document.addEventListener("keydown", fi), () => document.removeEventListener("keydown", fi)
    }, [T]), jt.useEffect(() => {
        if (Ri.current) return () => {
            Rt.current && (Rt.current.focus({preventScroll: !0}), Rt.current = null, ni.current = !1)
        }
    }, [Ri.current]), jt.createElement("section", {
        ref: l,
        "aria-label": `${Ue} ${Ct}`,
        tabIndex: -1,
        "aria-live": "polite",
        "aria-relevant": "additions text",
        "aria-atomic": "false",
        suppressHydrationWarning: !0
    }, Mt.map((fi, nn) => {
        var cn;
        let [Zn, Bi] = fi.split("-");
        return _t.length ? jt.createElement("ol", {
            key: fi,
            dir: Me === "auto" ? aP() : Me,
            tabIndex: -1,
            ref: Ri,
            className: o,
            "data-sonner-toaster": !0,
            "data-theme": _i,
            "data-y-position": Zn,
            "data-lifted": Ht && _t.length > 1 && !A,
            "data-x-position": Bi,
            style: {
                "--front-toast-height": `${((cn = Xt[0]) == null ? void 0 : cn.height) || 0}px`,
                "--width": `${P4}px`,
                "--gap": `${pe}px`, ...ae, ...k4(j, q)
            },
            onBlur: Ii => {
                ni.current && !Ii.currentTarget.contains(Ii.relatedTarget) && (ni.current = !1, Rt.current && (Rt.current.focus({preventScroll: !0}), Rt.current = null))
            },
            onFocus: Ii => {
                Ii.target instanceof HTMLElement && Ii.target.dataset.dismissible === "false" || ni.current || (ni.current = !0, Rt.current = Ii.relatedTarget)
            },
            onMouseEnter: () => hi(!0),
            onMouseMove: () => hi(!0),
            onMouseLeave: () => {
                Mi || hi(!1)
            },
            onDragEnd: () => hi(!1),
            onPointerDown: Ii => {
                Ii.target instanceof HTMLElement && Ii.target.dataset.dismissible === "false" || $t(!0)
            },
            onPointerUp: () => $t(!1)
        }, _t.filter(Ii => !Ii.position && nn === 0 || Ii.position === fi).map((Ii, Bn) => {
            var ar, An;
            return jt.createElement(L4, {
                key: Ii.id,
                icons: be,
                index: Bn,
                toast: Ii,
                defaultRichColors: oe,
                duration: (ar = fe == null ? void 0 : fe.duration) != null ? ar : de,
                className: fe == null ? void 0 : fe.className,
                descriptionClassName: fe == null ? void 0 : fe.descriptionClassName,
                invert: p,
                visibleToasts: Re,
                closeButton: (An = fe == null ? void 0 : fe.closeButton) != null ? An : D,
                interacting: Mi,
                position: fi,
                style: fe == null ? void 0 : fe.style,
                unstyled: fe == null ? void 0 : fe.unstyled,
                classNames: fe == null ? void 0 : fe.classNames,
                cancelButtonStyle: fe == null ? void 0 : fe.cancelButtonStyle,
                actionButtonStyle: fe == null ? void 0 : fe.actionButtonStyle,
                removeToast: ai,
                toasts: _t.filter(Zr => Zr.position == Ii.position),
                heights: Xt.filter(Zr => Zr.position == Ii.position),
                setHeights: Zt,
                expandByDefault: A,
                gap: pe,
                loadingIcon: le,
                expanded: Ht,
                pauseWhenPageIsHidden: et,
                swipeDirections: r.swipeDirections
            })
        })) : null
    }))
});
const F4 = ({...r}) => {
    const {theme: l = "system"} = c4();
    return K.jsx(O4, {
        theme: l,
        className: "toaster group",
        toastOptions: {
            classNames: {
                toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
                description: "group-[.toast]:text-muted-foreground",
                actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
                cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground"
            }
        }, ...r
    })
};
var B4 = OT[" useId ".trim().toString()] || (() => {
}), N4 = 0;

function Xz(r) {
    const [l, p] = Ce.useState(B4());
    return Il(() => {
        p(y => y ?? String(N4++))
    }, [r]), l ? `radix-${l}` : ""
}

const j4 = ["top", "right", "bottom", "left"], Ou = Math.min, Us = Math.max, Xv = Math.round, ev = Math.floor,
    Al = r => ({x: r, y: r}), V4 = {left: "right", right: "left", bottom: "top", top: "bottom"},
    U4 = {start: "end", end: "start"};

function yT(r, l, p) {
    return Us(r, Ou(l, p))
}

function fc(r, l) {
    return typeof r == "function" ? r(l) : r
}

function pc(r) {
    return r.split("-")[0]
}

function Ep(r) {
    return r.split("-")[1]
}

function z2(r) {
    return r === "x" ? "y" : "x"
}

function D2(r) {
    return r === "y" ? "height" : "width"
}

const G4 = new Set(["top", "bottom"]);

function Tl(r) {
    return G4.has(pc(r)) ? "y" : "x"
}

function L2(r) {
    return z2(Tl(r))
}

function $4(r, l, p) {
    p === void 0 && (p = !1);
    const y = Ep(r), T = L2(r), A = D2(T);
    let D = T === "x" ? y === (p ? "end" : "start") ? "right" : "left" : y === "start" ? "bottom" : "top";
    return l.reference[A] > l.floating[A] && (D = Yv(D)), [D, Yv(D)]
}

function H4(r) {
    const l = Yv(r);
    return [vT(r), l, vT(l)]
}

function vT(r) {
    return r.replace(/start|end/g, l => U4[l])
}

const lP = ["left", "right"], cP = ["right", "left"], q4 = ["top", "bottom"], W4 = ["bottom", "top"];

function Z4(r, l, p) {
    switch (r) {
        case"top":
        case"bottom":
            return p ? l ? cP : lP : l ? lP : cP;
        case"left":
        case"right":
            return l ? q4 : W4;
        default:
            return []
    }
}

function X4(r, l, p, y) {
    const T = Ep(r);
    let A = Z4(pc(r), p === "start", y);
    return T && (A = A.map(D => D + "-" + T), l && (A = A.concat(A.map(vT)))), A
}

function Yv(r) {
    return r.replace(/left|right|bottom|top/g, l => V4[l])
}

function Y4(r) {
    return {top: 0, right: 0, bottom: 0, left: 0, ...r}
}

function Yz(r) {
    return typeof r != "number" ? Y4(r) : {top: r, right: r, bottom: r, left: r}
}

function Kv(r) {
    const {x: l, y: p, width: y, height: T} = r;
    return {width: y, height: T, top: p, left: l, right: l + y, bottom: p + T, x: l, y: p}
}

function uP(r, l, p) {
    let {reference: y, floating: T} = r;
    const A = Tl(l), D = L2(l), o = D2(D), j = pc(l), q = A === "y", ee = y.x + y.width / 2 - T.width / 2,
        oe = y.y + y.height / 2 - T.height / 2, de = y[o] / 2 - T[o] / 2;
    let ae;
    switch (j) {
        case"top":
            ae = {x: ee, y: y.y - T.height};
            break;
        case"bottom":
            ae = {x: ee, y: y.y + y.height};
            break;
        case"right":
            ae = {x: y.x + y.width, y: oe};
            break;
        case"left":
            ae = {x: y.x - T.width, y: oe};
            break;
        default:
            ae = {x: y.x, y: y.y}
    }
    switch (Ep(l)) {
        case"start":
            ae[D] -= de * (p && q ? -1 : 1);
            break;
        case"end":
            ae[D] += de * (p && q ? -1 : 1);
            break
    }
    return ae
}

const K4 = async (r, l, p) => {
    const {placement: y = "bottom", strategy: T = "absolute", middleware: A = [], platform: D} = p,
        o = A.filter(Boolean), j = await (D.isRTL == null ? void 0 : D.isRTL(l));
    let q = await D.getElementRects({reference: r, floating: l, strategy: T}), {x: ee, y: oe} = uP(q, y, j), de = y,
        ae = {}, Re = 0;
    for (let fe = 0; fe < o.length; fe++) {
        const {name: Me, fn: pe} = o[fe], {x: le, y: be, data: Ue, reset: et} = await pe({
            x: ee,
            y: oe,
            initialPlacement: y,
            placement: de,
            strategy: T,
            middlewareData: ae,
            rects: q,
            platform: D,
            elements: {reference: r, floating: l}
        });
        ee = le ?? ee, oe = be ?? oe, ae = {
            ...ae,
            [Me]: {...ae[Me], ...Ue}
        }, et && Re <= 50 && (Re++, typeof et == "object" && (et.placement && (de = et.placement), et.rects && (q = et.rects === !0 ? await D.getElementRects({
            reference: r,
            floating: l,
            strategy: T
        }) : et.rects), {x: ee, y: oe} = uP(q, de, j)), fe = -1)
    }
    return {x: ee, y: oe, placement: de, strategy: T, middlewareData: ae}
};

async function __(r, l) {
    var p;
    l === void 0 && (l = {});
    const {x: y, y: T, platform: A, rects: D, elements: o, strategy: j} = r, {
            boundary: q = "clippingAncestors",
            rootBoundary: ee = "viewport",
            elementContext: oe = "floating",
            altBoundary: de = !1,
            padding: ae = 0
        } = fc(l, r), Re = Yz(ae), Me = o[de ? oe === "floating" ? "reference" : "floating" : oe],
        pe = Kv(await A.getClippingRect({
            element: (p = await (A.isElement == null ? void 0 : A.isElement(Me))) == null || p ? Me : Me.contextElement || await (A.getDocumentElement == null ? void 0 : A.getDocumentElement(o.floating)),
            boundary: q,
            rootBoundary: ee,
            strategy: j
        })), le = oe === "floating" ? {x: y, y: T, width: D.floating.width, height: D.floating.height} : D.reference,
        be = await (A.getOffsetParent == null ? void 0 : A.getOffsetParent(o.floating)),
        Ue = await (A.isElement == null ? void 0 : A.isElement(be)) ? await (A.getScale == null ? void 0 : A.getScale(be)) || {
            x: 1,
            y: 1
        } : {x: 1, y: 1},
        et = Kv(A.convertOffsetParentRelativeRectToViewportRelativeRect ? await A.convertOffsetParentRelativeRectToViewportRelativeRect({
            elements: o,
            rect: le,
            offsetParent: be,
            strategy: j
        }) : le);
    return {
        top: (pe.top - et.top + Re.top) / Ue.y,
        bottom: (et.bottom - pe.bottom + Re.bottom) / Ue.y,
        left: (pe.left - et.left + Re.left) / Ue.x,
        right: (et.right - pe.right + Re.right) / Ue.x
    }
}

const Q4 = r => ({
    name: "arrow", options: r, async fn(l) {
        const {x: p, y, placement: T, rects: A, platform: D, elements: o, middlewareData: j} = l, {
            element: q,
            padding: ee = 0
        } = fc(r, l) || {};
        if (q == null) return {};
        const oe = Yz(ee), de = {x: p, y}, ae = L2(T), Re = D2(ae), fe = await D.getDimensions(q), Me = ae === "y",
            pe = Me ? "top" : "left", le = Me ? "bottom" : "right", be = Me ? "clientHeight" : "clientWidth",
            Ue = A.reference[Re] + A.reference[ae] - de[ae] - A.floating[Re], et = de[ae] - A.reference[ae],
            _t = await (D.getOffsetParent == null ? void 0 : D.getOffsetParent(q));
        let xt = _t ? _t[be] : 0;
        (!xt || !await (D.isElement == null ? void 0 : D.isElement(_t))) && (xt = o.floating[be] || A.floating[Re]);
        const Mt = Ue / 2 - et / 2, Xt = xt / 2 - fe[Re] / 2 - 1, Zt = Ou(oe[pe], Xt), Ht = Ou(oe[le], Xt), hi = Zt,
            Mi = xt - fe[Re] - Ht, $t = xt / 2 - fe[Re] / 2 + Mt, _i = yT(hi, $t, Mi),
            si = !j.arrow && Ep(T) != null && $t !== _i && A.reference[Re] / 2 - ($t < hi ? Zt : Ht) - fe[Re] / 2 < 0,
            Ri = si ? $t < hi ? $t - hi : $t - Mi : 0;
        return {
            [ae]: de[ae] + Ri,
            data: {[ae]: _i, centerOffset: $t - _i - Ri, ...si && {alignmentOffset: Ri}},
            reset: si
        }
    }
}), J4 = function (r) {
    return r === void 0 && (r = {}), {
        name: "flip", options: r, async fn(l) {
            var p, y;
            const {
                placement: T,
                middlewareData: A,
                rects: D,
                initialPlacement: o,
                platform: j,
                elements: q
            } = l, {
                mainAxis: ee = !0,
                crossAxis: oe = !0,
                fallbackPlacements: de,
                fallbackStrategy: ae = "bestFit",
                fallbackAxisSideDirection: Re = "none",
                flipAlignment: fe = !0,
                ...Me
            } = fc(r, l);
            if ((p = A.arrow) != null && p.alignmentOffset) return {};
            const pe = pc(T), le = Tl(o), be = pc(o) === o, Ue = await (j.isRTL == null ? void 0 : j.isRTL(q.floating)),
                et = de || (be || !fe ? [Yv(o)] : H4(o)), _t = Re !== "none";
            !de && _t && et.push(...X4(o, fe, Re, Ue));
            const xt = [o, ...et], Mt = await __(l, Me), Xt = [];
            let Zt = ((y = A.flip) == null ? void 0 : y.overflows) || [];
            if (ee && Xt.push(Mt[pe]), oe) {
                const $t = $4(T, D, Ue);
                Xt.push(Mt[$t[0]], Mt[$t[1]])
            }
            if (Zt = [...Zt, {placement: T, overflows: Xt}], !Xt.every($t => $t <= 0)) {
                var Ht, hi;
                const $t = (((Ht = A.flip) == null ? void 0 : Ht.index) || 0) + 1, _i = xt[$t];
                if (_i && (!(oe === "alignment" ? le !== Tl(_i) : !1) || Zt.every(Ct => Ct.overflows[0] > 0 && Tl(Ct.placement) === le))) return {
                    data: {
                        index: $t,
                        overflows: Zt
                    }, reset: {placement: _i}
                };
                let si = (hi = Zt.filter(Ri => Ri.overflows[0] <= 0).sort((Ri, Ct) => Ri.overflows[1] - Ct.overflows[1])[0]) == null ? void 0 : hi.placement;
                if (!si) switch (ae) {
                    case"bestFit": {
                        var Mi;
                        const Ri = (Mi = Zt.filter(Ct => {
                            if (_t) {
                                const Rt = Tl(Ct.placement);
                                return Rt === le || Rt === "y"
                            }
                            return !0
                        }).map(Ct => [Ct.placement, Ct.overflows.filter(Rt => Rt > 0).reduce((Rt, ni) => Rt + ni, 0)]).sort((Ct, Rt) => Ct[1] - Rt[1])[0]) == null ? void 0 : Mi[0];
                        Ri && (si = Ri);
                        break
                    }
                    case"initialPlacement":
                        si = o;
                        break
                }
                if (T !== si) return {reset: {placement: si}}
            }
            return {}
        }
    }
};

function hP(r, l) {
    return {top: r.top - l.height, right: r.right - l.width, bottom: r.bottom - l.height, left: r.left - l.width}
}

function dP(r) {
    return j4.some(l => r[l] >= 0)
}

const ej = function (r) {
    return r === void 0 && (r = {}), {
        name: "hide", options: r, async fn(l) {
            const {rects: p} = l, {strategy: y = "referenceHidden", ...T} = fc(r, l);
            switch (y) {
                case"referenceHidden": {
                    const A = await __(l, {...T, elementContext: "reference"}), D = hP(A, p.reference);
                    return {data: {referenceHiddenOffsets: D, referenceHidden: dP(D)}}
                }
                case"escaped": {
                    const A = await __(l, {...T, altBoundary: !0}), D = hP(A, p.floating);
                    return {data: {escapedOffsets: D, escaped: dP(D)}}
                }
                default:
                    return {}
            }
        }
    }
}, Kz = new Set(["left", "top"]);

async function tj(r, l) {
    const {placement: p, platform: y, elements: T} = r, A = await (y.isRTL == null ? void 0 : y.isRTL(T.floating)),
        D = pc(p), o = Ep(p), j = Tl(p) === "y", q = Kz.has(D) ? -1 : 1, ee = A && j ? -1 : 1, oe = fc(l, r);
    let {mainAxis: de, crossAxis: ae, alignmentAxis: Re} = typeof oe == "number" ? {
        mainAxis: oe,
        crossAxis: 0,
        alignmentAxis: null
    } : {mainAxis: oe.mainAxis || 0, crossAxis: oe.crossAxis || 0, alignmentAxis: oe.alignmentAxis};
    return o && typeof Re == "number" && (ae = o === "end" ? Re * -1 : Re), j ? {x: ae * ee, y: de * q} : {
        x: de * q,
        y: ae * ee
    }
}

const ij = function (r) {
    return r === void 0 && (r = 0), {
        name: "offset", options: r, async fn(l) {
            var p, y;
            const {x: T, y: A, placement: D, middlewareData: o} = l, j = await tj(l, r);
            return D === ((p = o.offset) == null ? void 0 : p.placement) && (y = o.arrow) != null && y.alignmentOffset ? {} : {
                x: T + j.x,
                y: A + j.y,
                data: {...j, placement: D}
            }
        }
    }
}, nj = function (r) {
    return r === void 0 && (r = {}), {
        name: "shift", options: r, async fn(l) {
            const {x: p, y, placement: T} = l, {
                mainAxis: A = !0, crossAxis: D = !1, limiter: o = {
                    fn: Me => {
                        let {x: pe, y: le} = Me;
                        return {x: pe, y: le}
                    }
                }, ...j
            } = fc(r, l), q = {x: p, y}, ee = await __(l, j), oe = Tl(pc(T)), de = z2(oe);
            let ae = q[de], Re = q[oe];
            if (A) {
                const Me = de === "y" ? "top" : "left", pe = de === "y" ? "bottom" : "right", le = ae + ee[Me],
                    be = ae - ee[pe];
                ae = yT(le, ae, be)
            }
            if (D) {
                const Me = oe === "y" ? "top" : "left", pe = oe === "y" ? "bottom" : "right", le = Re + ee[Me],
                    be = Re - ee[pe];
                Re = yT(le, Re, be)
            }
            const fe = o.fn({...l, [de]: ae, [oe]: Re});
            return {...fe, data: {x: fe.x - p, y: fe.y - y, enabled: {[de]: A, [oe]: D}}}
        }
    }
}, rj = function (r) {
    return r === void 0 && (r = {}), {
        options: r, fn(l) {
            const {x: p, y, placement: T, rects: A, middlewareData: D} = l, {
                offset: o = 0,
                mainAxis: j = !0,
                crossAxis: q = !0
            } = fc(r, l), ee = {x: p, y}, oe = Tl(T), de = z2(oe);
            let ae = ee[de], Re = ee[oe];
            const fe = fc(o, l),
                Me = typeof fe == "number" ? {mainAxis: fe, crossAxis: 0} : {mainAxis: 0, crossAxis: 0, ...fe};
            if (j) {
                const be = de === "y" ? "height" : "width", Ue = A.reference[de] - A.floating[be] + Me.mainAxis,
                    et = A.reference[de] + A.reference[be] - Me.mainAxis;
                ae < Ue ? ae = Ue : ae > et && (ae = et)
            }
            if (q) {
                var pe, le;
                const be = de === "y" ? "width" : "height", Ue = Kz.has(pc(T)),
                    et = A.reference[oe] - A.floating[be] + (Ue && ((pe = D.offset) == null ? void 0 : pe[oe]) || 0) + (Ue ? 0 : Me.crossAxis),
                    _t = A.reference[oe] + A.reference[be] + (Ue ? 0 : ((le = D.offset) == null ? void 0 : le[oe]) || 0) - (Ue ? Me.crossAxis : 0);
                Re < et ? Re = et : Re > _t && (Re = _t)
            }
            return {[de]: ae, [oe]: Re}
        }
    }
}, oj = function (r) {
    return r === void 0 && (r = {}), {
        name: "size", options: r, async fn(l) {
            var p, y;
            const {placement: T, rects: A, platform: D, elements: o} = l, {
                apply: j = () => {
                }, ...q
            } = fc(r, l), ee = await __(l, q), oe = pc(T), de = Ep(T), ae = Tl(T) === "y", {
                width: Re,
                height: fe
            } = A.floating;
            let Me, pe;
            oe === "top" || oe === "bottom" ? (Me = oe, pe = de === (await (D.isRTL == null ? void 0 : D.isRTL(o.floating)) ? "start" : "end") ? "left" : "right") : (pe = oe, Me = de === "end" ? "top" : "bottom");
            const le = fe - ee.top - ee.bottom, be = Re - ee.left - ee.right, Ue = Ou(fe - ee[Me], le),
                et = Ou(Re - ee[pe], be), _t = !l.middlewareData.shift;
            let xt = Ue, Mt = et;
            if ((p = l.middlewareData.shift) != null && p.enabled.x && (Mt = be), (y = l.middlewareData.shift) != null && y.enabled.y && (xt = le), _t && !de) {
                const Zt = Us(ee.left, 0), Ht = Us(ee.right, 0), hi = Us(ee.top, 0), Mi = Us(ee.bottom, 0);
                ae ? Mt = Re - 2 * (Zt !== 0 || Ht !== 0 ? Zt + Ht : Us(ee.left, ee.right)) : xt = fe - 2 * (hi !== 0 || Mi !== 0 ? hi + Mi : Us(ee.top, ee.bottom))
            }
            await j({...l, availableWidth: Mt, availableHeight: xt});
            const Xt = await D.getDimensions(o.floating);
            return Re !== Xt.width || fe !== Xt.height ? {reset: {rects: !0}} : {}
        }
    }
};

function Ex() {
    return typeof window < "u"
}

function Ap(r) {
    return Qz(r) ? (r.nodeName || "").toLowerCase() : "#document"
}

function Hs(r) {
    var l;
    return (r == null || (l = r.ownerDocument) == null ? void 0 : l.defaultView) || window
}

function Pl(r) {
    var l;
    return (l = (Qz(r) ? r.ownerDocument : r.document) || window.document) == null ? void 0 : l.documentElement
}

function Qz(r) {
    return Ex() ? r instanceof Node || r instanceof Hs(r).Node : !1
}

function Ba(r) {
    return Ex() ? r instanceof Element || r instanceof Hs(r).Element : !1
}

function Cl(r) {
    return Ex() ? r instanceof HTMLElement || r instanceof Hs(r).HTMLElement : !1
}

function fP(r) {
    return !Ex() || typeof ShadowRoot > "u" ? !1 : r instanceof ShadowRoot || r instanceof Hs(r).ShadowRoot
}

const sj = new Set(["inline", "contents"]);

function z_(r) {
    const {overflow: l, overflowX: p, overflowY: y, display: T} = Na(r);
    return /auto|scroll|overlay|hidden|clip/.test(l + y + p) && !sj.has(T)
}

const aj = new Set(["table", "td", "th"]);

function lj(r) {
    return aj.has(Ap(r))
}

const cj = [":popover-open", ":modal"];

function Ax(r) {
    return cj.some(l => {
        try {
            return r.matches(l)
        } catch {
            return !1
        }
    })
}

const uj = ["transform", "translate", "scale", "rotate", "perspective"],
    hj = ["transform", "translate", "scale", "rotate", "perspective", "filter"],
    dj = ["paint", "layout", "strict", "content"];

function k2(r) {
    const l = O2(), p = Ba(r) ? Na(r) : r;
    return uj.some(y => p[y] ? p[y] !== "none" : !1) || (p.containerType ? p.containerType !== "normal" : !1) || !l && (p.backdropFilter ? p.backdropFilter !== "none" : !1) || !l && (p.filter ? p.filter !== "none" : !1) || hj.some(y => (p.willChange || "").includes(y)) || dj.some(y => (p.contain || "").includes(y))
}

function fj(r) {
    let l = Fu(r);
    for (; Cl(l) && !mp(l);) {
        if (k2(l)) return l;
        if (Ax(l)) return null;
        l = Fu(l)
    }
    return null
}

function O2() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none")
}

const pj = new Set(["html", "body", "#document"]);

function mp(r) {
    return pj.has(Ap(r))
}

function Na(r) {
    return Hs(r).getComputedStyle(r)
}

function Ix(r) {
    return Ba(r) ? {scrollLeft: r.scrollLeft, scrollTop: r.scrollTop} : {scrollLeft: r.scrollX, scrollTop: r.scrollY}
}

function Fu(r) {
    if (Ap(r) === "html") return r;
    const l = r.assignedSlot || r.parentNode || fP(r) && r.host || Pl(r);
    return fP(l) ? l.host : l
}

function Jz(r) {
    const l = Fu(r);
    return mp(l) ? r.ownerDocument ? r.ownerDocument.body : r.body : Cl(l) && z_(l) ? l : Jz(l)
}

function y_(r, l, p) {
    var y;
    l === void 0 && (l = []), p === void 0 && (p = !0);
    const T = Jz(r), A = T === ((y = r.ownerDocument) == null ? void 0 : y.body), D = Hs(T);
    if (A) {
        const o = xT(D);
        return l.concat(D, D.visualViewport || [], z_(T) ? T : [], o && p ? y_(o) : [])
    }
    return l.concat(T, y_(T, [], p))
}

function xT(r) {
    return r.parent && Object.getPrototypeOf(r.parent) ? r.frameElement : null
}

function eD(r) {
    const l = Na(r);
    let p = parseFloat(l.width) || 0, y = parseFloat(l.height) || 0;
    const T = Cl(r), A = T ? r.offsetWidth : p, D = T ? r.offsetHeight : y, o = Xv(p) !== A || Xv(y) !== D;
    return o && (p = A, y = D), {width: p, height: y, $: o}
}

function F2(r) {
    return Ba(r) ? r : r.contextElement
}

function Kf(r) {
    const l = F2(r);
    if (!Cl(l)) return Al(1);
    const p = l.getBoundingClientRect(), {width: y, height: T, $: A} = eD(l);
    let D = (A ? Xv(p.width) : p.width) / y, o = (A ? Xv(p.height) : p.height) / T;
    return (!D || !Number.isFinite(D)) && (D = 1), (!o || !Number.isFinite(o)) && (o = 1), {x: D, y: o}
}

const mj = Al(0);

function tD(r) {
    const l = Hs(r);
    return !O2() || !l.visualViewport ? mj : {x: l.visualViewport.offsetLeft, y: l.visualViewport.offsetTop}
}

function gj(r, l, p) {
    return l === void 0 && (l = !1), !p || l && p !== Hs(r) ? !1 : l
}

function od(r, l, p, y) {
    l === void 0 && (l = !1), p === void 0 && (p = !1);
    const T = r.getBoundingClientRect(), A = F2(r);
    let D = Al(1);
    l && (y ? Ba(y) && (D = Kf(y)) : D = Kf(r));
    const o = gj(A, p, y) ? tD(A) : Al(0);
    let j = (T.left + o.x) / D.x, q = (T.top + o.y) / D.y, ee = T.width / D.x, oe = T.height / D.y;
    if (A) {
        const de = Hs(A), ae = y && Ba(y) ? Hs(y) : y;
        let Re = de, fe = xT(Re);
        for (; fe && y && ae !== Re;) {
            const Me = Kf(fe), pe = fe.getBoundingClientRect(), le = Na(fe),
                be = pe.left + (fe.clientLeft + parseFloat(le.paddingLeft)) * Me.x,
                Ue = pe.top + (fe.clientTop + parseFloat(le.paddingTop)) * Me.y;
            j *= Me.x, q *= Me.y, ee *= Me.x, oe *= Me.y, j += be, q += Ue, Re = Hs(fe), fe = xT(Re)
        }
    }
    return Kv({width: ee, height: oe, x: j, y: q})
}

function B2(r, l) {
    const p = Ix(r).scrollLeft;
    return l ? l.left + p : od(Pl(r)).left + p
}

function iD(r, l, p) {
    p === void 0 && (p = !1);
    const y = r.getBoundingClientRect(), T = y.left + l.scrollLeft - (p ? 0 : B2(r, y)), A = y.top + l.scrollTop;
    return {x: T, y: A}
}

function _j(r) {
    let {elements: l, rect: p, offsetParent: y, strategy: T} = r;
    const A = T === "fixed", D = Pl(y), o = l ? Ax(l.floating) : !1;
    if (y === D || o && A) return p;
    let j = {scrollLeft: 0, scrollTop: 0}, q = Al(1);
    const ee = Al(0), oe = Cl(y);
    if ((oe || !oe && !A) && ((Ap(y) !== "body" || z_(D)) && (j = Ix(y)), Cl(y))) {
        const ae = od(y);
        q = Kf(y), ee.x = ae.x + y.clientLeft, ee.y = ae.y + y.clientTop
    }
    const de = D && !oe && !A ? iD(D, j, !0) : Al(0);
    return {
        width: p.width * q.x,
        height: p.height * q.y,
        x: p.x * q.x - j.scrollLeft * q.x + ee.x + de.x,
        y: p.y * q.y - j.scrollTop * q.y + ee.y + de.y
    }
}

function yj(r) {
    return Array.from(r.getClientRects())
}

function vj(r) {
    const l = Pl(r), p = Ix(r), y = r.ownerDocument.body,
        T = Us(l.scrollWidth, l.clientWidth, y.scrollWidth, y.clientWidth),
        A = Us(l.scrollHeight, l.clientHeight, y.scrollHeight, y.clientHeight);
    let D = -p.scrollLeft + B2(r);
    const o = -p.scrollTop;
    return Na(y).direction === "rtl" && (D += Us(l.clientWidth, y.clientWidth) - T), {width: T, height: A, x: D, y: o}
}

function xj(r, l) {
    const p = Hs(r), y = Pl(r), T = p.visualViewport;
    let A = y.clientWidth, D = y.clientHeight, o = 0, j = 0;
    if (T) {
        A = T.width, D = T.height;
        const q = O2();
        (!q || q && l === "fixed") && (o = T.offsetLeft, j = T.offsetTop)
    }
    return {width: A, height: D, x: o, y: j}
}

const wj = new Set(["absolute", "fixed"]);

function bj(r, l) {
    const p = od(r, !0, l === "fixed"), y = p.top + r.clientTop, T = p.left + r.clientLeft, A = Cl(r) ? Kf(r) : Al(1),
        D = r.clientWidth * A.x, o = r.clientHeight * A.y, j = T * A.x, q = y * A.y;
    return {width: D, height: o, x: j, y: q}
}

function pP(r, l, p) {
    let y;
    if (l === "viewport") y = xj(r, p); else if (l === "document") y = vj(Pl(r)); else if (Ba(l)) y = bj(l, p); else {
        const T = tD(r);
        y = {x: l.x - T.x, y: l.y - T.y, width: l.width, height: l.height}
    }
    return Kv(y)
}

function nD(r, l) {
    const p = Fu(r);
    return p === l || !Ba(p) || mp(p) ? !1 : Na(p).position === "fixed" || nD(p, l)
}

function Tj(r, l) {
    const p = l.get(r);
    if (p) return p;
    let y = y_(r, [], !1).filter(o => Ba(o) && Ap(o) !== "body"), T = null;
    const A = Na(r).position === "fixed";
    let D = A ? Fu(r) : r;
    for (; Ba(D) && !mp(D);) {
        const o = Na(D), j = k2(D);
        !j && o.position === "fixed" && (T = null), (A ? !j && !T : !j && o.position === "static" && !!T && wj.has(T.position) || z_(D) && !j && nD(r, D)) ? y = y.filter(ee => ee !== D) : T = o, D = Fu(D)
    }
    return l.set(r, y), y
}

function Sj(r) {
    let {element: l, boundary: p, rootBoundary: y, strategy: T} = r;
    const D = [...p === "clippingAncestors" ? Ax(l) ? [] : Tj(l, this._c) : [].concat(p), y], o = D[0],
        j = D.reduce((q, ee) => {
            const oe = pP(l, ee, T);
            return q.top = Us(oe.top, q.top), q.right = Ou(oe.right, q.right), q.bottom = Ou(oe.bottom, q.bottom), q.left = Us(oe.left, q.left), q
        }, pP(l, o, T));
    return {width: j.right - j.left, height: j.bottom - j.top, x: j.left, y: j.top}
}

function Ej(r) {
    const {width: l, height: p} = eD(r);
    return {width: l, height: p}
}

function Aj(r, l, p) {
    const y = Cl(l), T = Pl(l), A = p === "fixed", D = od(r, !0, A, l);
    let o = {scrollLeft: 0, scrollTop: 0};
    const j = Al(0);

    function q() {
        j.x = B2(T)
    }

    if (y || !y && !A) if ((Ap(l) !== "body" || z_(T)) && (o = Ix(l)), y) {
        const ae = od(l, !0, A, l);
        j.x = ae.x + l.clientLeft, j.y = ae.y + l.clientTop
    } else T && q();
    A && !y && T && q();
    const ee = T && !y && !A ? iD(T, o) : Al(0), oe = D.left + o.scrollLeft - j.x - ee.x,
        de = D.top + o.scrollTop - j.y - ee.y;
    return {x: oe, y: de, width: D.width, height: D.height}
}

function hb(r) {
    return Na(r).position === "static"
}

function mP(r, l) {
    if (!Cl(r) || Na(r).position === "fixed") return null;
    if (l) return l(r);
    let p = r.offsetParent;
    return Pl(r) === p && (p = p.ownerDocument.body), p
}

function rD(r, l) {
    const p = Hs(r);
    if (Ax(r)) return p;
    if (!Cl(r)) {
        let T = Fu(r);
        for (; T && !mp(T);) {
            if (Ba(T) && !hb(T)) return T;
            T = Fu(T)
        }
        return p
    }
    let y = mP(r, l);
    for (; y && lj(y) && hb(y);) y = mP(y, l);
    return y && mp(y) && hb(y) && !k2(y) ? p : y || fj(r) || p
}

const Ij = async function (r) {
    const l = this.getOffsetParent || rD, p = this.getDimensions, y = await p(r.floating);
    return {
        reference: Aj(r.reference, await l(r.floating), r.strategy),
        floating: {x: 0, y: 0, width: y.width, height: y.height}
    }
};

function Cj(r) {
    return Na(r).direction === "rtl"
}

const Pj = {
    convertOffsetParentRelativeRectToViewportRelativeRect: _j,
    getDocumentElement: Pl,
    getClippingRect: Sj,
    getOffsetParent: rD,
    getElementRects: Ij,
    getClientRects: yj,
    getDimensions: Ej,
    getScale: Kf,
    isElement: Ba,
    isRTL: Cj
};

function oD(r, l) {
    return r.x === l.x && r.y === l.y && r.width === l.width && r.height === l.height
}

function Mj(r, l) {
    let p = null, y;
    const T = Pl(r);

    function A() {
        var o;
        clearTimeout(y), (o = p) == null || o.disconnect(), p = null
    }

    function D(o, j) {
        o === void 0 && (o = !1), j === void 0 && (j = 1), A();
        const q = r.getBoundingClientRect(), {left: ee, top: oe, width: de, height: ae} = q;
        if (o || l(), !de || !ae) return;
        const Re = ev(oe), fe = ev(T.clientWidth - (ee + de)), Me = ev(T.clientHeight - (oe + ae)), pe = ev(ee),
            be = {rootMargin: -Re + "px " + -fe + "px " + -Me + "px " + -pe + "px", threshold: Us(0, Ou(1, j)) || 1};
        let Ue = !0;

        function et(_t) {
            const xt = _t[0].intersectionRatio;
            if (xt !== j) {
                if (!Ue) return D();
                xt ? D(!1, xt) : y = setTimeout(() => {
                    D(!1, 1e-7)
                }, 1e3)
            }
            xt === 1 && !oD(q, r.getBoundingClientRect()) && D(), Ue = !1
        }

        try {
            p = new IntersectionObserver(et, {...be, root: T.ownerDocument})
        } catch {
            p = new IntersectionObserver(et, be)
        }
        p.observe(r)
    }

    return D(!0), A
}

function Rj(r, l, p, y) {
    y === void 0 && (y = {});
    const {
        ancestorScroll: T = !0,
        ancestorResize: A = !0,
        elementResize: D = typeof ResizeObserver == "function",
        layoutShift: o = typeof IntersectionObserver == "function",
        animationFrame: j = !1
    } = y, q = F2(r), ee = T || A ? [...q ? y_(q) : [], ...y_(l)] : [];
    ee.forEach(pe => {
        T && pe.addEventListener("scroll", p, {passive: !0}), A && pe.addEventListener("resize", p)
    });
    const oe = q && o ? Mj(q, p) : null;
    let de = -1, ae = null;
    D && (ae = new ResizeObserver(pe => {
        let [le] = pe;
        le && le.target === q && ae && (ae.unobserve(l), cancelAnimationFrame(de), de = requestAnimationFrame(() => {
            var be;
            (be = ae) == null || be.observe(l)
        })), p()
    }), q && !j && ae.observe(q), ae.observe(l));
    let Re, fe = j ? od(r) : null;
    j && Me();

    function Me() {
        const pe = od(r);
        fe && !oD(fe, pe) && p(), fe = pe, Re = requestAnimationFrame(Me)
    }

    return p(), () => {
        var pe;
        ee.forEach(le => {
            T && le.removeEventListener("scroll", p), A && le.removeEventListener("resize", p)
        }), oe == null || oe(), (pe = ae) == null || pe.disconnect(), ae = null, j && cancelAnimationFrame(Re)
    }
}

const zj = ij, Dj = nj, Lj = J4, kj = oj, Oj = ej, gP = Q4, Fj = rj, Bj = (r, l, p) => {
    const y = new Map, T = {platform: Pj, ...p}, A = {...T.platform, _c: y};
    return K4(r, l, {...T, platform: A})
};
var Nj = typeof document < "u", jj = function () {
}, yv = Nj ? Ce.useLayoutEffect : jj;

function Qv(r, l) {
    if (r === l) return !0;
    if (typeof r != typeof l) return !1;
    if (typeof r == "function" && r.toString() === l.toString()) return !0;
    let p, y, T;
    if (r && l && typeof r == "object") {
        if (Array.isArray(r)) {
            if (p = r.length, p !== l.length) return !1;
            for (y = p; y-- !== 0;) if (!Qv(r[y], l[y])) return !1;
            return !0
        }
        if (T = Object.keys(r), p = T.length, p !== Object.keys(l).length) return !1;
        for (y = p; y-- !== 0;) if (!{}.hasOwnProperty.call(l, T[y])) return !1;
        for (y = p; y-- !== 0;) {
            const A = T[y];
            if (!(A === "_owner" && r.$$typeof) && !Qv(r[A], l[A])) return !1
        }
        return !0
    }
    return r !== r && l !== l
}

function sD(r) {
    return typeof window > "u" ? 1 : (r.ownerDocument.defaultView || window).devicePixelRatio || 1
}

function _P(r, l) {
    const p = sD(r);
    return Math.round(l * p) / p
}

function db(r) {
    const l = Ce.useRef(r);
    return yv(() => {
        l.current = r
    }), l
}

function Vj(r) {
    r === void 0 && (r = {});
    const {
        placement: l = "bottom",
        strategy: p = "absolute",
        middleware: y = [],
        platform: T,
        elements: {reference: A, floating: D} = {},
        transform: o = !0,
        whileElementsMounted: j,
        open: q
    } = r, [ee, oe] = Ce.useState({
        x: 0,
        y: 0,
        strategy: p,
        placement: l,
        middlewareData: {},
        isPositioned: !1
    }), [de, ae] = Ce.useState(y);
    Qv(de, y) || ae(y);
    const [Re, fe] = Ce.useState(null), [Me, pe] = Ce.useState(null), le = Ce.useCallback(Ct => {
            Ct !== _t.current && (_t.current = Ct, fe(Ct))
        }, []), be = Ce.useCallback(Ct => {
            Ct !== xt.current && (xt.current = Ct, pe(Ct))
        }, []), Ue = A || Re, et = D || Me, _t = Ce.useRef(null), xt = Ce.useRef(null), Mt = Ce.useRef(ee), Xt = j != null,
        Zt = db(j), Ht = db(T), hi = db(q), Mi = Ce.useCallback(() => {
            if (!_t.current || !xt.current) return;
            const Ct = {placement: l, strategy: p, middleware: de};
            Ht.current && (Ct.platform = Ht.current), Bj(_t.current, xt.current, Ct).then(Rt => {
                const ni = {...Rt, isPositioned: hi.current !== !1};
                $t.current && !Qv(Mt.current, ni) && (Mt.current = ni, M_.flushSync(() => {
                    oe(ni)
                }))
            })
        }, [de, l, p, Ht, hi]);
    yv(() => {
        q === !1 && Mt.current.isPositioned && (Mt.current.isPositioned = !1, oe(Ct => ({...Ct, isPositioned: !1})))
    }, [q]);
    const $t = Ce.useRef(!1);
    yv(() => ($t.current = !0, () => {
        $t.current = !1
    }), []), yv(() => {
        if (Ue && (_t.current = Ue), et && (xt.current = et), Ue && et) {
            if (Zt.current) return Zt.current(Ue, et, Mi);
            Mi()
        }
    }, [Ue, et, Mi, Zt, Xt]);
    const _i = Ce.useMemo(() => ({reference: _t, floating: xt, setReference: le, setFloating: be}), [le, be]),
        si = Ce.useMemo(() => ({reference: Ue, floating: et}), [Ue, et]), Ri = Ce.useMemo(() => {
            const Ct = {position: p, left: 0, top: 0};
            if (!si.floating) return Ct;
            const Rt = _P(si.floating, ee.x), ni = _P(si.floating, ee.y);
            return o ? {
                ...Ct,
                transform: "translate(" + Rt + "px, " + ni + "px)", ...sD(si.floating) >= 1.5 && {willChange: "transform"}
            } : {position: p, left: Rt, top: ni}
        }, [p, o, si.floating, ee.x, ee.y]);
    return Ce.useMemo(() => ({...ee, update: Mi, refs: _i, elements: si, floatingStyles: Ri}), [ee, Mi, _i, si, Ri])
}

const Uj = r => {
        function l(p) {
            return {}.hasOwnProperty.call(p, "current")
        }

        return {
            name: "arrow", options: r, fn(p) {
                const {element: y, padding: T} = typeof r == "function" ? r(p) : r;
                return y && l(y) ? y.current != null ? gP({element: y.current, padding: T}).fn(p) : {} : y ? gP({
                    element: y,
                    padding: T
                }).fn(p) : {}
            }
        }
    }, Gj = (r, l) => ({...zj(r), options: [r, l]}), $j = (r, l) => ({...Dj(r), options: [r, l]}),
    Hj = (r, l) => ({...Fj(r), options: [r, l]}), qj = (r, l) => ({...Lj(r), options: [r, l]}),
    Wj = (r, l) => ({...kj(r), options: [r, l]}), Zj = (r, l) => ({...Oj(r), options: [r, l]}),
    Xj = (r, l) => ({...Uj(r), options: [r, l]});
var Yj = "Arrow", aD = Ce.forwardRef((r, l) => {
    const {children: p, width: y = 10, height: T = 5, ...A} = r;
    return K.jsx(so.svg, {
        ...A,
        ref: l,
        width: y,
        height: T,
        viewBox: "0 0 30 10",
        preserveAspectRatio: "none",
        children: r.asChild ? p : K.jsx("polygon", {points: "0,0 30,0 15,10"})
    })
});
aD.displayName = Yj;
var Kj = aD;

function Qj(r) {
    const [l, p] = Ce.useState(void 0);
    return Il(() => {
        if (r) {
            p({width: r.offsetWidth, height: r.offsetHeight});
            const y = new ResizeObserver(T => {
                if (!Array.isArray(T) || !T.length) return;
                const A = T[0];
                let D, o;
                if ("borderBoxSize" in A) {
                    const j = A.borderBoxSize, q = Array.isArray(j) ? j[0] : j;
                    D = q.inlineSize, o = q.blockSize
                } else D = r.offsetWidth, o = r.offsetHeight;
                p({width: D, height: o})
            });
            return y.observe(r, {box: "border-box"}), () => y.unobserve(r)
        } else p(void 0)
    }, [r]), l
}

var lD = "Popper", [cD, uD] = Tp(lD), [f8, hD] = cD(lD), dD = "PopperAnchor", fD = Ce.forwardRef((r, l) => {
    const {__scopePopper: p, virtualRef: y, ...T} = r, A = hD(dD, p), D = Ce.useRef(null), o = Ws(l, D);
    return Ce.useEffect(() => {
        A.onAnchorChange((y == null ? void 0 : y.current) || D.current)
    }), y ? null : K.jsx(so.div, {...T, ref: o})
});
fD.displayName = dD;
var N2 = "PopperContent", [Jj, eV] = cD(N2), pD = Ce.forwardRef((r, l) => {
    var Ii, Bn, ar, An, Zr, wo;
    const {
            __scopePopper: p,
            side: y = "bottom",
            sideOffset: T = 0,
            align: A = "center",
            alignOffset: D = 0,
            arrowPadding: o = 0,
            avoidCollisions: j = !0,
            collisionBoundary: q = [],
            collisionPadding: ee = 0,
            sticky: oe = "partial",
            hideWhenDetached: de = !1,
            updatePositionStrategy: ae = "optimized",
            onPlaced: Re,
            ...fe
        } = r, Me = hD(N2, p), [pe, le] = Ce.useState(null), be = Ws(l, Do => le(Do)), [Ue, et] = Ce.useState(null),
        _t = Qj(Ue), xt = (_t == null ? void 0 : _t.width) ?? 0, Mt = (_t == null ? void 0 : _t.height) ?? 0,
        Xt = y + (A !== "center" ? "-" + A : ""),
        Zt = typeof ee == "number" ? ee : {top: 0, right: 0, bottom: 0, left: 0, ...ee},
        Ht = Array.isArray(q) ? q : [q], hi = Ht.length > 0,
        Mi = {padding: Zt, boundary: Ht.filter(iV), altBoundary: hi}, {
            refs: $t,
            floatingStyles: _i,
            placement: si,
            isPositioned: Ri,
            middlewareData: Ct
        } = Vj({
            strategy: "fixed",
            placement: Xt,
            whileElementsMounted: (...Do) => Rj(...Do, {animationFrame: ae === "always"}),
            elements: {reference: Me.anchor},
            middleware: [Gj({mainAxis: T + Mt, alignmentAxis: D}), j && $j({
                mainAxis: !0,
                crossAxis: !1,
                limiter: oe === "partial" ? Hj() : void 0, ...Mi
            }), j && qj({...Mi}), Wj({
                ...Mi,
                apply: ({elements: Do, rects: Xr, availableWidth: Nn, availableHeight: Ar}) => {
                    const {width: fs, height: Rs} = Xr.reference, lo = Do.floating.style;
                    lo.setProperty("--radix-popper-available-width", `${Nn}px`), lo.setProperty("--radix-popper-available-height", `${Ar}px`), lo.setProperty("--radix-popper-anchor-width", `${fs}px`), lo.setProperty("--radix-popper-anchor-height", `${Rs}px`)
                }
            }), Ue && Xj({element: Ue, padding: o}), nV({
                arrowWidth: xt,
                arrowHeight: Mt
            }), de && Zj({strategy: "referenceHidden", ...Mi})]
        }), [Rt, ni] = _D(si), ai = ku(Re);
    Il(() => {
        Ri && (ai == null || ai())
    }, [Ri, ai]);
    const fi = (Ii = Ct.arrow) == null ? void 0 : Ii.x, nn = (Bn = Ct.arrow) == null ? void 0 : Bn.y,
        cn = ((ar = Ct.arrow) == null ? void 0 : ar.centerOffset) !== 0, [Zn, Bi] = Ce.useState();
    return Il(() => {
        pe && Bi(window.getComputedStyle(pe).zIndex)
    }, [pe]), K.jsx("div", {
        ref: $t.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
            ..._i,
            transform: Ri ? _i.transform : "translate(0, -200%)",
            minWidth: "max-content",
            zIndex: Zn,
            "--radix-popper-transform-origin": [(An = Ct.transformOrigin) == null ? void 0 : An.x, (Zr = Ct.transformOrigin) == null ? void 0 : Zr.y].join(" "), ...((wo = Ct.hide) == null ? void 0 : wo.referenceHidden) && {
                visibility: "hidden",
                pointerEvents: "none"
            }
        },
        dir: r.dir,
        children: K.jsx(Jj, {
            scope: p,
            placedSide: Rt,
            onArrowChange: et,
            arrowX: fi,
            arrowY: nn,
            shouldHideArrow: cn,
            children: K.jsx(so.div, {
                "data-side": Rt,
                "data-align": ni, ...fe,
                ref: be,
                style: {...fe.style, animation: Ri ? void 0 : "none"}
            })
        })
    })
});
pD.displayName = N2;
var mD = "PopperArrow", tV = {top: "bottom", right: "left", bottom: "top", left: "right"},
    gD = Ce.forwardRef(function (l, p) {
        const {__scopePopper: y, ...T} = l, A = eV(mD, y), D = tV[A.placedSide];
        return K.jsx("span", {
            ref: A.onArrowChange,
            style: {
                position: "absolute",
                left: A.arrowX,
                top: A.arrowY,
                [D]: 0,
                transformOrigin: {top: "", right: "0 0", bottom: "center 0", left: "100% 0"}[A.placedSide],
                transform: {
                    top: "translateY(100%)",
                    right: "translateY(50%) rotate(90deg) translateX(-50%)",
                    bottom: "rotate(180deg)",
                    left: "translateY(50%) rotate(-90deg) translateX(50%)"
                }[A.placedSide],
                visibility: A.shouldHideArrow ? "hidden" : void 0
            },
            children: K.jsx(Kj, {...T, ref: p, style: {...T.style, display: "block"}})
        })
    });
gD.displayName = mD;

function iV(r) {
    return r !== null
}

var nV = r => ({
    name: "transformOrigin", options: r, fn(l) {
        var Me, pe, le;
        const {placement: p, rects: y, middlewareData: T} = l,
            D = ((Me = T.arrow) == null ? void 0 : Me.centerOffset) !== 0, o = D ? 0 : r.arrowWidth,
            j = D ? 0 : r.arrowHeight, [q, ee] = _D(p), oe = {start: "0%", center: "50%", end: "100%"}[ee],
            de = (((pe = T.arrow) == null ? void 0 : pe.x) ?? 0) + o / 2,
            ae = (((le = T.arrow) == null ? void 0 : le.y) ?? 0) + j / 2;
        let Re = "", fe = "";
        return q === "bottom" ? (Re = D ? oe : `${de}px`, fe = `${-j}px`) : q === "top" ? (Re = D ? oe : `${de}px`, fe = `${y.floating.height + j}px`) : q === "right" ? (Re = `${-j}px`, fe = D ? oe : `${ae}px`) : q === "left" && (Re = `${y.floating.width + j}px`, fe = D ? oe : `${ae}px`), {
            data: {
                x: Re,
                y: fe
            }
        }
    }
});

function _D(r) {
    const [l, p = "center"] = r.split("-");
    return [l, p]
}

var rV = fD, oV = pD, sV = gD, [Cx, p8] = Tp("Tooltip", [uD]), j2 = uD(), yD = "TooltipProvider", aV = 700,
    yP = "tooltip.open", [lV, vD] = Cx(yD), xD = r => {
        const {
            __scopeTooltip: l,
            delayDuration: p = aV,
            skipDelayDuration: y = 300,
            disableHoverableContent: T = !1,
            children: A
        } = r, D = Ce.useRef(!0), o = Ce.useRef(!1), j = Ce.useRef(0);
        return Ce.useEffect(() => {
            const q = j.current;
            return () => window.clearTimeout(q)
        }, []), K.jsx(lV, {
            scope: l, isOpenDelayedRef: D, delayDuration: p, onOpen: Ce.useCallback(() => {
                window.clearTimeout(j.current), D.current = !1
            }, []), onClose: Ce.useCallback(() => {
                window.clearTimeout(j.current), j.current = window.setTimeout(() => D.current = !0, y)
            }, [y]), isPointerInTransitRef: o, onPointerInTransitChange: Ce.useCallback(q => {
                o.current = q
            }, []), disableHoverableContent: T, children: A
        })
    };
xD.displayName = yD;
var wD = "Tooltip", [m8, Px] = Cx(wD), wT = "TooltipTrigger", cV = Ce.forwardRef((r, l) => {
    const {__scopeTooltip: p, ...y} = r, T = Px(wT, p), A = vD(wT, p), D = j2(p), o = Ce.useRef(null),
        j = Ws(l, o, T.onTriggerChange), q = Ce.useRef(!1), ee = Ce.useRef(!1),
        oe = Ce.useCallback(() => q.current = !1, []);
    return Ce.useEffect(() => () => document.removeEventListener("pointerup", oe), [oe]), K.jsx(rV, {
        asChild: !0, ...D,
        children: K.jsx(so.button, {
            "aria-describedby": T.open ? T.contentId : void 0,
            "data-state": T.stateAttribute, ...y,
            ref: j,
            onPointerMove: Vr(r.onPointerMove, de => {
                de.pointerType !== "touch" && !ee.current && !A.isPointerInTransitRef.current && (T.onTriggerEnter(), ee.current = !0)
            }),
            onPointerLeave: Vr(r.onPointerLeave, () => {
                T.onTriggerLeave(), ee.current = !1
            }),
            onPointerDown: Vr(r.onPointerDown, () => {
                T.open && T.onClose(), q.current = !0, document.addEventListener("pointerup", oe, {once: !0})
            }),
            onFocus: Vr(r.onFocus, () => {
                q.current || T.onOpen()
            }),
            onBlur: Vr(r.onBlur, T.onClose),
            onClick: Vr(r.onClick, T.onClose)
        })
    })
});
cV.displayName = wT;
var uV = "TooltipPortal", [g8, hV] = Cx(uV, {forceMount: void 0}), gp = "TooltipContent", bD = Ce.forwardRef((r, l) => {
    const p = hV(gp, r.__scopeTooltip), {forceMount: y = p.forceMount, side: T = "top", ...A} = r,
        D = Px(gp, r.__scopeTooltip);
    return K.jsx(wx, {
        present: y || D.open,
        children: D.disableHoverableContent ? K.jsx(TD, {side: T, ...A, ref: l}) : K.jsx(dV, {side: T, ...A, ref: l})
    })
}), dV = Ce.forwardRef((r, l) => {
    const p = Px(gp, r.__scopeTooltip), y = vD(gp, r.__scopeTooltip), T = Ce.useRef(null),
        A = Ws(l, T), [D, o] = Ce.useState(null), {trigger: j, onClose: q} = p,
        ee = T.current, {onPointerInTransitChange: oe} = y, de = Ce.useCallback(() => {
            o(null), oe(!1)
        }, [oe]), ae = Ce.useCallback((Re, fe) => {
            const Me = Re.currentTarget, pe = {x: Re.clientX, y: Re.clientY}, le = _V(pe, Me.getBoundingClientRect()),
                be = yV(pe, le), Ue = vV(fe.getBoundingClientRect()), et = wV([...be, ...Ue]);
            o(et), oe(!0)
        }, [oe]);
    return Ce.useEffect(() => () => de(), [de]), Ce.useEffect(() => {
        if (j && ee) {
            const Re = Me => ae(Me, ee), fe = Me => ae(Me, j);
            return j.addEventListener("pointerleave", Re), ee.addEventListener("pointerleave", fe), () => {
                j.removeEventListener("pointerleave", Re), ee.removeEventListener("pointerleave", fe)
            }
        }
    }, [j, ee, ae, de]), Ce.useEffect(() => {
        if (D) {
            const Re = fe => {
                const Me = fe.target, pe = {x: fe.clientX, y: fe.clientY},
                    le = (j == null ? void 0 : j.contains(Me)) || (ee == null ? void 0 : ee.contains(Me)),
                    be = !xV(pe, D);
                le ? de() : be && (de(), q())
            };
            return document.addEventListener("pointermove", Re), () => document.removeEventListener("pointermove", Re)
        }
    }, [j, ee, D, q, de]), K.jsx(TD, {...r, ref: A})
}), [fV, pV] = Cx(wD, {isInside: !1}), mV = PN("TooltipContent"), TD = Ce.forwardRef((r, l) => {
    const {__scopeTooltip: p, children: y, "aria-label": T, onEscapeKeyDown: A, onPointerDownOutside: D, ...o} = r,
        j = Px(gp, p), q = j2(p), {onClose: ee} = j;
    return Ce.useEffect(() => (document.addEventListener(yP, ee), () => document.removeEventListener(yP, ee)), [ee]), Ce.useEffect(() => {
        if (j.trigger) {
            const oe = de => {
                const ae = de.target;
                ae != null && ae.contains(j.trigger) && ee()
            };
            return window.addEventListener("scroll", oe, {capture: !0}), () => window.removeEventListener("scroll", oe, {capture: !0})
        }
    }, [j.trigger, ee]), K.jsx(I2, {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: A,
        onPointerDownOutside: D,
        onFocusOutside: oe => oe.preventDefault(),
        onDismiss: ee,
        children: K.jsxs(oV, {
            "data-state": j.stateAttribute, ...q, ...o,
            ref: l,
            style: {
                ...o.style,
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [K.jsx(mV, {children: y}), K.jsx(fV, {
                scope: p,
                isInside: !0,
                children: K.jsx(QN, {id: j.contentId, role: "tooltip", children: T || y})
            })]
        })
    })
});
bD.displayName = gp;
var SD = "TooltipArrow", gV = Ce.forwardRef((r, l) => {
    const {__scopeTooltip: p, ...y} = r, T = j2(p);
    return pV(SD, p).isInside ? null : K.jsx(sV, {...T, ...y, ref: l})
});
gV.displayName = SD;

function _V(r, l) {
    const p = Math.abs(l.top - r.y), y = Math.abs(l.bottom - r.y), T = Math.abs(l.right - r.x),
        A = Math.abs(l.left - r.x);
    switch (Math.min(p, y, T, A)) {
        case A:
            return "left";
        case T:
            return "right";
        case p:
            return "top";
        case y:
            return "bottom";
        default:
            throw new Error("unreachable")
    }
}

function yV(r, l, p = 5) {
    const y = [];
    switch (l) {
        case"top":
            y.push({x: r.x - p, y: r.y + p}, {x: r.x + p, y: r.y + p});
            break;
        case"bottom":
            y.push({x: r.x - p, y: r.y - p}, {x: r.x + p, y: r.y - p});
            break;
        case"left":
            y.push({x: r.x + p, y: r.y - p}, {x: r.x + p, y: r.y + p});
            break;
        case"right":
            y.push({x: r.x - p, y: r.y - p}, {x: r.x - p, y: r.y + p});
            break
    }
    return y
}

function vV(r) {
    const {top: l, right: p, bottom: y, left: T} = r;
    return [{x: T, y: l}, {x: p, y: l}, {x: p, y}, {x: T, y}]
}

function xV(r, l) {
    const {x: p, y} = r;
    let T = !1;
    for (let A = 0, D = l.length - 1; A < l.length; D = A++) {
        const o = l[A], j = l[D], q = o.x, ee = o.y, oe = j.x, de = j.y;
        ee > y != de > y && p < (oe - q) * (y - ee) / (de - ee) + q && (T = !T)
    }
    return T
}

function wV(r) {
    const l = r.slice();
    return l.sort((p, y) => p.x < y.x ? -1 : p.x > y.x ? 1 : p.y < y.y ? -1 : p.y > y.y ? 1 : 0), bV(l)
}

function bV(r) {
    if (r.length <= 1) return r.slice();
    const l = [];
    for (let y = 0; y < r.length; y++) {
        const T = r[y];
        for (; l.length >= 2;) {
            const A = l[l.length - 1], D = l[l.length - 2];
            if ((A.x - D.x) * (T.y - D.y) >= (A.y - D.y) * (T.x - D.x)) l.pop(); else break
        }
        l.push(T)
    }
    l.pop();
    const p = [];
    for (let y = r.length - 1; y >= 0; y--) {
        const T = r[y];
        for (; p.length >= 2;) {
            const A = p[p.length - 1], D = p[p.length - 2];
            if ((A.x - D.x) * (T.y - D.y) >= (A.y - D.y) * (T.x - D.x)) p.pop(); else break
        }
        p.push(T)
    }
    return p.pop(), l.length === 1 && p.length === 1 && l[0].x === p[0].x && l[0].y === p[0].y ? l : l.concat(p)
}

var TV = xD, ED = bD;
const SV = TV, EV = Ce.forwardRef(({className: r, sideOffset: l = 4, ...p}, y) => K.jsx(ED, {
    ref: y,
    sideOffset: l,
    className: ao("z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", r), ...p
}));
EV.displayName = ED.displayName;
var Mx = class {
    constructor() {
        this.listeners = new Set, this.subscribe = this.subscribe.bind(this)
    }

    subscribe(r) {
        return this.listeners.add(r), this.onSubscribe(), () => {
            this.listeners.delete(r), this.onUnsubscribe()
        }
    }

    hasListeners() {
        return this.listeners.size > 0
    }

    onSubscribe() {
    }

    onUnsubscribe() {
    }
}, Rx = typeof window > "u" || "Deno" in globalThis;

function Pa() {
}

function AV(r, l) {
    return typeof r == "function" ? r(l) : r
}

function IV(r) {
    return typeof r == "number" && r >= 0 && r !== 1 / 0
}

function CV(r, l) {
    return Math.max(r + (l || 0) - Date.now(), 0)
}

function bT(r, l) {
    return typeof r == "function" ? r(l) : r
}

function PV(r, l) {
    return typeof r == "function" ? r(l) : r
}

function vP(r, l) {
    const {type: p = "all", exact: y, fetchStatus: T, predicate: A, queryKey: D, stale: o} = r;
    if (D) {
        if (y) {
            if (l.queryHash !== V2(D, l.options)) return !1
        } else if (!x_(l.queryKey, D)) return !1
    }
    if (p !== "all") {
        const j = l.isActive();
        if (p === "active" && !j || p === "inactive" && j) return !1
    }
    return !(typeof o == "boolean" && l.isStale() !== o || T && T !== l.state.fetchStatus || A && !A(l))
}

function xP(r, l) {
    const {exact: p, status: y, predicate: T, mutationKey: A} = r;
    if (A) {
        if (!l.options.mutationKey) return !1;
        if (p) {
            if (v_(l.options.mutationKey) !== v_(A)) return !1
        } else if (!x_(l.options.mutationKey, A)) return !1
    }
    return !(y && l.state.status !== y || T && !T(l))
}

function V2(r, l) {
    return ((l == null ? void 0 : l.queryKeyHashFn) || v_)(r)
}

function v_(r) {
    return JSON.stringify(r, (l, p) => TT(p) ? Object.keys(p).sort().reduce((y, T) => (y[T] = p[T], y), {}) : p)
}

function x_(r, l) {
    return r === l ? !0 : typeof r != typeof l ? !1 : r && l && typeof r == "object" && typeof l == "object" ? Object.keys(l).every(p => x_(r[p], l[p])) : !1
}

function AD(r, l) {
    if (r === l) return r;
    const p = wP(r) && wP(l);
    if (p || TT(r) && TT(l)) {
        const y = p ? r : Object.keys(r), T = y.length, A = p ? l : Object.keys(l), D = A.length, o = p ? [] : {},
            j = new Set(y);
        let q = 0;
        for (let ee = 0; ee < D; ee++) {
            const oe = p ? ee : A[ee];
            (!p && j.has(oe) || p) && r[oe] === void 0 && l[oe] === void 0 ? (o[oe] = void 0, q++) : (o[oe] = AD(r[oe], l[oe]), o[oe] === r[oe] && r[oe] !== void 0 && q++)
        }
        return T === D && q === T ? r : o
    }
    return l
}

function wP(r) {
    return Array.isArray(r) && r.length === Object.keys(r).length
}

function TT(r) {
    if (!bP(r)) return !1;
    const l = r.constructor;
    if (l === void 0) return !0;
    const p = l.prototype;
    return !(!bP(p) || !p.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(r) !== Object.prototype)
}

function bP(r) {
    return Object.prototype.toString.call(r) === "[object Object]"
}

function MV(r) {
    return new Promise(l => {
        setTimeout(l, r)
    })
}

function RV(r, l, p) {
    return typeof p.structuralSharing == "function" ? p.structuralSharing(r, l) : p.structuralSharing !== !1 ? AD(r, l) : l
}

function zV(r, l, p = 0) {
    const y = [...r, l];
    return p && y.length > p ? y.slice(1) : y
}

function DV(r, l, p = 0) {
    const y = [l, ...r];
    return p && y.length > p ? y.slice(0, -1) : y
}

var U2 = Symbol();

function ID(r, l) {
    return !r.queryFn && (l != null && l.initialPromise) ? () => l.initialPromise : !r.queryFn || r.queryFn === U2 ? () => Promise.reject(new Error(`Missing queryFn: '${r.queryHash}'`)) : r.queryFn
}

var Hh, gu, ep, OP, LV = (OP = class extends Mx {
    constructor() {
        super();
        Wn(this, Hh);
        Wn(this, gu);
        Wn(this, ep);
        fn(this, ep, l => {
            if (!Rx && window.addEventListener) {
                const p = () => l();
                return window.addEventListener("visibilitychange", p, !1), () => {
                    window.removeEventListener("visibilitychange", p)
                }
            }
        })
    }

    onSubscribe() {
        Dt(this, gu) || this.setEventListener(Dt(this, ep))
    }

    onUnsubscribe() {
        var l;
        this.hasListeners() || ((l = Dt(this, gu)) == null || l.call(this), fn(this, gu, void 0))
    }

    setEventListener(l) {
        var p;
        fn(this, ep, l), (p = Dt(this, gu)) == null || p.call(this), fn(this, gu, l(y => {
            typeof y == "boolean" ? this.setFocused(y) : this.onFocus()
        }))
    }

    setFocused(l) {
        Dt(this, Hh) !== l && (fn(this, Hh, l), this.onFocus())
    }

    onFocus() {
        const l = this.isFocused();
        this.listeners.forEach(p => {
            p(l)
        })
    }

    isFocused() {
        var l;
        return typeof Dt(this, Hh) == "boolean" ? Dt(this, Hh) : ((l = globalThis.document) == null ? void 0 : l.visibilityState) !== "hidden"
    }
}, Hh = new WeakMap, gu = new WeakMap, ep = new WeakMap, OP), CD = new LV, tp, _u, ip, FP, kV = (FP = class extends Mx {
    constructor() {
        super();
        Wn(this, tp, !0);
        Wn(this, _u);
        Wn(this, ip);
        fn(this, ip, l => {
            if (!Rx && window.addEventListener) {
                const p = () => l(!0), y = () => l(!1);
                return window.addEventListener("online", p, !1), window.addEventListener("offline", y, !1), () => {
                    window.removeEventListener("online", p), window.removeEventListener("offline", y)
                }
            }
        })
    }

    onSubscribe() {
        Dt(this, _u) || this.setEventListener(Dt(this, ip))
    }

    onUnsubscribe() {
        var l;
        this.hasListeners() || ((l = Dt(this, _u)) == null || l.call(this), fn(this, _u, void 0))
    }

    setEventListener(l) {
        var p;
        fn(this, ip, l), (p = Dt(this, _u)) == null || p.call(this), fn(this, _u, l(this.setOnline.bind(this)))
    }

    setOnline(l) {
        Dt(this, tp) !== l && (fn(this, tp, l), this.listeners.forEach(y => {
            y(l)
        }))
    }

    isOnline() {
        return Dt(this, tp)
    }
}, tp = new WeakMap, _u = new WeakMap, ip = new WeakMap, FP), Jv = new kV;

function OV() {
    let r, l;
    const p = new Promise((T, A) => {
        r = T, l = A
    });
    p.status = "pending", p.catch(() => {
    });

    function y(T) {
        Object.assign(p, T), delete p.resolve, delete p.reject
    }

    return p.resolve = T => {
        y({status: "fulfilled", value: T}), r(T)
    }, p.reject = T => {
        y({status: "rejected", reason: T}), l(T)
    }, p
}

function FV(r) {
    return Math.min(1e3 * 2 ** r, 3e4)
}

function PD(r) {
    return (r ?? "online") === "online" ? Jv.isOnline() : !0
}

var MD = class extends Error {
    constructor(r) {
        super("CancelledError"), this.revert = r == null ? void 0 : r.revert, this.silent = r == null ? void 0 : r.silent
    }
};

function fb(r) {
    return r instanceof MD
}

function RD(r) {
    let l = !1, p = 0, y = !1, T;
    const A = OV(), D = fe => {
            var Me;
            y || (de(new MD(fe)), (Me = r.abort) == null || Me.call(r))
        }, o = () => {
            l = !0
        }, j = () => {
            l = !1
        }, q = () => CD.isFocused() && (r.networkMode === "always" || Jv.isOnline()) && r.canRun(),
        ee = () => PD(r.networkMode) && r.canRun(), oe = fe => {
            var Me;
            y || (y = !0, (Me = r.onSuccess) == null || Me.call(r, fe), T == null || T(), A.resolve(fe))
        }, de = fe => {
            var Me;
            y || (y = !0, (Me = r.onError) == null || Me.call(r, fe), T == null || T(), A.reject(fe))
        }, ae = () => new Promise(fe => {
            var Me;
            T = pe => {
                (y || q()) && fe(pe)
            }, (Me = r.onPause) == null || Me.call(r)
        }).then(() => {
            var fe;
            T = void 0, y || (fe = r.onContinue) == null || fe.call(r)
        }), Re = () => {
            if (y) return;
            let fe;
            const Me = p === 0 ? r.initialPromise : void 0;
            try {
                fe = Me ?? r.fn()
            } catch (pe) {
                fe = Promise.reject(pe)
            }
            Promise.resolve(fe).then(oe).catch(pe => {
                var _t;
                if (y) return;
                const le = r.retry ?? (Rx ? 0 : 3), be = r.retryDelay ?? FV, Ue = typeof be == "function" ? be(p, pe) : be,
                    et = le === !0 || typeof le == "number" && p < le || typeof le == "function" && le(p, pe);
                if (l || !et) {
                    de(pe);
                    return
                }
                p++, (_t = r.onFail) == null || _t.call(r, p, pe), MV(Ue).then(() => q() ? void 0 : ae()).then(() => {
                    l ? de(pe) : Re()
                })
            })
        };
    return {
        promise: A,
        cancel: D,
        continue: () => (T == null || T(), A),
        cancelRetry: o,
        continueRetry: j,
        canStart: ee,
        start: () => (ee() ? Re() : ae().then(Re), A)
    }
}

var BV = r => setTimeout(r, 0);

function NV() {
    let r = [], l = 0, p = o => {
        o()
    }, y = o => {
        o()
    }, T = BV;
    const A = o => {
        l ? r.push(o) : T(() => {
            p(o)
        })
    }, D = () => {
        const o = r;
        r = [], o.length && T(() => {
            y(() => {
                o.forEach(j => {
                    p(j)
                })
            })
        })
    };
    return {
        batch: o => {
            let j;
            l++;
            try {
                j = o()
            } finally {
                l--, l || D()
            }
            return j
        }, batchCalls: o => (...j) => {
            A(() => {
                o(...j)
            })
        }, schedule: A, setNotifyFunction: o => {
            p = o
        }, setBatchNotifyFunction: o => {
            y = o
        }, setScheduler: o => {
            T = o
        }
    }
}

var cs = NV(), qh, BP, zD = (BP = class {
    constructor() {
        Wn(this, qh)
    }

    destroy() {
        this.clearGcTimeout()
    }

    scheduleGc() {
        this.clearGcTimeout(), IV(this.gcTime) && fn(this, qh, setTimeout(() => {
            this.optionalRemove()
        }, this.gcTime))
    }

    updateGcTime(r) {
        this.gcTime = Math.max(this.gcTime || 0, r ?? (Rx ? 1 / 0 : 5 * 60 * 1e3))
    }

    clearGcTimeout() {
        Dt(this, qh) && (clearTimeout(Dt(this, qh)), fn(this, qh, void 0))
    }
}, qh = new WeakMap, BP), np, Wh, oa, Zh, Go, T_, Xh, Ma, ic, NP, jV = (NP = class extends zD {
    constructor(l) {
        super();
        Wn(this, Ma);
        Wn(this, np);
        Wn(this, Wh);
        Wn(this, oa);
        Wn(this, Zh);
        Wn(this, Go);
        Wn(this, T_);
        Wn(this, Xh);
        fn(this, Xh, !1), fn(this, T_, l.defaultOptions), this.setOptions(l.options), this.observers = [], fn(this, Zh, l.client), fn(this, oa, Dt(this, Zh).getQueryCache()), this.queryKey = l.queryKey, this.queryHash = l.queryHash, fn(this, np, UV(this.options)), this.state = l.state ?? Dt(this, np), this.scheduleGc()
    }

    get meta() {
        return this.options.meta
    }

    get promise() {
        var l;
        return (l = Dt(this, Go)) == null ? void 0 : l.promise
    }

    setOptions(l) {
        this.options = {...Dt(this, T_), ...l}, this.updateGcTime(this.options.gcTime)
    }

    optionalRemove() {
        !this.observers.length && this.state.fetchStatus === "idle" && Dt(this, oa).remove(this)
    }

    setData(l, p) {
        const y = RV(this.state.data, l, this.options);
        return jo(this, Ma, ic).call(this, {
            data: y,
            type: "success",
            dataUpdatedAt: p == null ? void 0 : p.updatedAt,
            manual: p == null ? void 0 : p.manual
        }), y
    }

    setState(l, p) {
        jo(this, Ma, ic).call(this, {type: "setState", state: l, setStateOptions: p})
    }

    cancel(l) {
        var y, T;
        const p = (y = Dt(this, Go)) == null ? void 0 : y.promise;
        return (T = Dt(this, Go)) == null || T.cancel(l), p ? p.then(Pa).catch(Pa) : Promise.resolve()
    }

    destroy() {
        super.destroy(), this.cancel({silent: !0})
    }

    reset() {
        this.destroy(), this.setState(Dt(this, np))
    }

    isActive() {
        return this.observers.some(l => PV(l.options.enabled, this) !== !1)
    }

    isDisabled() {
        return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === U2 || this.state.dataUpdateCount + this.state.errorUpdateCount === 0
    }

    isStatic() {
        return this.getObserversCount() > 0 ? this.observers.some(l => bT(l.options.staleTime, this) === "static") : !1
    }

    isStale() {
        return this.getObserversCount() > 0 ? this.observers.some(l => l.getCurrentResult().isStale) : this.state.data === void 0 || this.state.isInvalidated
    }

    isStaleByTime(l = 0) {
        return this.state.data === void 0 ? !0 : l === "static" ? !1 : this.state.isInvalidated ? !0 : !CV(this.state.dataUpdatedAt, l)
    }

    onFocus() {
        var p;
        const l = this.observers.find(y => y.shouldFetchOnWindowFocus());
        l == null || l.refetch({cancelRefetch: !1}), (p = Dt(this, Go)) == null || p.continue()
    }

    onOnline() {
        var p;
        const l = this.observers.find(y => y.shouldFetchOnReconnect());
        l == null || l.refetch({cancelRefetch: !1}), (p = Dt(this, Go)) == null || p.continue()
    }

    addObserver(l) {
        this.observers.includes(l) || (this.observers.push(l), this.clearGcTimeout(), Dt(this, oa).notify({
            type: "observerAdded",
            query: this,
            observer: l
        }))
    }

    removeObserver(l) {
        this.observers.includes(l) && (this.observers = this.observers.filter(p => p !== l), this.observers.length || (Dt(this, Go) && (Dt(this, Xh) ? Dt(this, Go).cancel({revert: !0}) : Dt(this, Go).cancelRetry()), this.scheduleGc()), Dt(this, oa).notify({
            type: "observerRemoved",
            query: this,
            observer: l
        }))
    }

    getObserversCount() {
        return this.observers.length
    }

    invalidate() {
        this.state.isInvalidated || jo(this, Ma, ic).call(this, {type: "invalidate"})
    }

    fetch(l, p) {
        var q, ee, oe;
        if (this.state.fetchStatus !== "idle") {
            if (this.state.data !== void 0 && (p != null && p.cancelRefetch)) this.cancel({silent: !0}); else if (Dt(this, Go)) return Dt(this, Go).continueRetry(), Dt(this, Go).promise
        }
        if (l && this.setOptions(l), !this.options.queryFn) {
            const de = this.observers.find(ae => ae.options.queryFn);
            de && this.setOptions(de.options)
        }
        const y = new AbortController, T = de => {
            Object.defineProperty(de, "signal", {enumerable: !0, get: () => (fn(this, Xh, !0), y.signal)})
        }, A = () => {
            const de = ID(this.options, p), Re = (() => {
                const fe = {client: Dt(this, Zh), queryKey: this.queryKey, meta: this.meta};
                return T(fe), fe
            })();
            return fn(this, Xh, !1), this.options.persister ? this.options.persister(de, Re, this) : de(Re)
        }, o = (() => {
            const de = {
                fetchOptions: p,
                options: this.options,
                queryKey: this.queryKey,
                client: Dt(this, Zh),
                state: this.state,
                fetchFn: A
            };
            return T(de), de
        })();
        (q = this.options.behavior) == null || q.onFetch(o, this), fn(this, Wh, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((ee = o.fetchOptions) == null ? void 0 : ee.meta)) && jo(this, Ma, ic).call(this, {
            type: "fetch",
            meta: (oe = o.fetchOptions) == null ? void 0 : oe.meta
        });
        const j = de => {
            var ae, Re, fe, Me;
            fb(de) && de.silent || jo(this, Ma, ic).call(this, {
                type: "error",
                error: de
            }), fb(de) || ((Re = (ae = Dt(this, oa).config).onError) == null || Re.call(ae, de, this), (Me = (fe = Dt(this, oa).config).onSettled) == null || Me.call(fe, this.state.data, de, this)), this.scheduleGc()
        };
        return fn(this, Go, RD({
            initialPromise: p == null ? void 0 : p.initialPromise,
            fn: o.fetchFn,
            abort: y.abort.bind(y),
            onSuccess: de => {
                var ae, Re, fe, Me;
                if (de === void 0) {
                    j(new Error(`${this.queryHash} data is undefined`));
                    return
                }
                try {
                    this.setData(de)
                } catch (pe) {
                    j(pe);
                    return
                }
                (Re = (ae = Dt(this, oa).config).onSuccess) == null || Re.call(ae, de, this), (Me = (fe = Dt(this, oa).config).onSettled) == null || Me.call(fe, de, this.state.error, this), this.scheduleGc()
            },
            onError: j,
            onFail: (de, ae) => {
                jo(this, Ma, ic).call(this, {type: "failed", failureCount: de, error: ae})
            },
            onPause: () => {
                jo(this, Ma, ic).call(this, {type: "pause"})
            },
            onContinue: () => {
                jo(this, Ma, ic).call(this, {type: "continue"})
            },
            retry: o.options.retry,
            retryDelay: o.options.retryDelay,
            networkMode: o.options.networkMode,
            canRun: () => !0
        })), Dt(this, Go).start()
    }
}, np = new WeakMap, Wh = new WeakMap, oa = new WeakMap, Zh = new WeakMap, Go = new WeakMap, T_ = new WeakMap, Xh = new WeakMap, Ma = new WeakSet, ic = function (l) {
    const p = y => {
        switch (l.type) {
            case"failed":
                return {...y, fetchFailureCount: l.failureCount, fetchFailureReason: l.error};
            case"pause":
                return {...y, fetchStatus: "paused"};
            case"continue":
                return {...y, fetchStatus: "fetching"};
            case"fetch":
                return {...y, ...VV(y.data, this.options), fetchMeta: l.meta ?? null};
            case"success":
                return fn(this, Wh, void 0), {
                    ...y,
                    data: l.data,
                    dataUpdateCount: y.dataUpdateCount + 1,
                    dataUpdatedAt: l.dataUpdatedAt ?? Date.now(),
                    error: null,
                    isInvalidated: !1,
                    status: "success", ...!l.manual && {
                        fetchStatus: "idle",
                        fetchFailureCount: 0,
                        fetchFailureReason: null
                    }
                };
            case"error":
                const T = l.error;
                return fb(T) && T.revert && Dt(this, Wh) ? {...Dt(this, Wh), fetchStatus: "idle"} : {
                    ...y,
                    error: T,
                    errorUpdateCount: y.errorUpdateCount + 1,
                    errorUpdatedAt: Date.now(),
                    fetchFailureCount: y.fetchFailureCount + 1,
                    fetchFailureReason: T,
                    fetchStatus: "idle",
                    status: "error"
                };
            case"invalidate":
                return {...y, isInvalidated: !0};
            case"setState":
                return {...y, ...l.state}
        }
    };
    this.state = p(this.state), cs.batch(() => {
        this.observers.forEach(y => {
            y.onQueryUpdate()
        }), Dt(this, oa).notify({query: this, type: "updated", action: l})
    })
}, NP);

function VV(r, l) {
    return {
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchStatus: PD(l.networkMode) ? "fetching" : "paused", ...r === void 0 && {error: null, status: "pending"}
    }
}

function UV(r) {
    const l = typeof r.initialData == "function" ? r.initialData() : r.initialData, p = l !== void 0,
        y = p ? typeof r.initialDataUpdatedAt == "function" ? r.initialDataUpdatedAt() : r.initialDataUpdatedAt : 0;
    return {
        data: l,
        dataUpdateCount: 0,
        dataUpdatedAt: p ? y ?? Date.now() : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: !1,
        status: p ? "success" : "pending",
        fetchStatus: "idle"
    }
}

var vl, jP, GV = (jP = class extends Mx {
    constructor(l = {}) {
        super();
        Wn(this, vl);
        this.config = l, fn(this, vl, new Map)
    }

    build(l, p, y) {
        const T = p.queryKey, A = p.queryHash ?? V2(T, p);
        let D = this.get(A);
        return D || (D = new jV({
            client: l,
            queryKey: T,
            queryHash: A,
            options: l.defaultQueryOptions(p),
            state: y,
            defaultOptions: l.getQueryDefaults(T)
        }), this.add(D)), D
    }

    add(l) {
        Dt(this, vl).has(l.queryHash) || (Dt(this, vl).set(l.queryHash, l), this.notify({type: "added", query: l}))
    }

    remove(l) {
        const p = Dt(this, vl).get(l.queryHash);
        p && (l.destroy(), p === l && Dt(this, vl).delete(l.queryHash), this.notify({type: "removed", query: l}))
    }

    clear() {
        cs.batch(() => {
            this.getAll().forEach(l => {
                this.remove(l)
            })
        })
    }

    get(l) {
        return Dt(this, vl).get(l)
    }

    getAll() {
        return [...Dt(this, vl).values()]
    }

    find(l) {
        const p = {exact: !0, ...l};
        return this.getAll().find(y => vP(p, y))
    }

    findAll(l = {}) {
        const p = this.getAll();
        return Object.keys(l).length > 0 ? p.filter(y => vP(l, y)) : p
    }

    notify(l) {
        cs.batch(() => {
            this.listeners.forEach(p => {
                p(l)
            })
        })
    }

    onFocus() {
        cs.batch(() => {
            this.getAll().forEach(l => {
                l.onFocus()
            })
        })
    }

    onOnline() {
        cs.batch(() => {
            this.getAll().forEach(l => {
                l.onOnline()
            })
        })
    }
}, vl = new WeakMap, jP), xl, as, Yh, wl, hu, VP, $V = (VP = class extends zD {
    constructor(l) {
        super();
        Wn(this, wl);
        Wn(this, xl);
        Wn(this, as);
        Wn(this, Yh);
        this.mutationId = l.mutationId, fn(this, as, l.mutationCache), fn(this, xl, []), this.state = l.state || HV(), this.setOptions(l.options), this.scheduleGc()
    }

    setOptions(l) {
        this.options = l, this.updateGcTime(this.options.gcTime)
    }

    get meta() {
        return this.options.meta
    }

    addObserver(l) {
        Dt(this, xl).includes(l) || (Dt(this, xl).push(l), this.clearGcTimeout(), Dt(this, as).notify({
            type: "observerAdded",
            mutation: this,
            observer: l
        }))
    }

    removeObserver(l) {
        fn(this, xl, Dt(this, xl).filter(p => p !== l)), this.scheduleGc(), Dt(this, as).notify({
            type: "observerRemoved",
            mutation: this,
            observer: l
        })
    }

    optionalRemove() {
        Dt(this, xl).length || (this.state.status === "pending" ? this.scheduleGc() : Dt(this, as).remove(this))
    }

    continue() {
        var l;
        return ((l = Dt(this, Yh)) == null ? void 0 : l.continue()) ?? this.execute(this.state.variables)
    }

    async execute(l) {
        var A, D, o, j, q, ee, oe, de, ae, Re, fe, Me, pe, le, be, Ue, et, _t, xt, Mt;
        const p = () => {
            jo(this, wl, hu).call(this, {type: "continue"})
        };
        fn(this, Yh, RD({
            fn: () => this.options.mutationFn ? this.options.mutationFn(l) : Promise.reject(new Error("No mutationFn found")),
            onFail: (Xt, Zt) => {
                jo(this, wl, hu).call(this, {type: "failed", failureCount: Xt, error: Zt})
            },
            onPause: () => {
                jo(this, wl, hu).call(this, {type: "pause"})
            },
            onContinue: p,
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
            canRun: () => Dt(this, as).canRun(this)
        }));
        const y = this.state.status === "pending", T = !Dt(this, Yh).canStart();
        try {
            if (y) p(); else {
                jo(this, wl, hu).call(this, {
                    type: "pending",
                    variables: l,
                    isPaused: T
                }), await ((D = (A = Dt(this, as).config).onMutate) == null ? void 0 : D.call(A, l, this));
                const Zt = await ((j = (o = this.options).onMutate) == null ? void 0 : j.call(o, l));
                Zt !== this.state.context && jo(this, wl, hu).call(this, {
                    type: "pending",
                    context: Zt,
                    variables: l,
                    isPaused: T
                })
            }
            const Xt = await Dt(this, Yh).start();
            return await ((ee = (q = Dt(this, as).config).onSuccess) == null ? void 0 : ee.call(q, Xt, l, this.state.context, this)), await ((de = (oe = this.options).onSuccess) == null ? void 0 : de.call(oe, Xt, l, this.state.context)), await ((Re = (ae = Dt(this, as).config).onSettled) == null ? void 0 : Re.call(ae, Xt, null, this.state.variables, this.state.context, this)), await ((Me = (fe = this.options).onSettled) == null ? void 0 : Me.call(fe, Xt, null, l, this.state.context)), jo(this, wl, hu).call(this, {
                type: "success",
                data: Xt
            }), Xt
        } catch (Xt) {
            try {
                throw await ((le = (pe = Dt(this, as).config).onError) == null ? void 0 : le.call(pe, Xt, l, this.state.context, this)), await ((Ue = (be = this.options).onError) == null ? void 0 : Ue.call(be, Xt, l, this.state.context)), await ((_t = (et = Dt(this, as).config).onSettled) == null ? void 0 : _t.call(et, void 0, Xt, this.state.variables, this.state.context, this)), await ((Mt = (xt = this.options).onSettled) == null ? void 0 : Mt.call(xt, void 0, Xt, l, this.state.context)), Xt
            } finally {
                jo(this, wl, hu).call(this, {type: "error", error: Xt})
            }
        } finally {
            Dt(this, as).runNext(this)
        }
    }
}, xl = new WeakMap, as = new WeakMap, Yh = new WeakMap, wl = new WeakSet, hu = function (l) {
    const p = y => {
        switch (l.type) {
            case"failed":
                return {...y, failureCount: l.failureCount, failureReason: l.error};
            case"pause":
                return {...y, isPaused: !0};
            case"continue":
                return {...y, isPaused: !1};
            case"pending":
                return {
                    ...y,
                    context: l.context,
                    data: void 0,
                    failureCount: 0,
                    failureReason: null,
                    error: null,
                    isPaused: l.isPaused,
                    status: "pending",
                    variables: l.variables,
                    submittedAt: Date.now()
                };
            case"success":
                return {
                    ...y,
                    data: l.data,
                    failureCount: 0,
                    failureReason: null,
                    error: null,
                    status: "success",
                    isPaused: !1
                };
            case"error":
                return {
                    ...y,
                    data: void 0,
                    error: l.error,
                    failureCount: y.failureCount + 1,
                    failureReason: l.error,
                    isPaused: !1,
                    status: "error"
                }
        }
    };
    this.state = p(this.state), cs.batch(() => {
        Dt(this, xl).forEach(y => {
            y.onMutationUpdate(l)
        }), Dt(this, as).notify({mutation: this, type: "updated", action: l})
    })
}, VP);

function HV() {
    return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: !1,
        status: "idle",
        variables: void 0,
        submittedAt: 0
    }
}

var oc, Ra, S_, UP, qV = (UP = class extends Mx {
    constructor(l = {}) {
        super();
        Wn(this, oc);
        Wn(this, Ra);
        Wn(this, S_);
        this.config = l, fn(this, oc, new Set), fn(this, Ra, new Map), fn(this, S_, 0)
    }

    build(l, p, y) {
        const T = new $V({
            mutationCache: this,
            mutationId: ++D0(this, S_)._,
            options: l.defaultMutationOptions(p),
            state: y
        });
        return this.add(T), T
    }

    add(l) {
        Dt(this, oc).add(l);
        const p = tv(l);
        if (typeof p == "string") {
            const y = Dt(this, Ra).get(p);
            y ? y.push(l) : Dt(this, Ra).set(p, [l])
        }
        this.notify({type: "added", mutation: l})
    }

    remove(l) {
        if (Dt(this, oc).delete(l)) {
            const p = tv(l);
            if (typeof p == "string") {
                const y = Dt(this, Ra).get(p);
                if (y) if (y.length > 1) {
                    const T = y.indexOf(l);
                    T !== -1 && y.splice(T, 1)
                } else y[0] === l && Dt(this, Ra).delete(p)
            }
        }
        this.notify({type: "removed", mutation: l})
    }

    canRun(l) {
        const p = tv(l);
        if (typeof p == "string") {
            const y = Dt(this, Ra).get(p), T = y == null ? void 0 : y.find(A => A.state.status === "pending");
            return !T || T === l
        } else return !0
    }

    runNext(l) {
        var y;
        const p = tv(l);
        if (typeof p == "string") {
            const T = (y = Dt(this, Ra).get(p)) == null ? void 0 : y.find(A => A !== l && A.state.isPaused);
            return (T == null ? void 0 : T.continue()) ?? Promise.resolve()
        } else return Promise.resolve()
    }

    clear() {
        cs.batch(() => {
            Dt(this, oc).forEach(l => {
                this.notify({type: "removed", mutation: l})
            }), Dt(this, oc).clear(), Dt(this, Ra).clear()
        })
    }

    getAll() {
        return Array.from(Dt(this, oc))
    }

    find(l) {
        const p = {exact: !0, ...l};
        return this.getAll().find(y => xP(p, y))
    }

    findAll(l = {}) {
        return this.getAll().filter(p => xP(l, p))
    }

    notify(l) {
        cs.batch(() => {
            this.listeners.forEach(p => {
                p(l)
            })
        })
    }

    resumePausedMutations() {
        const l = this.getAll().filter(p => p.state.isPaused);
        return cs.batch(() => Promise.all(l.map(p => p.continue().catch(Pa))))
    }
}, oc = new WeakMap, Ra = new WeakMap, S_ = new WeakMap, UP);

function tv(r) {
    var l;
    return (l = r.options.scope) == null ? void 0 : l.id
}

function TP(r) {
    return {
        onFetch: (l, p) => {
            var ee, oe, de, ae, Re;
            const y = l.options,
                T = (de = (oe = (ee = l.fetchOptions) == null ? void 0 : ee.meta) == null ? void 0 : oe.fetchMore) == null ? void 0 : de.direction,
                A = ((ae = l.state.data) == null ? void 0 : ae.pages) || [],
                D = ((Re = l.state.data) == null ? void 0 : Re.pageParams) || [];
            let o = {pages: [], pageParams: []}, j = 0;
            const q = async () => {
                let fe = !1;
                const Me = be => {
                    Object.defineProperty(be, "signal", {
                        enumerable: !0,
                        get: () => (l.signal.aborted ? fe = !0 : l.signal.addEventListener("abort", () => {
                            fe = !0
                        }), l.signal)
                    })
                }, pe = ID(l.options, l.fetchOptions), le = async (be, Ue, et) => {
                    if (fe) return Promise.reject();
                    if (Ue == null && be.pages.length) return Promise.resolve(be);
                    const xt = (() => {
                        const Ht = {
                            client: l.client,
                            queryKey: l.queryKey,
                            pageParam: Ue,
                            direction: et ? "backward" : "forward",
                            meta: l.options.meta
                        };
                        return Me(Ht), Ht
                    })(), Mt = await pe(xt), {maxPages: Xt} = l.options, Zt = et ? DV : zV;
                    return {pages: Zt(be.pages, Mt, Xt), pageParams: Zt(be.pageParams, Ue, Xt)}
                };
                if (T && A.length) {
                    const be = T === "backward", Ue = be ? WV : SP, et = {pages: A, pageParams: D}, _t = Ue(y, et);
                    o = await le(et, _t, be)
                } else {
                    const be = r ?? A.length;
                    do {
                        const Ue = j === 0 ? D[0] ?? y.initialPageParam : SP(y, o);
                        if (j > 0 && Ue == null) break;
                        o = await le(o, Ue), j++
                    } while (j < be)
                }
                return o
            };
            l.options.persister ? l.fetchFn = () => {
                var fe, Me;
                return (Me = (fe = l.options).persister) == null ? void 0 : Me.call(fe, q, {
                    client: l.client,
                    queryKey: l.queryKey,
                    meta: l.options.meta,
                    signal: l.signal
                }, p)
            } : l.fetchFn = q
        }
    }
}

function SP(r, {pages: l, pageParams: p}) {
    const y = l.length - 1;
    return l.length > 0 ? r.getNextPageParam(l[y], l, p[y], p) : void 0
}

function WV(r, {pages: l, pageParams: p}) {
    var y;
    return l.length > 0 ? (y = r.getPreviousPageParam) == null ? void 0 : y.call(r, l[0], l, p[0], p) : void 0
}

var Lr, yu, vu, rp, op, xu, sp, ap, GP, ZV = (GP = class {
        constructor(r = {}) {
            Wn(this, Lr);
            Wn(this, yu);
            Wn(this, vu);
            Wn(this, rp);
            Wn(this, op);
            Wn(this, xu);
            Wn(this, sp);
            Wn(this, ap);
            fn(this, Lr, r.queryCache || new GV), fn(this, yu, r.mutationCache || new qV), fn(this, vu, r.defaultOptions || {}), fn(this, rp, new Map), fn(this, op, new Map), fn(this, xu, 0)
        }

        mount() {
            D0(this, xu)._++, Dt(this, xu) === 1 && (fn(this, sp, CD.subscribe(async r => {
                r && (await this.resumePausedMutations(), Dt(this, Lr).onFocus())
            })), fn(this, ap, Jv.subscribe(async r => {
                r && (await this.resumePausedMutations(), Dt(this, Lr).onOnline())
            })))
        }

        unmount() {
            var r, l;
            D0(this, xu)._--, Dt(this, xu) === 0 && ((r = Dt(this, sp)) == null || r.call(this), fn(this, sp, void 0), (l = Dt(this, ap)) == null || l.call(this), fn(this, ap, void 0))
        }

        isFetching(r) {
            return Dt(this, Lr).findAll({...r, fetchStatus: "fetching"}).length
        }

        isMutating(r) {
            return Dt(this, yu).findAll({...r, status: "pending"}).length
        }

        getQueryData(r) {
            var p;
            const l = this.defaultQueryOptions({queryKey: r});
            return (p = Dt(this, Lr).get(l.queryHash)) == null ? void 0 : p.state.data
        }

        ensureQueryData(r) {
            const l = this.defaultQueryOptions(r), p = Dt(this, Lr).build(this, l), y = p.state.data;
            return y === void 0 ? this.fetchQuery(r) : (r.revalidateIfStale && p.isStaleByTime(bT(l.staleTime, p)) && this.prefetchQuery(l), Promise.resolve(y))
        }

        getQueriesData(r) {
            return Dt(this, Lr).findAll(r).map(({queryKey: l, state: p}) => {
                const y = p.data;
                return [l, y]
            })
        }

        setQueryData(r, l, p) {
            const y = this.defaultQueryOptions({queryKey: r}), T = Dt(this, Lr).get(y.queryHash),
                A = T == null ? void 0 : T.state.data, D = AV(l, A);
            if (D !== void 0) return Dt(this, Lr).build(this, y).setData(D, {...p, manual: !0})
        }

        setQueriesData(r, l, p) {
            return cs.batch(() => Dt(this, Lr).findAll(r).map(({queryKey: y}) => [y, this.setQueryData(y, l, p)]))
        }

        getQueryState(r) {
            var p;
            const l = this.defaultQueryOptions({queryKey: r});
            return (p = Dt(this, Lr).get(l.queryHash)) == null ? void 0 : p.state
        }

        removeQueries(r) {
            const l = Dt(this, Lr);
            cs.batch(() => {
                l.findAll(r).forEach(p => {
                    l.remove(p)
                })
            })
        }

        resetQueries(r, l) {
            const p = Dt(this, Lr);
            return cs.batch(() => (p.findAll(r).forEach(y => {
                y.reset()
            }), this.refetchQueries({type: "active", ...r}, l)))
        }

        cancelQueries(r, l = {}) {
            const p = {revert: !0, ...l}, y = cs.batch(() => Dt(this, Lr).findAll(r).map(T => T.cancel(p)));
            return Promise.all(y).then(Pa).catch(Pa)
        }

        invalidateQueries(r, l = {}) {
            return cs.batch(() => (Dt(this, Lr).findAll(r).forEach(p => {
                p.invalidate()
            }), (r == null ? void 0 : r.refetchType) === "none" ? Promise.resolve() : this.refetchQueries({
                ...r,
                type: (r == null ? void 0 : r.refetchType) ?? (r == null ? void 0 : r.type) ?? "active"
            }, l)))
        }

        refetchQueries(r, l = {}) {
            const p = {...l, cancelRefetch: l.cancelRefetch ?? !0},
                y = cs.batch(() => Dt(this, Lr).findAll(r).filter(T => !T.isDisabled() && !T.isStatic()).map(T => {
                    let A = T.fetch(void 0, p);
                    return p.throwOnError || (A = A.catch(Pa)), T.state.fetchStatus === "paused" ? Promise.resolve() : A
                }));
            return Promise.all(y).then(Pa)
        }

        fetchQuery(r) {
            const l = this.defaultQueryOptions(r);
            l.retry === void 0 && (l.retry = !1);
            const p = Dt(this, Lr).build(this, l);
            return p.isStaleByTime(bT(l.staleTime, p)) ? p.fetch(l) : Promise.resolve(p.state.data)
        }

        prefetchQuery(r) {
            return this.fetchQuery(r).then(Pa).catch(Pa)
        }

        fetchInfiniteQuery(r) {
            return r.behavior = TP(r.pages), this.fetchQuery(r)
        }

        prefetchInfiniteQuery(r) {
            return this.fetchInfiniteQuery(r).then(Pa).catch(Pa)
        }

        ensureInfiniteQueryData(r) {
            return r.behavior = TP(r.pages), this.ensureQueryData(r)
        }

        resumePausedMutations() {
            return Jv.isOnline() ? Dt(this, yu).resumePausedMutations() : Promise.resolve()
        }

        getQueryCache() {
            return Dt(this, Lr)
        }

        getMutationCache() {
            return Dt(this, yu)
        }

        getDefaultOptions() {
            return Dt(this, vu)
        }

        setDefaultOptions(r) {
            fn(this, vu, r)
        }

        setQueryDefaults(r, l) {
            Dt(this, rp).set(v_(r), {queryKey: r, defaultOptions: l})
        }

        getQueryDefaults(r) {
            const l = [...Dt(this, rp).values()], p = {};
            return l.forEach(y => {
                x_(r, y.queryKey) && Object.assign(p, y.defaultOptions)
            }), p
        }

        setMutationDefaults(r, l) {
            Dt(this, op).set(v_(r), {mutationKey: r, defaultOptions: l})
        }

        getMutationDefaults(r) {
            const l = [...Dt(this, op).values()], p = {};
            return l.forEach(y => {
                x_(r, y.mutationKey) && Object.assign(p, y.defaultOptions)
            }), p
        }

        defaultQueryOptions(r) {
            if (r._defaulted) return r;
            const l = {...Dt(this, vu).queries, ...this.getQueryDefaults(r.queryKey), ...r, _defaulted: !0};
            return l.queryHash || (l.queryHash = V2(l.queryKey, l)), l.refetchOnReconnect === void 0 && (l.refetchOnReconnect = l.networkMode !== "always"), l.throwOnError === void 0 && (l.throwOnError = !!l.suspense), !l.networkMode && l.persister && (l.networkMode = "offlineFirst"), l.queryFn === U2 && (l.enabled = !1), l
        }

        defaultMutationOptions(r) {
            return r != null && r._defaulted ? r : {
                ...Dt(this, vu).mutations, ...(r == null ? void 0 : r.mutationKey) && this.getMutationDefaults(r.mutationKey), ...r,
                _defaulted: !0
            }
        }

        clear() {
            Dt(this, Lr).clear(), Dt(this, yu).clear()
        }
    }, Lr = new WeakMap, yu = new WeakMap, vu = new WeakMap, rp = new WeakMap, op = new WeakMap, xu = new WeakMap, sp = new WeakMap, ap = new WeakMap, GP),
    XV = Ce.createContext(void 0), YV = ({client: r, children: l}) => (Ce.useEffect(() => (r.mount(), () => {
        r.unmount()
    }), [r]), K.jsx(XV.Provider, {value: r, children: l}));

/**
 * @remix-run/router v1.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function w_() {
    return w_ = Object.assign ? Object.assign.bind() : function (r) {
        for (var l = 1; l < arguments.length; l++) {
            var p = arguments[l];
            for (var y in p) Object.prototype.hasOwnProperty.call(p, y) && (r[y] = p[y])
        }
        return r
    }, w_.apply(this, arguments)
}

var Tu;
(function (r) {
    r.Pop = "POP", r.Push = "PUSH", r.Replace = "REPLACE"
})(Tu || (Tu = {}));
const EP = "popstate";

function KV(r) {
    r === void 0 && (r = {});

    function l(y, T) {
        let {pathname: A, search: D, hash: o} = y.location;
        return ST("", {
            pathname: A,
            search: D,
            hash: o
        }, T.state && T.state.usr || null, T.state && T.state.key || "default")
    }

    function p(y, T) {
        return typeof T == "string" ? T : ex(T)
    }

    return JV(l, p, null, r)
}

function Or(r, l) {
    if (r === !1 || r === null || typeof r > "u") throw new Error(l)
}

function DD(r, l) {
    if (!r) {
        typeof console < "u" && console.warn(l);
        try {
            throw new Error(l)
        } catch {
        }
    }
}

function QV() {
    return Math.random().toString(36).substr(2, 8)
}

function AP(r, l) {
    return {usr: r.state, key: r.key, idx: l}
}

function ST(r, l, p, y) {
    return p === void 0 && (p = null), w_({
        pathname: typeof r == "string" ? r : r.pathname,
        search: "",
        hash: ""
    }, typeof l == "string" ? Ip(l) : l, {state: p, key: l && l.key || y || QV()})
}

function ex(r) {
    let {pathname: l = "/", search: p = "", hash: y = ""} = r;
    return p && p !== "?" && (l += p.charAt(0) === "?" ? p : "?" + p), y && y !== "#" && (l += y.charAt(0) === "#" ? y : "#" + y), l
}

function Ip(r) {
    let l = {};
    if (r) {
        let p = r.indexOf("#");
        p >= 0 && (l.hash = r.substr(p), r = r.substr(0, p));
        let y = r.indexOf("?");
        y >= 0 && (l.search = r.substr(y), r = r.substr(0, y)), r && (l.pathname = r)
    }
    return l
}

function JV(r, l, p, y) {
    y === void 0 && (y = {});
    let {window: T = document.defaultView, v5Compat: A = !1} = y, D = T.history, o = Tu.Pop, j = null, q = ee();
    q == null && (q = 0, D.replaceState(w_({}, D.state, {idx: q}), ""));

    function ee() {
        return (D.state || {idx: null}).idx
    }

    function oe() {
        o = Tu.Pop;
        let Me = ee(), pe = Me == null ? null : Me - q;
        q = Me, j && j({action: o, location: fe.location, delta: pe})
    }

    function de(Me, pe) {
        o = Tu.Push;
        let le = ST(fe.location, Me, pe);
        q = ee() + 1;
        let be = AP(le, q), Ue = fe.createHref(le);
        try {
            D.pushState(be, "", Ue)
        } catch (et) {
            if (et instanceof DOMException && et.name === "DataCloneError") throw et;
            T.location.assign(Ue)
        }
        A && j && j({action: o, location: fe.location, delta: 1})
    }

    function ae(Me, pe) {
        o = Tu.Replace;
        let le = ST(fe.location, Me, pe);
        q = ee();
        let be = AP(le, q), Ue = fe.createHref(le);
        D.replaceState(be, "", Ue), A && j && j({action: o, location: fe.location, delta: 0})
    }

    function Re(Me) {
        let pe = T.location.origin !== "null" ? T.location.origin : T.location.href,
            le = typeof Me == "string" ? Me : ex(Me);
        return le = le.replace(/ $/, "%20"), Or(pe, "No window.location.(origin|href) available to create URL for href: " + le), new URL(le, pe)
    }

    let fe = {
        get action() {
            return o
        }, get location() {
            return r(T, D)
        }, listen(Me) {
            if (j) throw new Error("A history only accepts one active listener");
            return T.addEventListener(EP, oe), j = Me, () => {
                T.removeEventListener(EP, oe), j = null
            }
        }, createHref(Me) {
            return l(T, Me)
        }, createURL: Re, encodeLocation(Me) {
            let pe = Re(Me);
            return {pathname: pe.pathname, search: pe.search, hash: pe.hash}
        }, push: de, replace: ae, go(Me) {
            return D.go(Me)
        }
    };
    return fe
}

var IP;
(function (r) {
    r.data = "data", r.deferred = "deferred", r.redirect = "redirect", r.error = "error"
})(IP || (IP = {}));

function eU(r, l, p) {
    return p === void 0 && (p = "/"), tU(r, l, p, !1)
}

function tU(r, l, p, y) {
    let T = typeof l == "string" ? Ip(l) : l, A = _p(T.pathname || "/", p);
    if (A == null) return null;
    let D = LD(r);
    iU(D);
    let o = null;
    for (let j = 0; o == null && j < D.length; ++j) {
        let q = fU(A);
        o = hU(D[j], q, y)
    }
    return o
}

function LD(r, l, p, y) {
    l === void 0 && (l = []), p === void 0 && (p = []), y === void 0 && (y = "");
    let T = (A, D, o) => {
        let j = {
            relativePath: o === void 0 ? A.path || "" : o,
            caseSensitive: A.caseSensitive === !0,
            childrenIndex: D,
            route: A
        };
        j.relativePath.startsWith("/") && (Or(j.relativePath.startsWith(y), 'Absolute route path "' + j.relativePath + '" nested under path ' + ('"' + y + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), j.relativePath = j.relativePath.slice(y.length));
        let q = zu([y, j.relativePath]), ee = p.concat(j);
        A.children && A.children.length > 0 && (Or(A.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + q + '".')), LD(A.children, l, ee, q)), !(A.path == null && !A.index) && l.push({
            path: q,
            score: cU(q, A.index),
            routesMeta: ee
        })
    };
    return r.forEach((A, D) => {
        var o;
        if (A.path === "" || !((o = A.path) != null && o.includes("?"))) T(A, D); else for (let j of kD(A.path)) T(A, D, j)
    }), l
}

function kD(r) {
    let l = r.split("/");
    if (l.length === 0) return [];
    let [p, ...y] = l, T = p.endsWith("?"), A = p.replace(/\?$/, "");
    if (y.length === 0) return T ? [A, ""] : [A];
    let D = kD(y.join("/")), o = [];
    return o.push(...D.map(j => j === "" ? A : [A, j].join("/"))), T && o.push(...D), o.map(j => r.startsWith("/") && j === "" ? "/" : j)
}

function iU(r) {
    r.sort((l, p) => l.score !== p.score ? p.score - l.score : uU(l.routesMeta.map(y => y.childrenIndex), p.routesMeta.map(y => y.childrenIndex)))
}

const nU = /^:[\w-]+$/, rU = 3, oU = 2, sU = 1, aU = 10, lU = -2, CP = r => r === "*";

function cU(r, l) {
    let p = r.split("/"), y = p.length;
    return p.some(CP) && (y += lU), l && (y += oU), p.filter(T => !CP(T)).reduce((T, A) => T + (nU.test(A) ? rU : A === "" ? sU : aU), y)
}

function uU(r, l) {
    return r.length === l.length && r.slice(0, -1).every((y, T) => y === l[T]) ? r[r.length - 1] - l[l.length - 1] : 0
}

function hU(r, l, p) {
    let {routesMeta: y} = r, T = {}, A = "/", D = [];
    for (let o = 0; o < y.length; ++o) {
        let j = y[o], q = o === y.length - 1, ee = A === "/" ? l : l.slice(A.length) || "/",
            oe = tx({path: j.relativePath, caseSensitive: j.caseSensitive, end: q}, ee), de = j.route;
        if (!oe && q && p && !y[y.length - 1].route.index && (oe = tx({
            path: j.relativePath,
            caseSensitive: j.caseSensitive,
            end: !1
        }, ee)), !oe) return null;
        Object.assign(T, oe.params), D.push({
            params: T,
            pathname: zu([A, oe.pathname]),
            pathnameBase: _U(zu([A, oe.pathnameBase])),
            route: de
        }), oe.pathnameBase !== "/" && (A = zu([A, oe.pathnameBase]))
    }
    return D
}

function tx(r, l) {
    typeof r == "string" && (r = {path: r, caseSensitive: !1, end: !0});
    let [p, y] = dU(r.path, r.caseSensitive, r.end), T = l.match(p);
    if (!T) return null;
    let A = T[0], D = A.replace(/(.)\/+$/, "$1"), o = T.slice(1);
    return {
        params: y.reduce((q, ee, oe) => {
            let {paramName: de, isOptional: ae} = ee;
            if (de === "*") {
                let fe = o[oe] || "";
                D = A.slice(0, A.length - fe.length).replace(/(.)\/+$/, "$1")
            }
            const Re = o[oe];
            return ae && !Re ? q[de] = void 0 : q[de] = (Re || "").replace(/%2F/g, "/"), q
        }, {}), pathname: A, pathnameBase: D, pattern: r
    }
}

function dU(r, l, p) {
    l === void 0 && (l = !1), p === void 0 && (p = !0), DD(r === "*" || !r.endsWith("*") || r.endsWith("/*"), 'Route path "' + r + '" will be treated as if it were ' + ('"' + r.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + r.replace(/\*$/, "/*") + '".'));
    let y = [],
        T = "^" + r.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (D, o, j) => (y.push({
            paramName: o,
            isOptional: j != null
        }), j ? "/?([^\\/]+)?" : "/([^\\/]+)"));
    return r.endsWith("*") ? (y.push({paramName: "*"}), T += r === "*" || r === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : p ? T += "\\/*$" : r !== "" && r !== "/" && (T += "(?:(?=\\/|$))"), [new RegExp(T, l ? void 0 : "i"), y]
}

function fU(r) {
    try {
        return r.split("/").map(l => decodeURIComponent(l).replace(/\//g, "%2F")).join("/")
    } catch (l) {
        return DD(!1, 'The URL path "' + r + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + l + ").")), r
    }
}

function _p(r, l) {
    if (l === "/") return r;
    if (!r.toLowerCase().startsWith(l.toLowerCase())) return null;
    let p = l.endsWith("/") ? l.length - 1 : l.length, y = r.charAt(p);
    return y && y !== "/" ? null : r.slice(p) || "/"
}

function pU(r, l) {
    l === void 0 && (l = "/");
    let {pathname: p, search: y = "", hash: T = ""} = typeof r == "string" ? Ip(r) : r;
    return {pathname: p ? p.startsWith("/") ? p : mU(p, l) : l, search: yU(y), hash: vU(T)}
}

function mU(r, l) {
    let p = l.replace(/\/+$/, "").split("/");
    return r.split("/").forEach(T => {
        T === ".." ? p.length > 1 && p.pop() : T !== "." && p.push(T)
    }), p.length > 1 ? p.join("/") : "/"
}

function pb(r, l, p, y) {
    return "Cannot include a '" + r + "' character in a manually specified " + ("`to." + l + "` field [" + JSON.stringify(y) + "].  Please separate it out to the ") + ("`to." + p + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.'
}

function gU(r) {
    return r.filter((l, p) => p === 0 || l.route.path && l.route.path.length > 0)
}

function OD(r, l) {
    let p = gU(r);
    return l ? p.map((y, T) => T === p.length - 1 ? y.pathname : y.pathnameBase) : p.map(y => y.pathnameBase)
}

function FD(r, l, p, y) {
    y === void 0 && (y = !1);
    let T;
    typeof r == "string" ? T = Ip(r) : (T = w_({}, r), Or(!T.pathname || !T.pathname.includes("?"), pb("?", "pathname", "search", T)), Or(!T.pathname || !T.pathname.includes("#"), pb("#", "pathname", "hash", T)), Or(!T.search || !T.search.includes("#"), pb("#", "search", "hash", T)));
    let A = r === "" || T.pathname === "", D = A ? "/" : T.pathname, o;
    if (D == null) o = p; else {
        let oe = l.length - 1;
        if (!y && D.startsWith("..")) {
            let de = D.split("/");
            for (; de[0] === "..";) de.shift(), oe -= 1;
            T.pathname = de.join("/")
        }
        o = oe >= 0 ? l[oe] : "/"
    }
    let j = pU(T, o), q = D && D !== "/" && D.endsWith("/"), ee = (A || D === ".") && p.endsWith("/");
    return !j.pathname.endsWith("/") && (q || ee) && (j.pathname += "/"), j
}

const zu = r => r.join("/").replace(/\/\/+/g, "/"), _U = r => r.replace(/\/+$/, "").replace(/^\/*/, "/"),
    yU = r => !r || r === "?" ? "" : r.startsWith("?") ? r : "?" + r,
    vU = r => !r || r === "#" ? "" : r.startsWith("#") ? r : "#" + r;

function xU(r) {
    return r != null && typeof r.status == "number" && typeof r.statusText == "string" && typeof r.internal == "boolean" && "data" in r
}

const BD = ["post", "put", "patch", "delete"];
new Set(BD);
const wU = ["get", ...BD];
new Set(wU);

/**
 * React Router v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function b_() {
    return b_ = Object.assign ? Object.assign.bind() : function (r) {
        for (var l = 1; l < arguments.length; l++) {
            var p = arguments[l];
            for (var y in p) Object.prototype.hasOwnProperty.call(p, y) && (r[y] = p[y])
        }
        return r
    }, b_.apply(this, arguments)
}

const zx = Ce.createContext(null), ND = Ce.createContext(null), Uu = Ce.createContext(null),
    Dx = Ce.createContext(null), ld = Ce.createContext({outlet: null, matches: [], isDataRoute: !1}),
    jD = Ce.createContext(null);

function bU(r, l) {
    let {relative: p} = l === void 0 ? {} : l;
    D_() || Or(!1);
    let {basename: y, navigator: T} = Ce.useContext(Uu), {hash: A, pathname: D, search: o} = Lx(r, {relative: p}),
        j = D;
    return y !== "/" && (j = D === "/" ? y : zu([y, D])), T.createHref({pathname: j, search: o, hash: A})
}

function D_() {
    return Ce.useContext(Dx) != null
}

function Cp() {
    return D_() || Or(!1), Ce.useContext(Dx).location
}

function VD(r) {
    Ce.useContext(Uu).static || Ce.useLayoutEffect(r)
}

function TU() {
    let {isDataRoute: r} = Ce.useContext(ld);
    return r ? OU() : SU()
}

function SU() {
    D_() || Or(!1);
    let r = Ce.useContext(zx), {
            basename: l,
            future: p,
            navigator: y
        } = Ce.useContext(Uu), {matches: T} = Ce.useContext(ld), {pathname: A} = Cp(),
        D = JSON.stringify(OD(T, p.v7_relativeSplatPath)), o = Ce.useRef(!1);
    return VD(() => {
        o.current = !0
    }), Ce.useCallback(function (q, ee) {
        if (ee === void 0 && (ee = {}), !o.current) return;
        if (typeof q == "number") {
            y.go(q);
            return
        }
        let oe = FD(q, JSON.parse(D), A, ee.relative === "path");
        r == null && l !== "/" && (oe.pathname = oe.pathname === "/" ? l : zu([l, oe.pathname])), (ee.replace ? y.replace : y.push)(oe, ee.state, ee)
    }, [l, y, D, A, r])
}

function Lx(r, l) {
    let {relative: p} = l === void 0 ? {} : l, {future: y} = Ce.useContext(Uu), {matches: T} = Ce.useContext(ld), {pathname: A} = Cp(),
        D = JSON.stringify(OD(T, y.v7_relativeSplatPath));
    return Ce.useMemo(() => FD(r, JSON.parse(D), A, p === "path"), [r, D, A, p])
}

function EU(r, l) {
    return AU(r, l)
}

function AU(r, l, p, y) {
    D_() || Or(!1);
    let {navigator: T} = Ce.useContext(Uu), {matches: A} = Ce.useContext(ld), D = A[A.length - 1],
        o = D ? D.params : {};
    D && D.pathname;
    let j = D ? D.pathnameBase : "/";
    D && D.route;
    let q = Cp(), ee;
    if (l) {
        var oe;
        let Me = typeof l == "string" ? Ip(l) : l;
        j === "/" || (oe = Me.pathname) != null && oe.startsWith(j) || Or(!1), ee = Me
    } else ee = q;
    let de = ee.pathname || "/", ae = de;
    if (j !== "/") {
        let Me = j.replace(/^\//, "").split("/");
        ae = "/" + de.replace(/^\//, "").split("/").slice(Me.length).join("/")
    }
    let Re = eU(r, {pathname: ae}), fe = RU(Re && Re.map(Me => Object.assign({}, Me, {
        params: Object.assign({}, o, Me.params),
        pathname: zu([j, T.encodeLocation ? T.encodeLocation(Me.pathname).pathname : Me.pathname]),
        pathnameBase: Me.pathnameBase === "/" ? j : zu([j, T.encodeLocation ? T.encodeLocation(Me.pathnameBase).pathname : Me.pathnameBase])
    })), A, p, y);
    return l && fe ? Ce.createElement(Dx.Provider, {
        value: {
            location: b_({
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default"
            }, ee), navigationType: Tu.Pop
        }
    }, fe) : fe
}

function IU() {
    let r = kU(), l = xU(r) ? r.status + " " + r.statusText : r instanceof Error ? r.message : JSON.stringify(r),
        p = r instanceof Error ? r.stack : null, T = {padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)"};
    return Ce.createElement(Ce.Fragment, null, Ce.createElement("h2", null, "Unexpected Application Error!"), Ce.createElement("h3", {style: {fontStyle: "italic"}}, l), p ? Ce.createElement("pre", {style: T}, p) : null, null)
}

const CU = Ce.createElement(IU, null);

class PU extends Ce.Component {
    constructor(l) {
        super(l), this.state = {location: l.location, revalidation: l.revalidation, error: l.error}
    }

    static getDerivedStateFromError(l) {
        return {error: l}
    }

    static getDerivedStateFromProps(l, p) {
        return p.location !== l.location || p.revalidation !== "idle" && l.revalidation === "idle" ? {
            error: l.error,
            location: l.location,
            revalidation: l.revalidation
        } : {
            error: l.error !== void 0 ? l.error : p.error,
            location: p.location,
            revalidation: l.revalidation || p.revalidation
        }
    }

    componentDidCatch(l, p) {
        console.error("React Router caught the following error during render", l, p)
    }

    render() {
        return this.state.error !== void 0 ? Ce.createElement(ld.Provider, {value: this.props.routeContext}, Ce.createElement(jD.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}

function MU(r) {
    let {routeContext: l, match: p, children: y} = r, T = Ce.useContext(zx);
    return T && T.static && T.staticContext && (p.route.errorElement || p.route.ErrorBoundary) && (T.staticContext._deepestRenderedBoundaryId = p.route.id), Ce.createElement(ld.Provider, {value: l}, y)
}

function RU(r, l, p, y) {
    var T;
    if (l === void 0 && (l = []), p === void 0 && (p = null), y === void 0 && (y = null), r == null) {
        var A;
        if (!p) return null;
        if (p.errors) r = p.matches; else if ((A = y) != null && A.v7_partialHydration && l.length === 0 && !p.initialized && p.matches.length > 0) r = p.matches; else return null
    }
    let D = r, o = (T = p) == null ? void 0 : T.errors;
    if (o != null) {
        let ee = D.findIndex(oe => oe.route.id && (o == null ? void 0 : o[oe.route.id]) !== void 0);
        ee >= 0 || Or(!1), D = D.slice(0, Math.min(D.length, ee + 1))
    }
    let j = !1, q = -1;
    if (p && y && y.v7_partialHydration) for (let ee = 0; ee < D.length; ee++) {
        let oe = D[ee];
        if ((oe.route.HydrateFallback || oe.route.hydrateFallbackElement) && (q = ee), oe.route.id) {
            let {loaderData: de, errors: ae} = p,
                Re = oe.route.loader && de[oe.route.id] === void 0 && (!ae || ae[oe.route.id] === void 0);
            if (oe.route.lazy || Re) {
                j = !0, q >= 0 ? D = D.slice(0, q + 1) : D = [D[0]];
                break
            }
        }
    }
    return D.reduceRight((ee, oe, de) => {
        let ae, Re = !1, fe = null, Me = null;
        p && (ae = o && oe.route.id ? o[oe.route.id] : void 0, fe = oe.route.errorElement || CU, j && (q < 0 && de === 0 ? (Re = !0, Me = null) : q === de && (Re = !0, Me = oe.route.hydrateFallbackElement || null)));
        let pe = l.concat(D.slice(0, de + 1)), le = () => {
            let be;
            return ae ? be = fe : Re ? be = Me : oe.route.Component ? be = Ce.createElement(oe.route.Component, null) : oe.route.element ? be = oe.route.element : be = ee, Ce.createElement(MU, {
                match: oe,
                routeContext: {outlet: ee, matches: pe, isDataRoute: p != null},
                children: be
            })
        };
        return p && (oe.route.ErrorBoundary || oe.route.errorElement || de === 0) ? Ce.createElement(PU, {
            location: p.location,
            revalidation: p.revalidation,
            component: fe,
            error: ae,
            children: le(),
            routeContext: {outlet: null, matches: pe, isDataRoute: !0}
        }) : le()
    }, null)
}

var UD = function (r) {
    return r.UseBlocker = "useBlocker", r.UseRevalidator = "useRevalidator", r.UseNavigateStable = "useNavigate", r
}(UD || {}), ix = function (r) {
    return r.UseBlocker = "useBlocker", r.UseLoaderData = "useLoaderData", r.UseActionData = "useActionData", r.UseRouteError = "useRouteError", r.UseNavigation = "useNavigation", r.UseRouteLoaderData = "useRouteLoaderData", r.UseMatches = "useMatches", r.UseRevalidator = "useRevalidator", r.UseNavigateStable = "useNavigate", r.UseRouteId = "useRouteId", r
}(ix || {});

function zU(r) {
    let l = Ce.useContext(zx);
    return l || Or(!1), l
}

function DU(r) {
    let l = Ce.useContext(ND);
    return l || Or(!1), l
}

function LU(r) {
    let l = Ce.useContext(ld);
    return l || Or(!1), l
}

function GD(r) {
    let l = LU(), p = l.matches[l.matches.length - 1];
    return p.route.id || Or(!1), p.route.id
}

function kU() {
    var r;
    let l = Ce.useContext(jD), p = DU(ix.UseRouteError), y = GD(ix.UseRouteError);
    return l !== void 0 ? l : (r = p.errors) == null ? void 0 : r[y]
}

function OU() {
    let {router: r} = zU(UD.UseNavigateStable), l = GD(ix.UseNavigateStable), p = Ce.useRef(!1);
    return VD(() => {
        p.current = !0
    }), Ce.useCallback(function (T, A) {
        A === void 0 && (A = {}), p.current && (typeof T == "number" ? r.navigate(T) : r.navigate(T, b_({fromRouteId: l}, A)))
    }, [r, l])
}

function FU(r, l) {
    r == null || r.v7_startTransition, r == null || r.v7_relativeSplatPath
}

function Rf(r) {
    Or(!1)
}

function BU(r) {
    let {
        basename: l = "/",
        children: p = null,
        location: y,
        navigationType: T = Tu.Pop,
        navigator: A,
        static: D = !1,
        future: o
    } = r;
    D_() && Or(!1);
    let j = l.replace(/^\/*/, "/"), q = Ce.useMemo(() => ({
        basename: j,
        navigator: A,
        static: D,
        future: b_({v7_relativeSplatPath: !1}, o)
    }), [j, o, A, D]);
    typeof y == "string" && (y = Ip(y));
    let {pathname: ee = "/", search: oe = "", hash: de = "", state: ae = null, key: Re = "default"} = y,
        fe = Ce.useMemo(() => {
            let Me = _p(ee, j);
            return Me == null ? null : {
                location: {pathname: Me, search: oe, hash: de, state: ae, key: Re},
                navigationType: T
            }
        }, [j, ee, oe, de, ae, Re, T]);
    return fe == null ? null : Ce.createElement(Uu.Provider, {value: q}, Ce.createElement(Dx.Provider, {
        children: p,
        value: fe
    }))
}

function NU(r) {
    let {children: l, location: p} = r;
    return EU(ET(l), p)
}

new Promise(() => {
});

function ET(r, l) {
    l === void 0 && (l = []);
    let p = [];
    return Ce.Children.forEach(r, (y, T) => {
        if (!Ce.isValidElement(y)) return;
        let A = [...l, T];
        if (y.type === Ce.Fragment) {
            p.push.apply(p, ET(y.props.children, A));
            return
        }
        y.type !== Rf && Or(!1), !y.props.index || !y.props.children || Or(!1);
        let D = {
            id: y.props.id || A.join("-"),
            caseSensitive: y.props.caseSensitive,
            element: y.props.element,
            Component: y.props.Component,
            index: y.props.index,
            path: y.props.path,
            loader: y.props.loader,
            action: y.props.action,
            errorElement: y.props.errorElement,
            ErrorBoundary: y.props.ErrorBoundary,
            hasErrorBoundary: y.props.ErrorBoundary != null || y.props.errorElement != null,
            shouldRevalidate: y.props.shouldRevalidate,
            handle: y.props.handle,
            lazy: y.props.lazy
        };
        y.props.children && (D.children = ET(y.props.children, A)), p.push(D)
    }), p
}

/**
 * React Router DOM v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function nx() {
    return nx = Object.assign ? Object.assign.bind() : function (r) {
        for (var l = 1; l < arguments.length; l++) {
            var p = arguments[l];
            for (var y in p) Object.prototype.hasOwnProperty.call(p, y) && (r[y] = p[y])
        }
        return r
    }, nx.apply(this, arguments)
}

function $D(r, l) {
    if (r == null) return {};
    var p = {}, y = Object.keys(r), T, A;
    for (A = 0; A < y.length; A++) T = y[A], !(l.indexOf(T) >= 0) && (p[T] = r[T]);
    return p
}

function jU(r) {
    return !!(r.metaKey || r.altKey || r.ctrlKey || r.shiftKey)
}

function VU(r, l) {
    return r.button === 0 && (!l || l === "_self") && !jU(r)
}

const UU = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"],
    GU = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"], $U = "6";
try {
    window.__reactRouterVersion = $U
} catch {
}
const HU = Ce.createContext({isTransitioning: !1}), qU = "startTransition", PP = OT[qU];

function WU(r) {
    let {basename: l, children: p, future: y, window: T} = r, A = Ce.useRef();
    A.current == null && (A.current = KV({window: T, v5Compat: !0}));
    let D = A.current, [o, j] = Ce.useState({
        action: D.action,
        location: D.location
    }), {v7_startTransition: q} = y || {}, ee = Ce.useCallback(oe => {
        q && PP ? PP(() => j(oe)) : j(oe)
    }, [j, q]);
    return Ce.useLayoutEffect(() => D.listen(ee), [D, ee]), Ce.useEffect(() => FU(y), [y]), Ce.createElement(BU, {
        basename: l,
        children: p,
        location: o.location,
        navigationType: o.action,
        navigator: D,
        future: y
    })
}

const ZU = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u",
    XU = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, ca = Ce.forwardRef(function (l, p) {
        let {
            onClick: y,
            relative: T,
            reloadDocument: A,
            replace: D,
            state: o,
            target: j,
            to: q,
            preventScrollReset: ee,
            viewTransition: oe
        } = l, de = $D(l, UU), {basename: ae} = Ce.useContext(Uu), Re, fe = !1;
        if (typeof q == "string" && XU.test(q) && (Re = q, ZU)) try {
            let be = new URL(window.location.href), Ue = q.startsWith("//") ? new URL(be.protocol + q) : new URL(q),
                et = _p(Ue.pathname, ae);
            Ue.origin === be.origin && et != null ? q = et + Ue.search + Ue.hash : fe = !0
        } catch {
        }
        let Me = bU(q, {relative: T}),
            pe = KU(q, {replace: D, state: o, target: j, preventScrollReset: ee, relative: T, viewTransition: oe});

        function le(be) {
            y && y(be), be.defaultPrevented || pe(be)
        }

        return Ce.createElement("a", nx({}, de, {href: Re || Me, onClick: fe || A ? y : le, ref: p, target: j}))
    }), iv = Ce.forwardRef(function (l, p) {
        let {
                "aria-current": y = "page",
                caseSensitive: T = !1,
                className: A = "",
                end: D = !1,
                style: o,
                to: j,
                viewTransition: q,
                children: ee
            } = l, oe = $D(l, GU), de = Lx(j, {relative: oe.relative}), ae = Cp(), Re = Ce.useContext(ND), {
                navigator: fe,
                basename: Me
            } = Ce.useContext(Uu), pe = Re != null && QU(de) && q === !0,
            le = fe.encodeLocation ? fe.encodeLocation(de).pathname : de.pathname, be = ae.pathname,
            Ue = Re && Re.navigation && Re.navigation.location ? Re.navigation.location.pathname : null;
        T || (be = be.toLowerCase(), Ue = Ue ? Ue.toLowerCase() : null, le = le.toLowerCase()), Ue && Me && (Ue = _p(Ue, Me) || Ue);
        const et = le !== "/" && le.endsWith("/") ? le.length - 1 : le.length;
        let _t = be === le || !D && be.startsWith(le) && be.charAt(et) === "/",
            xt = Ue != null && (Ue === le || !D && Ue.startsWith(le) && Ue.charAt(le.length) === "/"),
            Mt = {isActive: _t, isPending: xt, isTransitioning: pe}, Xt = _t ? y : void 0, Zt;
        typeof A == "function" ? Zt = A(Mt) : Zt = [A, _t ? "active" : null, xt ? "pending" : null, pe ? "transitioning" : null].filter(Boolean).join(" ");
        let Ht = typeof o == "function" ? o(Mt) : o;
        return Ce.createElement(ca, nx({}, oe, {
            "aria-current": Xt,
            className: Zt,
            ref: p,
            style: Ht,
            to: j,
            viewTransition: q
        }), typeof ee == "function" ? ee(Mt) : ee)
    });
var AT;
(function (r) {
    r.UseScrollRestoration = "useScrollRestoration", r.UseSubmit = "useSubmit", r.UseSubmitFetcher = "useSubmitFetcher", r.UseFetcher = "useFetcher", r.useViewTransitionState = "useViewTransitionState"
})(AT || (AT = {}));
var MP;
(function (r) {
    r.UseFetcher = "useFetcher", r.UseFetchers = "useFetchers", r.UseScrollRestoration = "useScrollRestoration"
})(MP || (MP = {}));

function YU(r) {
    let l = Ce.useContext(zx);
    return l || Or(!1), l
}

function KU(r, l) {
    let {
        target: p,
        replace: y,
        state: T,
        preventScrollReset: A,
        relative: D,
        viewTransition: o
    } = l === void 0 ? {} : l, j = TU(), q = Cp(), ee = Lx(r, {relative: D});
    return Ce.useCallback(oe => {
        if (VU(oe, p)) {
            oe.preventDefault();
            let de = y !== void 0 ? y : ex(q) === ex(ee);
            j(r, {replace: de, state: T, preventScrollReset: A, relative: D, viewTransition: o})
        }
    }, [q, j, ee, y, T, p, r, A, D, o])
}

function QU(r, l) {
    l === void 0 && (l = {});
    let p = Ce.useContext(HU);
    p == null && Or(!1);
    let {basename: y} = YU(AT.useViewTransitionState), T = Lx(r, {relative: l.relative});
    if (!p.isTransitioning) return !1;
    let A = _p(p.currentLocation.pathname, y) || p.currentLocation.pathname,
        D = _p(p.nextLocation.pathname, y) || p.nextLocation.pathname;
    return tx(T.pathname, D) != null || tx(T.pathname, A) != null
}

var JU = typeof Element < "u", e6 = typeof Map == "function", t6 = typeof Set == "function",
    i6 = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;

function vv(r, l) {
    if (r === l) return !0;
    if (r && l && typeof r == "object" && typeof l == "object") {
        if (r.constructor !== l.constructor) return !1;
        var p, y, T;
        if (Array.isArray(r)) {
            if (p = r.length, p != l.length) return !1;
            for (y = p; y-- !== 0;) if (!vv(r[y], l[y])) return !1;
            return !0
        }
        var A;
        if (e6 && r instanceof Map && l instanceof Map) {
            if (r.size !== l.size) return !1;
            for (A = r.entries(); !(y = A.next()).done;) if (!l.has(y.value[0])) return !1;
            for (A = r.entries(); !(y = A.next()).done;) if (!vv(y.value[1], l.get(y.value[0]))) return !1;
            return !0
        }
        if (t6 && r instanceof Set && l instanceof Set) {
            if (r.size !== l.size) return !1;
            for (A = r.entries(); !(y = A.next()).done;) if (!l.has(y.value[0])) return !1;
            return !0
        }
        if (i6 && ArrayBuffer.isView(r) && ArrayBuffer.isView(l)) {
            if (p = r.length, p != l.length) return !1;
            for (y = p; y-- !== 0;) if (r[y] !== l[y]) return !1;
            return !0
        }
        if (r.constructor === RegExp) return r.source === l.source && r.flags === l.flags;
        if (r.valueOf !== Object.prototype.valueOf && typeof r.valueOf == "function" && typeof l.valueOf == "function") return r.valueOf() === l.valueOf();
        if (r.toString !== Object.prototype.toString && typeof r.toString == "function" && typeof l.toString == "function") return r.toString() === l.toString();
        if (T = Object.keys(r), p = T.length, p !== Object.keys(l).length) return !1;
        for (y = p; y-- !== 0;) if (!Object.prototype.hasOwnProperty.call(l, T[y])) return !1;
        if (JU && r instanceof Element) return !1;
        for (y = p; y-- !== 0;) if (!((T[y] === "_owner" || T[y] === "__v" || T[y] === "__o") && r.$$typeof) && !vv(r[T[y]], l[T[y]])) return !1;
        return !0
    }
    return r !== r && l !== l
}

var n6 = function (l, p) {
    try {
        return vv(l, p)
    } catch (y) {
        if ((y.message || "").match(/stack|recursion/i)) return console.warn("react-fast-compare cannot handle circular refs"), !1;
        throw y
    }
};
const r6 = vp(n6);
var o6 = function (r, l, p, y, T, A, D, o) {
    if (!r) {
        var j;
        if (l === void 0) j = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else {
            var q = [p, y, T, A, D, o], ee = 0;
            j = new Error(l.replace(/%s/g, function () {
                return q[ee++]
            })), j.name = "Invariant Violation"
        }
        throw j.framesToPop = 1, j
    }
}, s6 = o6;
const RP = vp(s6);
var a6 = function (l, p, y, T) {
    var A = y ? y.call(T, l, p) : void 0;
    if (A !== void 0) return !!A;
    if (l === p) return !0;
    if (typeof l != "object" || !l || typeof p != "object" || !p) return !1;
    var D = Object.keys(l), o = Object.keys(p);
    if (D.length !== o.length) return !1;
    for (var j = Object.prototype.hasOwnProperty.bind(p), q = 0; q < D.length; q++) {
        var ee = D[q];
        if (!j(ee)) return !1;
        var oe = l[ee], de = p[ee];
        if (A = y ? y.call(T, oe, de, ee) : void 0, A === !1 || A === void 0 && oe !== de) return !1
    }
    return !0
};
const l6 = vp(a6);
var HD = (r => (r.BASE = "base", r.BODY = "body", r.HEAD = "head", r.HTML = "html", r.LINK = "link", r.META = "meta", r.NOSCRIPT = "noscript", r.SCRIPT = "script", r.STYLE = "style", r.TITLE = "title", r.FRAGMENT = "Symbol(react.fragment)", r))(HD || {}),
    mb = {
        link: {rel: ["amphtml", "canonical", "alternate"]},
        script: {type: ["application/ld+json"]},
        meta: {
            charset: "",
            name: ["generator", "robots", "description"],
            property: ["og:type", "og:title", "og:url", "og:image", "og:image:alt", "og:description", "twitter:url", "twitter:title", "twitter:description", "twitter:image", "twitter:image:alt", "twitter:card", "twitter:site"]
        }
    }, zP = Object.values(HD), G2 = {
        accesskey: "accessKey",
        charset: "charSet",
        class: "className",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        "http-equiv": "httpEquiv",
        itemprop: "itemProp",
        tabindex: "tabIndex"
    }, c6 = Object.entries(G2).reduce((r, [l, p]) => (r[p] = l, r), {}), La = "data-rh", Qf = {
        DEFAULT_TITLE: "defaultTitle",
        DEFER: "defer",
        ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters",
        ON_CHANGE_CLIENT_STATE: "onChangeClientState",
        TITLE_TEMPLATE: "titleTemplate",
        PRIORITIZE_SEO_TAGS: "prioritizeSeoTags"
    }, Jf = (r, l) => {
        for (let p = r.length - 1; p >= 0; p -= 1) {
            const y = r[p];
            if (Object.prototype.hasOwnProperty.call(y, l)) return y[l]
        }
        return null
    }, u6 = r => {
        let l = Jf(r, "title");
        const p = Jf(r, Qf.TITLE_TEMPLATE);
        if (Array.isArray(l) && (l = l.join("")), p && l) return p.replace(/%s/g, () => l);
        const y = Jf(r, Qf.DEFAULT_TITLE);
        return l || y || void 0
    }, h6 = r => Jf(r, Qf.ON_CHANGE_CLIENT_STATE) || (() => {
    }), gb = (r, l) => l.filter(p => typeof p[r] < "u").map(p => p[r]).reduce((p, y) => ({...p, ...y}), {}),
    d6 = (r, l) => l.filter(p => typeof p.base < "u").map(p => p.base).reverse().reduce((p, y) => {
        if (!p.length) {
            const T = Object.keys(y);
            for (let A = 0; A < T.length; A += 1) {
                const o = T[A].toLowerCase();
                if (r.indexOf(o) !== -1 && y[o]) return p.concat(y)
            }
        }
        return p
    }, []), f6 = r => console && typeof console.warn == "function" && console.warn(r), Fg = (r, l, p) => {
        const y = {};
        return p.filter(T => Array.isArray(T[r]) ? !0 : (typeof T[r] < "u" && f6(`Helmet: ${r} should be of type "Array". Instead found type "${typeof T[r]}"`), !1)).map(T => T[r]).reverse().reduce((T, A) => {
            const D = {};
            A.filter(j => {
                let q;
                const ee = Object.keys(j);
                for (let de = 0; de < ee.length; de += 1) {
                    const ae = ee[de], Re = ae.toLowerCase();
                    l.indexOf(Re) !== -1 && !(q === "rel" && j[q].toLowerCase() === "canonical") && !(Re === "rel" && j[Re].toLowerCase() === "stylesheet") && (q = Re), l.indexOf(ae) !== -1 && (ae === "innerHTML" || ae === "cssText" || ae === "itemprop") && (q = ae)
                }
                if (!q || !j[q]) return !1;
                const oe = j[q].toLowerCase();
                return y[q] || (y[q] = {}), D[q] || (D[q] = {}), y[q][oe] ? !1 : (D[q][oe] = !0, !0)
            }).reverse().forEach(j => T.push(j));
            const o = Object.keys(D);
            for (let j = 0; j < o.length; j += 1) {
                const q = o[j], ee = {...y[q], ...D[q]};
                y[q] = ee
            }
            return T
        }, []).reverse()
    }, p6 = (r, l) => {
        if (Array.isArray(r) && r.length) {
            for (let p = 0; p < r.length; p += 1) if (r[p][l]) return !0
        }
        return !1
    }, m6 = r => ({
        baseTag: d6(["href"], r),
        bodyAttributes: gb("bodyAttributes", r),
        defer: Jf(r, Qf.DEFER),
        encode: Jf(r, Qf.ENCODE_SPECIAL_CHARACTERS),
        htmlAttributes: gb("htmlAttributes", r),
        linkTags: Fg("link", ["rel", "href"], r),
        metaTags: Fg("meta", ["name", "charset", "http-equiv", "property", "itemprop"], r),
        noscriptTags: Fg("noscript", ["innerHTML"], r),
        onChangeClientState: h6(r),
        scriptTags: Fg("script", ["src", "innerHTML"], r),
        styleTags: Fg("style", ["cssText"], r),
        title: u6(r),
        titleAttributes: gb("titleAttributes", r),
        prioritizeSeoTags: p6(r, Qf.PRIORITIZE_SEO_TAGS)
    }), qD = r => Array.isArray(r) ? r.join("") : r, g6 = (r, l) => {
        const p = Object.keys(r);
        for (let y = 0; y < p.length; y += 1) if (l[p[y]] && l[p[y]].includes(r[p[y]])) return !0;
        return !1
    }, _b = (r, l) => Array.isArray(r) ? r.reduce((p, y) => (g6(y, l) ? p.priority.push(y) : p.default.push(y), p), {
        priority: [],
        default: []
    }) : {default: r, priority: []}, DP = (r, l) => ({...r, [l]: void 0}), _6 = ["noscript", "script", "style"],
    IT = (r, l = !0) => l === !1 ? String(r) : String(r).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;"),
    WD = r => Object.keys(r).reduce((l, p) => {
        const y = typeof r[p] < "u" ? `${p}="${r[p]}"` : `${p}`;
        return l ? `${l} ${y}` : y
    }, ""), y6 = (r, l, p, y) => {
        const T = WD(p), A = qD(l);
        return T ? `<${r} ${La}="true" ${T}>${IT(A, y)}</${r}>` : `<${r} ${La}="true">${IT(A, y)}</${r}>`
    }, v6 = (r, l, p = !0) => l.reduce((y, T) => {
        const A = T, D = Object.keys(A).filter(q => !(q === "innerHTML" || q === "cssText")).reduce((q, ee) => {
            const oe = typeof A[ee] > "u" ? ee : `${ee}="${IT(A[ee], p)}"`;
            return q ? `${q} ${oe}` : oe
        }, ""), o = A.innerHTML || A.cssText || "", j = _6.indexOf(r) === -1;
        return `${y}<${r} ${La}="true" ${D}${j ? "/>" : `>${o}</${r}>`}`
    }, ""), ZD = (r, l = {}) => Object.keys(r).reduce((p, y) => {
        const T = G2[y];
        return p[T || y] = r[y], p
    }, l), x6 = (r, l, p) => {
        const y = {key: l, [La]: !0}, T = ZD(p, y);
        return [jt.createElement("title", T, l)]
    }, xv = (r, l) => l.map((p, y) => {
        const T = {key: y, [La]: !0};
        return Object.keys(p).forEach(A => {
            const o = G2[A] || A;
            if (o === "innerHTML" || o === "cssText") {
                const j = p.innerHTML || p.cssText;
                T.dangerouslySetInnerHTML = {__html: j}
            } else T[o] = p[A]
        }), jt.createElement(r, T)
    }), ra = (r, l, p = !0) => {
        switch (r) {
            case"title":
                return {
                    toComponent: () => x6(r, l.title, l.titleAttributes),
                    toString: () => y6(r, l.title, l.titleAttributes, p)
                };
            case"bodyAttributes":
            case"htmlAttributes":
                return {toComponent: () => ZD(l), toString: () => WD(l)};
            default:
                return {toComponent: () => xv(r, l), toString: () => v6(r, l, p)}
        }
    }, w6 = ({metaTags: r, linkTags: l, scriptTags: p, encode: y}) => {
        const T = _b(r, mb.meta), A = _b(l, mb.link), D = _b(p, mb.script);
        return {
            priorityMethods: {
                toComponent: () => [...xv("meta", T.priority), ...xv("link", A.priority), ...xv("script", D.priority)],
                toString: () => `${ra("meta", T.priority, y)} ${ra("link", A.priority, y)} ${ra("script", D.priority, y)}`
            }, metaTags: T.default, linkTags: A.default, scriptTags: D.default
        }
    }, b6 = r => {
        const {
            baseTag: l,
            bodyAttributes: p,
            encode: y = !0,
            htmlAttributes: T,
            noscriptTags: A,
            styleTags: D,
            title: o = "",
            titleAttributes: j,
            prioritizeSeoTags: q
        } = r;
        let {linkTags: ee, metaTags: oe, scriptTags: de} = r, ae = {
            toComponent: () => {
            }, toString: () => ""
        };
        return q && ({priorityMethods: ae, linkTags: ee, metaTags: oe, scriptTags: de} = w6(r)), {
            priority: ae,
            base: ra("base", l, y),
            bodyAttributes: ra("bodyAttributes", p, y),
            htmlAttributes: ra("htmlAttributes", T, y),
            link: ra("link", ee, y),
            meta: ra("meta", oe, y),
            noscript: ra("noscript", A, y),
            script: ra("script", de, y),
            style: ra("style", D, y),
            title: ra("title", {title: o, titleAttributes: j}, y)
        }
    }, CT = b6, nv = [], XD = !!(typeof window < "u" && window.document && window.document.createElement), PT = class {
        constructor(r, l) {
            ec(this, "instances", []);
            ec(this, "canUseDOM", XD);
            ec(this, "context");
            ec(this, "value", {
                setHelmet: r => {
                    this.context.helmet = r
                }, helmetInstances: {
                    get: () => this.canUseDOM ? nv : this.instances, add: r => {
                        (this.canUseDOM ? nv : this.instances).push(r)
                    }, remove: r => {
                        const l = (this.canUseDOM ? nv : this.instances).indexOf(r);
                        (this.canUseDOM ? nv : this.instances).splice(l, 1)
                    }
                }
            });
            this.context = r, this.canUseDOM = l || !1, l || (r.helmet = CT({
                baseTag: [],
                bodyAttributes: {},
                encodeSpecialCharacters: !0,
                htmlAttributes: {},
                linkTags: [],
                metaTags: [],
                noscriptTags: [],
                scriptTags: [],
                styleTags: [],
                title: "",
                titleAttributes: {}
            }))
        }
    }, T6 = {}, YD = jt.createContext(T6), Kh, KD = (Kh = class extends Ce.Component {
        constructor(p) {
            super(p);
            ec(this, "helmetData");
            this.helmetData = new PT(this.props.context || {}, Kh.canUseDOM)
        }

        render() {
            return jt.createElement(YD.Provider, {value: this.helmetData.value}, this.props.children)
        }
    }, ec(Kh, "canUseDOM", XD), Kh), Mf = (r, l) => {
        const p = document.head || document.querySelector("head"), y = p.querySelectorAll(`${r}[${La}]`),
            T = [].slice.call(y), A = [];
        let D;
        return l && l.length && l.forEach(o => {
            const j = document.createElement(r);
            for (const q in o) if (Object.prototype.hasOwnProperty.call(o, q)) if (q === "innerHTML") j.innerHTML = o.innerHTML; else if (q === "cssText") j.styleSheet ? j.styleSheet.cssText = o.cssText : j.appendChild(document.createTextNode(o.cssText)); else {
                const ee = q, oe = typeof o[ee] > "u" ? "" : o[ee];
                j.setAttribute(q, oe)
            }
            j.setAttribute(La, "true"), T.some((q, ee) => (D = ee, j.isEqualNode(q))) ? T.splice(D, 1) : A.push(j)
        }), T.forEach(o => {
            var j;
            return (j = o.parentNode) == null ? void 0 : j.removeChild(o)
        }), A.forEach(o => p.appendChild(o)), {oldTags: T, newTags: A}
    }, MT = (r, l) => {
        const p = document.getElementsByTagName(r)[0];
        if (!p) return;
        const y = p.getAttribute(La), T = y ? y.split(",") : [], A = [...T], D = Object.keys(l);
        for (const o of D) {
            const j = l[o] || "";
            p.getAttribute(o) !== j && p.setAttribute(o, j), T.indexOf(o) === -1 && T.push(o);
            const q = A.indexOf(o);
            q !== -1 && A.splice(q, 1)
        }
        for (let o = A.length - 1; o >= 0; o -= 1) p.removeAttribute(A[o]);
        T.length === A.length ? p.removeAttribute(La) : p.getAttribute(La) !== D.join(",") && p.setAttribute(La, D.join(","))
    }, S6 = (r, l) => {
        typeof r < "u" && document.title !== r && (document.title = qD(r)), MT("title", l)
    }, LP = (r, l) => {
        const {
            baseTag: p,
            bodyAttributes: y,
            htmlAttributes: T,
            linkTags: A,
            metaTags: D,
            noscriptTags: o,
            onChangeClientState: j,
            scriptTags: q,
            styleTags: ee,
            title: oe,
            titleAttributes: de
        } = r;
        MT("body", y), MT("html", T), S6(oe, de);
        const ae = {
            baseTag: Mf("base", p),
            linkTags: Mf("link", A),
            metaTags: Mf("meta", D),
            noscriptTags: Mf("noscript", o),
            scriptTags: Mf("script", q),
            styleTags: Mf("style", ee)
        }, Re = {}, fe = {};
        Object.keys(ae).forEach(Me => {
            const {newTags: pe, oldTags: le} = ae[Me];
            pe.length && (Re[Me] = pe), le.length && (fe[Me] = ae[Me].oldTags)
        }), l && l(), j(r, Re, fe)
    }, Bg = null, E6 = r => {
        Bg && cancelAnimationFrame(Bg), r.defer ? Bg = requestAnimationFrame(() => {
            LP(r, () => {
                Bg = null
            })
        }) : (LP(r), Bg = null)
    }, A6 = E6, kP = class extends Ce.Component {
        constructor() {
            super(...arguments);
            ec(this, "rendered", !1)
        }

        shouldComponentUpdate(l) {
            return !l6(l, this.props)
        }

        componentDidUpdate() {
            this.emitChange()
        }

        componentWillUnmount() {
            const {helmetInstances: l} = this.props.context;
            l.remove(this), this.emitChange()
        }

        emitChange() {
            const {helmetInstances: l, setHelmet: p} = this.props.context;
            let y = null;
            const T = m6(l.get().map(A => {
                const D = {...A.props};
                return delete D.context, D
            }));
            KD.canUseDOM ? A6(T) : CT && (y = CT(T)), p(y)
        }

        init() {
            if (this.rendered) return;
            this.rendered = !0;
            const {helmetInstances: l} = this.props.context;
            l.add(this), this.emitChange()
        }

        render() {
            return this.init(), null
        }
    }, vb, kx = (vb = class extends Ce.Component {
        shouldComponentUpdate(r) {
            return !r6(DP(this.props, "helmetData"), DP(r, "helmetData"))
        }

        mapNestedChildrenToProps(r, l) {
            if (!l) return null;
            switch (r.type) {
                case"script":
                case"noscript":
                    return {innerHTML: l};
                case"style":
                    return {cssText: l};
                default:
                    throw new Error(`<${r.type} /> elements are self-closing and can not contain children. Refer to our API for more information.`)
            }
        }

        flattenArrayTypeChildren(r, l, p, y) {
            return {...l, [r.type]: [...l[r.type] || [], {...p, ...this.mapNestedChildrenToProps(r, y)}]}
        }

        mapObjectTypeChildren(r, l, p, y) {
            switch (r.type) {
                case"title":
                    return {...l, [r.type]: y, titleAttributes: {...p}};
                case"body":
                    return {...l, bodyAttributes: {...p}};
                case"html":
                    return {...l, htmlAttributes: {...p}};
                default:
                    return {...l, [r.type]: {...p}}
            }
        }

        mapArrayTypeChildrenToProps(r, l) {
            let p = {...l};
            return Object.keys(r).forEach(y => {
                p = {...p, [y]: r[y]}
            }), p
        }

        warnOnInvalidChildren(r, l) {
            return RP(zP.some(p => r.type === p), typeof r.type == "function" ? "You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information." : `Only elements types ${zP.join(", ")} are allowed. Helmet does not support rendering <${r.type}> elements. Refer to our API for more information.`), RP(!l || typeof l == "string" || Array.isArray(l) && !l.some(p => typeof p != "string"), `Helmet expects a string as a child of <${r.type}>. Did you forget to wrap your children in braces? ( <${r.type}>{\`\`}</${r.type}> ) Refer to our API for more information.`), !0
        }

        mapChildrenToProps(r, l) {
            let p = {};
            return jt.Children.forEach(r, y => {
                if (!y || !y.props) return;
                const {children: T, ...A} = y.props, D = Object.keys(A).reduce((j, q) => (j[c6[q] || q] = A[q], j), {});
                let {type: o} = y;
                switch (typeof o == "symbol" ? o = o.toString() : this.warnOnInvalidChildren(y, T), o) {
                    case"Symbol(react.fragment)":
                        l = this.mapChildrenToProps(T, l);
                        break;
                    case"link":
                    case"meta":
                    case"noscript":
                    case"script":
                    case"style":
                        p = this.flattenArrayTypeChildren(y, p, D, T);
                        break;
                    default:
                        l = this.mapObjectTypeChildren(y, l, D, T);
                        break
                }
            }), this.mapArrayTypeChildrenToProps(p, l)
        }

        render() {
            const {children: r, ...l} = this.props;
            let p = {...l}, {helmetData: y} = l;
            if (r && (p = this.mapChildrenToProps(r, p)), y && !(y instanceof PT)) {
                const T = y;
                y = new PT(T.context, !0), delete p.helmetData
            }
            return y ? jt.createElement(kP, {
                ...p,
                context: y.value
            }) : jt.createElement(YD.Consumer, null, T => jt.createElement(kP, {...p, context: T}))
        }
    }, ec(vb, "defaultProps", {defer: !0, encodeSpecialCharacters: !0, prioritizeSeoTags: !1}), vb);
const I6 = () => K.jsx("header", {
        className: "sticky top-0 z-40 w-full border-b bg-background/80 backdrop-blur supports-[backdrop-filter]:bg-background/60",
        children: K.jsxs("nav", {
            className: "container flex h-16 items-center justify-between",
            children: [K.jsxs(ca, {
                to: "/",
                className: "flex items-center gap-3",
                children: [K.jsx("img", {
                    src: "/surajna-legal-bloom/lovable-uploads/5f0548f5-4c38-4bd1-8a9d-75d0727eecec.png",
                    alt: "Surajna Group logo",
                    className: "h-10 w-10 object-contain",
                    loading: "lazy"
                }), K.jsx("span", {className: "font-display text-xl", children: "Surajna Group"})]
            }), K.jsxs("div", {
                className: "hidden md:flex items-center gap-8",
                children: [K.jsx(iv, {
                    to: "/",
                    className: ({isActive: r}) => `text-sm ${r ? "text-primary" : "text-muted-foreground hover:text-foreground transition-colors"}`,
                    children: "Home"
                }), K.jsx(iv, {
                    to: "/about",
                    className: ({isActive: r}) => `text-sm ${r ? "text-primary" : "text-muted-foreground hover:text-foreground transition-colors"}`,
                    children: "About"
                }), K.jsx(iv, {
                    to: "/blog",
                    className: ({isActive: r}) => `text-sm ${r ? "text-primary" : "text-muted-foreground hover:text-foreground transition-colors"}`,
                    children: "Blog"
                }), K.jsx(iv, {
                    to: "/contact",
                    className: ({isActive: r}) => `text-sm ${r ? "text-primary" : "text-muted-foreground hover:text-foreground transition-colors"}`,
                    children: "Contact"
                }), K.jsx(ca, {
                    to: "/contact",
                    className: "inline-flex h-9 items-center justify-center rounded-md bg-primary px-4 text-sm font-medium text-primary-foreground shadow-sm transition-colors hover:opacity-90",
                    children: "Get Started"
                })]
            })]
        })
    }), C6 = () => {
        const r = new Date().getFullYear();
        return K.jsxs("footer", {
            className: "border-t bg-background", children: [K.jsxs("div", {
                className: "container py-12 grid gap-8 md:grid-cols-4",
                children: [K.jsxs("div", {
                    children: [K.jsxs("div", {
                        className: "flex items-center gap-3",
                        children: [K.jsx("img", {
                            src: "/surajna-legal-bloom/lovable-uploads/5f0548f5-4c38-4bd1-8a9d-75d0727eecec.png",
                            alt: "Surajna Group logo",
                            className: "h-8 w-8"
                        }), K.jsx("span", {className: "font-display text-xl", children: "Surajna Group"})]
                    }), K.jsx("p", {
                        className: "mt-4 text-sm text-muted-foreground",
                        children: "Your partner in business growth & brand protection."
                    })]
                }), K.jsxs("div", {
                    children: [K.jsx("h3", {
                        className: "font-medium mb-3",
                        children: "Quick Links"
                    }), K.jsxs("ul", {
                        className: "space-y-2 text-sm",
                        children: [K.jsx("li", {
                            children: K.jsx(ca, {
                                to: "/",
                                className: "hover:text-primary transition-colors",
                                children: "Home"
                            })
                        }), K.jsx("li", {
                            children: K.jsx(ca, {
                                to: "/about",
                                className: "hover:text-primary transition-colors",
                                children: "About"
                            })
                        }), K.jsx("li", {
                            children: K.jsx(ca, {
                                to: "/blog",
                                className: "hover:text-primary transition-colors",
                                children: "Blog"
                            })
                        }), K.jsx("li", {
                            children: K.jsx(ca, {
                                to: "/contact",
                                className: "hover:text-primary transition-colors",
                                children: "Contact"
                            })
                        })]
                    })]
                }), K.jsxs("div", {
                    children: [K.jsx("h3", {
                        className: "font-medium mb-3",
                        children: "Services"
                    }), K.jsxs("ul", {
                        className: "space-y-2 text-sm",
                        children: [K.jsx("li", {children: "Company Registration"}), K.jsx("li", {children: "Trademark Registration"}), K.jsx("li", {children: "Corporate Compliance"}), K.jsx("li", {children: "Startup Launch & Legal Setup"}), K.jsx("li", {children: "Accounting & Reporting"}), K.jsx("li", {children: "Taxation & Compliance"}), K.jsx("li", {children: "Strategic Financial Advisory"}), K.jsx("li", {children: "Global Expansion Support"}), K.jsx("li", {children: "Intellectual Property Protection"})]
                    })]
                }), K.jsxs("div", {
                    children: [K.jsx("h3", {
                        className: "font-medium mb-3",
                        children: "Contact"
                    }), K.jsxs("ul", {
                        className: "space-y-2 text-sm",
                        children: [K.jsx("li", {children: "Email: contact@surajnagroup.in"}), K.jsx("li", {children: "Phone: +91-00000-00000"}), K.jsx("li", {children: "WhatsApp: to be provided"})]
                    })]
                })]
            }), K.jsxs("div", {
                className: "border-t py-4 text-center text-xs text-muted-foreground",
                children: ["© ", r, " Surajna Group. All rights reserved."]
            })]
        })
    },
    P6 = Lz("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0", {
        variants: {
            variant: {
                default: "bg-primary text-primary-foreground hover:bg-primary/90",
                destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
                outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
                secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
                ghost: "hover:bg-accent hover:text-accent-foreground",
                link: "text-primary underline-offset-4 hover:underline"
            },
            size: {default: "h-10 px-4 py-2", sm: "h-9 rounded-md px-3", lg: "h-11 rounded-md px-8", icon: "h-10 w-10"}
        }, defaultVariants: {variant: "default", size: "default"}
    }), yp = Ce.forwardRef(({className: r, variant: l, size: p, asChild: y = !1, ...T}, A) => {
        const D = y ? IN : "button";
        return K.jsx(D, {className: ao(P6({variant: l, size: p, className: r})), ref: A, ...T})
    });
yp.displayName = "Button";
const $o = Ce.forwardRef(({className: r, ...l}, p) => K.jsx("div", {
    ref: p,
    className: ao("rounded-lg border bg-card text-card-foreground shadow-sm", r), ...l
}));
$o.displayName = "Card";
const M6 = Ce.forwardRef(({className: r, ...l}, p) => K.jsx("div", {
    ref: p,
    className: ao("flex flex-col space-y-1.5 p-6", r), ...l
}));
M6.displayName = "CardHeader";
const R6 = Ce.forwardRef(({className: r, ...l}, p) => K.jsx("h3", {
    ref: p,
    className: ao("text-2xl font-semibold leading-none tracking-tight", r), ...l
}));
R6.displayName = "CardTitle";
const z6 = Ce.forwardRef(({className: r, ...l}, p) => K.jsx("p", {
    ref: p,
    className: ao("text-sm text-muted-foreground", r), ...l
}));
z6.displayName = "CardDescription";
const Ho = Ce.forwardRef(({className: r, ...l}, p) => K.jsx("div", {ref: p, className: ao("p-6 pt-0", r), ...l}));
Ho.displayName = "CardContent";
const D6 = Ce.forwardRef(({className: r, ...l}, p) => K.jsx("div", {
    ref: p,
    className: ao("flex items-center p-6 pt-0", r), ...l
}));
D6.displayName = "CardFooter";
var Ox = "Collapsible", [L6, QD] = Tp(Ox), [k6, $2] = L6(Ox), JD = Ce.forwardRef((r, l) => {
    const {
        __scopeCollapsible: p,
        open: y,
        defaultOpen: T,
        disabled: A,
        onOpenChange: D,
        ...o
    } = r, [j, q] = bx({prop: y, defaultProp: T ?? !1, onChange: D, caller: Ox});
    return K.jsx(k6, {
        scope: p,
        disabled: A,
        contentId: Xz(),
        open: j,
        onOpenToggle: Ce.useCallback(() => q(ee => !ee), [q]),
        children: K.jsx(so.div, {"data-state": q2(j), "data-disabled": A ? "" : void 0, ...o, ref: l})
    })
});
JD.displayName = Ox;
var eL = "CollapsibleTrigger", tL = Ce.forwardRef((r, l) => {
    const {__scopeCollapsible: p, ...y} = r, T = $2(eL, p);
    return K.jsx(so.button, {
        type: "button",
        "aria-controls": T.contentId,
        "aria-expanded": T.open || !1,
        "data-state": q2(T.open),
        "data-disabled": T.disabled ? "" : void 0,
        disabled: T.disabled, ...y,
        ref: l,
        onClick: Vr(r.onClick, T.onOpenToggle)
    })
});
tL.displayName = eL;
var H2 = "CollapsibleContent", iL = Ce.forwardRef((r, l) => {
    const {forceMount: p, ...y} = r, T = $2(H2, r.__scopeCollapsible);
    return K.jsx(wx, {present: p || T.open, children: ({present: A}) => K.jsx(O6, {...y, ref: l, present: A})})
});
iL.displayName = H2;
var O6 = Ce.forwardRef((r, l) => {
    const {__scopeCollapsible: p, present: y, children: T, ...A} = r, D = $2(H2, p), [o, j] = Ce.useState(y),
        q = Ce.useRef(null), ee = Ws(l, q), oe = Ce.useRef(0), de = oe.current, ae = Ce.useRef(0), Re = ae.current,
        fe = D.open || o, Me = Ce.useRef(fe), pe = Ce.useRef(void 0);
    return Ce.useEffect(() => {
        const le = requestAnimationFrame(() => Me.current = !1);
        return () => cancelAnimationFrame(le)
    }, []), Il(() => {
        const le = q.current;
        if (le) {
            pe.current = pe.current || {
                transitionDuration: le.style.transitionDuration,
                animationName: le.style.animationName
            }, le.style.transitionDuration = "0s", le.style.animationName = "none";
            const be = le.getBoundingClientRect();
            oe.current = be.height, ae.current = be.width, Me.current || (le.style.transitionDuration = pe.current.transitionDuration, le.style.animationName = pe.current.animationName), j(y)
        }
    }, [D.open, y]), K.jsx(so.div, {
        "data-state": q2(D.open),
        "data-disabled": D.disabled ? "" : void 0,
        id: D.contentId,
        hidden: !fe, ...A,
        ref: ee,
        style: {
            "--radix-collapsible-content-height": de ? `${de}px` : void 0,
            "--radix-collapsible-content-width": Re ? `${Re}px` : void 0, ...r.style
        },
        children: fe && T
    })
});

function q2(r) {
    return r ? "open" : "closed"
}

var F6 = JD, B6 = tL, N6 = iL, j6 = Ce.createContext(void 0);

function V6(r) {
    const l = Ce.useContext(j6);
    return r || l || "ltr"
}

var ja = "Accordion",
    U6 = ["Home", "End", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"], [W2, G6, $6] = az(ja), [Fx, _8] = Tp(ja, [$6, QD]),
    Z2 = QD(), nL = jt.forwardRef((r, l) => {
        const {type: p, ...y} = r, T = y, A = y;
        return K.jsx(W2.Provider, {
            scope: r.__scopeAccordion,
            children: p === "multiple" ? K.jsx(Z6, {...A, ref: l}) : K.jsx(W6, {...T, ref: l})
        })
    });
nL.displayName = ja;
var [rL, H6] = Fx(ja), [oL, q6] = Fx(ja, {collapsible: !1}), W6 = jt.forwardRef((r, l) => {
    const {
        value: p, defaultValue: y, onValueChange: T = () => {
        }, collapsible: A = !1, ...D
    } = r, [o, j] = bx({prop: p, defaultProp: y ?? "", onChange: T, caller: ja});
    return K.jsx(rL, {
        scope: r.__scopeAccordion,
        value: jt.useMemo(() => o ? [o] : [], [o]),
        onItemOpen: j,
        onItemClose: jt.useCallback(() => A && j(""), [A, j]),
        children: K.jsx(oL, {scope: r.__scopeAccordion, collapsible: A, children: K.jsx(sL, {...D, ref: l})})
    })
}), Z6 = jt.forwardRef((r, l) => {
    const {
            value: p, defaultValue: y, onValueChange: T = () => {
            }, ...A
        } = r, [D, o] = bx({prop: p, defaultProp: y ?? [], onChange: T, caller: ja}),
        j = jt.useCallback(ee => o((oe = []) => [...oe, ee]), [o]),
        q = jt.useCallback(ee => o((oe = []) => oe.filter(de => de !== ee)), [o]);
    return K.jsx(rL, {
        scope: r.__scopeAccordion,
        value: D,
        onItemOpen: j,
        onItemClose: q,
        children: K.jsx(oL, {scope: r.__scopeAccordion, collapsible: !0, children: K.jsx(sL, {...A, ref: l})})
    })
}), [X6, Bx] = Fx(ja), sL = jt.forwardRef((r, l) => {
    const {__scopeAccordion: p, disabled: y, dir: T, orientation: A = "vertical", ...D} = r, o = jt.useRef(null),
        j = Ws(o, l), q = G6(p), oe = V6(T) === "ltr", de = Vr(r.onKeyDown, ae => {
            var Mt;
            if (!U6.includes(ae.key)) return;
            const Re = ae.target, fe = q().filter(Xt => {
                var Zt;
                return !((Zt = Xt.ref.current) != null && Zt.disabled)
            }), Me = fe.findIndex(Xt => Xt.ref.current === Re), pe = fe.length;
            if (Me === -1) return;
            ae.preventDefault();
            let le = Me;
            const be = 0, Ue = pe - 1, et = () => {
                le = Me + 1, le > Ue && (le = be)
            }, _t = () => {
                le = Me - 1, le < be && (le = Ue)
            };
            switch (ae.key) {
                case"Home":
                    le = be;
                    break;
                case"End":
                    le = Ue;
                    break;
                case"ArrowRight":
                    A === "horizontal" && (oe ? et() : _t());
                    break;
                case"ArrowDown":
                    A === "vertical" && et();
                    break;
                case"ArrowLeft":
                    A === "horizontal" && (oe ? _t() : et());
                    break;
                case"ArrowUp":
                    A === "vertical" && _t();
                    break
            }
            const xt = le % pe;
            (Mt = fe[xt].ref.current) == null || Mt.focus()
        });
    return K.jsx(X6, {
        scope: p,
        disabled: y,
        direction: T,
        orientation: A,
        children: K.jsx(W2.Slot, {
            scope: p,
            children: K.jsx(so.div, {...D, "data-orientation": A, ref: j, onKeyDown: y ? void 0 : de})
        })
    })
}), rx = "AccordionItem", [Y6, X2] = Fx(rx), aL = jt.forwardRef((r, l) => {
    const {__scopeAccordion: p, value: y, ...T} = r, A = Bx(rx, p), D = H6(rx, p), o = Z2(p), j = Xz(),
        q = y && D.value.includes(y) || !1, ee = A.disabled || r.disabled;
    return K.jsx(Y6, {
        scope: p,
        open: q,
        disabled: ee,
        triggerId: j,
        children: K.jsx(F6, {
            "data-orientation": A.orientation,
            "data-state": fL(q), ...o, ...T,
            ref: l,
            disabled: ee,
            open: q,
            onOpenChange: oe => {
                oe ? D.onItemOpen(y) : D.onItemClose(y)
            }
        })
    })
});
aL.displayName = rx;
var lL = "AccordionHeader", cL = jt.forwardRef((r, l) => {
    const {__scopeAccordion: p, ...y} = r, T = Bx(ja, p), A = X2(lL, p);
    return K.jsx(so.h3, {
        "data-orientation": T.orientation,
        "data-state": fL(A.open),
        "data-disabled": A.disabled ? "" : void 0, ...y,
        ref: l
    })
});
cL.displayName = lL;
var RT = "AccordionTrigger", uL = jt.forwardRef((r, l) => {
    const {__scopeAccordion: p, ...y} = r, T = Bx(ja, p), A = X2(RT, p), D = q6(RT, p), o = Z2(p);
    return K.jsx(W2.ItemSlot, {
        scope: p,
        children: K.jsx(B6, {
            "aria-disabled": A.open && !D.collapsible || void 0,
            "data-orientation": T.orientation,
            id: A.triggerId, ...o, ...y,
            ref: l
        })
    })
});
uL.displayName = RT;
var hL = "AccordionContent", dL = jt.forwardRef((r, l) => {
    const {__scopeAccordion: p, ...y} = r, T = Bx(ja, p), A = X2(hL, p), D = Z2(p);
    return K.jsx(N6, {
        role: "region",
        "aria-labelledby": A.triggerId,
        "data-orientation": T.orientation, ...D, ...y,
        ref: l,
        style: {
            "--radix-accordion-content-height": "var(--radix-collapsible-content-height)",
            "--radix-accordion-content-width": "var(--radix-collapsible-content-width)", ...r.style
        }
    })
});
dL.displayName = hL;

function fL(r) {
    return r ? "open" : "closed"
}

var K6 = nL, Q6 = aL, J6 = cL, pL = uL, mL = dL;
const e8 = K6, wv = Ce.forwardRef(({className: r, ...l}, p) => K.jsx(Q6, {ref: p, className: ao("border-b", r), ...l}));
wv.displayName = "AccordionItem";
const bv = Ce.forwardRef(({className: r, children: l, ...p}, y) => K.jsx(J6, {
    className: "flex",
    children: K.jsxs(pL, {
        ref: y,
        className: ao("flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180", r), ...p,
        children: [l, K.jsx(w5, {className: "h-4 w-4 shrink-0 transition-transform duration-200"})]
    })
}));
bv.displayName = pL.displayName;
const Tv = Ce.forwardRef(({className: r, children: l, ...p}, y) => K.jsx(mL, {
    ref: y,
    className: "overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down", ...p,
    children: K.jsx("div", {className: ao("pb-4 pt-0", r), children: l})
}));
Tv.displayName = mL.displayName;
const t8 = () => {
    const r = typeof window < "u" ? window.location.href : "/";
    return K.jsxs("main", {
        children: [K.jsxs(kx, {
            children: [K.jsx("title", {children: "Surajna Group – Company Registration & Trademark Services"}), K.jsx("meta", {
                name: "description",
                content: "Company Registration in India, Trademark Registration Services, and Corporate Compliance. Surajna Group is your trusted partner."
            }), K.jsx("link", {rel: "canonical", href: r}), K.jsx("link", {
                rel: "icon",
                href: "/surajna-legal-bloom/lovable-uploads/5f0548f5-4c38-4bd1-8a9d-75d0727eecec.png"
            })]
        }), K.jsxs("section", {
            className: "relative overflow-hidden",
            children: [K.jsxs("div", {
                className: "absolute inset-0 -z-10",
                children: [K.jsx("div", {className: "absolute -top-24 -left-24 h-96 w-96 rounded-full bg-primary/10 blur-3xl"}), K.jsx("div", {className: "absolute -bottom-24 -right-24 h-96 w-96 rounded-full bg-accent/20 blur-3xl"})]
            }), K.jsxs("div", {
                className: "container flex min-h-[70vh] flex-col items-center justify-center text-center py-24",
                children: [K.jsx("img", {
                    src: "/surajna-legal-bloom/lovable-uploads/5f0548f5-4c38-4bd1-8a9d-75d0727eecec.png",
                    alt: "Surajna Group logo",
                    className: "h-28 max-w-28 object-contain",
                    loading: "lazy"
                }), K.jsx("h1", {
                    className: "font-display text-4xl md:text-6xl leading-tight max-w-4xl",
                    children: "Surajna Group – Your Partner in Business Growth & Protection"
                }), K.jsx("p", {
                    className: "mt-4 max-w-2xl text-muted-foreground",
                    children: "From startup launch to global expansion, we handle your legal, financial, and strategic needs so you can focus on building your vision. No paperwork headaches. No compliance chaos. Just seamless growth."
                }), K.jsxs("div", {
                    className: "mt-8 flex flex-wrap items-center justify-center gap-4",
                    children: [K.jsx(ca, {
                        to: "/contact",
                        children: K.jsx(yp, {className: "h-11 px-6", children: "Get Started"})
                    }), K.jsx(ca, {
                        to: "/contact",
                        children: K.jsx(yp, {
                            variant: "outline",
                            className: "h-11 px-6",
                            children: "Book a Free Consultation"
                        })
                    })]
                })]
            })]
        }), K.jsxs("section", {
            className: "container py-16",
            children: [K.jsx("h2", {
                className: "text-2xl md:text-3xl font-semibold text-center mb-10",
                children: "Services Overview"
            }), K.jsxs("div", {
                className: "grid gap-6 md:grid-cols-3",
                children: [K.jsx($o, {
                    className: "hover:shadow-lg transition-shadow",
                    children: K.jsxs(Ho, {
                        className: "p-6",
                        children: [K.jsx("div", {
                            className: "h-12 w-12 rounded-md bg-primary/10 text-primary inline-flex items-center justify-center mb-4",
                            children: K.jsx(Fz, {size: 24})
                        }), K.jsx("h3", {
                            className: "text-lg font-medium mb-2",
                            children: "Company Registration"
                        }), K.jsx("p", {
                            className: "text-sm text-muted-foreground",
                            children: "Seamless setup of your Private Limited, LLP, or OPC."
                        })]
                    })
                }), K.jsx($o, {
                    className: "hover:shadow-lg transition-shadow",
                    children: K.jsxs(Ho, {
                        className: "p-6",
                        children: [K.jsx("div", {
                            className: "h-12 w-12 rounded-md bg-primary/10 text-primary inline-flex items-center justify-center mb-4",
                            children: K.jsx(Oz, {size: 24})
                        }), K.jsx("h3", {
                            className: "text-lg font-medium mb-2",
                            children: "Trademark Registration"
                        }), K.jsx("p", {
                            className: "text-sm text-muted-foreground",
                            children: "Protect your brand identity with hassle-free trademark services."
                        })]
                    })
                }), K.jsx($o, {
                    className: "hover:shadow-lg transition-shadow",
                    children: K.jsxs(Ho, {
                        className: "p-6",
                        children: [K.jsx("div", {
                            className: "h-12 w-12 rounded-md bg-primary/10 text-primary inline-flex items-center justify-center mb-4",
                            children: K.jsx(Bz, {size: 24})
                        }), K.jsx("h3", {
                            className: "text-lg font-medium mb-2",
                            children: "Corporate Compliance"
                        }), K.jsx("p", {
                            className: "text-sm text-muted-foreground",
                            children: "End-to-end solutions for legal and tax compliance."
                        })]
                    })
                })]
            })]
        }), K.jsxs("section", {
            className: "container py-12",
            children: [K.jsx("h2", {
                className: "text-2xl md:text-3xl font-semibold text-center mb-8",
                children: "Why Choose Us"
            }), K.jsxs("ul", {
                className: "mx-auto grid max-w-3xl list-disc gap-3 pl-6 text-muted-foreground",
                children: [K.jsx("li", {children: "Over 10 years of combined expertise in business registration & IP protection"}), K.jsx("li", {children: "Transparent pricing, no hidden fees"}), K.jsx("li", {children: "End-to-end support from documentation to approval"}), K.jsx("li", {children: "Trusted by 500+ happy clients nationwide"})]
            })]
        }), K.jsxs("section", {
            className: "container py-12",
            children: [K.jsx("h2", {
                className: "text-2xl md:text-3xl font-semibold text-center mb-6",
                children: "FAQs"
            }), K.jsx("div", {
                className: "mx-auto max-w-3xl",
                children: K.jsxs(e8, {
                    type: "single",
                    collapsible: !0,
                    className: "w-full",
                    children: [K.jsxs(wv, {
                        value: "q1",
                        children: [K.jsx(bv, {children: "How long does company registration take?"}), K.jsx(Tv, {children: "Typically 5–10 working days depending on approvals and document readiness."})]
                    }), K.jsxs(wv, {
                        value: "q2",
                        children: [K.jsx(bv, {children: "What are the steps to register a trademark?"}), K.jsx(Tv, {children: "We search, file the application, respond to objections if any, and track until registration."})]
                    }), K.jsxs(wv, {
                        value: "q3",
                        children: [K.jsx(bv, {children: "Do you offer transparent pricing?"}), K.jsx(Tv, {children: "Yes. We share a fixed quote upfront with no hidden fees."})]
                    })]
                })
            })]
        }), K.jsxs("section", {
            className: "container py-16",
            children: [K.jsx("h2", {
                className: "text-2xl md:text-3xl font-semibold text-center mb-10",
                children: "What Clients Say"
            }), K.jsx("div", {
                className: "grid gap-6 md:grid-cols-3",
                children: [1, 2, 3].map(l => K.jsx($o, {
                    className: "hover:shadow-lg transition-shadow",
                    children: K.jsxs(Ho, {
                        className: "p-6",
                        children: [K.jsxs("div", {
                            className: "flex items-center gap-3 mb-4",
                            children: [K.jsx("img", {
                                src: "/placeholder.svg",
                                alt: "Client profile",
                                className: "h-10 w-10 rounded-full"
                            }), K.jsxs("div", {
                                children: [K.jsxs("p", {
                                    className: "text-sm font-medium",
                                    children: ["Happy Client ", l]
                                }), K.jsx("p", {className: "text-xs text-muted-foreground", children: "Founder"})]
                            })]
                        }), K.jsx("p", {
                            className: "text-sm text-muted-foreground",
                            children: "“Great support from start to finish. Highly recommended for startups!”"
                        })]
                    })
                }, l))
            })]
        }), K.jsxs("section", {
            className: "container py-12",
            children: [K.jsxs("div", {
                className: "flex items-center justify-between mb-6",
                children: [K.jsx("h2", {
                    className: "text-2xl font-semibold",
                    children: "From the Blog"
                }), K.jsx(ca, {to: "/blog", className: "text-sm text-primary", children: "View all →"})]
            }), K.jsx("div", {
                className: "grid gap-6 md:grid-cols-3",
                children: [1, 2, 3].map(l => K.jsx($o, {
                    children: K.jsxs(Ho, {
                        className: "p-6",
                        children: [K.jsxs("h3", {
                            className: "text-lg font-medium mb-2",
                            children: ["Sample Article ", l]
                        }), K.jsx("p", {
                            className: "text-sm text-muted-foreground",
                            children: "SEO tips on registration, trademarks, and compliance."
                        })]
                    })
                }, l))
            })]
        })]
    })
}, i8 = () => {
    const r = typeof window < "u" ? window.location.href : "/about";
    return K.jsxs("main", {
        className: "min-h-screen",
        children: [K.jsxs(kx, {
            children: [K.jsx("title", {children: "About Surajna Group | Who We Are"}), K.jsx("meta", {
                name: "description",
                content: "Surajna — Your Growth Partner in Business Success. From startup launch to global expansion, we handle your legal, financial, and strategic needs."
            }), K.jsx("link", {rel: "canonical", href: r})]
        }), K.jsx("section", {
            className: "container py-16", children: K.jsxs("div", {
                className: "relative overflow-hidden rounded-lg bg-gradient-to-r from-primary/10 to-accent/10 p-8 md:p-12",
                children: [K.jsx("div", {className: "absolute -top-24 -left-24 h-96 w-96 rounded-full bg-primary/10 blur-3xl"}), K.jsx("div", {className: "absolute -bottom-24 -right-24 h-96 w-96 rounded-full bg-accent/20 blur-3xl"}), K.jsxs("div", {
                    className: "relative",
                    children: [K.jsxs("h1", {
                        className: "font-display text-4xl md:text-5xl mb-4 flex items-center gap-2",
                        children: [K.jsx("img", {
                            src: "/surajna-legal-bloom/lovable-uploads/5f0548f5-4c38-4bd1-8a9d-75d0727eecec.png",
                            alt: "Surajna Group logo",
                            className: "h-15 max-w-20 object-contain"
                        }), "Surajna — Your Growth Partner in Business Success"]
                    }), K.jsx("p", {
                        className: "text-muted-foreground max-w-3xl text-lg mb-6",
                        children: "From startup launch to global expansion, we handle your legal, financial, and strategic needs so you can focus on building your vision. No paperwork headaches. No compliance chaos. Just seamless growth."
                    }), K.jsx("div", {
                        className: "flex flex-wrap gap-4",
                        children: K.jsx(ca, {
                            to: "/contact",
                            children: K.jsx(yp, {className: "h-11 px-6", children: "Book a Free Consultation"})
                        })
                    })]
                })]
            })
        }), K.jsxs("section", {
            className: "container py-12",
            children: [K.jsx("h2", {
                className: "text-3xl font-semibold mb-8 text-center",
                children: "🌟 Why Choose Surajna?"
            }), K.jsxs("div", {
                className: "grid gap-6 md:grid-cols-3",
                children: [K.jsx($o, {
                    className: "hover:shadow-lg transition-shadow",
                    children: K.jsxs(Ho, {
                        className: "p-6",
                        children: [K.jsx("h3", {
                            className: "text-xl font-medium mb-3",
                            children: "End-to-End Expertise"
                        }), K.jsx("p", {
                            className: "text-muted-foreground",
                            children: "From company incorporation to international structuring — we've got it all covered."
                        })]
                    })
                }), K.jsx($o, {
                    className: "hover:shadow-lg transition-shadow",
                    children: K.jsxs(Ho, {
                        className: "p-6",
                        children: [K.jsx("h3", {
                            className: "text-xl font-medium mb-3",
                            children: "Trusted by Founders & CEOs"
                        }), K.jsx("p", {
                            className: "text-muted-foreground",
                            children: "We act as your extended CFO & compliance team."
                        })]
                    })
                }), K.jsx($o, {
                    className: "hover:shadow-lg transition-shadow",
                    children: K.jsxs(Ho, {
                        className: "p-6",
                        children: [K.jsx("h3", {
                            className: "text-xl font-medium mb-3",
                            children: "Scalable Support"
                        }), K.jsx("p", {
                            className: "text-muted-foreground",
                            children: "Whether you're a bootstrapped startup or a growing enterprise, our solutions adapt to you."
                        })]
                    })
                })]
            })]
        }), K.jsxs("section", {
            className: "container py-12",
            children: [K.jsx("h2", {
                className: "text-3xl font-semibold mb-8 text-center",
                children: "📈 Our Services"
            }), K.jsxs("div", {
                className: "grid gap-8 md:grid-cols-2 lg:grid-cols-3",
                children: [K.jsx($o, {
                    className: "hover:shadow-lg transition-shadow",
                    children: K.jsxs(Ho, {
                        className: "p-6",
                        children: [K.jsx("div", {
                            className: "h-12 w-12 rounded-md bg-primary/10 text-primary inline-flex items-center justify-center mb-4",
                            children: K.jsx(Fz, {size: 24})
                        }), K.jsx("h3", {
                            className: "text-xl font-medium mb-3",
                            children: "Startup Launch & Legal Setup"
                        }), K.jsxs("ul", {
                            className: "space-y-2 text-muted-foreground",
                            children: [K.jsx("li", {children: "• Company incorporation & government registrations"}), K.jsx("li", {children: "• Intellectual property (IP) protection"}), K.jsx("li", {children: "• Legal documentation & advisory for risk-free operations"})]
                        })]
                    })
                }), K.jsx($o, {
                    className: "hover:shadow-lg transition-shadow",
                    children: K.jsxs(Ho, {
                        className: "p-6",
                        children: [K.jsx("div", {
                            className: "h-12 w-12 rounded-md bg-primary/10 text-primary inline-flex items-center justify-center mb-4",
                            children: K.jsx(Bz, {size: 24})
                        }), K.jsx("h3", {
                            className: "text-xl font-medium mb-3",
                            children: "Accounting & Reporting"
                        }), K.jsxs("ul", {
                            className: "space-y-2 text-muted-foreground",
                            children: [K.jsx("li", {children: "• Cloud-based bookkeeping for real-time accuracy"}), K.jsx("li", {children: "• Custom MIS reports & interactive dashboards"}), K.jsx("li", {children: "• Audit-ready financial documentation"})]
                        })]
                    })
                }), K.jsx($o, {
                    className: "hover:shadow-lg transition-shadow",
                    children: K.jsxs(Ho, {
                        className: "p-6",
                        children: [K.jsx("div", {
                            className: "h-12 w-12 rounded-md bg-primary/10 text-primary inline-flex items-center justify-center mb-4",
                            children: K.jsx(Oz, {size: 24})
                        }), K.jsx("h3", {
                            className: "text-xl font-medium mb-3",
                            children: "Taxation & Compliance"
                        }), K.jsxs("ul", {
                            className: "space-y-2 text-muted-foreground",
                            children: [K.jsx("li", {children: "• GST, TDS & Income Tax filing made simple"}), K.jsx("li", {children: "• Automated due-date tracking"}), K.jsx("li", {children: "• Regulatory alerts so you're always compliant"})]
                        })]
                    })
                }), K.jsx($o, {
                    className: "hover:shadow-lg transition-shadow",
                    children: K.jsxs(Ho, {
                        className: "p-6",
                        children: [K.jsx("div", {
                            className: "h-12 w-12 rounded-md bg-primary/10 text-primary inline-flex items-center justify-center mb-4",
                            children: K.jsx(x5, {size: 24})
                        }), K.jsx("h3", {
                            className: "text-xl font-medium mb-3",
                            children: "Strategic Financial Advisory"
                        }), K.jsxs("ul", {
                            className: "space-y-2 text-muted-foreground",
                            children: [K.jsx("li", {children: "• Financial modeling for smarter decisions"}), K.jsx("li", {children: "• Fundraising & investor pitch preparation"}), K.jsx("li", {children: "• Valuation, mergers & acquisitions planning"})]
                        })]
                    })
                }), K.jsx($o, {
                    className: "hover:shadow-lg transition-shadow",
                    children: K.jsxs(Ho, {
                        className: "p-6",
                        children: [K.jsx("div", {
                            className: "h-12 w-12 rounded-md bg-primary/10 text-primary inline-flex items-center justify-center mb-4",
                            children: K.jsx(b5, {size: 24})
                        }), K.jsx("h3", {
                            className: "text-xl font-medium mb-3",
                            children: "Global Expansion Support"
                        }), K.jsxs("ul", {
                            className: "space-y-2 text-muted-foreground",
                            children: [K.jsx("li", {children: "• Overseas incorporation & market entry strategy"}), K.jsx("li", {children: "• Transfer pricing & structuring compliance"}), K.jsx("li", {children: "• Virtual CFO services for cross-border operations"})]
                        })]
                    })
                })]
            })]
        }), K.jsxs("section", {
            className: "container py-12 bg-muted/30 rounded-lg my-12",
            children: [K.jsx("h2", {
                className: "text-3xl font-semibold mb-8 text-center",
                children: "🏭 Industries We Serve"
            }), K.jsxs("div", {
                className: "grid gap-4 sm:grid-cols-2 lg:grid-cols-3",
                children: [K.jsxs("div", {
                    className: "p-4",
                    children: [K.jsx("h3", {
                        className: "text-xl font-medium mb-2",
                        children: "Technology & SaaS"
                    }), K.jsx("p", {
                        className: "text-muted-foreground",
                        children: "Scalable frameworks for fast-moving startups"
                    })]
                }), K.jsxs("div", {
                    className: "p-4",
                    children: [K.jsx("h3", {
                        className: "text-xl font-medium mb-2",
                        children: "Healthcare & Pharma"
                    }), K.jsx("p", {
                        className: "text-muted-foreground",
                        children: "Precision compliance in sensitive industries"
                    })]
                }), K.jsxs("div", {
                    className: "p-4",
                    children: [K.jsx("h3", {
                        className: "text-xl font-medium mb-2",
                        children: "Retail & E-Commerce"
                    }), K.jsx("p", {className: "text-muted-foreground", children: "Data-driven growth & reporting"})]
                }), K.jsxs("div", {
                    className: "p-4",
                    children: [K.jsx("h3", {
                        className: "text-xl font-medium mb-2",
                        children: "Media & Creative Startups"
                    }), K.jsx("p", {
                        className: "text-muted-foreground",
                        children: "Flexible, project-based financial solutions"
                    })]
                }), K.jsxs("div", {
                    className: "p-4",
                    children: [K.jsx("h3", {
                        className: "text-xl font-medium mb-2",
                        children: "Manufacturing & Industrial"
                    }), K.jsx("p", {
                        className: "text-muted-foreground",
                        children: "Process-focused operational support"
                    })]
                }), K.jsxs("div", {
                    className: "p-4",
                    children: [K.jsx("h3", {
                        className: "text-xl font-medium mb-2",
                        children: "Real Estate & Infrastructure"
                    }), K.jsx("p", {
                        className: "text-muted-foreground",
                        children: "Structuring large-scale investments"
                    })]
                })]
            })]
        }), K.jsxs("section", {
            className: "container py-12",
            children: [K.jsx("h2", {
                className: "text-3xl font-semibold mb-8 text-center",
                children: "❤️ What Our Clients Say"
            }), K.jsxs("div", {
                className: "grid gap-6 md:grid-cols-2",
                children: [K.jsx($o, {
                    className: "hover:shadow-lg transition-shadow",
                    children: K.jsxs(Ho, {
                        className: "p-6",
                        children: [K.jsxs("div", {
                            className: "flex items-center gap-3 mb-4",
                            children: [K.jsx("div", {
                                className: "h-12 w-12 rounded-full bg-primary/10 text-primary inline-flex items-center justify-center",
                                children: K.jsx(iP, {size: 24})
                            }), K.jsxs("div", {
                                children: [K.jsx("p", {
                                    className: "text-lg font-medium",
                                    children: "Kritika T."
                                }), K.jsx("p", {
                                    className: "text-sm text-muted-foreground",
                                    children: "Co-Founder, MetaGlow Health"
                                })]
                            })]
                        }), K.jsx("p", {
                            className: "text-muted-foreground",
                            children: '"Surajna made our startup launch seamless — no paperwork worries, just progress. Their team feels like an extension of ours."'
                        })]
                    })
                }), K.jsx($o, {
                    className: "hover:shadow-lg transition-shadow",
                    children: K.jsxs(Ho, {
                        className: "p-6",
                        children: [K.jsxs("div", {
                            className: "flex items-center gap-3 mb-4",
                            children: [K.jsx("div", {
                                className: "h-12 w-12 rounded-full bg-primary/10 text-primary inline-flex items-center justify-center",
                                children: K.jsx(iP, {size: 24})
                            }), K.jsxs("div", {
                                children: [K.jsx("p", {
                                    className: "text-lg font-medium",
                                    children: "Rohan A."
                                }), K.jsx("p", {
                                    className: "text-sm text-muted-foreground",
                                    children: "CTO, Clustrix Retail"
                                })]
                            })]
                        }), K.jsx("p", {
                            className: "text-muted-foreground",
                            children: '"We raised funding while they handled compliance and reporting. Surajna helped us stay sharp during scale."'
                        })]
                    })
                })]
            })]
        }), K.jsxs("section", {
            className: "container py-12",
            children: [K.jsx("h2", {
                className: "text-3xl font-semibold mb-6",
                children: "Our Team"
            }), K.jsx("div", {
                className: "grid gap-6 sm:grid-cols-2 lg:grid-cols-3",
                children: [1, 2, 3].map(l => K.jsxs("article", {
                    className: "rounded-lg border bg-card p-6 shadow-sm",
                    children: [K.jsx("img", {
                        src: "/placeholder.svg",
                        alt: "Team member portrait",
                        className: "mb-4 h-32 w-32 rounded-full object-cover"
                    }), K.jsxs("h3", {
                        className: "text-lg font-medium",
                        children: ["Team Member ", l]
                    }), K.jsx("p", {
                        className: "text-sm text-muted-foreground",
                        children: "Expert in company formation and IP protection."
                    })]
                }, l))
            })]
        }), K.jsx("section", {
            className: "container py-12 mb-16", children: K.jsxs("div", {
                className: "rounded-lg border bg-card p-8",
                children: [K.jsx("h2", {
                    className: "text-3xl font-semibold mb-6 text-center",
                    children: "📞 Let's Build Your Business — The Right Way"
                }), K.jsxs("div", {
                    className: "grid gap-6 md:grid-cols-2 lg:grid-cols-3 text-center",
                    children: [K.jsxs("div", {
                        children: [K.jsx("h3", {
                            className: "text-lg font-medium mb-2",
                            children: "📍 Location"
                        }), K.jsx("p", {className: "text-muted-foreground", children: "Bengaluru, India"})]
                    }), K.jsxs("div", {
                        children: [K.jsx("h3", {
                            className: "text-lg font-medium mb-2",
                            children: "📱 WhatsApp"
                        }), K.jsx("p", {className: "text-muted-foreground", children: "+91 XXXXXXXXXX"})]
                    }), K.jsxs("div", {
                        children: [K.jsx("h3", {
                            className: "text-lg font-medium mb-2",
                            children: "📧 Email"
                        }), K.jsx("p", {className: "text-muted-foreground", children: "hello@surajna.com"})]
                    })]
                }), K.jsxs("div", {
                    className: "mt-8 text-center",
                    children: [K.jsxs("p", {
                        className: "text-lg mb-6",
                        children: ["🌐 Visit: ", K.jsx("a", {
                            href: "http://www.surajna.com",
                            className: "text-primary hover:underline",
                            children: "www.surajna.com"
                        })]
                    }), K.jsx("p", {
                        className: "text-lg font-medium",
                        children: "💡 Act now: Book your free 20-minute consultation and see how Surajna can save you time, money, and sleepless nights."
                    }), K.jsx("div", {
                        className: "mt-6",
                        children: K.jsx(ca, {
                            to: "/contact",
                            children: K.jsx(yp, {size: "lg", className: "px-8", children: "Book a Free Consultation"})
                        })
                    })]
                })]
            })
        })]
    })
}, n8 = () => {
    const r = typeof window < "u" ? window.location.href : "/blog", l = [{
        slug: "register-company-india",
        title: "How to Register a Company in India",
        excerpt: "A practical, step-by-step guide to your company incorporation."
    }, {
        slug: "benefits-trademark-registration",
        title: "Benefits of Trademark Registration",
        excerpt: "Why brand protection matters and how to get it right."
    }, {
        slug: "corporate-compliance-checklist",
        title: "Corporate Compliance Checklist for Startups",
        excerpt: "Stay compliant with this simple, actionable checklist."
    }];
    return K.jsxs("main", {
        className: "min-h-screen",
        children: [K.jsxs(kx, {
            children: [K.jsx("title", {children: "Blog | Company Registration & Trademark Guides"}), K.jsx("meta", {
                name: "description",
                content: "SEO-focused articles on business setup, trademark registration, and corporate compliance in India."
            }), K.jsx("link", {rel: "canonical", href: r})]
        }), K.jsxs("section", {
            className: "container py-16",
            children: [K.jsx("h1", {
                className: "font-display text-4xl md:text-5xl mb-6",
                children: "Insights & Guides"
            }), K.jsx("div", {
                className: "grid gap-6 md:grid-cols-2 lg:grid-cols-3",
                children: l.map(p => K.jsxs("article", {
                    className: "rounded-lg border bg-card p-6 shadow-sm",
                    children: [K.jsx("h2", {
                        className: "text-xl font-semibold mb-2",
                        children: p.title
                    }), K.jsx("p", {
                        className: "text-sm text-muted-foreground mb-4",
                        children: p.excerpt
                    }), K.jsx("a", {href: "#", className: "text-primary text-sm", children: "Read more →"})]
                }, p.slug))
            })]
        })]
    })
}, Gg = Ce.forwardRef(({className: r, type: l, ...p}, y) => K.jsx("input", {
    type: l,
    className: ao("flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", r),
    ref: y, ...p
}));
Gg.displayName = "Input";
const gL = Ce.forwardRef(({
                              className: r,
                              ...l
                          }, p) => K.jsx("textarea", {
    className: ao("flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", r),
    ref: p, ...l
}));
gL.displayName = "Textarea";
var _L = {exports: {}};
(function (r, l) {
    (function (p, y) {
        r.exports = y()
    })(XO, function () {
        var p, y, T;

        function A(o, j) {
            if (!p) p = j; else if (!y) y = j; else {
                var q = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + p + ")(sharedChunk); (" + y + ")(sharedChunk); self.onerror = null;",
                    ee = {};
                p(ee), T = j(ee), typeof window < "u" && window && window.URL && window.URL.createObjectURL && (T.workerUrl = window.URL.createObjectURL(new Blob([q], {type: "text/javascript"})))
            }
        }

        A(["exports"], function (o) {
            var j = 1e-6, q = typeof Float32Array < "u" ? Float32Array : Array;

            function ee(n, e) {
                var i = e[0], a = e[1], c = e[2], d = e[3], f = i * d - c * a;
                return f ? (n[0] = d * (f = 1 / f), n[1] = -a * f, n[2] = -c * f, n[3] = i * f, n) : null
            }

            function oe() {
                var n = new q(9);
                return q != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[5] = 0, n[6] = 0, n[7] = 0), n[0] = 1, n[4] = 1, n[8] = 1, n
            }

            function de(n, e) {
                var i = e[0], a = e[1], c = e[2], d = e[3], f = e[4], _ = e[5], x = e[6], w = e[7], E = e[8];
                return n[0] = f * E - _ * w, n[1] = c * w - a * E, n[2] = a * _ - c * f, n[3] = _ * x - d * E, n[4] = i * E - c * x, n[5] = c * d - i * _, n[6] = d * w - f * x, n[7] = a * x - i * w, n[8] = i * f - a * d, n
            }

            function ae(n, e, i) {
                var a = e[0], c = e[1], d = e[2], f = e[3], _ = e[4], x = e[5], w = e[6], E = e[7], I = e[8], C = i[0],
                    z = i[1], L = i[2], F = i[3], N = i[4], H = i[5], Y = i[6], X = i[7], J = i[8];
                return n[0] = C * a + z * f + L * w, n[1] = C * c + z * _ + L * E, n[2] = C * d + z * x + L * I, n[3] = F * a + N * f + H * w, n[4] = F * c + N * _ + H * E, n[5] = F * d + N * x + H * I, n[6] = Y * a + X * f + J * w, n[7] = Y * c + X * _ + J * E, n[8] = Y * d + X * x + J * I, n
            }

            function Re() {
                var n = new q(16);
                return q != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0), n[0] = 1, n[5] = 1, n[10] = 1, n[15] = 1, n
            }

            function fe(n) {
                return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n
            }

            function Me(n, e) {
                var i = e[0], a = e[1], c = e[2], d = e[3], f = e[4], _ = e[5], x = e[6], w = e[7], E = e[8], I = e[9],
                    C = e[10], z = e[11], L = e[12], F = e[13], N = e[14], H = e[15], Y = i * _ - a * f,
                    X = i * x - c * f, J = i * w - d * f, xe = a * x - c * _, ge = a * w - d * _, ye = c * w - d * x,
                    Ee = E * F - I * L, Ie = E * N - C * L, We = E * H - z * L, De = I * N - C * F, Ye = I * H - z * F,
                    ht = C * H - z * N, Qe = Y * ht - X * Ye + J * De + xe * We - ge * Ie + ye * Ee;
                return Qe ? (n[0] = (_ * ht - x * Ye + w * De) * (Qe = 1 / Qe), n[1] = (c * Ye - a * ht - d * De) * Qe, n[2] = (F * ye - N * ge + H * xe) * Qe, n[3] = (C * ge - I * ye - z * xe) * Qe, n[4] = (x * We - f * ht - w * Ie) * Qe, n[5] = (i * ht - c * We + d * Ie) * Qe, n[6] = (N * J - L * ye - H * X) * Qe, n[7] = (E * ye - C * J + z * X) * Qe, n[8] = (f * Ye - _ * We + w * Ee) * Qe, n[9] = (a * We - i * Ye - d * Ee) * Qe, n[10] = (L * ge - F * J + H * Y) * Qe, n[11] = (I * J - E * ge - z * Y) * Qe, n[12] = (_ * Ie - f * De - x * Ee) * Qe, n[13] = (i * De - a * Ie + c * Ee) * Qe, n[14] = (F * X - L * xe - N * Y) * Qe, n[15] = (E * xe - I * X + C * Y) * Qe, n) : null
            }

            function pe(n, e, i) {
                var a = e[0], c = e[1], d = e[2], f = e[3], _ = e[4], x = e[5], w = e[6], E = e[7], I = e[8], C = e[9],
                    z = e[10], L = e[11], F = e[12], N = e[13], H = e[14], Y = e[15], X = i[0], J = i[1], xe = i[2],
                    ge = i[3];
                return n[0] = X * a + J * _ + xe * I + ge * F, n[1] = X * c + J * x + xe * C + ge * N, n[2] = X * d + J * w + xe * z + ge * H, n[3] = X * f + J * E + xe * L + ge * Y, n[4] = (X = i[4]) * a + (J = i[5]) * _ + (xe = i[6]) * I + (ge = i[7]) * F, n[5] = X * c + J * x + xe * C + ge * N, n[6] = X * d + J * w + xe * z + ge * H, n[7] = X * f + J * E + xe * L + ge * Y, n[8] = (X = i[8]) * a + (J = i[9]) * _ + (xe = i[10]) * I + (ge = i[11]) * F, n[9] = X * c + J * x + xe * C + ge * N, n[10] = X * d + J * w + xe * z + ge * H, n[11] = X * f + J * E + xe * L + ge * Y, n[12] = (X = i[12]) * a + (J = i[13]) * _ + (xe = i[14]) * I + (ge = i[15]) * F, n[13] = X * c + J * x + xe * C + ge * N, n[14] = X * d + J * w + xe * z + ge * H, n[15] = X * f + J * E + xe * L + ge * Y, n
            }

            function le(n, e, i) {
                var a, c, d, f, _, x, w, E, I, C, z, L, F = i[0], N = i[1], H = i[2];
                return e === n ? (n[12] = e[0] * F + e[4] * N + e[8] * H + e[12], n[13] = e[1] * F + e[5] * N + e[9] * H + e[13], n[14] = e[2] * F + e[6] * N + e[10] * H + e[14], n[15] = e[3] * F + e[7] * N + e[11] * H + e[15]) : (c = e[1], d = e[2], f = e[3], _ = e[4], x = e[5], w = e[6], E = e[7], I = e[8], C = e[9], z = e[10], L = e[11], n[0] = a = e[0], n[1] = c, n[2] = d, n[3] = f, n[4] = _, n[5] = x, n[6] = w, n[7] = E, n[8] = I, n[9] = C, n[10] = z, n[11] = L, n[12] = a * F + _ * N + I * H + e[12], n[13] = c * F + x * N + C * H + e[13], n[14] = d * F + w * N + z * H + e[14], n[15] = f * F + E * N + L * H + e[15]), n
            }

            function be(n, e, i) {
                var a = i[0], c = i[1], d = i[2];
                return n[0] = e[0] * a, n[1] = e[1] * a, n[2] = e[2] * a, n[3] = e[3] * a, n[4] = e[4] * c, n[5] = e[5] * c, n[6] = e[6] * c, n[7] = e[7] * c, n[8] = e[8] * d, n[9] = e[9] * d, n[10] = e[10] * d, n[11] = e[11] * d, n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15], n
            }

            function Ue(n, e, i) {
                var a = Math.sin(i), c = Math.cos(i), d = e[4], f = e[5], _ = e[6], x = e[7], w = e[8], E = e[9],
                    I = e[10], C = e[11];
                return e !== n && (n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n[4] = d * c + w * a, n[5] = f * c + E * a, n[6] = _ * c + I * a, n[7] = x * c + C * a, n[8] = w * c - d * a, n[9] = E * c - f * a, n[10] = I * c - _ * a, n[11] = C * c - x * a, n
            }

            function et(n, e, i) {
                var a = Math.sin(i), c = Math.cos(i), d = e[0], f = e[1], _ = e[2], x = e[3], w = e[8], E = e[9],
                    I = e[10], C = e[11];
                return e !== n && (n[4] = e[4], n[5] = e[5], n[6] = e[6], n[7] = e[7], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n[0] = d * c - w * a, n[1] = f * c - E * a, n[2] = _ * c - I * a, n[3] = x * c - C * a, n[8] = d * a + w * c, n[9] = f * a + E * c, n[10] = _ * a + I * c, n[11] = x * a + C * c, n
            }

            function _t(n, e, i) {
                var a = Math.sin(i), c = Math.cos(i), d = e[0], f = e[1], _ = e[2], x = e[3], w = e[4], E = e[5],
                    I = e[6], C = e[7];
                return e !== n && (n[8] = e[8], n[9] = e[9], n[10] = e[10], n[11] = e[11], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n[0] = d * c + w * a, n[1] = f * c + E * a, n[2] = _ * c + I * a, n[3] = x * c + C * a, n[4] = w * c - d * a, n[5] = E * c - f * a, n[6] = I * c - _ * a, n[7] = C * c - x * a, n
            }

            function xt(n, e) {
                return n[0] = e[0], n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = e[1], n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = e[2], n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n
            }

            function Mt(n, e, i) {
                var a, c, d, f = i[0], _ = i[1], x = i[2], w = Math.hypot(f, _, x);
                return w < j ? null : (f *= w = 1 / w, _ *= w, x *= w, a = Math.sin(e), c = Math.cos(e), n[0] = f * f * (d = 1 - c) + c, n[1] = _ * f * d + x * a, n[2] = x * f * d - _ * a, n[3] = 0, n[4] = f * _ * d - x * a, n[5] = _ * _ * d + c, n[6] = x * _ * d + f * a, n[7] = 0, n[8] = f * x * d + _ * a, n[9] = _ * x * d - f * a, n[10] = x * x * d + c, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n)
            }

            function Xt(n, e) {
                var i = e[0], a = e[1], c = e[2], d = e[3], f = i + i, _ = a + a, x = c + c, w = i * f, E = a * f,
                    I = a * _, C = c * f, z = c * _, L = c * x, F = d * f, N = d * _, H = d * x;
                return n[0] = 1 - I - L, n[1] = E + H, n[2] = C - N, n[3] = 0, n[4] = E - H, n[5] = 1 - w - L, n[6] = z + F, n[7] = 0, n[8] = C + N, n[9] = z - F, n[10] = 1 - w - I, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n
            }

            Math.hypot || (Math.hypot = function () {
                for (var n = 0, e = arguments.length; e--;) n += arguments[e] * arguments[e];
                return Math.sqrt(n)
            });
            var Zt = pe;

            function Ht() {
                var n = new q(3);
                return q != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n
            }

            function hi(n) {
                var e = new q(3);
                return e[0] = n[0], e[1] = n[1], e[2] = n[2], e
            }

            function Mi(n) {
                return Math.hypot(n[0], n[1], n[2])
            }

            function $t(n, e, i) {
                var a = new q(3);
                return a[0] = n, a[1] = e, a[2] = i, a
            }

            function _i(n, e, i, a) {
                return n[0] = e, n[1] = i, n[2] = a, n
            }

            function si(n, e, i) {
                return n[0] = e[0] + i[0], n[1] = e[1] + i[1], n[2] = e[2] + i[2], n
            }

            function Ri(n, e, i) {
                return n[0] = e[0] - i[0], n[1] = e[1] - i[1], n[2] = e[2] - i[2], n
            }

            function Ct(n, e, i) {
                return n[0] = e[0] * i[0], n[1] = e[1] * i[1], n[2] = e[2] * i[2], n
            }

            function Rt(n, e, i) {
                return n[0] = Math.min(e[0], i[0]), n[1] = Math.min(e[1], i[1]), n[2] = Math.min(e[2], i[2]), n
            }

            function ni(n, e, i) {
                return n[0] = Math.max(e[0], i[0]), n[1] = Math.max(e[1], i[1]), n[2] = Math.max(e[2], i[2]), n
            }

            function ai(n, e, i) {
                return n[0] = e[0] * i, n[1] = e[1] * i, n[2] = e[2] * i, n
            }

            function fi(n, e, i, a) {
                return n[0] = e[0] + i[0] * a, n[1] = e[1] + i[1] * a, n[2] = e[2] + i[2] * a, n
            }

            function nn(n, e) {
                var i = e[0] - n[0], a = e[1] - n[1], c = e[2] - n[2];
                return i * i + a * a + c * c
            }

            function cn(n) {
                var e = n[0], i = n[1], a = n[2];
                return e * e + i * i + a * a
            }

            function Zn(n, e) {
                return n[0] = -e[0], n[1] = -e[1], n[2] = -e[2], n
            }

            function Bi(n, e) {
                var i = e[0], a = e[1], c = e[2], d = i * i + a * a + c * c;
                return d > 0 && (d = 1 / Math.sqrt(d)), n[0] = e[0] * d, n[1] = e[1] * d, n[2] = e[2] * d, n
            }

            function Ii(n, e) {
                return n[0] * e[0] + n[1] * e[1] + n[2] * e[2]
            }

            function Bn(n, e, i) {
                var a = e[0], c = e[1], d = e[2], f = i[0], _ = i[1], x = i[2];
                return n[0] = c * x - d * _, n[1] = d * f - a * x, n[2] = a * _ - c * f, n
            }

            function ar(n, e, i, a) {
                var c = e[0], d = e[1], f = e[2];
                return n[0] = c + a * (i[0] - c), n[1] = d + a * (i[1] - d), n[2] = f + a * (i[2] - f), n
            }

            function An(n, e, i) {
                var a = e[0], c = e[1], d = e[2], f = i[3] * a + i[7] * c + i[11] * d + i[15];
                return n[0] = (i[0] * a + i[4] * c + i[8] * d + i[12]) / (f = f || 1), n[1] = (i[1] * a + i[5] * c + i[9] * d + i[13]) / f, n[2] = (i[2] * a + i[6] * c + i[10] * d + i[14]) / f, n
            }

            function Zr(n, e, i) {
                var a = e[0], c = e[1], d = e[2];
                return n[0] = a * i[0] + c * i[3] + d * i[6], n[1] = a * i[1] + c * i[4] + d * i[7], n[2] = a * i[2] + c * i[5] + d * i[8], n
            }

            function wo(n, e, i) {
                var a = i[0], c = i[1], d = i[2], f = e[0], _ = e[1], x = e[2], w = c * x - d * _, E = d * f - a * x,
                    I = a * _ - c * f, C = c * I - d * E, z = d * w - a * I, L = a * E - c * w, F = 2 * i[3];
                return E *= F, I *= F, z *= 2, L *= 2, n[0] = f + (w *= F) + (C *= 2), n[1] = _ + E + z, n[2] = x + I + L, n
            }

            function Do(n) {
                return n[0] = 0, n[1] = 0, n[2] = 0, n
            }

            function Xr(n, e) {
                return n[0] === e[0] && n[1] === e[1] && n[2] === e[2]
            }

            var Nn = Ri, Ar = Ct, fs = Mi;

            function Rs() {
                var n = new q(4);
                return q != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 0), n
            }

            function lo(n, e, i) {
                return n[0] = e[0] * i, n[1] = e[1] * i, n[2] = e[2] * i, n[3] = e[3] * i, n
            }

            function co(n, e) {
                var i = e[0], a = e[1], c = e[2], d = e[3], f = i * i + a * a + c * c + d * d;
                return f > 0 && (f = 1 / Math.sqrt(f)), n[0] = i * f, n[1] = a * f, n[2] = c * f, n[3] = d * f, n
            }

            function Ir(n, e, i) {
                var a = e[0], c = e[1], d = e[2], f = e[3];
                return n[0] = i[0] * a + i[4] * c + i[8] * d + i[12] * f, n[1] = i[1] * a + i[5] * c + i[9] * d + i[13] * f, n[2] = i[2] * a + i[6] * c + i[10] * d + i[14] * f, n[3] = i[3] * a + i[7] * c + i[11] * d + i[15] * f, n
            }

            function ps() {
                var n = new q(4);
                return q != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n[3] = 1, n
            }

            function Yr(n) {
                return n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1, n
            }

            function fa(n, e, i) {
                i *= .5;
                var a = e[0], c = e[1], d = e[2], f = e[3], _ = Math.sin(i), x = Math.cos(i);
                return n[0] = a * x + f * _, n[1] = c * x + d * _, n[2] = d * x - c * _, n[3] = f * x - a * _, n
            }

            function Va(n, e, i) {
                i *= .5;
                var a = e[0], c = e[1], d = e[2], f = e[3], _ = Math.sin(i), x = Math.cos(i);
                return n[0] = a * x - d * _, n[1] = c * x + f * _, n[2] = d * x + a * _, n[3] = f * x - c * _, n
            }

            Ht(), Rs();
            var Qn, Cr, Ml, zs = co, Ds = (Qn = Ht(), Cr = $t(1, 0, 0), Ml = $t(0, 1, 0), function (n, e, i) {
                var a = Ii(e, i);
                return a < -.999999 ? (Bn(Qn, Cr, e), fs(Qn) < 1e-6 && Bn(Qn, Ml, e), Bi(Qn, Qn), function (c, d, f) {
                    f *= .5;
                    var _ = Math.sin(f);
                    c[0] = _ * d[0], c[1] = _ * d[1], c[2] = _ * d[2], c[3] = Math.cos(f)
                }(n, Qn, Math.PI), n) : a > .999999 ? (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1, n) : (Bn(Qn, e, i), n[0] = Qn[0], n[1] = Qn[1], n[2] = Qn[2], n[3] = 1 + a, zs(n, n))
            });

            function Fr() {
                var n = new q(2);
                return q != Float32Array && (n[0] = 0, n[1] = 0), n
            }

            function uo(n, e) {
                var i = new q(2);
                return i[0] = n, i[1] = e, i
            }

            function ms(n, e, i) {
                return n[0] = e[0] + i[0], n[1] = e[1] + i[1], n
            }

            function ho(n, e, i) {
                return n[0] = e[0] - i[0], n[1] = e[1] - i[1], n
            }

            function Ls(n, e, i) {
                return n[0] = e[0] * i, n[1] = e[1] * i, n
            }

            function bo(n) {
                return Math.hypot(n[0], n[1])
            }

            function Ua(n, e) {
                var i = e[0], a = e[1], c = i * i + a * a;
                return c > 0 && (c = 1 / Math.sqrt(c)), n[0] = e[0] * c, n[1] = e[1] * c, n
            }

            function bn(n, e) {
                return n[0] * e[0] + n[1] * e[1]
            }

            ps(), ps(), oe();
            var Ga, $a, To = ho;

            function pa(n) {
                return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
            }

            Fr();
            var gs = function () {
                if ($a) return Ga;

                function n(e, i, a, c) {
                    this.cx = 3 * e, this.bx = 3 * (a - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * i, this.by = 3 * (c - i) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = i, this.p2x = a, this.p2y = c
                }

                return $a = 1, Ga = n, n.prototype = {
                    sampleCurveX: function (e) {
                        return ((this.ax * e + this.bx) * e + this.cx) * e
                    }, sampleCurveY: function (e) {
                        return ((this.ay * e + this.by) * e + this.cy) * e
                    }, sampleCurveDerivativeX: function (e) {
                        return (3 * this.ax * e + 2 * this.bx) * e + this.cx
                    }, solveCurveX: function (e, i) {
                        if (i === void 0 && (i = 1e-6), e < 0) return 0;
                        if (e > 1) return 1;
                        for (var a = e, c = 0; c < 8; c++) {
                            var d = this.sampleCurveX(a) - e;
                            if (Math.abs(d) < i) return a;
                            var f = this.sampleCurveDerivativeX(a);
                            if (Math.abs(f) < 1e-6) break;
                            a -= d / f
                        }
                        var _ = 0, x = 1;
                        for (a = e, c = 0; c < 20 && (d = this.sampleCurveX(a), !(Math.abs(d - e) < i)); c++) e > d ? _ = a : x = a, a = .5 * (x - _) + _;
                        return a
                    }, solve: function (e, i) {
                        return this.sampleCurveY(this.solveCurveX(e, i))
                    }
                }, Ga
            }(), Ha = pa(gs);

            function Ze(n, e) {
                this.x = n, this.y = e
            }

            function xn(n, e) {
                if (Array.isArray(n)) {
                    if (!Array.isArray(e) || n.length !== e.length) return !1;
                    for (let i = 0; i < n.length; i++) if (!xn(n[i], e[i])) return !1;
                    return !0
                }
                if (typeof n == "object" && n !== null && e !== null) {
                    if (typeof e != "object" || Object.keys(n).length !== Object.keys(e).length) return !1;
                    for (const i in n) if (!xn(n[i], e[i])) return !1;
                    return !0
                }
                return n === e
            }

            Ze.prototype = {
                clone() {
                    return new Ze(this.x, this.y)
                }, add(n) {
                    return this.clone()._add(n)
                }, sub(n) {
                    return this.clone()._sub(n)
                }, multByPoint(n) {
                    return this.clone()._multByPoint(n)
                }, divByPoint(n) {
                    return this.clone()._divByPoint(n)
                }, mult(n) {
                    return this.clone()._mult(n)
                }, div(n) {
                    return this.clone()._div(n)
                }, rotate(n) {
                    return this.clone()._rotate(n)
                }, rotateAround(n, e) {
                    return this.clone()._rotateAround(n, e)
                }, matMult(n) {
                    return this.clone()._matMult(n)
                }, unit() {
                    return this.clone()._unit()
                }, perp() {
                    return this.clone()._perp()
                }, round() {
                    return this.clone()._round()
                }, mag() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }, equals(n) {
                    return this.x === n.x && this.y === n.y
                }, dist(n) {
                    return Math.sqrt(this.distSqr(n))
                }, distSqr(n) {
                    const e = n.x - this.x, i = n.y - this.y;
                    return e * e + i * i
                }, angle() {
                    return Math.atan2(this.y, this.x)
                }, angleTo(n) {
                    return Math.atan2(this.y - n.y, this.x - n.x)
                }, angleWith(n) {
                    return this.angleWithSep(n.x, n.y)
                }, angleWithSep(n, e) {
                    return Math.atan2(this.x * e - this.y * n, this.x * n + this.y * e)
                }, _matMult(n) {
                    const e = n[2] * this.x + n[3] * this.y;
                    return this.x = n[0] * this.x + n[1] * this.y, this.y = e, this
                }, _add(n) {
                    return this.x += n.x, this.y += n.y, this
                }, _sub(n) {
                    return this.x -= n.x, this.y -= n.y, this
                }, _mult(n) {
                    return this.x *= n, this.y *= n, this
                }, _div(n) {
                    return this.x /= n, this.y /= n, this
                }, _multByPoint(n) {
                    return this.x *= n.x, this.y *= n.y, this
                }, _divByPoint(n) {
                    return this.x /= n.x, this.y /= n.y, this
                }, _unit() {
                    return this._div(this.mag()), this
                }, _perp() {
                    const n = this.y;
                    return this.y = this.x, this.x = -n, this
                }, _rotate(n) {
                    const e = Math.cos(n), i = Math.sin(n), a = i * this.x + e * this.y;
                    return this.x = e * this.x - i * this.y, this.y = a, this
                }, _rotateAround(n, e) {
                    const i = Math.cos(n), a = Math.sin(n), c = e.y + a * (this.x - e.x) + i * (this.y - e.y);
                    return this.x = e.x + i * (this.x - e.x) - a * (this.y - e.y), this.y = c, this
                }, _round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                }, constructor: Ze
            }, Ze.convert = function (n) {
                if (n instanceof Ze) return n;
                if (Array.isArray(n)) return new Ze(+n[0], +n[1]);
                if (n.x !== void 0 && n.y !== void 0) return new Ze(+n.x, +n.y);
                throw new Error("Expected [x, y] or {x, y} point format")
            };
            const Jn = Math.PI / 180, Kr = 180 / Math.PI;

            function Ai(n) {
                return n * Jn
            }

            function Le(n) {
                return n * Kr
            }

            const $ = [[0, 0], [1, 0], [1, 1], [0, 1]];

            function W(n) {
                if (n <= 0) return 0;
                if (n >= 1) return 1;
                const e = n * n, i = e * n;
                return 4 * (n < .5 ? i : 3 * (n - e) + i - .75)
            }

            function ie(n, e, i, a) {
                const c = new Ha(n, e, i, a);
                return function (d) {
                    return c.solve(d)
                }
            }

            const we = ie(.25, .1, .25, 1);

            function se(n, e, i) {
                return Math.min(i, Math.max(e, n))
            }

            function Ae(n, e, i) {
                return (i = se((i - n) / (e - n), 0, 1)) * i * (3 - 2 * i)
            }

            function Ve(n, e, i) {
                const a = i - e, c = ((n - e) % a + a) % a + e;
                return c === e ? i : c
            }

            function Pe(n, e, i) {
                if (!n.length) return i(null, []);
                let a = n.length;
                const c = new Array(n.length);
                let d = null;
                n.forEach((f, _) => {
                    e(f, (x, w) => {
                        x && (d = x), c[_] = w, --a == 0 && i(d, c)
                    })
                })
            }

            function Ne(n, ...e) {
                for (const i of e) for (const a in i) n[a] = i[a];
                return n
            }

            let ft = 1;

            function Je() {
                return ft++
            }

            function Gt(n) {
                return n <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
            }

            function ii(n, e) {
                n.forEach(i => {
                    e[i] && (e[i] = e[i].bind(e))
                })
            }

            function li(n, e, i) {
                const a = {};
                for (const c in n) a[c] = e.call(this, n[c], c, n);
                return a
            }

            function zi(n, e, i) {
                const a = {};
                for (const c in n) e.call(this, n[c], c, n) && (a[c] = n[c]);
                return a
            }

            function Ti(n) {
                return Array.isArray(n) ? n.map(Ti) : typeof n == "object" && n ? li(n, Ti) : n
            }

            function Di(n, e) {
                for (let i = 0; i < n.length; i++) if (e.indexOf(n[i]) >= 0) return !0;
                return !1
            }

            const mn = {};

            function Li(n) {
                mn[n] || (typeof console < "u" && console.warn(n), mn[n] = !0)
            }

            function Xn(n, e, i) {
                return (i.y - n.y) * (e.x - n.x) > (e.y - n.y) * (i.x - n.x)
            }

            function mr(n) {
                let e = 0;
                for (let i, a, c = 0, d = n.length, f = d - 1; c < d; f = c++) i = n[c], a = n[f], e += (a.x - i.x) * (i.y + a.y);
                return e
            }

            function lr([n, e, i]) {
                const a = Ai(e + 90), c = Ai(i);
                return {
                    x: n * Math.cos(a) * Math.sin(c),
                    y: n * Math.sin(a) * Math.sin(c),
                    z: n * Math.cos(c),
                    azimuthal: e,
                    polar: i
                }
            }

            function un(n) {
                return (typeof self < "u" || n !== void 0) && typeof WorkerGlobalScope < "u" && (n !== void 0 ? n : self) instanceof WorkerGlobalScope
            }

            function Zi(n) {
                const e = {};
                if (n.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (i, a, c, d) => {
                    const f = c || d;
                    return e[a] = !f || f.toLowerCase(), ""
                }), e["max-age"]) {
                    const i = parseInt(e["max-age"], 10);
                    isNaN(i) ? delete e["max-age"] : e["max-age"] = i
                }
                return e
            }

            let Hn = null;

            function jn(n, e) {
                return [n[4 * e], n[4 * e + 1], n[4 * e + 2], n[4 * e + 3]]
            }

            function Dn(n, e, i, a) {
                for (; e < i;) {
                    const c = e + i >> 1;
                    n[c] < a ? e = c + 1 : i = c
                }
                return e
            }

            function Pr(n, e, i, a) {
                for (; e < i;) {
                    const c = e + i >> 1;
                    n[c] <= a ? e = c + 1 : i = c
                }
                return e
            }

            function So(n) {
                return n > 0 ? 1 / (1.001 - n) : 1 + n
            }

            function Qr(n) {
                return n > 0 ? 1 - 1 / (1.001 - n) : -n
            }

            function Gu(n, e, i) {
                return (n - e.min) * (i.max - i.min) / (e.max - e.min) + i.min
            }

            const Br = {
                API_URL: "https://api.mapbox.com",
                get API_URL_REGEX() {
                    return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i
                },
                get API_TILEJSON_REGEX() {
                    return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i
                },
                get API_SPRITE_REGEX() {
                    return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i
                },
                get API_FONTS_REGEX() {
                    return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i
                },
                get API_STYLE_REGEX() {
                    return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i
                },
                get API_CDN_URL_REGEX() {
                    return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i
                },
                get EVENTS_URL() {
                    if (!Br.API_URL) return null;
                    try {
                        const n = new URL(Br.API_URL);
                        return n.hostname === "api.mapbox.cn" ? "https://events.mapbox.cn/events/v2" : n.hostname === "api.mapbox.com" ? "https://events.mapbox.com/events/v2" : null
                    } catch {
                        return null
                    }
                },
                SESSION_PATH: "/map-sessions/v1",
                FEEDBACK_URL: "https://apps.mapbox.com/feedback",
                TILE_URL_VERSION: "v4",
                RASTER_URL_PREFIX: "raster/v1",
                RASTERARRAYS_URL_PREFIX: "rasterarrays/v1",
                REQUIRE_ACCESS_TOKEN: !0,
                ACCESS_TOKEN: null,
                DEFAULT_STYLE: "mapbox://styles/mapbox/standard",
                MAX_PARALLEL_IMAGE_REQUESTS: 16,
                DRACO_URL: "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm",
                MESHOPT_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm",
                MESHOPT_SIMD_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm",
                BUILDING_GEN_URL: "https://api.mapbox.com/mapbox-gl-js/building-gen/building_gen_v1.2.1.wasm",
                GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf",
                TILES3D_URL_PREFIX: "3dtiles/v1"
            };

            function qa(n) {
                return Br.API_URL_REGEX.test(n)
            }

            function cd(n) {
                return Br.API_SPRITE_REGEX.test(n)
            }

            let $u, Hu, ud, hd, Rl, qu;

            function dd() {
                return $u == null && ($u = self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && typeof self.createImageBitmap == "function"), $u
            }

            const ks = {
                now: () => hd !== void 0 ? hd : performance.now(),
                setNow(n) {
                    hd = n
                },
                restoreNow() {
                    hd = void 0
                },
                frame(n) {
                    const e = requestAnimationFrame(n);
                    return {cancel: () => cancelAnimationFrame(e)}
                },
                getImageData(n, e = 0) {
                    const {width: i, height: a} = n;
                    Rl || (Rl = document.createElement("canvas"));
                    const c = Rl.getContext("2d", {willReadFrequently: !0});
                    if (!c) throw new Error("failed to create canvas 2d context");
                    return (i > Rl.width || a > Rl.height) && (Rl.width = i, Rl.height = a), c.clearRect(-e, -e, i + 2 * e, a + 2 * e), c.drawImage(n, 0, 0, i, a), c.getImageData(-e, -e, i + 2 * e, a + 2 * e)
                },
                resolveURL: n => (Hu || (Hu = document.createElement("a")), Hu.href = n, Hu.href),
                get devicePixelRatio() {
                    return window.devicePixelRatio
                },
                get prefersReducedMotion() {
                    return !!window.matchMedia && (ud == null && (ud = window.matchMedia("(prefers-reduced-motion: reduce)")), ud.matches)
                },
                hasCanvasFingerprintNoise() {
                    if (qu !== void 0) return qu;
                    if (!dd()) return qu = !1, !1;
                    const n = new OffscreenCanvas(85, 1), e = n.getContext("2d", {willReadFrequently: !0});
                    let i = 0;
                    for (let c = 0; c < n.width; ++c) e.fillStyle = `rgba(${i++},${i++},${i++}, 255)`, e.fillRect(c, 0, 1, 1);
                    const a = e.getImageData(0, 0, n.width, n.height);
                    i = 0;
                    for (let c = 0; c < a.data.length; ++c) if (c % 4 != 3 && i++ !== a.data[c]) return qu = !0, !0;
                    return qu = !1, !1
                }
            };

            function Zo(n, e) {
                const i = n.indexOf("?");
                if (i < 0) return `${n}?${new URLSearchParams(e).toString()}`;
                const a = new URLSearchParams(n.slice(i));
                for (const c in e) a.set(c, e[c]);
                return `${n.slice(0, i)}?${a.toString()}`
            }

            function _s(n, e = {persistentParams: []}) {
                const i = n.indexOf("?");
                if (i < 0) return n;
                const a = new URLSearchParams, c = new URLSearchParams(n.slice(i));
                for (const f of e.persistentParams) {
                    const _ = c.get(f);
                    _ && a.set(f, _)
                }
                const d = a.toString();
                return `${n.slice(0, i)}${d.length > 0 ? `?${d}` : ""}`
            }

            const ma = "mapbox-tiles";
            let Os = 500, ga = 50;
            const Wu = ["language", "worldview", "jobid"];
            let Ys, Zu;

            function zl() {
                try {
                    return caches
                } catch {
                }
            }

            function gc() {
                const n = zl();
                n && Ys == null && (Ys = n.open(ma))
            }

            let Pp = 1 / 0;
            const Mp = {
                supported: !1, testSupport: function (n) {
                    !Xu && Dl && (_c ? k_(n) : Eo = n)
                }
            };
            let Eo, Dl, Xu = !1, _c = !1;
            const L_ = typeof self < "u" ? self : {};

            function k_(n) {
                const e = n.createTexture();
                n.bindTexture(n.TEXTURE_2D, e);
                try {
                    if (n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, Dl), n.isContextLost()) return;
                    Mp.supported = !0
                } catch {
                }
                n.deleteTexture(e), Xu = !0
            }

            L_.document && (Dl = L_.document.createElement("img"), Dl.onload = function () {
                Eo && k_(Eo), Eo = null, _c = !0
            }, Dl.onerror = function () {
                Xu = !0, Eo = null
            }, Dl.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
            const Yu = {
                Unknown: "Unknown",
                Style: "Style",
                Source: "Source",
                Tile: "Tile",
                Glyphs: "Glyphs",
                SpriteImage: "SpriteImage",
                SpriteJSON: "SpriteJSON",
                Iconset: "Iconset",
                Image: "Image",
                Model: "Model"
            };
            typeof Object.freeze == "function" && Object.freeze(Yu);

            class Vi extends Error {
                constructor(e, i, a) {
                    i === 401 && qa(a) && (e += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(e), this.status = i, this.url = a
                }

                toString() {
                    return `${this.name}: ${this.message} (${this.status}): ${this.url}`
                }
            }

            const fd = un() ? () => self.worker.referrer : () => (location.protocol === "blob:" ? parent : self).location.href,
                yc = function (n, e) {
                    if (!(/^file:/.test(i = n.url) || /^file:/.test(fd()) && !/^\w+:/.test(i))) {
                        if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty("signal")) return function (a, c) {
                            const d = new AbortController, f = new Request(a.url, {
                                method: a.method || "GET",
                                body: a.body,
                                credentials: a.credentials,
                                headers: a.headers,
                                referrer: fd(),
                                referrerPolicy: a.referrerPolicy,
                                signal: d.signal
                            });
                            let _ = !1, x = !1;
                            const w = (E = f.url).indexOf("sku=") > 0 && qa(E);
                            var E;
                            a.type === "json" && f.headers.set("Accept", "application/json");
                            const I = (z, L, F) => {
                                if (x) return;
                                if (z && z.message !== "SecurityError" && Li(z.toString()), L && F) return C(L);
                                const N = Date.now();
                                fetch(f).then(H => {
                                    if (H.ok) {
                                        const Y = w ? H.clone() : null;
                                        return C(H, Y, N)
                                    }
                                    return c(new Vi(H.statusText, H.status, a.url))
                                }).catch(H => {
                                    H.name !== "AbortError" && c(new Error(`${H.message} ${a.url}`))
                                })
                            }, C = (z, L, F) => {
                                (a.type === "arrayBuffer" ? z.arrayBuffer() : a.type === "json" ? z.json() : z.text()).then(N => {
                                    x || (L && F && function (H, Y, X) {
                                        if (gc(), Ys == null) return;
                                        const J = Zi(Y.headers.get("Cache-Control") || "");
                                        if (J["no-store"]) return;
                                        const xe = {status: Y.status, statusText: Y.statusText, headers: new Headers};
                                        Y.headers.forEach((Ee, Ie) => xe.headers.set(Ie, Ee)), J["max-age"] && xe.headers.set("Expires", new Date(X + 1e3 * J["max-age"]).toUTCString());
                                        const ge = xe.headers.get("Expires");
                                        if (!ge || new Date(ge).getTime() - X < 42e4) return;
                                        let ye = _s(H.url, {persistentParams: Wu});
                                        if (Y.status === 206) {
                                            const Ee = H.headers.get("Range");
                                            if (!Ee) return;
                                            xe.status = 200, ye = Zo(ye, {range: Ee})
                                        }
                                        (function (Ee, Ie) {
                                            if (Zu === void 0) try {
                                                new Response(new ReadableStream), Zu = !0
                                            } catch {
                                                Zu = !1
                                            }
                                            Zu ? Ie(Ee.body) : Ee.blob().then(Ie).catch(We => Li(We.message))
                                        })(Y, Ee => {
                                            const Ie = new Response((We = Y.status) !== 200 && We !== 404 && [101, 103, 204, 205, 304].includes(We) ? null : Ee, xe);
                                            var We;
                                            gc(), Ys != null && Ys.then(De => De.put(ye, Ie)).catch(De => Li(De.message))
                                        })
                                    }(f, L, F), _ = !0, c(null, N, z.headers.get("Cache-Control"), z.headers.get("Expires")))
                                }).catch(N => {
                                    x || c(new Error(N.message))
                                })
                            };
                            return w ? function (z, L) {
                                if (gc(), Ys == null) return L(null);
                                Ys.then(F => {
                                    let N = _s(z.url, {persistentParams: Wu});
                                    const H = z.headers.get("Range");
                                    H && (N = Zo(N, {range: H})), F.match(N).then(Y => {
                                        const X = function (J) {
                                            if (!J) return !1;
                                            const xe = new Date(J.headers.get("Expires") || 0),
                                                ge = Zi(J.headers.get("Cache-Control") || "");
                                            return Number(xe) > Date.now() && !ge["no-cache"]
                                        }(Y);
                                        F.delete(N).catch(L), X && F.put(N, Y.clone()).catch(L), L(null, Y, X)
                                    }).catch(L)
                                }).catch(L)
                            }(f, I) : I(null, null), {
                                cancel: () => {
                                    x = !0, _ || d.abort()
                                }
                            }
                        }(n, e);
                        if (un(self) && self.worker.actor) return self.worker.actor.send("getResource", n, e, void 0, !0)
                    }
                    var i;
                    return function (a, c) {
                        const d = new XMLHttpRequest;
                        d.open(a.method || "GET", a.url, !0), a.type === "arrayBuffer" && (d.responseType = "arraybuffer");
                        for (const f in a.headers) d.setRequestHeader(f, a.headers[f]);
                        return a.type === "json" && (d.responseType = "text", d.setRequestHeader("Accept", "application/json")), d.withCredentials = a.credentials === "include", d.onerror = () => {
                            c(new Error(d.statusText))
                        }, d.onload = () => {
                            if ((d.status >= 200 && d.status < 300 || d.status === 0) && d.response !== null) {
                                let f = d.response;
                                if (a.type === "json") try {
                                    f = JSON.parse(d.response)
                                } catch (_) {
                                    return c(_)
                                }
                                c(null, f, d.getResponseHeader("Cache-Control"), d.getResponseHeader("Expires"))
                            } else c(new Vi(d.statusText, d.status, a.url))
                        }, d.send(a.body), {cancel: () => d.abort()}
                    }(n, e)
                }, Ku = function (n, e) {
                    return yc(Ne(n, {type: "arrayBuffer"}), e)
                };

            function Nx(n) {
                const e = document.createElement("a");
                return e.href = n, e.protocol === location.protocol && e.host === location.host
            }

            const Qu = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
            let Ll, Wa;
            Ll = [], Wa = 0;
            const Ju = function (n, e) {
                if (Mp.supported && (n.headers || (n.headers = {}), n.headers.accept = "image/webp,*/*"), Wa >= Br.MAX_PARALLEL_IMAGE_REQUESTS) {
                    const d = {
                        requestParameters: n, callback: e, cancelled: !1, cancel() {
                            this.cancelled = !0
                        }
                    };
                    return Ll.push(d), d
                }
                Wa++;
                let i = !1;
                const a = () => {
                    if (!i) for (i = !0, Wa--; Ll.length && Wa < Br.MAX_PARALLEL_IMAGE_REQUESTS;) {
                        const d = Ll.shift(), {requestParameters: f, callback: _, cancelled: x} = d;
                        x || (d.cancel = Ju(f, _).cancel)
                    }
                }, c = Ku(n, (d, f, _, x) => {
                    a(), d ? e(d) : f && (self.createImageBitmap ? function (w, E) {
                        const I = new Blob([new Uint8Array(w)], {type: "image/png"});
                        createImageBitmap(I).then(C => {
                            E(null, C)
                        }).catch(C => {
                            E(new Error(`Could not load image because of ${C.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`))
                        })
                    }(f, (w, E) => e(w, E, _, x)) : function (w, E) {
                        const I = new Image;
                        I.onload = () => {
                            E(null, I), URL.revokeObjectURL(I.src), I.onload = null, requestAnimationFrame(() => {
                                I.src = Qu
                            })
                        }, I.onerror = () => E(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                        const C = new Blob([new Uint8Array(w)], {type: "image/png"});
                        I.src = w.byteLength ? URL.createObjectURL(C) : Qu
                    }(f, (w, E) => e(w, E, _, x)))
                });
                return {
                    cancel: () => {
                        c.cancel(), a()
                    }
                }
            };
            var O_, pd, F_, vc = {exports: {}}, kl = {exports: {}}, B_ = {exports: {}}, eh = function () {
                if (F_) return vc.exports;
                F_ = 1;
                var n = (O_ || (O_ = 1, kl.exports = function (i, a) {
                    var c, d, f, _, x, w, E, I;
                    for (d = i.length - (c = 3 & i.length), f = a, x = 3432918353, w = 461845907, I = 0; I < d;) E = 255 & i.charCodeAt(I) | (255 & i.charCodeAt(++I)) << 8 | (255 & i.charCodeAt(++I)) << 16 | (255 & i.charCodeAt(++I)) << 24, ++I, f = 27492 + (65535 & (_ = 5 * (65535 & (f = (f ^= E = (65535 & (E = (E = (65535 & E) * x + (((E >>> 16) * x & 65535) << 16) & 4294967295) << 15 | E >>> 17)) * w + (((E >>> 16) * w & 65535) << 16) & 4294967295) << 13 | f >>> 19)) + ((5 * (f >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (_ >>> 16) & 65535) << 16);
                    switch (E = 0, c) {
                        case 3:
                            E ^= (255 & i.charCodeAt(I + 2)) << 16;
                        case 2:
                            E ^= (255 & i.charCodeAt(I + 1)) << 8;
                        case 1:
                            f ^= E = (65535 & (E = (E = (65535 & (E ^= 255 & i.charCodeAt(I))) * x + (((E >>> 16) * x & 65535) << 16) & 4294967295) << 15 | E >>> 17)) * w + (((E >>> 16) * w & 65535) << 16) & 4294967295
                    }
                    return f ^= i.length, f = 2246822507 * (65535 & (f ^= f >>> 16)) + ((2246822507 * (f >>> 16) & 65535) << 16) & 4294967295, f = 3266489909 * (65535 & (f ^= f >>> 13)) + ((3266489909 * (f >>> 16) & 65535) << 16) & 4294967295, (f ^= f >>> 16) >>> 0
                }), kl.exports), e = (pd || (pd = 1, B_.exports = function (i, a) {
                    for (var c, d = i.length, f = a ^ d, _ = 0; d >= 4;) c = 1540483477 * (65535 & (c = 255 & i.charCodeAt(_) | (255 & i.charCodeAt(++_)) << 8 | (255 & i.charCodeAt(++_)) << 16 | (255 & i.charCodeAt(++_)) << 24)) + ((1540483477 * (c >>> 16) & 65535) << 16), f = 1540483477 * (65535 & f) + ((1540483477 * (f >>> 16) & 65535) << 16) ^ (c = 1540483477 * (65535 & (c ^= c >>> 24)) + ((1540483477 * (c >>> 16) & 65535) << 16)), d -= 4, ++_;
                    switch (d) {
                        case 3:
                            f ^= (255 & i.charCodeAt(_ + 2)) << 16;
                        case 2:
                            f ^= (255 & i.charCodeAt(_ + 1)) << 8;
                        case 1:
                            f = 1540483477 * (65535 & (f ^= 255 & i.charCodeAt(_))) + ((1540483477 * (f >>> 16) & 65535) << 16)
                    }
                    return f = 1540483477 * (65535 & (f ^= f >>> 13)) + ((1540483477 * (f >>> 16) & 65535) << 16), (f ^= f >>> 15) >>> 0
                }), B_.exports);
                return vc.exports = n, vc.exports.murmur3 = n, vc.exports.murmur2 = e, vc.exports
            }(), xc = pa(eh);

            class _a {
                constructor(e, ...i) {
                    Ne(this, i[0] || {}), this.type = e
                }
            }

            class Xo extends _a {
                constructor(e, i = {}) {
                    super("error", Ne({error: e}, i))
                }
            }

            function Rp(n, e, i) {
                i[n] && i[n].indexOf(e) !== -1 || (i[n] = i[n] || [], i[n].push(e))
            }

            function zp(n, e, i) {
                if (i && i[n]) {
                    const a = i[n].indexOf(e);
                    a !== -1 && i[n].splice(a, 1)
                }
            }

            class Ol {
                on(e, i) {
                    return this._listeners = this._listeners || {}, Rp(e, i, this._listeners), this
                }

                off(e, i) {
                    return zp(e, i, this._listeners), zp(e, i, this._oneTimeListeners), this
                }

                once(e, i) {
                    return i ? (this._oneTimeListeners = this._oneTimeListeners || {}, Rp(e, i, this._oneTimeListeners), this) : new Promise(a => {
                        this.once(e, a)
                    })
                }

                fire(e, i) {
                    const a = typeof e == "string" ? new _a(e, i) : e, c = a.type;
                    if (this.listens(c)) {
                        a.target = this;
                        const d = this._listeners && this._listeners[c] ? this._listeners[c].slice() : [];
                        for (const x of d) x.call(this, a);
                        const f = this._oneTimeListeners && this._oneTimeListeners[c] ? this._oneTimeListeners[c].slice() : [];
                        for (const x of f) zp(c, x, this._oneTimeListeners), x.call(this, a);
                        const _ = this._eventedParent;
                        _ && (Ne(a, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), _.fire(a))
                    } else a instanceof Xo && console.error(a.error);
                    return this
                }

                listens(e) {
                    return !!(this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e))
                }

                setEventedParent(e, i) {
                    return this._eventedParent = e, this._eventedParentData = i, this
                }
            }

            class Lo {
                constructor(e) {
                    typeof e == "string" ? this.name = e : (this.name = e.name, this.iconsetId = e.iconsetId)
                }

                static from(e) {
                    return new Lo(e)
                }

                static toString(e) {
                    return e.iconsetId ? `${e.name}${e.iconsetId}` : e.name
                }

                static parse(e) {
                    const [i, a] = e.split("");
                    return new Lo({name: i, iconsetId: a})
                }

                static isEqual(e, i) {
                    return e.name === i.name && e.iconsetId === i.iconsetId
                }

                toString() {
                    return Lo.toString(this)
                }

                serialize() {
                    return {name: this.name, iconsetId: this.iconsetId}
                }
            }

            var Dp, md = {}, Lp = function () {
                if (Dp) return md;
                Dp = 1;
                var n = {
                    transparent: [0, 0, 0, 0],
                    aliceblue: [240, 248, 255, 1],
                    antiquewhite: [250, 235, 215, 1],
                    aqua: [0, 255, 255, 1],
                    aquamarine: [127, 255, 212, 1],
                    azure: [240, 255, 255, 1],
                    beige: [245, 245, 220, 1],
                    bisque: [255, 228, 196, 1],
                    black: [0, 0, 0, 1],
                    blanchedalmond: [255, 235, 205, 1],
                    blue: [0, 0, 255, 1],
                    blueviolet: [138, 43, 226, 1],
                    brown: [165, 42, 42, 1],
                    burlywood: [222, 184, 135, 1],
                    cadetblue: [95, 158, 160, 1],
                    chartreuse: [127, 255, 0, 1],
                    chocolate: [210, 105, 30, 1],
                    coral: [255, 127, 80, 1],
                    cornflowerblue: [100, 149, 237, 1],
                    cornsilk: [255, 248, 220, 1],
                    crimson: [220, 20, 60, 1],
                    cyan: [0, 255, 255, 1],
                    darkblue: [0, 0, 139, 1],
                    darkcyan: [0, 139, 139, 1],
                    darkgoldenrod: [184, 134, 11, 1],
                    darkgray: [169, 169, 169, 1],
                    darkgreen: [0, 100, 0, 1],
                    darkgrey: [169, 169, 169, 1],
                    darkkhaki: [189, 183, 107, 1],
                    darkmagenta: [139, 0, 139, 1],
                    darkolivegreen: [85, 107, 47, 1],
                    darkorange: [255, 140, 0, 1],
                    darkorchid: [153, 50, 204, 1],
                    darkred: [139, 0, 0, 1],
                    darksalmon: [233, 150, 122, 1],
                    darkseagreen: [143, 188, 143, 1],
                    darkslateblue: [72, 61, 139, 1],
                    darkslategray: [47, 79, 79, 1],
                    darkslategrey: [47, 79, 79, 1],
                    darkturquoise: [0, 206, 209, 1],
                    darkviolet: [148, 0, 211, 1],
                    deeppink: [255, 20, 147, 1],
                    deepskyblue: [0, 191, 255, 1],
                    dimgray: [105, 105, 105, 1],
                    dimgrey: [105, 105, 105, 1],
                    dodgerblue: [30, 144, 255, 1],
                    firebrick: [178, 34, 34, 1],
                    floralwhite: [255, 250, 240, 1],
                    forestgreen: [34, 139, 34, 1],
                    fuchsia: [255, 0, 255, 1],
                    gainsboro: [220, 220, 220, 1],
                    ghostwhite: [248, 248, 255, 1],
                    gold: [255, 215, 0, 1],
                    goldenrod: [218, 165, 32, 1],
                    gray: [128, 128, 128, 1],
                    green: [0, 128, 0, 1],
                    greenyellow: [173, 255, 47, 1],
                    grey: [128, 128, 128, 1],
                    honeydew: [240, 255, 240, 1],
                    hotpink: [255, 105, 180, 1],
                    indianred: [205, 92, 92, 1],
                    indigo: [75, 0, 130, 1],
                    ivory: [255, 255, 240, 1],
                    khaki: [240, 230, 140, 1],
                    lavender: [230, 230, 250, 1],
                    lavenderblush: [255, 240, 245, 1],
                    lawngreen: [124, 252, 0, 1],
                    lemonchiffon: [255, 250, 205, 1],
                    lightblue: [173, 216, 230, 1],
                    lightcoral: [240, 128, 128, 1],
                    lightcyan: [224, 255, 255, 1],
                    lightgoldenrodyellow: [250, 250, 210, 1],
                    lightgray: [211, 211, 211, 1],
                    lightgreen: [144, 238, 144, 1],
                    lightgrey: [211, 211, 211, 1],
                    lightpink: [255, 182, 193, 1],
                    lightsalmon: [255, 160, 122, 1],
                    lightseagreen: [32, 178, 170, 1],
                    lightskyblue: [135, 206, 250, 1],
                    lightslategray: [119, 136, 153, 1],
                    lightslategrey: [119, 136, 153, 1],
                    lightsteelblue: [176, 196, 222, 1],
                    lightyellow: [255, 255, 224, 1],
                    lime: [0, 255, 0, 1],
                    limegreen: [50, 205, 50, 1],
                    linen: [250, 240, 230, 1],
                    magenta: [255, 0, 255, 1],
                    maroon: [128, 0, 0, 1],
                    mediumaquamarine: [102, 205, 170, 1],
                    mediumblue: [0, 0, 205, 1],
                    mediumorchid: [186, 85, 211, 1],
                    mediumpurple: [147, 112, 219, 1],
                    mediumseagreen: [60, 179, 113, 1],
                    mediumslateblue: [123, 104, 238, 1],
                    mediumspringgreen: [0, 250, 154, 1],
                    mediumturquoise: [72, 209, 204, 1],
                    mediumvioletred: [199, 21, 133, 1],
                    midnightblue: [25, 25, 112, 1],
                    mintcream: [245, 255, 250, 1],
                    mistyrose: [255, 228, 225, 1],
                    moccasin: [255, 228, 181, 1],
                    navajowhite: [255, 222, 173, 1],
                    navy: [0, 0, 128, 1],
                    oldlace: [253, 245, 230, 1],
                    olive: [128, 128, 0, 1],
                    olivedrab: [107, 142, 35, 1],
                    orange: [255, 165, 0, 1],
                    orangered: [255, 69, 0, 1],
                    orchid: [218, 112, 214, 1],
                    palegoldenrod: [238, 232, 170, 1],
                    palegreen: [152, 251, 152, 1],
                    paleturquoise: [175, 238, 238, 1],
                    palevioletred: [219, 112, 147, 1],
                    papayawhip: [255, 239, 213, 1],
                    peachpuff: [255, 218, 185, 1],
                    peru: [205, 133, 63, 1],
                    pink: [255, 192, 203, 1],
                    plum: [221, 160, 221, 1],
                    powderblue: [176, 224, 230, 1],
                    purple: [128, 0, 128, 1],
                    rebeccapurple: [102, 51, 153, 1],
                    red: [255, 0, 0, 1],
                    rosybrown: [188, 143, 143, 1],
                    royalblue: [65, 105, 225, 1],
                    saddlebrown: [139, 69, 19, 1],
                    salmon: [250, 128, 114, 1],
                    sandybrown: [244, 164, 96, 1],
                    seagreen: [46, 139, 87, 1],
                    seashell: [255, 245, 238, 1],
                    sienna: [160, 82, 45, 1],
                    silver: [192, 192, 192, 1],
                    skyblue: [135, 206, 235, 1],
                    slateblue: [106, 90, 205, 1],
                    slategray: [112, 128, 144, 1],
                    slategrey: [112, 128, 144, 1],
                    snow: [255, 250, 250, 1],
                    springgreen: [0, 255, 127, 1],
                    steelblue: [70, 130, 180, 1],
                    tan: [210, 180, 140, 1],
                    teal: [0, 128, 128, 1],
                    thistle: [216, 191, 216, 1],
                    tomato: [255, 99, 71, 1],
                    turquoise: [64, 224, 208, 1],
                    violet: [238, 130, 238, 1],
                    wheat: [245, 222, 179, 1],
                    white: [255, 255, 255, 1],
                    whitesmoke: [245, 245, 245, 1],
                    yellow: [255, 255, 0, 1],
                    yellowgreen: [154, 205, 50, 1]
                };

                function e(d) {
                    return (d = Math.round(d)) < 0 ? 0 : d > 255 ? 255 : d
                }

                function i(d) {
                    return e(d[d.length - 1] === "%" ? parseFloat(d) / 100 * 255 : parseInt(d))
                }

                function a(d) {
                    return (f = d[d.length - 1] === "%" ? parseFloat(d) / 100 : parseFloat(d)) < 0 ? 0 : f > 1 ? 1 : f;
                    var f
                }

                function c(d, f, _) {
                    return _ < 0 ? _ += 1 : _ > 1 && (_ -= 1), 6 * _ < 1 ? d + (f - d) * _ * 6 : 2 * _ < 1 ? f : 3 * _ < 2 ? d + (f - d) * (2 / 3 - _) * 6 : d
                }

                try {
                    md.parseCSSColor = function (d) {
                        var f, _ = d.replace(/ /g, "").toLowerCase();
                        if (_ in n) return n[_].slice();
                        if (_[0] === "#") return _.length === 4 ? (f = parseInt(_.substr(1), 16)) >= 0 && f <= 4095 ? [(3840 & f) >> 4 | (3840 & f) >> 8, 240 & f | (240 & f) >> 4, 15 & f | (15 & f) << 4, 1] : null : _.length === 7 && (f = parseInt(_.substr(1), 16)) >= 0 && f <= 16777215 ? [(16711680 & f) >> 16, (65280 & f) >> 8, 255 & f, 1] : null;
                        var x = _.indexOf("("), w = _.indexOf(")");
                        if (x !== -1 && w + 1 === _.length) {
                            var E = _.substr(0, x), I = _.substr(x + 1, w - (x + 1)).split(","), C = 1;
                            switch (E) {
                                case"rgba":
                                    if (I.length !== 4) return null;
                                    C = a(I.pop());
                                case"rgb":
                                    return I.length !== 3 ? null : [i(I[0]), i(I[1]), i(I[2]), C];
                                case"hsla":
                                    if (I.length !== 4) return null;
                                    C = a(I.pop());
                                case"hsl":
                                    if (I.length !== 3) return null;
                                    var z = (parseFloat(I[0]) % 360 + 360) % 360 / 360, L = a(I[1]), F = a(I[2]),
                                        N = F <= .5 ? F * (L + 1) : F + L - F * L, H = 2 * F - N;
                                    return [e(255 * c(H, N, z + 1 / 3)), e(255 * c(H, N, z)), e(255 * c(H, N, z - 1 / 3)), C];
                                default:
                                    return null
                            }
                        }
                        return null
                    }
                } catch {
                }
                return md
            }();

            class Ji {
                constructor(e, i, a, c = 1) {
                    this.r = e, this.g = i, this.b = a, this.a = c
                }

                static parse(e) {
                    if (!e) return;
                    if (e instanceof Ji) return e;
                    if (typeof e != "string") return;
                    const i = Lp.parseCSSColor(e);
                    return i ? new Ji(i[0] / 255, i[1] / 255, i[2] / 255, i[3]) : void 0
                }

                toString() {
                    const [e, i, a, c] = [this.r, this.g, this.b, this.a];
                    return `rgba(${Math.round(255 * e)},${Math.round(255 * i)},${Math.round(255 * a)},${c})`
                }

                toNonPremultipliedRenderColor(e) {
                    const {r: i, g: a, b: c, a: d} = this;
                    return new wc(e, i, a, c, d)
                }

                toPremultipliedRenderColor(e) {
                    const {r: i, g: a, b: c, a: d} = this;
                    return new N_(e, i * d, a * d, c * d, d)
                }

                clone() {
                    return new Ji(this.r, this.g, this.b, this.a)
                }
            }

            class th {
                constructor(e, i, a, c, d, f = !1) {
                    if (this.premultiplied = !1, this.premultiplied = f, e) {
                        const _ = e.image.height, x = _ * _;
                        this.premultiplied ? (i = d === 0 ? 0 : i / d * (_ - 1), a = d === 0 ? 0 : a / d * (_ - 1), c = d === 0 ? 0 : c / d * (_ - 1)) : (i *= _ - 1, a *= _ - 1, c *= _ - 1);
                        const w = Math.floor(i), E = Math.floor(a), I = Math.floor(c), C = Math.ceil(i),
                            z = Math.ceil(a), L = Math.ceil(c), F = i - w, N = a - E, H = c - I, Y = e.image.data,
                            X = 4 * (w + E * x + I * _), J = 4 * (w + E * x + L * _), xe = 4 * (w + z * x + I * _),
                            ge = 4 * (w + z * x + L * _), ye = 4 * (C + E * x + I * _), Ee = 4 * (C + E * x + L * _),
                            Ie = 4 * (C + z * x + I * _), We = 4 * (C + z * x + L * _);
                        if (X < 0 || We >= Y.length) throw new Error("out of range");
                        this.r = qt(qt(qt(Y[X], Y[J], H), qt(Y[xe], Y[ge], H), N), qt(qt(Y[ye], Y[Ee], H), qt(Y[Ie], Y[We], H), N), F) / 255 * (this.premultiplied ? d : 1), this.g = qt(qt(qt(Y[X + 1], Y[J + 1], H), qt(Y[xe + 1], Y[ge + 1], H), N), qt(qt(Y[ye + 1], Y[Ee + 1], H), qt(Y[Ie + 1], Y[We + 1], H), N), F) / 255 * (this.premultiplied ? d : 1), this.b = qt(qt(qt(Y[X + 2], Y[J + 2], H), qt(Y[xe + 2], Y[ge + 2], H), N), qt(qt(Y[ye + 2], Y[Ee + 2], H), qt(Y[Ie + 2], Y[We + 2], H), N), F) / 255 * (this.premultiplied ? d : 1), this.a = d
                    } else this.r = i, this.g = a, this.b = c, this.a = d
                }

                toArray() {
                    const {r: e, g: i, b: a, a: c} = this;
                    return [255 * e, 255 * i, 255 * a, c]
                }

                toHslaArray() {
                    let {r: e, g: i, b: a, a: c} = this;
                    if (this.premultiplied) {
                        if (c === 0) return [0, 0, 0, 0];
                        e /= c, i /= c, a /= c
                    }
                    const d = Math.min(Math.max(e, 0), 1), f = Math.min(Math.max(i, 0), 1),
                        _ = Math.min(Math.max(a, 0), 1), x = Math.min(d, f, _), w = Math.max(d, f, _), E = (x + w) / 2;
                    if (x === w) return [0, 0, 100 * E, c];
                    const I = w - x, C = E > .5 ? I / (2 - w - x) : I / (w + x);
                    let z = 0;
                    return w === d ? z = (f - _) / I + (f < _ ? 6 : 0) : w === f ? z = (_ - d) / I + 2 : w === _ && (z = (d - f) / I + 4), z *= 60, [Math.min(Math.max(z, 0), 360), Math.min(Math.max(100 * C, 0), 100), Math.min(Math.max(100 * E, 0), 100), c]
                }

                toArray01() {
                    const {r: e, g: i, b: a, a: c} = this;
                    return [e, i, a, c]
                }

                toArray01Scaled(e) {
                    const {r: i, g: a, b: c} = this;
                    return [i * e, a * e, c * e]
                }

                toArray01Linear() {
                    const {r: e, g: i, b: a, a: c} = this;
                    return [Math.pow(e, 2.2), Math.pow(i, 2.2), Math.pow(a, 2.2), c]
                }
            }

            class wc extends th {
                constructor(e, i, a, c, d) {
                    super(e, i, a, c, d, !1)
                }
            }

            class N_ extends th {
                constructor(e, i, a, c, d) {
                    super(e, i, a, c, d, !0)
                }
            }

            function qt(n, e, i) {
                return n * (1 - i) + e * i
            }

            function j_(n, e, i) {
                return n.map((a, c) => qt(a, e[c], i))
            }

            Ji.black = new Ji(0, 0, 0, 1), Ji.white = new Ji(1, 1, 1, 1), Ji.transparent = new Ji(0, 0, 0, 0), Ji.red = new Ji(1, 0, 0, 1), Ji.blue = new Ji(0, 0, 1, 1);
            var ih = Object.freeze({
                __proto__: null, array: j_, color: function (n, e, i) {
                    return new Ji(qt(n.r, e.r, i), qt(n.g, e.g, i), qt(n.b, e.b, i), qt(n.a, e.a, i))
                }, number: qt
            });

            function Fl(n, ...e) {
                for (const i of e) for (const a in i) n[a] = i[a];
                return n
            }

            class Yo extends Error {
                constructor(e, i) {
                    super(i), this.message = i, this.key = e
                }
            }

            class kp {
                constructor(e, i = []) {
                    this.parent = e, this.bindings = {};
                    for (const [a, c] of i) this.bindings[a] = c
                }

                concat(e) {
                    return new kp(this, e)
                }

                get(e) {
                    if (this.bindings[e]) return this.bindings[e];
                    if (this.parent) return this.parent.get(e);
                    throw new Error(`${e} not found in scope.`)
                }

                has(e) {
                    return !!this.bindings[e] || !!this.parent && this.parent.has(e)
                }
            }

            const bc = {kind: "null"}, Vt = {kind: "number"}, Ki = {kind: "string"}, Qi = {kind: "boolean"},
                ko = {kind: "color"}, ya = {kind: "object"}, en = {kind: "value"}, gd = {kind: "collator"},
                nh = {kind: "formatted"}, rh = {kind: "resolvedImage"};

            function Jr(n, e) {
                return {kind: "array", itemType: n, N: e}
            }

            function cr(n) {
                if (n.kind === "array") {
                    const e = cr(n.itemType);
                    return typeof n.N == "number" ? `array<${e}, ${n.N}>` : n.itemType.kind === "value" ? "array" : `array<${e}>`
                }
                return n.kind
            }

            const jx = [bc, Vt, Ki, Qi, ko, nh, ya, Jr(en), rh];

            function Tc(n, e) {
                if (e.kind === "error") return null;
                if (n.kind === "array") {
                    if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !Tc(n.itemType, e.itemType)) && (typeof n.N != "number" || n.N === e.N)) return null
                } else {
                    if (n.kind === e.kind) return null;
                    if (n.kind === "value") {
                        for (const i of jx) if (!Tc(i, e)) return null
                    }
                }
                return `Expected ${cr(n)} but found ${cr(e)} instead.`
            }

            function Za(n, e) {
                return e.some(i => i.kind === n.kind)
            }

            function oh(n, e) {
                return e.some(i => i === "null" ? n === null : i === "array" ? Array.isArray(n) : i === "object" ? n && !Array.isArray(n) && typeof n == "object" : i === typeof n)
            }

            function _d(n, e) {
                return n.kind === "array" && e.kind === "array" ? n.N === e.N && _d(n.itemType, e.itemType) : n.kind === e.kind
            }

            class sh {
                constructor(e, i, a) {
                    this.sensitivity = e ? i ? "variant" : "case" : i ? "accent" : "base", this.locale = a, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
                        sensitivity: this.sensitivity,
                        usage: "search"
                    })
                }

                compare(e, i) {
                    return this.collator.compare(e, i)
                }

                resolvedLocale() {
                    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
                }
            }

            class yd {
                constructor(e, i, a, c, d) {
                    this.text = e.normalize ? e.normalize() : e, this.image = i, this.scale = a, this.fontStack = c, this.textColor = d
                }
            }

            class fo {
                constructor(e) {
                    this.sections = e
                }

                static fromString(e) {
                    return new fo([new yd(e, null, null, null, null)])
                }

                isEmpty() {
                    return this.sections.length === 0 || !this.sections.some(e => e.text.length !== 0 || !!e.image && e.image.hasPrimary())
                }

                static factory(e) {
                    return e instanceof fo ? e : fo.fromString(e)
                }

                toString() {
                    return this.sections.length === 0 ? "" : this.sections.map(e => e.text).join("")
                }

                serialize() {
                    const e = ["format"];
                    for (const i of this.sections) {
                        if (i.image) {
                            const c = i.image.getPrimary().id.toString();
                            e.push(["image", c]);
                            continue
                        }
                        e.push(i.text);
                        const a = {};
                        i.fontStack && (a["text-font"] = ["literal", i.fontStack.split(",")]), i.scale && (a["font-scale"] = i.scale), i.textColor && (a["text-color"] = ["rgba"].concat(i.textColor.toNonPremultipliedRenderColor(null).toArray())), e.push(a)
                    }
                    return e
                }
            }

            class va {
                constructor(e, i = {}) {
                    if (this.id = Lo.from(e), this.options = Object.assign({}, i), i.transform) {
                        const {a, b: c, c: d, d: f, e: _, f: x} = i.transform;
                        this.options.transform = new DOMMatrix([a, c, d, f, _, x])
                    } else this.options.transform = new DOMMatrix([1, 0, 0, 1, 0, 0])
                }

                toString() {
                    const {a: e, b: i, c: a, d: c, e: d, f} = this.options.transform;
                    return JSON.stringify({
                        name: this.id.name,
                        iconsetId: this.id.iconsetId,
                        params: this.options.params,
                        transform: {a: e, b: i, c: a, d: c, e: d, f}
                    })
                }

                static parse(e) {
                    let i, a, c, d;
                    try {
                        ({name: i, iconsetId: a, params: c, transform: d} = JSON.parse(e) || {})
                    } catch {
                        return null
                    }
                    if (!i) return null;
                    const {a: f, b: _, c: x, d: w, e: E, f: I} = d || {};
                    return new va({name: i, iconsetId: a}, {params: c, transform: new DOMMatrix([f, _, x, w, E, I])})
                }

                scaleSelf(e, i) {
                    return this.options.transform.scaleSelf(e, i), this
                }
            }

            class Ao {
                constructor(e, i, a, c, d = !1) {
                    this.primaryId = Lo.from(e), this.primaryOptions = i, a && (this.secondaryId = Lo.from(a)), this.secondaryOptions = c, this.available = d
                }

                toString() {
                    return this.primaryId && this.secondaryId ? `[${this.primaryId.name},${this.secondaryId.name}]` : this.primaryId.name
                }

                hasPrimary() {
                    return !!this.primaryId
                }

                getPrimary() {
                    return new va(this.primaryId, this.primaryOptions)
                }

                hasSecondary() {
                    return !!this.secondaryId
                }

                getSecondary() {
                    return this.secondaryId ? new va(this.secondaryId, this.secondaryOptions) : null
                }

                static from(e) {
                    return typeof e == "string" ? Ao.build({name: e}) : e
                }

                static build(e, i, a, c) {
                    return !e || typeof e == "object" && !("name" in e) ? null : new Ao(e, a, i, c)
                }
            }

            function Bl(n, e, i, a) {
                return typeof n == "number" && n >= 0 && n <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof i == "number" && i >= 0 && i <= 255 ? a === void 0 || typeof a == "number" && a >= 0 && a <= 1 ? null : `Invalid rgba value [${[n, e, i, a].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof a == "number" ? [n, e, i, a] : [n, e, i]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
            }

            function gi(n) {
                if (n === null || typeof n == "string" || typeof n == "boolean" || typeof n == "number" || n instanceof Ji || n instanceof sh || n instanceof fo || n instanceof Ao) return !0;
                if (Array.isArray(n)) {
                    for (const e of n) if (!gi(e)) return !1;
                    return !0
                }
                if (typeof n == "object") {
                    for (const e in n) if (!gi(n[e])) return !1;
                    return !0
                }
                return !1
            }

            function It(n) {
                if (n === null) return bc;
                if (typeof n == "string") return Ki;
                if (typeof n == "boolean") return Qi;
                if (typeof n == "number") return Vt;
                if (n instanceof Ji) return ko;
                if (n instanceof sh) return gd;
                if (n instanceof fo) return nh;
                if (n instanceof Ao) return rh;
                if (Array.isArray(n)) {
                    const e = n.length;
                    let i;
                    for (const a of n) {
                        const c = It(a);
                        if (i) {
                            if (i === c) continue;
                            i = en;
                            break
                        }
                        i = c
                    }
                    return Jr(i || en, e)
                }
                return ya
            }

            function ys(n) {
                const e = typeof n;
                return n === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(n) : n instanceof fo || n instanceof Ao || n instanceof Ji ? n.toString() : JSON.stringify(n)
            }

            class ei {
                constructor(e, i) {
                    this.type = e, this.value = i
                }

                static parse(e, i) {
                    if (e.length !== 2) return i.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
                    if (!gi(e[1])) return i.error("invalid value");
                    const a = e[1];
                    let c = It(a);
                    const d = i.expectedType;
                    return c.kind !== "array" || c.N !== 0 || !d || d.kind !== "array" || typeof d.N == "number" && d.N !== 0 || (c = d), new ei(c, a)
                }

                evaluate() {
                    return this.value
                }

                eachChild() {
                }

                outputDefined() {
                    return !0
                }

                serialize() {
                    return this.type.kind === "array" || this.type.kind === "object" ? ["literal", this.value] : this.value instanceof Ji ? ["rgba"].concat(this.value.toNonPremultipliedRenderColor(null).toArray()) : this.value instanceof fo ? this.value.serialize() : this.value
                }
            }

            class or {
                constructor(e) {
                    this.name = "ExpressionEvaluationError", this.message = e
                }

                toJSON() {
                    return this.message
                }
            }

            const ah = {string: Ki, number: Vt, boolean: Qi, object: ya};

            class Yt {
                constructor(e, i) {
                    this.type = e, this.args = i
                }

                static parse(e, i) {
                    if (e.length < 2) return i.error("Expected at least one argument.");
                    let a, c = 1;
                    const d = e[0];
                    if (d === "array") {
                        let _, x;
                        if (e.length > 2) {
                            const w = e[1];
                            if (typeof w != "string" || !(w in ah) || w === "object") return i.error('The item type argument of "array" must be one of string, number, boolean', 1);
                            _ = ah[w], c++
                        } else _ = en;
                        if (e.length > 3) {
                            if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2]))) return i.error('The length argument to "array" must be a positive integer literal', 2);
                            x = e[2], c++
                        }
                        a = Jr(_, x)
                    } else a = ah[d];
                    const f = [];
                    for (; c < e.length; c++) {
                        const _ = i.parse(e[c], c, en);
                        if (!_) return null;
                        f.push(_)
                    }
                    return new Yt(a, f)
                }

                evaluate(e) {
                    for (let i = 0; i < this.args.length; i++) {
                        const a = this.args[i].evaluate(e);
                        if (!Tc(this.type, It(a))) return a;
                        if (i === this.args.length - 1) throw new or(`The expression ${JSON.stringify(this.args[i].serialize())} evaluated to ${cr(It(a))} but was expected to be of type ${cr(this.type)}.`)
                    }
                    return null
                }

                eachChild(e) {
                    this.args.forEach(e)
                }

                outputDefined() {
                    return this.args.every(e => e.outputDefined())
                }

                serialize() {
                    const e = this.type, i = [e.kind];
                    if (e.kind === "array") {
                        const a = e.itemType;
                        if (a.kind === "string" || a.kind === "number" || a.kind === "boolean") {
                            i.push(a.kind);
                            const c = e.N;
                            (typeof c == "number" || this.args.length > 1) && i.push(c)
                        }
                    }
                    return i.concat(this.args.map(a => a.serialize()))
                }
            }

            class Sc {
                constructor(e) {
                    this.type = nh, this.sections = e
                }

                static parse(e, i) {
                    if (e.length < 2) return i.error("Expected at least one argument.");
                    const a = e[1];
                    if (!Array.isArray(a) && typeof a == "object") return i.error("First argument must be an image or text section.");
                    const c = [];
                    let d = !1;
                    for (let f = 1; f <= e.length - 1; ++f) {
                        const _ = e[f];
                        if (d && typeof _ == "object" && !Array.isArray(_)) {
                            d = !1;
                            let x = null;
                            if (_["font-scale"] && (x = i.parseObjectValue(_["font-scale"], f, "font-scale", Vt), !x)) return null;
                            let w = null;
                            if (_["text-font"] && (w = i.parseObjectValue(_["text-font"], f, "text-font", Jr(Ki)), !w)) return null;
                            let E = null;
                            if (_["text-color"] && (E = i.parseObjectValue(_["text-color"], f, "text-color", ko), !E)) return null;
                            const I = c[c.length - 1];
                            I.scale = x, I.font = w, I.textColor = E
                        } else {
                            const x = i.parse(e[f], f, en);
                            if (!x) return null;
                            const w = x.type.kind;
                            if (w !== "string" && w !== "value" && w !== "null" && w !== "resolvedImage") return i.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                            d = !0, c.push({content: x, scale: null, font: null, textColor: null})
                        }
                    }
                    return new Sc(c)
                }

                evaluate(e) {
                    return new fo(this.sections.map(i => {
                        const a = i.content.evaluate(e);
                        return _d(It(a), rh) ? new yd("", a, null, null, null) : new yd(ys(a), null, i.scale ? i.scale.evaluate(e) : null, i.font ? i.font.evaluate(e).join(",") : null, i.textColor ? i.textColor.evaluate(e) : null)
                    }))
                }

                eachChild(e) {
                    for (const i of this.sections) e(i.content), i.scale && e(i.scale), i.font && e(i.font), i.textColor && e(i.textColor)
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    const e = ["format"];
                    for (const i of this.sections) {
                        e.push(i.content.serialize());
                        const a = {};
                        i.scale && (a["font-scale"] = i.scale.serialize()), i.font && (a["text-font"] = i.font.serialize()), i.textColor && (a["text-color"] = i.textColor.serialize()), e.push(a)
                    }
                    return e
                }
            }

            class Ec {
                constructor(e, i, a, c) {
                    this._imageWarnHistory = {}, this.type = rh, this.namePrimary = e, this.nameSecondary = i, a && (this.paramsPrimary = a.params, this.iconsetIdPrimary = a.iconset ? a.iconset.id : void 0), c && (this.paramsSecondary = c.params, this.iconsetIdSecondary = c.iconset ? c.iconset.id : void 0)
                }

                static parse(e, i) {
                    if (e.length < 2) return i.error("Expected two or more arguments.");
                    let a = 1;
                    const c = [];

                    function d() {
                        if (a < e.length) {
                            const _ = i.parse(e[a], a++, Ki);
                            return _ ? (c.push({
                                image: _,
                                options: {}
                            }), !0) : (i.error(c.length ? "Secondary image variant is not a string." : "No image name provided."), !1)
                        }
                        return !0
                    }

                    function f() {
                        if (a < e.length) {
                            const x = e[a];
                            if ((_ = x) === null || typeof _ != "object" || Array.isArray(_)) return !0;
                            const w = x.params, E = x.iconset, I = i.concat(a);
                            if (!w && !E) return a++, !0;
                            if (w) {
                                if (typeof w != "object" || w.constructor !== Object) return I.error('Image options "params" should be an object'), !1;
                                const C = {}, z = I.concat(void 0, "params");
                                for (const L in w) {
                                    if (!L) return z.error("Image parameter name should be non-empty"), !1;
                                    const F = z.concat(void 0, L).parse(w[L], void 0, ko, void 0, {typeAnnotation: "coerce"});
                                    if (!F) return !1;
                                    C[L] = F
                                }
                                c[c.length - 1].options.params = C
                            }
                            if (E) {
                                if (typeof E != "object" || E.constructor !== Object) return I.error('Image options "iconset" should be an object'), !1;
                                if (!E.id) return I.error('Image options "iconset" should have an "id" property'), !1;
                                c[c.length - 1].options.iconset = E
                            }
                            return a++, !0
                        }
                        var _;
                        return !0
                    }

                    for (let _ = 0; _ < 2; _++) if (!d() || !f()) return;
                    return new Ec(c[0].image, c[1] ? c[1].image : void 0, c[0].options, c[1] ? c[1].options : void 0)
                }

                evaluateParams(e, i) {
                    const a = {};
                    if (i) {
                        for (const c in i) if (i[c]) try {
                            a[c] = i[c].evaluate(e)
                        } catch {
                            continue
                        }
                        if (Object.keys(a).length !== 0) return {params: a}
                    }
                }

                evaluate(e) {
                    const i = {name: this.namePrimary.evaluate(e), iconsetId: this.iconsetIdPrimary},
                        a = this.nameSecondary ? {
                            name: this.nameSecondary.evaluate(e),
                            iconsetId: this.iconsetIdSecondary
                        } : void 0,
                        c = Ao.build(i, a, this.paramsPrimary ? this.evaluateParams(e, this.paramsPrimary) : void 0, this.paramsSecondary ? this.evaluateParams(e, this.paramsSecondary) : void 0);
                    if (c && e.availableImages) {
                        const d = c.getPrimary().id;
                        if (c.available = e.availableImages.some(f => Lo.isEqual(f, d)), c.available) {
                            const f = c.getSecondary() ? c.getSecondary().id : null;
                            f && (c.available = e.availableImages.some(_ => Lo.isEqual(_, f)))
                        }
                    }
                    return c
                }

                eachChild(e) {
                    if (e(this.namePrimary), this.paramsPrimary) for (const i in this.paramsPrimary) this.paramsPrimary[i] && e(this.paramsPrimary[i]);
                    if (this.nameSecondary && (e(this.nameSecondary), this.paramsSecondary)) for (const i in this.paramsSecondary) this.paramsSecondary[i] && e(this.paramsSecondary[i])
                }

                outputDefined() {
                    return !1
                }

                serializeOptions(e, i) {
                    const a = {};
                    if (i && (a.iconset = {id: i}), e) {
                        a.params = {};
                        for (const c in e) e[c] && (a.params[c] = e[c].serialize())
                    }
                    return Object.keys(a).length > 0 ? a : void 0
                }

                serialize() {
                    const e = ["image", this.namePrimary.serialize()];
                    if (this.paramsPrimary || this.iconsetIdPrimary) {
                        const i = this.serializeOptions(this.paramsPrimary, this.iconsetIdPrimary);
                        i && e.push(i)
                    }
                    if (this.nameSecondary && (e.push(this.nameSecondary.serialize()), this.paramsSecondary || this.iconsetIdSecondary)) {
                        const i = this.serializeOptions(this.paramsSecondary, this.iconsetIdSecondary);
                        i && e.push(i)
                    }
                    return e
                }
            }

            function Xa(n) {
                return n instanceof Number ? "number" : n instanceof String ? "string" : n instanceof Boolean ? "boolean" : Array.isArray(n) ? "array" : n === null ? "null" : typeof n
            }

            const V_ = {"to-boolean": Qi, "to-color": ko, "to-number": Vt, "to-string": Ki};

            class vs {
                constructor(e, i) {
                    this.type = e, this.args = i
                }

                static parse(e, i) {
                    if (e.length < 2) return i.error("Expected at least one argument.");
                    const a = e[0], c = [];
                    let d = bc;
                    if (a === "to-array") {
                        if (!Array.isArray(e[1])) return null;
                        const f = e[1].length;
                        if (i.expectedType) {
                            if (i.expectedType.kind !== "array") return i.error(`Expected ${i.expectedType.kind} but found array.`);
                            d = Jr(i.expectedType.itemType, f)
                        } else {
                            if (!(f > 0 && gi(e[1][0]))) return null;
                            d = Jr(It(e[1][0]), f)
                        }
                        for (let _ = 0; _ < f; _++) {
                            const x = e[1][_];
                            let w;
                            if (Xa(x) === "array") w = i.parse(x, void 0, d.itemType); else {
                                const E = Xa(x);
                                if (E !== d.itemType.kind) return i.error(`Expected ${d.itemType.kind} but found ${E}.`);
                                w = i.registry.literal.parse(["literal", x === void 0 ? null : x], i)
                            }
                            if (!w) return null;
                            c.push(w)
                        }
                    } else {
                        if ((a === "to-boolean" || a === "to-string") && e.length !== 2) return i.error("Expected one argument.");
                        d = V_[a];
                        for (let f = 1; f < e.length; f++) {
                            const _ = i.parse(e[f], f, en);
                            if (!_) return null;
                            c.push(_)
                        }
                    }
                    return new vs(d, c)
                }

                evaluate(e) {
                    if (this.type.kind === "boolean") return !!this.args[0].evaluate(e);
                    if (this.type.kind === "color") {
                        let i, a;
                        for (const c of this.args) {
                            if (i = c.evaluate(e), a = null, i instanceof Ji) return i;
                            if (typeof i == "string") {
                                const d = e.parseColor(i);
                                if (d) return d
                            } else if (Array.isArray(i) && (a = i.length < 3 || i.length > 4 ? `Invalid rbga value ${JSON.stringify(i)}: expected an array containing either three or four numeric values.` : Bl(i[0], i[1], i[2], i[3]), !a)) return new Ji(i[0] / 255, i[1] / 255, i[2] / 255, i[3])
                        }
                        throw new or(a || `Could not parse color from value '${typeof i == "string" ? i : String(JSON.stringify(i))}'`)
                    }
                    if (this.type.kind === "number") {
                        let i = null;
                        for (const a of this.args) {
                            if (i = a.evaluate(e), i === null) return 0;
                            const c = Number(i);
                            if (!isNaN(c)) return c
                        }
                        throw new or(`Could not convert ${JSON.stringify(i)} to number.`)
                    }
                    return this.type.kind === "formatted" ? fo.fromString(ys(this.args[0].evaluate(e))) : this.type.kind === "resolvedImage" ? Ao.build(ys(this.args[0].evaluate(e))) : this.type.kind === "array" ? this.args.map(i => i.evaluate(e)) : ys(this.args[0].evaluate(e))
                }

                eachChild(e) {
                    this.args.forEach(e)
                }

                outputDefined() {
                    return this.args.every(e => e.outputDefined())
                }

                serialize() {
                    if (this.type.kind === "formatted") return new Sc([{
                        content: this.args[0],
                        scale: null,
                        font: null,
                        textColor: null
                    }]).serialize();
                    if (this.type.kind === "resolvedImage") return new Ec(this.args[0]).serialize();
                    const e = this.type.kind === "array" ? [] : [`to-${this.type.kind}`];
                    return this.eachChild(i => {
                        e.push(i.serialize())
                    }), e
                }
            }

            const po = ["Unknown", "Point", "LineString", "Polygon"];

            class lh {
                constructor(e, i) {
                    this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = e, this.options = i
                }

                id() {
                    return this.feature && this.feature.id !== void 0 ? this.feature.id : null
                }

                geometryType() {
                    return this.feature ? typeof this.feature.type == "number" ? po[this.feature.type] : this.feature.type : null
                }

                geometry() {
                    return this.feature && "geometry" in this.feature ? this.feature.geometry : null
                }

                canonicalID() {
                    return this.canonical
                }

                properties() {
                    return this.feature && this.feature.properties || {}
                }

                measureLight(e) {
                    return this.globals.brightness || 0
                }

                distanceFromCenter() {
                    if (this.featureTileCoord && this.featureDistanceData) {
                        const e = this.featureDistanceData.center, i = this.featureDistanceData.scale, {
                            x: a,
                            y: c
                        } = this.featureTileCoord;
                        return this.featureDistanceData.bearing[0] * (a * i - e[0]) + this.featureDistanceData.bearing[1] * (c * i - e[1])
                    }
                    return 0
                }

                parseColor(e) {
                    let i = this._parseColorCache[e];
                    return i || (i = this._parseColorCache[e] = Ji.parse(e)), i
                }

                getConfig(e) {
                    return this.options ? this.options.get(e) : null
                }
            }

            class Mr {
                constructor(e, i, a, c, d) {
                    this.name = e, this.type = i, this._evaluate = a, this.args = c, this._overloadIndex = d
                }

                evaluate(e) {
                    if (!this._evaluate) {
                        const i = Mr.definitions[this.name];
                        this._evaluate = Array.isArray(i) ? i[2] : i.overloads[this._overloadIndex][1]
                    }
                    return this._evaluate(e, this.args)
                }

                eachChild(e) {
                    this.args.forEach(e)
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    return [this.name].concat(this.args.map(e => e.serialize()))
                }

                static parse(e, i) {
                    const a = e[0], c = Mr.definitions[a];
                    if (!c) return i.error(`Unknown expression "${a}". If you wanted a literal array, use ["literal", [...]].`, 0);
                    const d = Array.isArray(c) ? c[0] : c.type, f = Array.isArray(c) ? [[c[1], c[2]]] : c.overloads,
                        _ = [];
                    let x = null, w = -1;
                    for (const [E, I] of f) {
                        if (Array.isArray(E) && E.length !== e.length - 1) continue;
                        _.push(E), w++, x = new Rd(i.registry, i.path, null, i.scope, void 0, i._scope, i.options);
                        const C = [];
                        let z = !1;
                        for (let L = 1; L < e.length; L++) {
                            const F = e[L], N = Array.isArray(E) ? E[L - 1] : E.type, H = x.parse(F, 1 + C.length, N);
                            if (!H) {
                                z = !0;
                                break
                            }
                            C.push(H)
                        }
                        if (!z) if (Array.isArray(E) && E.length !== C.length) x.error(`Expected ${E.length} arguments, but found ${C.length} instead.`); else {
                            for (let L = 0; L < C.length; L++) {
                                const F = Array.isArray(E) ? E[L] : E.type, N = C[L];
                                x.concat(L + 1).checkSubtype(F, N.type)
                            }
                            if (x.errors.length === 0) return new Mr(a, d, I, C, w)
                        }
                    }
                    if (_.length === 1) i.errors.push(...x.errors); else {
                        const E = (_.length ? _ : f.map(([C]) => C)).map(Op).join(" | "), I = [];
                        for (let C = 1; C < e.length; C++) {
                            const z = i.parse(e[C], 1 + I.length);
                            if (!z) return null;
                            I.push(cr(z.type))
                        }
                        i.error(`Expected arguments of type ${E}, but found (${I.join(", ")}) instead.`)
                    }
                    return null
                }

                static register(e, i) {
                    Mr.definitions = i;
                    for (const a in i) e[a] = Mr
                }
            }

            function Op(n) {
                return Array.isArray(n) ? `(${n.map(cr).join(", ")})` : `(${cr(n.type)}...)`
            }

            class Ks {
                constructor(e, i, a) {
                    this.type = gd, this.locale = a, this.caseSensitive = e, this.diacriticSensitive = i
                }

                static parse(e, i) {
                    if (e.length !== 2) return i.error("Expected one argument.");
                    const a = e[1];
                    if (typeof a != "object" || Array.isArray(a)) return i.error("Collator options argument must be an object.");
                    const c = a["case-sensitive"] === void 0 ? i.parse(!1, 1, Qi) : i.parseObjectValue(a["case-sensitive"], 1, "case-sensitive", Qi);
                    if (!c) return null;
                    const d = a["diacritic-sensitive"] === void 0 ? i.parse(!1, 1, Qi) : i.parseObjectValue(a["diacritic-sensitive"], 1, "diacritic-sensitive", Qi);
                    if (!d) return null;
                    let f = null;
                    return a.locale && (f = i.parseObjectValue(a.locale, 1, "locale", Ki), !f) ? null : new Ks(c, d, f)
                }

                evaluate(e) {
                    return new sh(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null)
                }

                eachChild(e) {
                    e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale)
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    const e = {};
                    return e["case-sensitive"] = this.caseSensitive.serialize(), e["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (e.locale = this.locale.serialize()), ["collator", e]
                }
            }

            function eo(n, e, i = 0, a = n.length - 1, c = Vx) {
                for (; a > i;) {
                    if (a - i > 600) {
                        const x = a - i + 1, w = e - i + 1, E = Math.log(x), I = .5 * Math.exp(2 * E / 3),
                            C = .5 * Math.sqrt(E * I * (x - I) / x) * (w - x / 2 < 0 ? -1 : 1);
                        eo(n, e, Math.max(i, Math.floor(e - w * I / x + C)), Math.min(a, Math.floor(e + (x - w) * I / x + C)), c)
                    }
                    const d = n[e];
                    let f = i, _ = a;
                    for (ch(n, i, e), c(n[a], d) > 0 && ch(n, i, a); f < _;) {
                        for (ch(n, f, _), f++, _--; c(n[f], d) < 0;) f++;
                        for (; c(n[_], d) > 0;) _--
                    }
                    c(n[i], d) === 0 ? ch(n, i, _) : (_++, ch(n, _, a)), _ <= e && (i = _ + 1), e <= _ && (a = _ - 1)
                }
            }

            function ch(n, e, i) {
                const a = n[e];
                n[e] = n[i], n[i] = a
            }

            function Vx(n, e) {
                return n < e ? -1 : n > e ? 1 : 0
            }

            function Ux(n) {
                let e = 0;
                for (let i, a, c = 0, d = n.length, f = d - 1; c < d; f = c++) i = n[c], a = n[f], e += (a.x - i.x) * (i.y + a.y);
                return e
            }

            function Ya(n, e) {
                n[0] = Math.min(n[0], e[0]), n[1] = Math.min(n[1], e[1]), n[2] = Math.max(n[2], e[0]), n[3] = Math.max(n[3], e[1])
            }

            function Ac(n, e) {
                return !(n[0] <= e[0] || n[2] >= e[2] || n[1] <= e[1] || n[3] >= e[3])
            }

            function Nl(n, e, i) {
                const a = n[0] - e[0], c = n[1] - e[1], d = n[0] - i[0], f = n[1] - i[1];
                return a * f - d * c == 0 && a * d <= 0 && c * f <= 0
            }

            function Ic(n, e, i = !1) {
                let a = !1;
                for (let _ = 0, x = e.length; _ < x; _++) {
                    const w = e[_];
                    for (let E = 0, I = w.length, C = I - 1; E < I; C = E++) {
                        const z = w[C], L = w[E];
                        if (Nl(n, z, L)) return i;
                        (d = z)[1] > (c = n)[1] != (f = L)[1] > c[1] && c[0] < (f[0] - d[0]) * (c[1] - d[1]) / (f[1] - d[1]) + d[0] && (a = !a)
                    }
                }
                var c, d, f;
                return a
            }

            function U_(n, e, i, a) {
                const c = a[0] - i[0], d = a[1] - i[1], f = (n[0] - i[0]) * d - c * (n[1] - i[1]),
                    _ = (e[0] - i[0]) * d - c * (e[1] - i[1]);
                return f > 0 && _ < 0 || f < 0 && _ > 0
            }

            function vd(n, e, i, a) {
                return (c = [a[0] - i[0], a[1] - i[1]])[0] * (d = [e[0] - n[0], e[1] - n[1]])[1] - c[1] * d[0] != 0 && !(!U_(n, e, i, a) || !U_(i, a, n, e));
                var c, d
            }

            function Fp(n) {
                const e = new Ze(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY),
                    i = new Ze(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
                for (const a of n[0]) e.x > a.x && (e.x = a.x), e.y > a.y && (e.y = a.y), i.x < a.x && (i.x = a.x), i.y < a.y && (i.y = a.y);
                return {min: e, max: i}
            }

            const Ka = 8192;

            function Gx(n, e) {
                const i = (180 + n[0]) / 360,
                    a = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + n[1] * Math.PI / 360))) / 360,
                    c = Math.pow(2, e.z);
                return [Math.round(i * c * Ka), Math.round(a * c * Ka)]
            }

            function G_(n, e) {
                for (let i = 0; i < e.length; i++) if (Ic(n, e[i])) return !0;
                return !1
            }

            function $x(n, e, i) {
                for (const a of i) for (let c = 0, d = a.length, f = d - 1; c < d; f = c++) if (vd(n, e, a[f], a[c])) return !0;
                return !1
            }

            function $_(n, e) {
                for (let i = 0; i < n.length; ++i) if (!Ic(n[i], e)) return !1;
                for (let i = 0; i < n.length - 1; ++i) if ($x(n[i], n[i + 1], e)) return !1;
                return !0
            }

            function H_(n, e) {
                for (let i = 0; i < e.length; i++) if ($_(n, e[i])) return !0;
                return !1
            }

            function Bp(n, e, i) {
                const a = [];
                for (let c = 0; c < n.length; c++) {
                    const d = [];
                    for (let f = 0; f < n[c].length; f++) {
                        const _ = Gx(n[c][f], i);
                        Ya(e, _), d.push(_)
                    }
                    a.push(d)
                }
                return a
            }

            function Qa(n, e, i) {
                const a = [];
                for (let c = 0; c < n.length; c++) {
                    const d = Bp(n[c], e, i);
                    a.push(d)
                }
                return a
            }

            function q_(n, e, i, a) {
                if (n[0] < i[0] || n[0] > i[2]) {
                    const c = .5 * a;
                    let d = n[0] - i[0] > c ? -a : i[0] - n[0] > c ? a : 0;
                    d === 0 && (d = n[0] - i[2] > c ? -a : i[2] - n[0] > c ? a : 0), n[0] += d
                }
                Ya(e, n)
            }

            function W_(n, e, i, a) {
                const c = Math.pow(2, a.z) * Ka, d = [a.x * Ka, a.y * Ka], f = [];
                if (!n) return f;
                for (const _ of n) for (const x of _) {
                    const w = [x.x + d[0], x.y + d[1]];
                    q_(w, e, i, c), f.push(w)
                }
                return f
            }

            function xd(n, e, i, a) {
                const c = Math.pow(2, a.z) * Ka, d = [a.x * Ka, a.y * Ka], f = [];
                if (!n) return f;
                for (const x of n) {
                    const w = [];
                    for (const E of x) {
                        const I = [E.x + d[0], E.y + d[1]];
                        Ya(e, I), w.push(I)
                    }
                    f.push(w)
                }
                if (e[2] - e[0] <= c / 2) {
                    (_ = e)[0] = _[1] = 1 / 0, _[2] = _[3] = -1 / 0;
                    for (const x of f) for (const w of x) q_(w, e, i, c)
                }
                var _;
                return f
            }

            class Ja {
                constructor(e, i) {
                    this.type = Qi, this.geojson = e, this.geometries = i
                }

                static parse(e, i) {
                    if (e.length !== 2) return i.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
                    if (gi(e[1])) {
                        const a = e[1];
                        if (a.type === "FeatureCollection") for (let c = 0; c < a.features.length; ++c) {
                            const d = a.features[c].geometry.type;
                            if (d === "Polygon" || d === "MultiPolygon") return new Ja(a, a.features[c].geometry)
                        } else if (a.type === "Feature") {
                            const c = a.geometry.type;
                            if (c === "Polygon" || c === "MultiPolygon") return new Ja(a, a.geometry)
                        } else if (a.type === "Polygon" || a.type === "MultiPolygon") return new Ja(a, a)
                    }
                    return i.error("'within' expression requires valid geojson object that contains polygon geometry type.")
                }

                evaluate(e) {
                    if (e.geometry() != null && e.canonicalID() != null) {
                        if (e.geometryType() === "Point") return function (i, a) {
                            const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0], d = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                                f = i.canonicalID();
                            if (!f) return !1;
                            if (a.type === "Polygon") {
                                const _ = Bp(a.coordinates, d, f), x = W_(i.geometry(), c, d, f);
                                if (!Ac(c, d)) return !1;
                                for (const w of x) if (!Ic(w, _)) return !1
                            }
                            if (a.type === "MultiPolygon") {
                                const _ = Qa(a.coordinates, d, f), x = W_(i.geometry(), c, d, f);
                                if (!Ac(c, d)) return !1;
                                for (const w of x) if (!G_(w, _)) return !1
                            }
                            return !0
                        }(e, this.geometries);
                        if (e.geometryType() === "LineString") return function (i, a) {
                            const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0], d = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                                f = i.canonicalID();
                            if (!f) return !1;
                            if (a.type === "Polygon") {
                                const _ = Bp(a.coordinates, d, f), x = xd(i.geometry(), c, d, f);
                                if (!Ac(c, d)) return !1;
                                for (const w of x) if (!$_(w, _)) return !1
                            }
                            if (a.type === "MultiPolygon") {
                                const _ = Qa(a.coordinates, d, f), x = xd(i.geometry(), c, d, f);
                                if (!Ac(c, d)) return !1;
                                for (const w of x) if (!H_(w, _)) return !1
                            }
                            return !0
                        }(e, this.geometries)
                    }
                    return !1
                }

                eachChild() {
                }

                outputDefined() {
                    return !0
                }

                serialize() {
                    return ["within", this.geojson]
                }
            }

            const uh = {
                kilometers: 1,
                miles: 1e3 / 1609.344,
                nauticalmiles: 1e3 / 1852,
                meters: 1e3,
                metres: 1e3,
                yards: 1e3 / .9144,
                feet: 1e3 / .3048,
                inches: 1e3 / .0254
            }, xs = 1 / 298.257223563, Np = xs * (2 - xs), Cc = Math.PI / 180;

            class Pc {
                static fromTile(e, i, a) {
                    const c = Math.PI * (1 - 2 * (e + .5) / Math.pow(2, i)),
                        d = Math.atan(.5 * (Math.exp(c) - Math.exp(-c))) / Cc;
                    return new Pc(d, a)
                }

                static get units() {
                    return uh
                }

                constructor(e, i) {
                    if (e === void 0) throw new Error("No latitude given.");
                    if (i && !uh[i]) throw new Error(`Unknown unit ${i}. Use one of: ${Object.keys(uh).join(", ")}`);
                    const a = 6378.137 * Cc * (i ? uh[i] : 1), c = Math.cos(e * Cc), d = 1 / (1 - Np * (1 - c * c)),
                        f = Math.sqrt(d);
                    this.kx = a * f * c, this.ky = a * f * d * (1 - Np)
                }

                distance(e, i) {
                    const a = Ko(e[0] - i[0]) * this.kx, c = (e[1] - i[1]) * this.ky;
                    return Math.sqrt(a * a + c * c)
                }

                bearing(e, i) {
                    const a = Ko(i[0] - e[0]) * this.kx;
                    return Math.atan2(a, (i[1] - e[1]) * this.ky) / Cc
                }

                destination(e, i, a) {
                    const c = a * Cc;
                    return this.offset(e, Math.sin(c) * i, Math.cos(c) * i)
                }

                offset(e, i, a) {
                    return [e[0] + i / this.kx, e[1] + a / this.ky]
                }

                lineDistance(e) {
                    let i = 0;
                    for (let a = 0; a < e.length - 1; a++) i += this.distance(e[a], e[a + 1]);
                    return i
                }

                area(e) {
                    let i = 0;
                    for (let a = 0; a < e.length; a++) {
                        const c = e[a];
                        for (let d = 0, f = c.length, _ = f - 1; d < f; _ = d++) i += Ko(c[d][0] - c[_][0]) * (c[d][1] + c[_][1]) * (a ? -1 : 1)
                    }
                    return Math.abs(i) / 2 * this.kx * this.ky
                }

                along(e, i) {
                    let a = 0;
                    if (i <= 0) return e[0];
                    for (let c = 0; c < e.length - 1; c++) {
                        const d = e[c], f = e[c + 1], _ = this.distance(d, f);
                        if (a += _, a > i) return wd(d, f, (i - (a - _)) / _)
                    }
                    return e[e.length - 1]
                }

                pointToSegmentDistance(e, i, a) {
                    let [c, d] = i, f = Ko(a[0] - c) * this.kx, _ = (a[1] - d) * this.ky;
                    if (f !== 0 || _ !== 0) {
                        const x = (Ko(e[0] - c) * this.kx * f + (e[1] - d) * this.ky * _) / (f * f + _ * _);
                        x > 1 ? (c = a[0], d = a[1]) : x > 0 && (c += f / this.kx * x, d += _ / this.ky * x)
                    }
                    return f = Ko(e[0] - c) * this.kx, _ = (e[1] - d) * this.ky, Math.sqrt(f * f + _ * _)
                }

                pointOnLine(e, i) {
                    let a = 1 / 0, c = e[0][0], d = e[0][1], f = 0, _ = 0;
                    for (let x = 0; x < e.length - 1; x++) {
                        let w = e[x][0], E = e[x][1], I = Ko(e[x + 1][0] - w) * this.kx,
                            C = (e[x + 1][1] - E) * this.ky, z = 0;
                        I === 0 && C === 0 || (z = (Ko(i[0] - w) * this.kx * I + (i[1] - E) * this.ky * C) / (I * I + C * C), z > 1 ? (w = e[x + 1][0], E = e[x + 1][1]) : z > 0 && (w += I / this.kx * z, E += C / this.ky * z)), I = Ko(i[0] - w) * this.kx, C = (i[1] - E) * this.ky;
                        const L = I * I + C * C;
                        L < a && (a = L, c = w, d = E, f = x, _ = z)
                    }
                    return {point: [c, d], index: f, t: Math.max(0, Math.min(1, _))}
                }

                lineSlice(e, i, a) {
                    let c = this.pointOnLine(a, e), d = this.pointOnLine(a, i);
                    if (c.index > d.index || c.index === d.index && c.t > d.t) {
                        const w = c;
                        c = d, d = w
                    }
                    const f = [c.point], _ = c.index + 1, x = d.index;
                    !jp(a[_], f[0]) && _ <= x && f.push(a[_]);
                    for (let w = _ + 1; w <= x; w++) f.push(a[w]);
                    return jp(a[x], d.point) || f.push(d.point), f
                }

                lineSliceAlong(e, i, a) {
                    let c = 0;
                    const d = [];
                    for (let f = 0; f < a.length - 1; f++) {
                        const _ = a[f], x = a[f + 1], w = this.distance(_, x);
                        if (c += w, c > e && d.length === 0 && d.push(wd(_, x, (e - (c - w)) / w)), c >= i) return d.push(wd(_, x, (i - (c - w)) / w)), d;
                        c > e && d.push(x)
                    }
                    return d
                }

                bufferPoint(e, i) {
                    const a = i / this.ky, c = i / this.kx;
                    return [e[0] - c, e[1] - a, e[0] + c, e[1] + a]
                }

                bufferBBox(e, i) {
                    const a = i / this.ky, c = i / this.kx;
                    return [e[0] - c, e[1] - a, e[2] + c, e[3] + a]
                }

                insideBBox(e, i) {
                    return Ko(e[0] - i[0]) >= 0 && Ko(e[0] - i[2]) <= 0 && e[1] >= i[1] && e[1] <= i[3]
                }
            }

            function jp(n, e) {
                return n[0] === e[0] && n[1] === e[1]
            }

            function wd(n, e, i) {
                const a = Ko(e[0] - n[0]);
                return [n[0] + a * i, n[1] + (e[1] - n[1]) * i]
            }

            function Ko(n) {
                for (; n < -180;) n += 360;
                for (; n > 180;) n -= 360;
                return n
            }

            class bd {
                constructor(e = [], i = (a, c) => a < c ? -1 : a > c ? 1 : 0) {
                    if (this.data = e, this.length = this.data.length, this.compare = i, this.length > 0) for (let a = (this.length >> 1) - 1; a >= 0; a--) this._down(a)
                }

                push(e) {
                    this.data.push(e), this._up(this.length++)
                }

                pop() {
                    if (this.length === 0) return;
                    const e = this.data[0], i = this.data.pop();
                    return --this.length > 0 && (this.data[0] = i, this._down(0)), e
                }

                peek() {
                    return this.data[0]
                }

                _up(e) {
                    const {data: i, compare: a} = this, c = i[e];
                    for (; e > 0;) {
                        const d = e - 1 >> 1, f = i[d];
                        if (a(c, f) >= 0) break;
                        i[e] = f, e = d
                    }
                    i[e] = c
                }

                _down(e) {
                    const {data: i, compare: a} = this, c = this.length >> 1, d = i[e];
                    for (; e < c;) {
                        let f = 1 + (e << 1);
                        const _ = f + 1;
                        if (_ < this.length && a(i[_], i[f]) < 0 && (f = _), a(i[f], d) >= 0) break;
                        i[e] = i[f], e = f
                    }
                    i[e] = d
                }
            }

            var yt = 8192;

            function Vp(n, e) {
                return e.dist - n.dist
            }

            const Td = 100, Sd = 50;

            function hh(n) {
                const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                if (e.length !== n.length) return !1;
                for (let i = 0; i < e.length; i++) if (e[i] !== n[i]) return !1;
                return !0
            }

            function jl(n) {
                return n[1] - n[0] + 1
            }

            function ws(n, e) {
                const i = n[1] >= n[0] && n[1] < e;
                return i || console.warn("Distance Expression: Index is out of range"), i
            }

            function Ed(n, e) {
                if (n[0] > n[1]) return [null, null];
                const i = jl(n);
                if (e) {
                    if (i === 2) return [n, null];
                    const a = Math.floor(i / 2);
                    return [[n[0], n[0] + a], [n[0] + a, n[1]]]
                }
                {
                    if (i === 1) return [n, null];
                    const a = Math.floor(i / 2) - 1;
                    return [[n[0], n[0] + a], [n[0] + a + 1, n[1]]]
                }
            }

            function el(n, e) {
                const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                if (!ws(e, n.length)) return i;
                for (let a = e[0]; a <= e[1]; ++a) Ya(i, n[a]);
                return i
            }

            function dh(n) {
                const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                for (let i = 0; i < n.length; ++i) for (let a = 0; a < n[i].length; ++a) Ya(e, n[i][a]);
                return e
            }

            function Fs(n, e, i) {
                if (hh(n) || hh(e)) return NaN;
                let a = 0, c = 0;
                return n[2] < e[0] && (a = e[0] - n[2]), n[0] > e[2] && (a = n[0] - e[2]), n[1] > e[3] && (c = n[1] - e[3]), n[3] < e[1] && (c = e[1] - n[3]), i.distance([0, 0], [a, c])
            }

            function Oi(n) {
                return 360 * n - 180
            }

            function Hx(n) {
                return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n) * Math.PI / 180)) - 90
            }

            function Up(n, e) {
                const i = Math.pow(2, e.z), a = (n.y / yt + e.y) / i;
                return [Oi((n.x / yt + e.x) / i), Hx(a)]
            }

            function qx(n, e) {
                const i = [];
                for (let a = 0; a < n.length; ++a) i.push(Up(n[a], e));
                return i
            }

            function Gp(n, e, i) {
                const a = i.pointOnLine(e, n).point;
                return i.distance(n, a)
            }

            function Z_(n, e, i, a, c) {
                const d = i.slice(a[0], a[1] + 1);
                let f = 1 / 0;
                for (let _ = e[0]; _ <= e[1]; ++_) if ((f = Math.min(f, Gp(n[_], d, c))) === 0) return 0;
                return f
            }

            function zn(n, e, i, a, c) {
                const d = Math.min(c.pointToSegmentDistance(n, i, a), c.pointToSegmentDistance(e, i, a)),
                    f = Math.min(c.pointToSegmentDistance(i, n, e), c.pointToSegmentDistance(a, n, e));
                return Math.min(d, f)
            }

            function Wx(n, e, i, a, c) {
                if (!ws(e, n.length) || !ws(a, i.length)) return NaN;
                let d = 1 / 0;
                for (let f = e[0]; f < e[1]; ++f) for (let _ = a[0]; _ < a[1]; ++_) {
                    if (vd(n[f], n[f + 1], i[_], i[_ + 1])) return 0;
                    d = Math.min(d, zn(n[f], n[f + 1], i[_], i[_ + 1], c))
                }
                return d
            }

            function Zx(n, e, i, a, c) {
                if (!ws(e, n.length) || !ws(a, i.length)) return NaN;
                let d = 1 / 0;
                for (let f = e[0]; f <= e[1]; ++f) for (let _ = a[0]; _ <= a[1]; ++_) if ((d = Math.min(d, c.distance(n[f], i[_]))) === 0) return d;
                return d
            }

            function Xx(n, e, i) {
                if (Ic(n, e, !0)) return 0;
                let a = 1 / 0;
                for (const c of e) {
                    const d = c.length;
                    if (d < 2) return console.warn("Distance Expression: Invalid polygon!"), NaN;
                    if (c[0] !== c[d - 1] && (a = Math.min(a, i.pointToSegmentDistance(n, c[d - 1], c[0]))) === 0 || (a = Math.min(a, Gp(n, c, i))) === 0) return a
                }
                return a
            }

            function Yx(n, e, i, a) {
                if (!ws(e, n.length)) return NaN;
                for (let d = e[0]; d <= e[1]; ++d) if (Ic(n[d], i, !0)) return 0;
                let c = 1 / 0;
                for (let d = e[0]; d < e[1]; ++d) for (const f of i) for (let _ = 0, x = f.length, w = x - 1; _ < x; w = _++) {
                    if (vd(n[d], n[d + 1], f[w], f[_])) return 0;
                    c = Math.min(c, zn(n[d], n[d + 1], f[w], f[_], a))
                }
                return c
            }

            function X_(n, e) {
                for (const i of n) for (let a = 0; a <= i.length - 1; ++a) if (Ic(i[a], e, !0)) return !0;
                return !1
            }

            function Kx(n, e, i, a = 1 / 0) {
                const c = dh(n), d = dh(e);
                if (a !== 1 / 0 && Fs(c, d, i) >= a) return a;
                if (Ac(c, d)) {
                    if (X_(n, e)) return 0
                } else if (X_(e, n)) return 0;
                let f = a;
                for (const _ of n) for (let x = 0, w = _.length, E = w - 1; x < w; E = x++) for (const I of e) for (let C = 0, z = I.length, L = z - 1; C < z; L = C++) {
                    if (vd(_[E], _[x], I[L], I[C])) return 0;
                    f = Math.min(f, zn(_[E], _[x], I[L], I[C], i))
                }
                return f
            }

            function Ad(n, e, i, a, c, d, f) {
                if (d === null || f === null) return;
                const _ = Fs(el(a, d), el(c, f), i);
                _ < e && n.push({dist: _, range1: d, range2: f})
            }

            function Qx(n, e, i, a, c = 1 / 0) {
                let d = Math.min(a.distance(n[0], i[0][0]), c);
                if (d === 0) return d;
                const f = new bd([{dist: 0, range1: [0, n.length - 1], range2: [0, 0]}], Vp), _ = e ? Sd : Td,
                    x = dh(i);
                for (; f.length;) {
                    const w = f.pop();
                    if (w.dist >= d) continue;
                    const E = w.range1;
                    if (jl(E) <= _) {
                        if (!ws(E, n.length)) return NaN;
                        if (e) {
                            const I = Yx(n, E, i, a);
                            if ((d = Math.min(d, I)) === 0) return d
                        } else for (let I = E[0]; I <= E[1]; ++I) {
                            const C = Xx(n[I], i, a);
                            if ((d = Math.min(d, C)) === 0) return d
                        }
                    } else {
                        const I = Ed(E, e);
                        if (I[0] !== null) {
                            const C = Fs(el(n, I[0]), x, a);
                            C < d && f.push({dist: C, range1: I[0], range2: [0, 0]})
                        }
                        if (I[1] !== null) {
                            const C = Fs(el(n, I[1]), x, a);
                            C < d && f.push({dist: C, range1: I[1], range2: [0, 0]})
                        }
                    }
                }
                return d
            }

            function Y_(n, e, i, a, c, d = 1 / 0) {
                let f = Math.min(d, c.distance(n[0], i[0]));
                if (f === 0) return f;
                const _ = new bd([{dist: 0, range1: [0, n.length - 1], range2: [0, i.length - 1]}], Vp),
                    x = e ? Sd : Td, w = a ? Sd : Td;
                for (; _.length;) {
                    const E = _.pop();
                    if (E.dist >= f) continue;
                    const I = E.range1, C = E.range2;
                    if (jl(I) <= x && jl(C) <= w) {
                        if (!ws(I, n.length) || !ws(C, i.length)) return NaN;
                        if (e && a ? f = Math.min(f, Wx(n, I, i, C, c)) : e || a ? e && !a ? f = Math.min(f, Z_(i, C, n, I, c)) : !e && a && (f = Math.min(f, Z_(n, I, i, C, c))) : f = Math.min(f, Zx(n, I, i, C, c)), f === 0) return f
                    } else {
                        const z = Ed(I, e), L = Ed(C, a);
                        Ad(_, f, c, n, i, z[0], L[0]), Ad(_, f, c, n, i, z[0], L[1]), Ad(_, f, c, n, i, z[1], L[0]), Ad(_, f, c, n, i, z[1], L[1])
                    }
                }
                return f
            }

            function $p(n, e, i, a, c = 1 / 0) {
                let d = c;
                const f = el(n, [0, n.length - 1]);
                for (const _ of i) if (!(d !== 1 / 0 && Fs(f, el(_, [0, _.length - 1]), a) >= d) && (d = Math.min(d, Y_(n, e, _, !0, a, d)), d === 0)) return d;
                return d
            }

            function Id(n, e, i, a, c = 1 / 0) {
                let d = c;
                const f = el(n, [0, n.length - 1]);
                for (const _ of i) {
                    if (d !== 1 / 0 && Fs(f, dh(_), a) >= d) continue;
                    const x = Qx(n, e, _, a, d);
                    if (isNaN(x)) return x;
                    if ((d = Math.min(d, x)) === 0) return d
                }
                return d
            }

            function Hp(n) {
                return n === "Point" || n === "MultiPoint" || n === "LineString" || n === "MultiLineString" || n === "Polygon" || n === "MultiPolygon"
            }

            class Vl {
                constructor(e, i) {
                    this.type = Vt, this.geojson = e, this.geometries = i
                }

                static parse(e, i) {
                    if (e.length !== 2) return i.error(`'distance' expression requires either one argument, but found ' ${e.length - 1} instead.`);
                    if (gi(e[1])) {
                        const a = e[1];
                        if (a.type === "FeatureCollection") {
                            for (let c = 0; c < a.features.length; ++c) if (Hp(a.features[c].geometry.type)) return new Vl(a, a.features[c].geometry)
                        } else if (a.type === "Feature") {
                            if (Hp(a.geometry.type)) return new Vl(a, a.geometry)
                        } else if (Hp(a.type)) return new Vl(a, a)
                    }
                    return i.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].")
                }

                evaluate(e) {
                    const i = e.geometry(), a = e.canonicalID();
                    if (i != null && a != null) {
                        if (e.geometryType() === "Point") return function (c, d, f) {
                            const _ = [];
                            for (const w of c) for (const E of w) _.push(Up(E, d));
                            const x = new Pc(_[0][1], "meters");
                            return f.type === "Point" || f.type === "MultiPoint" || f.type === "LineString" ? Y_(_, !1, f.type === "Point" ? [f.coordinates] : f.coordinates, f.type === "LineString", x) : f.type === "MultiLineString" ? $p(_, !1, f.coordinates, x) : f.type === "Polygon" || f.type === "MultiPolygon" ? Id(_, !1, f.type === "Polygon" ? [f.coordinates] : f.coordinates, x) : null
                        }(i, a, this.geometries);
                        if (e.geometryType() === "LineString") return function (c, d, f) {
                            const _ = [];
                            for (const w of c) {
                                const E = [];
                                for (const I of w) E.push(Up(I, d));
                                _.push(E)
                            }
                            const x = new Pc(_[0][0][1], "meters");
                            if (f.type === "Point" || f.type === "MultiPoint" || f.type === "LineString") return $p(f.type === "Point" ? [f.coordinates] : f.coordinates, f.type === "LineString", _, x);
                            if (f.type === "MultiLineString") {
                                let w = 1 / 0;
                                for (let E = 0; E < f.coordinates.length; E++) {
                                    const I = $p(f.coordinates[E], !0, _, x, w);
                                    if (isNaN(I)) return I;
                                    if ((w = Math.min(w, I)) === 0) return w
                                }
                                return w
                            }
                            if (f.type === "Polygon" || f.type === "MultiPolygon") {
                                let w = 1 / 0;
                                for (let E = 0; E < _.length; E++) {
                                    const I = Id(_[E], !0, f.type === "Polygon" ? [f.coordinates] : f.coordinates, x, w);
                                    if (isNaN(I)) return I;
                                    if ((w = Math.min(w, I)) === 0) return w
                                }
                                return w
                            }
                            return null
                        }(i, a, this.geometries);
                        if (e.geometryType() === "Polygon") return function (c, d, f) {
                            const _ = [];
                            for (const w of function (E, I) {
                                const C = E.length;
                                if (C <= 1) return [E];
                                const z = [];
                                let L, F;
                                for (let N = 0; N < C; N++) {
                                    const H = Ux(E[N]);
                                    H !== 0 && (E[N].area = Math.abs(H), F === void 0 && (F = H < 0), F === H < 0 ? (L && z.push(L), L = [E[N]]) : L.push(E[N]))
                                }
                                return L && z.push(L), z
                            }(c)) {
                                const E = [];
                                for (let I = 0; I < w.length; ++I) E.push(qx(w[I], d));
                                _.push(E)
                            }
                            const x = new Pc(_[0][0][0][1], "meters");
                            if (f.type === "Point" || f.type === "MultiPoint" || f.type === "LineString") return Id(f.type === "Point" ? [f.coordinates] : f.coordinates, f.type === "LineString", _, x);
                            if (f.type === "MultiLineString") {
                                let w = 1 / 0;
                                for (let E = 0; E < f.coordinates.length; E++) {
                                    const I = Id(f.coordinates[E], !0, _, x, w);
                                    if (isNaN(I)) return I;
                                    if ((w = Math.min(w, I)) === 0) return w
                                }
                                return w
                            }
                            return f.type === "Polygon" || f.type === "MultiPolygon" ? function (w, E, I) {
                                let C = 1 / 0;
                                for (const z of w) for (const L of E) {
                                    const F = Kx(z, L, I, C);
                                    if (isNaN(F)) return F;
                                    if ((C = Math.min(C, F)) === 0) return C
                                }
                                return C
                            }(f.type === "Polygon" ? [f.coordinates] : f.coordinates, _, x) : null
                        }(i, a, this.geometries);
                        console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.")
                    } else console.warn("Distance Expression: requirs valid feature and canonical information.");
                    return null
                }

                eachChild() {
                }

                outputDefined() {
                    return !0
                }

                serialize() {
                    return ["distance", this.geojson]
                }
            }

            function Mc(n) {
                if (n instanceof Mr && (n.name === "get" && n.args.length === 1 || n.name === "feature-state" || n.name === "has" && n.args.length === 1 || n.name === "properties" || n.name === "geometry-type" || n.name === "id" || /^filter-/.test(n.name)) || n instanceof Ja || n instanceof Vl) return !1;
                if (n instanceof zc) return n.featureConstant;
                let e = !0;
                return n.eachChild(i => {
                    e && !Mc(i) && (e = !1)
                }), e
            }

            function Cd(n) {
                if (n instanceof Mr && n.name === "feature-state") return !1;
                let e = !0;
                return n.eachChild(i => {
                    e && !Cd(i) && (e = !1)
                }), e
            }

            function Pd(n) {
                if (n instanceof zc) return new Set([n.key]);
                let e = new Set;
                return n.eachChild(i => {
                    e = new Set([...e, ...Pd(i)])
                }), e
            }

            function Rc(n, e) {
                if (n instanceof Mr && e.indexOf(n.name) >= 0) return !1;
                let i = !0;
                return n.eachChild(a => {
                    i && !Rc(a, e) && (i = !1)
                }), i
            }

            function K_(n, e, i) {
                return [n, e, i].filter(Boolean).join("")
            }

            function qp(n, e) {
                switch (n) {
                    case"string":
                        return ys(e);
                    case"number":
                        return +e;
                    case"boolean":
                        return !!e;
                    case"color":
                        return Ji.parse(e);
                    case"formatted":
                        return fo.fromString(ys(e));
                    case"resolvedImage":
                        return Ao.build(ys(e))
                }
                return e
            }

            function Q_(n, e, i, a) {
                return a !== void 0 && (n = a * Math.round(n / a)), e !== void 0 && n < e && (n = e), i !== void 0 && n > i && (n = i), n
            }

            class zc {
                constructor(e, i, a, c = !1) {
                    this.type = e, this.key = i, this.scope = a, this.featureConstant = c
                }

                static parse(e, i) {
                    let a = i.expectedType;
                    if (a == null && (a = en), e.length < 2 || e.length > 3) return i.error("Invalid number of arguments for 'config' expression.");
                    const c = i.parse(e[1], 1);
                    if (!(c instanceof ei)) return i.error("Key name of 'config' expression must be a string literal.");
                    let d, f = !0;
                    const _ = ys(c.value);
                    if (e.length >= 3) {
                        const x = i.parse(e[2], 2);
                        if (!(x instanceof ei)) return i.error("Scope of 'config' expression must be a string literal.");
                        d = ys(x.value)
                    }
                    if (i.options) {
                        const x = K_(_, d, i._scope), w = i.options.get(x);
                        w && (f = Mc(w.value || w.default))
                    }
                    return new zc(a, _, d, f)
                }

                evaluate(e) {
                    const i = K_(this.key, this.scope, e.scope), a = e.getConfig(i);
                    if (!a) return null;
                    const {type: c, value: d, values: f, minValue: _, maxValue: x, stepValue: w} = a,
                        E = a.default.evaluate(e);
                    let I = E;
                    if (d) {
                        const C = e.scope;
                        e.scope = (C || "").split("").slice(1).join(""), I = d.evaluate(e), e.scope = C
                    }
                    return c && (I = qp(c, I)), I === void 0 || _ === void 0 && x === void 0 && w === void 0 || (typeof I == "number" ? I = Q_(I, _, x, w) : Array.isArray(I) && (I = I.map(C => typeof C == "number" ? Q_(C, _, x, w) : C))), d !== void 0 && I !== void 0 && f && !f.includes(I) && (I = E, c && (I = qp(c, I))), (c && c !== this.type || I !== void 0 && !_d(It(I), this.type)) && (I = qp(this.type.kind, I)), I
                }

                eachChild() {
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    const e = ["config", this.key];
                    return this.scope && e.concat(this.scope), e
                }
            }

            class Md {
                constructor(e, i) {
                    this.type = i.type, this.name = e, this.boundExpression = i
                }

                static parse(e, i) {
                    if (e.length !== 2 || typeof e[1] != "string") return i.error("'var' expression requires exactly one string literal argument.");
                    const a = e[1];
                    return i.scope.has(a) ? new Md(a, i.scope.get(a)) : i.error(`Unknown variable "${a}". Make sure "${a}" has been bound in an enclosing "let" expression before using it.`, 1)
                }

                evaluate(e) {
                    return this.boundExpression.evaluate(e)
                }

                eachChild() {
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    return ["var", this.name]
                }
            }

            class Rd {
                constructor(e, i = [], a, c = new kp, d = [], f, _) {
                    this.registry = e, this.path = i, this.key = i.map(x => typeof x == "string" ? `['${x}']` : `[${x}]`).join(""), this.scope = c, this.errors = d, this.expectedType = a, this._scope = f, this.options = _
                }

                parse(e, i, a, c, d = {}) {
                    return i || a ? this.concat(i, null, a, c)._parse(e, d) : this._parse(e, d)
                }

                parseObjectValue(e, i, a, c, d, f = {}) {
                    return this.concat(i, a, c, d)._parse(e, f)
                }

                _parse(e, i) {
                    function a(c, d, f) {
                        return f === "assert" ? new Yt(d, [c]) : f === "coerce" ? new vs(d, [c]) : c
                    }

                    if (e !== null && typeof e != "string" && typeof e != "boolean" && typeof e != "number" || (e = ["literal", e]), Array.isArray(e)) {
                        if (e.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                        const c = typeof e[0] == "string" ? this.registry[e[0]] : void 0;
                        if (c) {
                            let d = c.parse(e, this);
                            if (!d) return null;
                            if (this.expectedType) {
                                const f = this.expectedType, _ = d.type;
                                if (f.kind !== "string" && f.kind !== "number" && f.kind !== "boolean" && f.kind !== "object" && f.kind !== "array" || _.kind !== "value") if (f.kind !== "color" && f.kind !== "formatted" && f.kind !== "resolvedImage" || _.kind !== "value" && _.kind !== "string") {
                                    if (this.checkSubtype(f, _)) return null
                                } else d = a(d, f, i.typeAnnotation || "coerce"); else d = a(d, f, i.typeAnnotation || "assert")
                            }
                            if (!(d instanceof ei) && d.type.kind !== "resolvedImage" && Wp(d)) {
                                const f = new lh(this._scope, this.options);
                                try {
                                    d = new ei(d.type, d.evaluate(f))
                                } catch (_) {
                                    return this.error(_.message), null
                                }
                            }
                            return d
                        }
                        return vs.parse(["to-array", e], this)
                    }
                    return this.error(e === void 0 ? "'undefined' value invalid. Use null instead." : typeof e == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof e} instead.`)
                }

                concat(e, i, a, c) {
                    let d = typeof e == "number" ? this.path.concat(e) : this.path;
                    d = typeof i == "string" ? d.concat(i) : d;
                    const f = c ? this.scope.concat(c) : this.scope;
                    return new Rd(this.registry, d, a || null, f, this.errors, this._scope, this.options)
                }

                error(e, ...i) {
                    const a = `${this.key}${i.map(c => `[${c}]`).join("")}`;
                    this.errors.push(new Yo(a, e))
                }

                checkSubtype(e, i) {
                    const a = Tc(e, i);
                    return a && this.error(a), a
                }
            }

            function Wp(n) {
                if (n instanceof Md) return Wp(n.boundExpression);
                if (n instanceof Mr && n.name === "error" || n instanceof Ks || n instanceof Ja || n instanceof Vl || n instanceof zc) return !1;
                const e = n instanceof vs || n instanceof Yt;
                let i = !0;
                return n.eachChild(a => {
                    i = e ? i && Wp(a) : i && a instanceof ei
                }), !!i && Mc(n) && Rc(n, ["zoom", "heatmap-density", "worldview", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light", "raster-particle-speed"])
            }

            function zd(n, e) {
                const i = n.length - 1;
                let a, c, d = 0, f = i, _ = 0;
                for (; d <= f;) if (_ = Math.floor((d + f) / 2), a = n[_], c = n[_ + 1], a <= e) {
                    if (_ === i || e < c) return _;
                    d = _ + 1
                } else {
                    if (!(a > e)) throw new or("Input is not a number.");
                    f = _ - 1
                }
                return 0
            }

            class fh {
                constructor(e, i, a) {
                    this.type = e, this.input = i, this.labels = [], this.outputs = [];
                    for (const [c, d] of a) this.labels.push(c), this.outputs.push(d)
                }

                static parse(e, i) {
                    if (e.length - 1 < 4) return i.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
                    if ((e.length - 1) % 2 != 0) return i.error("Expected an even number of arguments.");
                    const a = i.parse(e[1], 1, Vt);
                    if (!a) return null;
                    const c = [];
                    let d = null;
                    i.expectedType && i.expectedType.kind !== "value" && (d = i.expectedType);
                    for (let f = 1; f < e.length; f += 2) {
                        const _ = f === 1 ? -1 / 0 : e[f], x = e[f + 1], w = f, E = f + 1;
                        if (typeof _ != "number") return i.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', w);
                        if (c.length && c[c.length - 1][0] >= _) return i.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', w);
                        const I = i.parse(x, E, d);
                        if (!I) return null;
                        d = d || I.type, c.push([_, I])
                    }
                    return new fh(d, a, c)
                }

                evaluate(e) {
                    const i = this.labels, a = this.outputs;
                    if (i.length === 1) return a[0].evaluate(e);
                    const c = this.input.evaluate(e);
                    if (c <= i[0]) return a[0].evaluate(e);
                    const d = i.length;
                    return c >= i[d - 1] ? a[d - 1].evaluate(e) : a[zd(i, c)].evaluate(e)
                }

                eachChild(e) {
                    e(this.input);
                    for (const i of this.outputs) e(i)
                }

                outputDefined() {
                    return this.outputs.every(e => e.outputDefined())
                }

                serialize() {
                    const e = ["step", this.input.serialize()];
                    for (let i = 0; i < this.labels.length; i++) i > 0 && e.push(this.labels[i]), e.push(this.outputs[i].serialize());
                    return e
                }
            }

            const J_ = .95047, ey = 1.08883, ty = 4 / 29, Dc = 6 / 29, iy = 3 * Dc * Dc, Zp = Dc * Dc * Dc,
                Jx = Math.PI / 180, ny = 180 / Math.PI;

            function Xp(n) {
                return n > Zp ? Math.pow(n, 1 / 3) : n / iy + ty
            }

            function Yp(n) {
                return n > Dc ? n * n * n : iy * (n - ty)
            }

            function Kp(n) {
                return 255 * (n <= .0031308 ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - .055)
            }

            function Dd(n) {
                return (n /= 255) <= .04045 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4)
            }

            function Qp(n) {
                const e = Dd(n.r), i = Dd(n.g), a = Dd(n.b), c = Xp((.4124564 * e + .3575761 * i + .1804375 * a) / J_),
                    d = Xp((.2126729 * e + .7151522 * i + .072175 * a) / 1);
                return {
                    l: 116 * d - 16,
                    a: 500 * (c - d),
                    b: 200 * (d - Xp((.0193339 * e + .119192 * i + .9503041 * a) / ey)),
                    alpha: n.a
                }
            }

            function Ul(n) {
                let e = (n.l + 16) / 116, i = isNaN(n.a) ? e : e + n.a / 500, a = isNaN(n.b) ? e : e - n.b / 200;
                return e = 1 * Yp(e), i = J_ * Yp(i), a = ey * Yp(a), new Ji(Kp(3.2404542 * i - 1.5371385 * e - .4985314 * a), Kp(-.969266 * i + 1.8760108 * e + .041556 * a), Kp(.0556434 * i - .2040259 * e + 1.0572252 * a), n.alpha)
            }

            function ry(n, e, i) {
                const a = e - n;
                return n + i * (a > 180 || a < -180 ? a - 360 * Math.round(a / 360) : a)
            }

            const Lc = {
                forward: Qp, reverse: Ul, interpolate: function (n, e, i) {
                    return {l: qt(n.l, e.l, i), a: qt(n.a, e.a, i), b: qt(n.b, e.b, i), alpha: qt(n.alpha, e.alpha, i)}
                }
            }, ph = {
                forward: function (n) {
                    const {l: e, a: i, b: a} = Qp(n), c = Math.atan2(a, i) * ny;
                    return {h: c < 0 ? c + 360 : c, c: Math.sqrt(i * i + a * a), l: e, alpha: n.a}
                }, reverse: function (n) {
                    const e = n.h * Jx, i = n.c;
                    return Ul({l: n.l, a: Math.cos(e) * i, b: Math.sin(e) * i, alpha: n.alpha})
                }, interpolate: function (n, e, i) {
                    return {h: ry(n.h, e.h, i), c: qt(n.c, e.c, i), l: qt(n.l, e.l, i), alpha: qt(n.alpha, e.alpha, i)}
                }
            };
            var Ld = Object.freeze({__proto__: null, hcl: ph, lab: Lc});

            class Io {
                constructor(e, i, a, c, d) {
                    this.type = e, this.operator = i, this.interpolation = a, this.input = c, this.labels = [], this.outputs = [];
                    for (const [f, _] of d) this.labels.push(f), this.outputs.push(_)
                }

                static interpolationFactor(e, i, a, c) {
                    let d = 0;
                    if (e.name === "exponential") d = Jp(i, e.base, a, c); else if (e.name === "linear") d = Jp(i, 1, a, c); else if (e.name === "cubic-bezier") {
                        const f = e.controlPoints;
                        d = new Ha(f[0], f[1], f[2], f[3]).solve(Jp(i, 1, a, c))
                    }
                    return d
                }

                static parse(e, i) {
                    let [a, c, d, ...f] = e;
                    if (!Array.isArray(c) || c.length === 0) return i.error("Expected an interpolation type expression.", 1);
                    if (c[0] === "linear") c = {name: "linear"}; else if (c[0] === "exponential") {
                        const w = c[1];
                        if (typeof w != "number") return i.error("Exponential interpolation requires a numeric base.", 1, 1);
                        c = {name: "exponential", base: w}
                    } else {
                        if (c[0] !== "cubic-bezier") return i.error(`Unknown interpolation type ${String(c[0])}`, 1, 0);
                        {
                            const w = c.slice(1);
                            if (w.length !== 4 || w.some(E => typeof E != "number" || E < 0 || E > 1)) return i.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                            c = {name: "cubic-bezier", controlPoints: w}
                        }
                    }
                    if (e.length - 1 < 4) return i.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
                    if (e.length - 1 > 3 && (e.length - 1) % 2 != 0) return i.error("Expected an even number of arguments.");
                    if (d = i.parse(d, 2, Vt), !d) return null;
                    const _ = [];
                    let x = null;
                    a === "interpolate-hcl" || a === "interpolate-lab" ? x = ko : i.expectedType && i.expectedType.kind !== "value" && (x = i.expectedType);
                    for (let w = 0; w < f.length; w += 2) {
                        const E = f[w], I = f[w + 1], C = w + 3, z = w + 4;
                        if (typeof E != "number") return i.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', C);
                        if (_.length && _[_.length - 1][0] >= E) return i.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', C);
                        const L = i.parse(I, z, x);
                        if (!L) return null;
                        x = x || L.type, _.push([E, L])
                    }
                    return x.kind === "number" || x.kind === "color" || x.kind === "array" && x.itemType.kind === "number" && typeof x.N == "number" ? new Io(x, a, c, d, _) : i.error(`Type ${cr(x)} is not interpolatable.`)
                }

                evaluate(e) {
                    const i = this.labels, a = this.outputs;
                    if (i.length === 1) return a[0].evaluate(e);
                    const c = this.input.evaluate(e);
                    if (c <= i[0]) return a[0].evaluate(e);
                    const d = i.length;
                    if (c >= i[d - 1]) return a[d - 1].evaluate(e);
                    const f = zd(i, c), _ = Io.interpolationFactor(this.interpolation, c, i[f], i[f + 1]),
                        x = a[f].evaluate(e), w = a[f + 1].evaluate(e);
                    return this.operator === "interpolate" ? ih[this.type.kind.toLowerCase()](x, w, _) : this.operator === "interpolate-hcl" ? ph.reverse(ph.interpolate(ph.forward(x), ph.forward(w), _)) : Lc.reverse(Lc.interpolate(Lc.forward(x), Lc.forward(w), _))
                }

                eachChild(e) {
                    e(this.input);
                    for (const i of this.outputs) e(i)
                }

                outputDefined() {
                    return this.outputs.every(e => e.outputDefined())
                }

                serialize() {
                    let e;
                    e = this.interpolation.name === "linear" ? ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier", ...this.interpolation.controlPoints];
                    const i = [this.operator, e, this.input.serialize()];
                    for (let a = 0; a < this.labels.length; a++) i.push(this.labels[a], this.outputs[a].serialize());
                    return i
                }
            }

            function Jp(n, e, i, a) {
                const c = a - i, d = n - i;
                return c === 0 ? 0 : e === 1 ? d / c : (Math.pow(e, d) - 1) / (Math.pow(e, c) - 1)
            }

            class kd {
                constructor(e, i) {
                    this.type = e, this.args = i
                }

                static parse(e, i) {
                    if (e.length < 2) return i.error("Expectected at least one argument.");
                    let a = null;
                    const c = i.expectedType;
                    c && c.kind !== "value" && (a = c);
                    const d = [];
                    for (const _ of e.slice(1)) {
                        const x = i.parse(_, 1 + d.length, a, void 0, {typeAnnotation: "omit"});
                        if (!x) return null;
                        a = a || x.type, d.push(x)
                    }
                    const f = c && d.some(_ => Tc(c, _.type));
                    return new kd(f ? en : a, d)
                }

                evaluate(e) {
                    let i, a = null, c = 0;
                    for (const d of this.args) {
                        if (c++, a = d.evaluate(e), a && a instanceof Ao && !a.available && (i || (i = a), a = null, c === this.args.length)) return i;
                        if (a !== null) break
                    }
                    return a
                }

                eachChild(e) {
                    this.args.forEach(e)
                }

                outputDefined() {
                    return this.args.every(e => e.outputDefined())
                }

                serialize() {
                    const e = ["coalesce"];
                    return this.eachChild(i => {
                        e.push(i.serialize())
                    }), e
                }
            }

            class mh {
                constructor(e, i) {
                    this.type = i.type, this.bindings = [].concat(e), this.result = i
                }

                evaluate(e) {
                    return this.result.evaluate(e)
                }

                eachChild(e) {
                    for (const i of this.bindings) e(i[1]);
                    e(this.result)
                }

                static parse(e, i) {
                    if (e.length < 4) return i.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
                    const a = [];
                    for (let d = 1; d < e.length - 1; d += 2) {
                        const f = e[d];
                        if (typeof f != "string") return i.error(`Expected string, but found ${typeof f} instead.`, d);
                        if (/[^a-zA-Z0-9_]/.test(f)) return i.error("Variable names must contain only alphanumeric characters or '_'.", d);
                        const _ = i.parse(e[d + 1], d + 1);
                        if (!_) return null;
                        a.push([f, _])
                    }
                    const c = i.parse(e[e.length - 1], e.length - 1, i.expectedType, a);
                    return c ? new mh(a, c) : null
                }

                outputDefined() {
                    return this.result.outputDefined()
                }

                serialize() {
                    const e = ["let"];
                    for (const [i, a] of this.bindings) e.push(i, a.serialize());
                    return e.push(this.result.serialize()), e
                }
            }

            class Od {
                constructor(e, i, a) {
                    this.type = e, this.index = i, this.input = a
                }

                static parse(e, i) {
                    if (e.length !== 3) return i.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
                    const a = i.parse(e[1], 1, Vt), c = i.parse(e[2], 2, Jr(i.expectedType || en));
                    return a && c ? new Od(c.type.itemType, a, c) : null
                }

                evaluate(e) {
                    const i = this.index.evaluate(e), a = this.input.evaluate(e);
                    if (i < 0) throw new or(`Array index out of bounds: ${i} < 0.`);
                    if (i >= a.length) throw new or(`Array index out of bounds: ${i} > ${a.length - 1}.`);
                    if (i !== Math.floor(i)) throw new or(`Array index must be an integer, but found ${i} instead. Use at-interpolated to retrieve interpolated result with a fractional index.`);
                    return a[i]
                }

                eachChild(e) {
                    e(this.index), e(this.input)
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    return ["at", this.index.serialize(), this.input.serialize()]
                }
            }

            class em {
                constructor(e, i, a) {
                    this.type = e, this.index = i, this.input = a
                }

                static parse(e, i) {
                    if (e.length !== 3) return i.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
                    const a = i.parse(e[1], 1, Vt), c = i.parse(e[2], 2, Jr(i.expectedType || en));
                    return a && c ? new em(c.type.itemType, a, c) : null
                }

                evaluate(e) {
                    const i = this.index.evaluate(e), a = this.input.evaluate(e);
                    if (i < 0) throw new or(`Array index out of bounds: ${i} < 0.`);
                    if (i > a.length - 1) throw new or(`Array index out of bounds: ${i} > ${a.length - 1}.`);
                    if (i === Math.floor(i)) return a[i];
                    const c = Math.floor(i), d = Math.ceil(i), f = a[c], _ = a[d];
                    if (typeof f != "number" || typeof _ != "number") throw new or(`Cannot interpolate between non-number values at index ${i}.`);
                    const x = i - c;
                    return f * (1 - x) + _ * x
                }

                eachChild(e) {
                    e(this.index), e(this.input)
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    return ["at-interpolated", this.index.serialize(), this.input.serialize()]
                }
            }

            class tm {
                constructor(e, i) {
                    this.type = Qi, this.needle = e, this.haystack = i
                }

                static parse(e, i) {
                    if (e.length !== 3) return i.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
                    const a = i.parse(e[1], 1, en), c = i.parse(e[2], 2, en);
                    return a && c ? Za(a.type, [Qi, Ki, Vt, bc, en]) ? new tm(a, c) : i.error(`Expected first argument to be of type boolean, string, number or null, but found ${cr(a.type)} instead`) : null
                }

                evaluate(e) {
                    const i = this.needle.evaluate(e), a = this.haystack.evaluate(e);
                    if (a == null) return !1;
                    if (!oh(i, ["boolean", "string", "number", "null"])) throw new or(`Expected first argument to be of type boolean, string, number or null, but found ${cr(It(i))} instead.`);
                    if (!oh(a, ["string", "array"])) throw new or(`Expected second argument to be of type array or string, but found ${cr(It(a))} instead.`);
                    return a.indexOf(i) >= 0
                }

                eachChild(e) {
                    e(this.needle), e(this.haystack)
                }

                outputDefined() {
                    return !0
                }

                serialize() {
                    return ["in", this.needle.serialize(), this.haystack.serialize()]
                }
            }

            class Fd {
                constructor(e, i, a) {
                    this.type = Vt, this.needle = e, this.haystack = i, this.fromIndex = a
                }

                static parse(e, i) {
                    if (e.length <= 2 || e.length >= 5) return i.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
                    const a = i.parse(e[1], 1, en), c = i.parse(e[2], 2, en);
                    if (!a || !c) return null;
                    if (!Za(a.type, [Qi, Ki, Vt, bc, en])) return i.error(`Expected first argument to be of type boolean, string, number or null, but found ${cr(a.type)} instead`);
                    if (e.length === 4) {
                        const d = i.parse(e[3], 3, Vt);
                        return d ? new Fd(a, c, d) : null
                    }
                    return new Fd(a, c)
                }

                evaluate(e) {
                    const i = this.needle.evaluate(e), a = this.haystack.evaluate(e);
                    if (!oh(i, ["boolean", "string", "number", "null"])) throw new or(`Expected first argument to be of type boolean, string, number or null, but found ${cr(It(i))} instead.`);
                    if (!oh(a, ["string", "array"])) throw new or(`Expected second argument to be of type array or string, but found ${cr(It(a))} instead.`);
                    if (this.fromIndex) {
                        const c = this.fromIndex.evaluate(e);
                        return a.indexOf(i, c)
                    }
                    return a.indexOf(i)
                }

                eachChild(e) {
                    e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex)
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    if (this.fromIndex != null && this.fromIndex !== void 0) {
                        const e = this.fromIndex.serialize();
                        return ["index-of", this.needle.serialize(), this.haystack.serialize(), e]
                    }
                    return ["index-of", this.needle.serialize(), this.haystack.serialize()]
                }
            }

            class Bd {
                constructor(e, i, a, c, d, f) {
                    this.inputType = e, this.type = i, this.input = a, this.cases = c, this.outputs = d, this.otherwise = f
                }

                static parse(e, i) {
                    if (e.length < 5) return i.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
                    if (e.length % 2 != 1) return i.error("Expected an even number of arguments.");
                    let a, c;
                    i.expectedType && i.expectedType.kind !== "value" && (c = i.expectedType);
                    const d = {}, f = [];
                    for (let w = 2; w < e.length - 1; w += 2) {
                        let E = e[w];
                        const I = e[w + 1];
                        Array.isArray(E) || (E = [E]);
                        const C = i.concat(w);
                        if (E.length === 0) return C.error("Expected at least one branch label.");
                        for (const L of E) {
                            if (typeof L != "number" && typeof L != "string") return C.error("Branch labels must be numbers or strings.");
                            if (typeof L == "number" && Math.abs(L) > Number.MAX_SAFE_INTEGER) return C.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                            if (typeof L == "number" && Math.floor(L) !== L) return C.error("Numeric branch labels must be integer values.");
                            if (a) {
                                if (C.checkSubtype(a, It(L))) return null
                            } else a = It(L);
                            if (d[String(L)] !== void 0) return C.error("Branch labels must be unique.");
                            d[String(L)] = f.length
                        }
                        const z = i.parse(I, w, c);
                        if (!z) return null;
                        c = c || z.type, f.push(z)
                    }
                    const _ = i.parse(e[1], 1, en);
                    if (!_) return null;
                    const x = i.parse(e[e.length - 1], e.length - 1, c);
                    return x ? _.type.kind !== "value" && i.concat(1).checkSubtype(a, _.type) ? null : new Bd(a, c, _, d, f, x) : null
                }

                evaluate(e) {
                    const i = this.input.evaluate(e);
                    return (_d(It(i), this.inputType) && this.outputs[this.cases[i]] || this.otherwise).evaluate(e)
                }

                eachChild(e) {
                    e(this.input), this.outputs.forEach(e), e(this.otherwise)
                }

                outputDefined() {
                    return this.outputs.every(e => e.outputDefined()) && this.otherwise.outputDefined()
                }

                serialize() {
                    const e = ["match", this.input.serialize()], i = Object.keys(this.cases).sort(), a = [], c = {};
                    for (const f of i) {
                        const _ = c[this.cases[f]];
                        _ === void 0 ? (c[this.cases[f]] = a.length, a.push([this.cases[f], [f]])) : a[_][1].push(f)
                    }
                    const d = f => this.inputType.kind === "number" ? Number(f) : f;
                    for (const [f, _] of a) e.push(_.length === 1 ? d(_[0]) : _.map(d)), e.push(this.outputs[f].serialize());
                    return e.push(this.otherwise.serialize()), e
                }
            }

            class Nd {
                constructor(e, i, a) {
                    this.type = e, this.branches = i, this.otherwise = a
                }

                static parse(e, i) {
                    if (e.length < 4) return i.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
                    if (e.length % 2 != 0) return i.error("Expected an odd number of arguments.");
                    let a;
                    i.expectedType && i.expectedType.kind !== "value" && (a = i.expectedType);
                    const c = [];
                    for (let f = 1; f < e.length - 1; f += 2) {
                        const _ = i.parse(e[f], f, Qi);
                        if (!_) return null;
                        const x = i.parse(e[f + 1], f + 1, a);
                        if (!x) return null;
                        c.push([_, x]), a = a || x.type
                    }
                    const d = i.parse(e[e.length - 1], e.length - 1, a);
                    return d ? new Nd(a, c, d) : null
                }

                evaluate(e) {
                    for (const [i, a] of this.branches) if (i.evaluate(e)) return a.evaluate(e);
                    return this.otherwise.evaluate(e)
                }

                eachChild(e) {
                    for (const [i, a] of this.branches) e(i), e(a);
                    e(this.otherwise)
                }

                outputDefined() {
                    return this.branches.every(([e, i]) => i.outputDefined()) && this.otherwise.outputDefined()
                }

                serialize() {
                    const e = ["case"];
                    return this.eachChild(i => {
                        e.push(i.serialize())
                    }), e
                }
            }

            class Gl {
                constructor(e, i, a, c) {
                    this.type = e, this.input = i, this.beginIndex = a, this.endIndex = c
                }

                static parse(e, i) {
                    if (e.length <= 2 || e.length >= 5) return i.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
                    const a = i.parse(e[1], 1, en), c = i.parse(e[2], 2, Vt);
                    if (!a || !c) return null;
                    if (!Za(a.type, [Jr(en), Ki, en])) return i.error(`Expected first argument to be of type array or string, but found ${cr(a.type)} instead`);
                    if (e.length === 4) {
                        const d = i.parse(e[3], 3, Vt);
                        return d ? new Gl(a.type, a, c, d) : null
                    }
                    return new Gl(a.type, a, c)
                }

                evaluate(e) {
                    const i = this.input.evaluate(e), a = this.beginIndex.evaluate(e);
                    if (!oh(i, ["string", "array"])) throw new or(`Expected first argument to be of type array or string, but found ${cr(It(i))} instead.`);
                    if (this.endIndex) {
                        const c = this.endIndex.evaluate(e);
                        return i.slice(a, c)
                    }
                    return i.slice(a)
                }

                eachChild(e) {
                    e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex)
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    if (this.endIndex != null && this.endIndex !== void 0) {
                        const e = this.endIndex.serialize();
                        return ["slice", this.input.serialize(), this.beginIndex.serialize(), e]
                    }
                    return ["slice", this.input.serialize(), this.beginIndex.serialize()]
                }
            }

            class im {
                constructor(e, i) {
                    this.type = Jr(Ki), this.str = e, this.delimiter = i
                }

                static parse(e, i) {
                    if (e.length !== 3) return i.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
                    const a = i.parse(e[1], 1, Ki), c = i.parse(e[2], 2, Ki);
                    return a && c ? new im(a, c) : void 0
                }

                evaluate(e) {
                    const i = this.str.evaluate(e), a = this.delimiter.evaluate(e);
                    return i.split(a)
                }

                eachChild(e) {
                    e(this.str), e(this.delimiter)
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    return ["split", this.str.serialize(), this.delimiter.serialize()]
                }
            }

            function nm(n, e) {
                return n === "==" || n === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value"
            }

            function oy(n, e, i, a) {
                return a.compare(e, i) === 0
            }

            function kc(n, e, i) {
                const a = n !== "==" && n !== "!=";
                return class yL {
                    constructor(d, f, _) {
                        this.type = Qi, this.lhs = d, this.rhs = f, this.collator = _, this.hasUntypedArgument = d.type.kind === "value" || f.type.kind === "value"
                    }

                    static parse(d, f) {
                        if (d.length !== 3 && d.length !== 4) return f.error("Expected two or three arguments.");
                        const _ = d[0];
                        let x = f.parse(d[1], 1, en);
                        if (!x) return null;
                        if (!nm(_, x.type)) return f.concat(1).error(`"${_}" comparisons are not supported for type '${cr(x.type)}'.`);
                        let w = f.parse(d[2], 2, en);
                        if (!w) return null;
                        if (!nm(_, w.type)) return f.concat(2).error(`"${_}" comparisons are not supported for type '${cr(w.type)}'.`);
                        if (x.type.kind !== w.type.kind && x.type.kind !== "value" && w.type.kind !== "value") return f.error(`Cannot compare types '${cr(x.type)}' and '${cr(w.type)}'.`);
                        a && (x.type.kind === "value" && w.type.kind !== "value" ? x = new Yt(w.type, [x]) : x.type.kind !== "value" && w.type.kind === "value" && (w = new Yt(x.type, [w])));
                        let E = null;
                        if (d.length === 4) {
                            if (x.type.kind !== "string" && w.type.kind !== "string" && x.type.kind !== "value" && w.type.kind !== "value") return f.error("Cannot use collator to compare non-string types.");
                            if (E = f.parse(d[3], 3, gd), !E) return null
                        }
                        return new yL(x, w, E)
                    }

                    evaluate(d) {
                        const f = this.lhs.evaluate(d), _ = this.rhs.evaluate(d);
                        if (a && this.hasUntypedArgument) {
                            const x = It(f), w = It(_);
                            if (x.kind !== w.kind || x.kind !== "string" && x.kind !== "number") throw new or(`Expected arguments for "${n}" to be (string, string) or (number, number), but found (${x.kind}, ${w.kind}) instead.`)
                        }
                        if (this.collator && !a && this.hasUntypedArgument) {
                            const x = It(f), w = It(_);
                            if (x.kind !== "string" || w.kind !== "string") return e(d, f, _)
                        }
                        return this.collator ? i(d, f, _, this.collator.evaluate(d)) : e(d, f, _)
                    }

                    eachChild(d) {
                        d(this.lhs), d(this.rhs), this.collator && d(this.collator)
                    }

                    outputDefined() {
                        return !0
                    }

                    serialize() {
                        const d = [n];
                        return this.eachChild(f => {
                            d.push(f.serialize())
                        }), d
                    }
                }
            }

            const sy = kc("==", function (n, e, i) {
                return e === i
            }, oy), ay = kc("!=", function (n, e, i) {
                return e !== i
            }, function (n, e, i, a) {
                return !oy(0, e, i, a)
            }), e1 = kc("<", function (n, e, i) {
                return e < i
            }, function (n, e, i, a) {
                return a.compare(e, i) < 0
            }), t1 = kc(">", function (n, e, i) {
                return e > i
            }, function (n, e, i, a) {
                return a.compare(e, i) > 0
            }), i1 = kc("<=", function (n, e, i) {
                return e <= i
            }, function (n, e, i, a) {
                return a.compare(e, i) <= 0
            }), jd = kc(">=", function (n, e, i) {
                return e >= i
            }, function (n, e, i, a) {
                return a.compare(e, i) >= 0
            });

            class rm {
                constructor(e, i, a, c, d, f) {
                    this.type = Ki, this.number = e, this.locale = i, this.currency = a, this.unit = c, this.minFractionDigits = d, this.maxFractionDigits = f
                }

                static parse(e, i) {
                    if (e.length !== 3) return i.error("Expected two arguments.");
                    const a = i.parse(e[1], 1, Vt);
                    if (!a) return null;
                    const c = e[2];
                    if (typeof c != "object" || Array.isArray(c)) return i.error("NumberFormat options argument must be an object.");
                    let d = null;
                    if (c.locale && (d = i.parseObjectValue(c.locale, 2, "locale", Ki), !d)) return null;
                    let f = null;
                    if (c.currency && (f = i.parseObjectValue(c.currency, 2, "currency", Ki), !f)) return null;
                    let _ = null;
                    if (c.unit && (_ = i.parseObjectValue(c.unit, 2, "unit", Ki), !_)) return null;
                    let x = null;
                    if (c["min-fraction-digits"] && (x = i.parseObjectValue(c["min-fraction-digits"], 2, "min-fraction-digits", Vt), !x)) return null;
                    let w = null;
                    return c["max-fraction-digits"] && (w = i.parseObjectValue(c["max-fraction-digits"], 2, "max-fraction-digits", Vt), !w) ? null : new rm(a, d, f, _, x, w)
                }

                evaluate(e) {
                    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], {
                        style: (this.currency ? "currency" : this.unit && "unit") || "decimal",
                        currency: this.currency ? this.currency.evaluate(e) : void 0,
                        unit: this.unit ? this.unit.evaluate(e) : void 0,
                        minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0,
                        maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0
                    }).format(this.number.evaluate(e))
                }

                eachChild(e) {
                    e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.unit && e(this.unit), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits)
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    const e = {};
                    return this.locale && (e.locale = this.locale.serialize()), this.currency && (e.currency = this.currency.serialize()), this.unit && (e.unit = this.unit.serialize()), this.minFractionDigits && (e["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (e["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), e]
                }
            }

            class om {
                constructor(e) {
                    this.type = Vt, this.input = e
                }

                static parse(e, i) {
                    if (e.length !== 2) return i.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
                    const a = i.parse(e[1], 1);
                    return a ? a.type.kind !== "array" && a.type.kind !== "string" && a.type.kind !== "value" ? i.error(`Expected argument of type string or array, but found ${cr(a.type)} instead.`) : new om(a) : null
                }

                evaluate(e) {
                    const i = this.input.evaluate(e);
                    if (typeof i == "string" || Array.isArray(i)) return i.length;
                    throw new or(`Expected value to be of type string or array, but found ${cr(It(i))} instead.`)
                }

                eachChild(e) {
                    e(this.input)
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    const e = ["length"];
                    return this.eachChild(i => {
                        e.push(i.serialize())
                    }), e
                }
            }

            function ly(n) {
                return function () {
                    n = 1831565813 + (n |= 0) | 0;
                    let e = Math.imul(n ^ n >>> 15, 1 | n);
                    return e = e + Math.imul(e ^ e >>> 7, 61 | e) ^ e, ((e ^ e >>> 14) >>> 0) / 4294967296
                }
            }

            const Oc = {
                "==": sy,
                "!=": ay,
                ">": t1,
                "<": e1,
                ">=": jd,
                "<=": i1,
                array: Yt,
                at: Od,
                "at-interpolated": em,
                boolean: Yt,
                case: Nd,
                coalesce: kd,
                collator: Ks,
                format: Sc,
                image: Ec,
                in: tm,
                "index-of": Fd,
                interpolate: Io,
                "interpolate-hcl": Io,
                "interpolate-lab": Io,
                length: om,
                let: mh,
                literal: ei,
                match: Bd,
                number: Yt,
                "number-format": rm,
                object: Yt,
                slice: Gl,
                step: fh,
                string: Yt,
                "to-boolean": vs,
                "to-color": vs,
                "to-number": vs,
                "to-string": vs,
                var: Md,
                within: Ja,
                distance: Vl,
                config: zc,
                split: im
            };

            function sm(n, [e, i, a, c]) {
                e = e.evaluate(n), i = i.evaluate(n), a = a.evaluate(n);
                const d = c ? c.evaluate(n) : 1, f = Bl(e, i, a, d);
                if (f) throw new or(f);
                return new Ji(e / 255, i / 255, a / 255, d)
            }

            function cy(n, [e, i, a, c]) {
                e = e.evaluate(n), i = i.evaluate(n), a = a.evaluate(n);
                const d = c ? c.evaluate(n) : 1, f = function (w, E, I, C) {
                    return typeof w == "number" && w >= 0 && w <= 360 ? typeof E == "number" && E >= 0 && E <= 100 && typeof I == "number" && I >= 0 && I <= 100 ? C === void 0 || typeof C == "number" && C >= 0 && C <= 1 ? null : `Invalid hsla value [${[w, E, I, C].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid hsla value [${(typeof C == "number" ? [w, E, I, C] : [w, E, I]).join(", ")}]: 's', and 'l' must be between 0 and 100.` : `Invalid hsla value [${(typeof C == "number" ? [w, E, I, C] : [w, E, I]).join(", ")}]: 'h' must be between 0 and 360.`
                }(e, i, a, d);
                if (f) throw new or(f);
                const _ = `hsla(${e}, ${i}%, ${a}%, ${d})`, x = Ji.parse(_);
                if (!x) throw new or(`Failed to parse HSLA color: ${_}`);
                return x
            }

            function uy(n, e) {
                return n in e
            }

            function Vd(n, e) {
                const i = e[n];
                return i === void 0 ? null : i
            }

            function tl(n) {
                return {type: n}
            }

            function am(n) {
                return {result: "success", value: n}
            }

            function il(n) {
                return {result: "error", value: n}
            }

            function nl(n, e) {
                return !!n && !!n.parameters && n.parameters.indexOf(e) > -1
            }

            function Ud(n) {
                return n["property-type"] === "data-driven"
            }

            function hy(n) {
                return nl(n.expression, "measure-light")
            }

            function dy(n) {
                return nl(n.expression, "zoom")
            }

            function Gd(n) {
                return !!n.expression && n.expression.interpolated
            }

            function $d(n) {
                return typeof n == "object" && n !== null && !Array.isArray(n)
            }

            function fy(n) {
                return n
            }

            function lm(n, e) {
                const i = e.type === "color", a = n.stops && typeof n.stops[0][0] == "object",
                    c = a || !(a || n.property !== void 0), d = n.type || (Gd(e) ? "exponential" : "interval");
                if (i && ((n = Fl({}, n)).stops && (n.stops = n.stops.map(w => [w[0], Ji.parse(w[1])])), n.default = Ji.parse(n.default ? n.default : e.default)), n.colorSpace && n.colorSpace !== "rgb" && !Ld[n.colorSpace]) throw new Error(`Unknown color space: ${n.colorSpace}`);
                let f, _, x;
                if (d === "exponential") f = my; else if (d === "interval") f = py; else if (d === "categorical") {
                    f = cm, _ = Object.create(null);
                    for (const w of n.stops) _[w[0]] = w[1];
                    x = typeof n.stops[0][0]
                } else {
                    if (d !== "identity") throw new Error(`Unknown function type "${d}"`);
                    f = rl
                }
                if (a) {
                    const w = {}, E = [];
                    for (let z = 0; z < n.stops.length; z++) {
                        const L = n.stops[z], F = L[0].zoom;
                        w[F] === void 0 && (w[F] = {
                            zoom: F,
                            type: n.type,
                            property: n.property,
                            default: n.default,
                            stops: []
                        }, E.push(F)), w[F].stops.push([L[0].value, L[1]])
                    }
                    const I = [];
                    for (const z of E) I.push([w[z].zoom, lm(w[z], e)]);
                    const C = {name: "linear"};
                    return {
                        kind: "composite",
                        interpolationType: C,
                        interpolationFactor: Io.interpolationFactor.bind(void 0, C),
                        zoomStops: I.map(z => z[0]),
                        evaluate: ({zoom: z}, L) => my({stops: I, base: n.base}, e, z).evaluate(z, L)
                    }
                }
                if (c) {
                    const w = d === "exponential" ? {name: "exponential", base: n.base !== void 0 ? n.base : 1} : null;
                    return {
                        kind: "camera",
                        interpolationType: w,
                        interpolationFactor: Io.interpolationFactor.bind(void 0, w),
                        zoomStops: n.stops.map(E => E[0]),
                        evaluate: ({zoom: E}) => f(n, e, E, _, x)
                    }
                }
                return {
                    kind: "source", evaluate(w, E) {
                        const I = E && E.properties ? E.properties[n.property] : void 0;
                        return I === void 0 ? $l(n.default, e.default) : f(n, e, I, _, x)
                    }
                }
            }

            function $l(n, e, i) {
                return n !== void 0 ? n : e !== void 0 ? e : i !== void 0 ? i : void 0
            }

            function cm(n, e, i, a, c) {
                return $l(typeof i === c ? a[i] : void 0, n.default, e.default)
            }

            function py(n, e, i) {
                if (Xa(i) !== "number") return $l(n.default, e.default);
                const a = n.stops.length;
                if (a === 1 || i <= n.stops[0][0]) return n.stops[0][1];
                if (i >= n.stops[a - 1][0]) return n.stops[a - 1][1];
                const c = zd(n.stops.map(d => d[0]), i);
                return n.stops[c][1]
            }

            function my(n, e, i) {
                const a = n.base !== void 0 ? n.base : 1;
                if (Xa(i) !== "number") return $l(n.default, e.default);
                const c = n.stops.length;
                if (c === 1 || i <= n.stops[0][0]) return n.stops[0][1];
                if (i >= n.stops[c - 1][0]) return n.stops[c - 1][1];
                const d = zd(n.stops.map(E => E[0]), i), f = function (E, I, C, z) {
                    const L = z - C, F = E - C;
                    return L === 0 ? 0 : I === 1 ? F / L : (Math.pow(I, F) - 1) / (Math.pow(I, L) - 1)
                }(i, a, n.stops[d][0], n.stops[d + 1][0]), _ = n.stops[d][1], x = n.stops[d + 1][1];
                let w = ih[e.type] || fy;
                if (n.colorSpace && n.colorSpace !== "rgb") {
                    const E = Ld[n.colorSpace];
                    w = (I, C) => E.reverse(E.interpolate(E.forward(I), E.forward(C), f))
                }
                return typeof _.evaluate == "function" ? {
                    evaluate(...E) {
                        const I = _.evaluate.apply(void 0, E), C = x.evaluate.apply(void 0, E);
                        if (I !== void 0 && C !== void 0) return w(I, C, f)
                    }
                } : w(_, x, f)
            }

            function rl(n, e, i) {
                return e.type === "color" ? i = Ji.parse(i) : e.type === "formatted" ? i = fo.fromString(i.toString()) : e.type === "resolvedImage" ? i = Ao.build(i.toString()) : Xa(i) === e.type || e.type === "enum" && e.values[i] || (i = void 0), $l(i, n.default, e.default)
            }

            Mr.register(Oc, {
                error: [{kind: "error"}, [Ki], (n, [e]) => {
                    throw new or(e.evaluate(n))
                }],
                typeof: [Ki, [en], (n, [e]) => cr(It(e.evaluate(n)))],
                "to-rgba": [Jr(Vt, 4), [ko], (n, [e]) => e.evaluate(n).toNonPremultipliedRenderColor(null).toArray()],
                "to-hsla": [Jr(Vt, 4), [ko], (n, [e]) => e.evaluate(n).toNonPremultipliedRenderColor(null).toHslaArray()],
                rgb: [ko, [Vt, Vt, Vt], sm],
                rgba: [ko, [Vt, Vt, Vt, Vt], sm],
                hsl: [ko, [Vt, Vt, Vt], cy],
                hsla: [ko, [Vt, Vt, Vt, Vt], cy],
                has: {
                    type: Qi,
                    overloads: [[[Ki], (n, [e]) => uy(e.evaluate(n), n.properties())], [[Ki, ya], (n, [e, i]) => uy(e.evaluate(n), i.evaluate(n))]]
                },
                get: {
                    type: en,
                    overloads: [[[Ki], (n, [e]) => Vd(e.evaluate(n), n.properties())], [[Ki, ya], (n, [e, i]) => Vd(e.evaluate(n), i.evaluate(n))]]
                },
                "feature-state": [en, [Ki], (n, [e]) => Vd(e.evaluate(n), n.featureState || {})],
                properties: [ya, [], n => n.properties()],
                "geometry-type": [Ki, [], n => n.geometryType()],
                worldview: [Ki, [], n => n.globals.worldview || ""],
                id: [en, [], n => n.id()],
                zoom: [Vt, [], n => n.globals.zoom],
                pitch: [Vt, [], n => n.globals.pitch || 0],
                "distance-from-center": [Vt, [], n => n.distanceFromCenter()],
                "measure-light": [Vt, [Ki], (n, [e]) => n.measureLight(e.evaluate(n))],
                "heatmap-density": [Vt, [], n => n.globals.heatmapDensity || 0],
                "line-progress": [Vt, [], n => n.globals.lineProgress || 0],
                "raster-value": [Vt, [], n => n.globals.rasterValue || 0],
                "raster-particle-speed": [Vt, [], n => n.globals.rasterParticleSpeed || 0],
                "sky-radial-progress": [Vt, [], n => n.globals.skyRadialProgress || 0],
                accumulated: [en, [], n => n.globals.accumulated === void 0 ? null : n.globals.accumulated],
                "+": [Vt, tl(Vt), (n, e) => {
                    let i = 0;
                    for (const a of e) i += a.evaluate(n);
                    return i
                }],
                "*": [Vt, tl(Vt), (n, e) => {
                    let i = 1;
                    for (const a of e) i *= a.evaluate(n);
                    return i
                }],
                "-": {
                    type: Vt,
                    overloads: [[[Vt, Vt], (n, [e, i]) => e.evaluate(n) - i.evaluate(n)], [[Vt], (n, [e]) => -e.evaluate(n)]]
                },
                "/": [Vt, [Vt, Vt], (n, [e, i]) => e.evaluate(n) / i.evaluate(n)],
                "%": [Vt, [Vt, Vt], (n, [e, i]) => e.evaluate(n) % i.evaluate(n)],
                ln2: [Vt, [], () => Math.LN2],
                pi: [Vt, [], () => Math.PI],
                e: [Vt, [], () => Math.E],
                "^": [Vt, [Vt, Vt], (n, [e, i]) => Math.pow(e.evaluate(n), i.evaluate(n))],
                sqrt: [Vt, [Vt], (n, [e]) => Math.sqrt(e.evaluate(n))],
                log10: [Vt, [Vt], (n, [e]) => Math.log(e.evaluate(n)) / Math.LN10],
                ln: [Vt, [Vt], (n, [e]) => Math.log(e.evaluate(n))],
                log2: [Vt, [Vt], (n, [e]) => Math.log(e.evaluate(n)) / Math.LN2],
                sin: [Vt, [Vt], (n, [e]) => Math.sin(e.evaluate(n))],
                cos: [Vt, [Vt], (n, [e]) => Math.cos(e.evaluate(n))],
                tan: [Vt, [Vt], (n, [e]) => Math.tan(e.evaluate(n))],
                asin: [Vt, [Vt], (n, [e]) => Math.asin(e.evaluate(n))],
                acos: [Vt, [Vt], (n, [e]) => Math.acos(e.evaluate(n))],
                atan: [Vt, [Vt], (n, [e]) => Math.atan(e.evaluate(n))],
                min: [Vt, tl(Vt), (n, e) => Math.min(...e.map(i => i.evaluate(n)))],
                max: [Vt, tl(Vt), (n, e) => Math.max(...e.map(i => i.evaluate(n)))],
                abs: [Vt, [Vt], (n, [e]) => Math.abs(e.evaluate(n))],
                round: [Vt, [Vt], (n, [e]) => {
                    const i = e.evaluate(n);
                    return i < 0 ? -Math.round(-i) : Math.round(i)
                }],
                floor: [Vt, [Vt], (n, [e]) => Math.floor(e.evaluate(n))],
                ceil: [Vt, [Vt], (n, [e]) => Math.ceil(e.evaluate(n))],
                "filter-==": [Qi, [Ki, en], (n, [e, i]) => n.properties()[e.value] === i.value],
                "filter-id-==": [Qi, [en], (n, [e]) => n.id() === e.value],
                "filter-type-==": [Qi, [Ki], (n, [e]) => n.geometryType() === e.value],
                "filter-<": [Qi, [Ki, en], (n, [e, i]) => {
                    const a = n.properties()[e.value], c = i.value;
                    return typeof a == typeof c && a < c
                }],
                "filter-id-<": [Qi, [en], (n, [e]) => {
                    const i = n.id(), a = e.value;
                    return typeof i == typeof a && i < a
                }],
                "filter->": [Qi, [Ki, en], (n, [e, i]) => {
                    const a = n.properties()[e.value], c = i.value;
                    return typeof a == typeof c && a > c
                }],
                "filter-id->": [Qi, [en], (n, [e]) => {
                    const i = n.id(), a = e.value;
                    return typeof i == typeof a && i > a
                }],
                "filter-<=": [Qi, [Ki, en], (n, [e, i]) => {
                    const a = n.properties()[e.value], c = i.value;
                    return typeof a == typeof c && a <= c
                }],
                "filter-id-<=": [Qi, [en], (n, [e]) => {
                    const i = n.id(), a = e.value;
                    return typeof i == typeof a && i <= a
                }],
                "filter->=": [Qi, [Ki, en], (n, [e, i]) => {
                    const a = n.properties()[e.value], c = i.value;
                    return typeof a == typeof c && a >= c
                }],
                "filter-id->=": [Qi, [en], (n, [e]) => {
                    const i = n.id(), a = e.value;
                    return typeof i == typeof a && i >= a
                }],
                "filter-has": [Qi, [en], (n, [e]) => e.value in n.properties()],
                "filter-has-id": [Qi, [], n => n.id() !== null && n.id() !== void 0],
                "filter-type-in": [Qi, [Jr(Ki)], (n, [e]) => e.value.indexOf(n.geometryType()) >= 0],
                "filter-id-in": [Qi, [Jr(en)], (n, [e]) => e.value.indexOf(n.id()) >= 0],
                "filter-in-small": [Qi, [Ki, Jr(en)], (n, [e, i]) => i.value.indexOf(n.properties()[e.value]) >= 0],
                "filter-in-large": [Qi, [Ki, Jr(en)], (n, [e, i]) => function (a, c, d, f) {
                    for (; d <= f;) {
                        const _ = d + f >> 1;
                        if (c[_] === a) return !0;
                        c[_] > a ? f = _ - 1 : d = _ + 1
                    }
                    return !1
                }(n.properties()[e.value], i.value, 0, i.value.length - 1)],
                all: {
                    type: Qi,
                    overloads: [[[Qi, Qi], (n, [e, i]) => e.evaluate(n) && i.evaluate(n)], [tl(Qi), (n, e) => {
                        for (const i of e) if (!i.evaluate(n)) return !1;
                        return !0
                    }]]
                },
                any: {
                    type: Qi,
                    overloads: [[[Qi, Qi], (n, [e, i]) => e.evaluate(n) || i.evaluate(n)], [tl(Qi), (n, e) => {
                        for (const i of e) if (i.evaluate(n)) return !0;
                        return !1
                    }]]
                },
                "!": [Qi, [Qi], (n, [e]) => !e.evaluate(n)],
                "is-supported-script": [Qi, [Ki], (n, [e]) => {
                    const i = n.globals && n.globals.isSupportedScript;
                    return !i || i(e.evaluate(n))
                }],
                upcase: [Ki, [Ki], (n, [e]) => e.evaluate(n).toUpperCase()],
                downcase: [Ki, [Ki], (n, [e]) => e.evaluate(n).toLowerCase()],
                concat: [Ki, tl(en), (n, e) => e.map(i => ys(i.evaluate(n))).join("")],
                "resolved-locale": [Ki, [gd], (n, [e]) => e.evaluate(n).resolvedLocale()],
                random: [Vt, [Vt, Vt, en], (n, e) => {
                    const [i, a, c] = e.map(f => f.evaluate(n));
                    if (i > a || i === a) return i;
                    let d;
                    if (typeof c == "string") d = function (f) {
                        let _ = 0;
                        if (f.length === 0) return _;
                        for (let x = 0; x < f.length; x++) _ = (_ << 5) - _ + f.charCodeAt(x), _ |= 0;
                        return _
                    }(c); else {
                        if (typeof c != "number") throw new or(`Invalid seed input: ${c}`);
                        d = c
                    }
                    return i + ly(d)() * (a - i)
                }]
            });

            class um {
                constructor(e, i, a, c) {
                    this.expression = e, this._warningHistory = {}, this._evaluator = new lh(a, c), this._defaultValue = i ? function (d) {
                        return d.type === "color" && ($d(d.default) || Array.isArray(d.default)) ? new Ji(0, 0, 0, 0) : d.type === "color" ? Ji.parse(d.default) || null : d.default === void 0 ? null : d.default
                    }(i) : null, this._enumValues = i && i.type === "enum" ? i.values : null, this.configDependencies = Pd(e)
                }

                evaluateWithoutErrorHandling(e, i, a, c, d, f, _, x) {
                    return this._evaluator.globals = e, this._evaluator.feature = i, this._evaluator.featureState = a, this._evaluator.canonical = c || null, this._evaluator.availableImages = d || null, this._evaluator.formattedSection = f, this._evaluator.featureTileCoord = _ || null, this._evaluator.featureDistanceData = x || null, this.expression.evaluate(this._evaluator)
                }

                evaluate(e, i, a, c, d, f, _, x) {
                    this._evaluator.globals = e, this._evaluator.feature = i || null, this._evaluator.featureState = a || null, this._evaluator.canonical = c || null, this._evaluator.availableImages = d || null, this._evaluator.formattedSection = f || null, this._evaluator.featureTileCoord = _ || null, this._evaluator.featureDistanceData = x || null;
                    try {
                        const w = this.expression.evaluate(this._evaluator);
                        if (w == null || typeof w == "number" && w != w) return this._defaultValue;
                        if (this._enumValues && !(w in this._enumValues)) throw new or(`Expected value to be one of ${Object.keys(this._enumValues).map(E => JSON.stringify(E)).join(", ")}, but found ${JSON.stringify(w)} instead.`);
                        return w
                    } catch (w) {
                        return this._warningHistory[w.message] || (this._warningHistory[w.message] = !0, typeof console < "u" && console.warn(`Failed to evaluate expression "${JSON.stringify(this.expression.serialize())}". ${w.message}`)), this._defaultValue
                    }
                }
            }

            function hm(n) {
                return Array.isArray(n) && n.length > 0 && typeof n[0] == "string" && n[0] in Oc
            }

            function Hl(n, e, i, a) {
                const c = new Rd(Oc, [], e ? function (f) {
                        const _ = {
                            color: ko,
                            string: Ki,
                            number: Vt,
                            enum: Ki,
                            boolean: Qi,
                            formatted: nh,
                            resolvedImage: rh
                        };
                        return f.type === "array" ? Jr(_[f.value] || en, f.length) : _[f.type]
                    }(e) : void 0, void 0, void 0, i, a),
                    d = c.parse(n, void 0, void 0, void 0, e && e.type === "string" ? {typeAnnotation: "coerce"} : void 0);
                return d ? am(new um(d, e, i, a)) : il(c.errors)
            }

            class Hd {
                constructor(e, i, a, c) {
                    this.kind = e, this._styleExpression = i, this.isLightConstant = a, this.isLineProgressConstant = c, this.isStateDependent = e !== "constant" && !Cd(i.expression), this.configDependencies = Pd(i.expression)
                }

                evaluateWithoutErrorHandling(e, i, a, c, d, f) {
                    return this._styleExpression.evaluateWithoutErrorHandling(e, i, a, c, d, f)
                }

                evaluate(e, i, a, c, d, f) {
                    return this._styleExpression.evaluate(e, i, a, c, d, f)
                }
            }

            class ol {
                constructor(e, i, a, c, d, f) {
                    this.kind = e, this.zoomStops = a, this._styleExpression = i, this.isStateDependent = e !== "camera" && !Cd(i.expression), this.isLightConstant = d, this.isLineProgressConstant = f, this.configDependencies = Pd(i.expression), this.interpolationType = c
                }

                evaluateWithoutErrorHandling(e, i, a, c, d, f) {
                    return this._styleExpression.evaluateWithoutErrorHandling(e, i, a, c, d, f)
                }

                evaluate(e, i, a, c, d, f) {
                    return this._styleExpression.evaluate(e, i, a, c, d, f)
                }

                interpolationFactor(e, i, a) {
                    return this.interpolationType ? Io.interpolationFactor(this.interpolationType, e, i, a) : 0
                }
            }

            function dm(n, e, i, a) {
                if ((n = Hl(n, e, i, a)).result === "error") return n;
                const c = n.value.expression, d = Mc(c);
                if (!d && !Ud(e)) return il([new Yo("", "data expressions not supported")]);
                const f = Rc(c, ["zoom", "pitch", "distance-from-center"]);
                if (!f && !dy(e)) return il([new Yo("", "zoom expressions not supported")]);
                const _ = Rc(c, ["measure-light"]);
                if (!_ && !hy(e)) return il([new Yo("", "measure-light expression not supported")]);
                const x = Rc(c, ["line-progress"]);
                if (!x && !function (I) {
                    return nl(I.expression, "line-progress")
                }(e)) return il([new Yo("", "line-progress expression not supported")]);
                const w = e.expression && e.expression.relaxZoomRestriction, E = gh(c);
                return E || f || w ? E instanceof Yo ? il([E]) : E instanceof Io && !Gd(e) ? il([new Yo("", '"interpolate" expressions cannot be used with this property')]) : am(E ? new ol(d && x ? "camera" : "composite", n.value, E.labels, E instanceof Io ? E.interpolation : void 0, _, x) : new Hd(d && x ? "constant" : "source", n.value, _, x)) : il([new Yo("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.')])
            }

            class ql {
                constructor(e, i) {
                    this._parameters = e, this._specification = i, Fl(this, lm(this._parameters, this._specification))
                }

                static deserialize(e) {
                    return new ql(e._parameters, e._specification)
                }

                static serialize(e) {
                    return {_parameters: e._parameters, _specification: e._specification}
                }
            }

            function gh(n) {
                let e = null;
                if (n instanceof mh) e = gh(n.result); else if (n instanceof kd) {
                    for (const i of n.args) if (e = gh(i), e) break
                } else (n instanceof fh || n instanceof Io) && n.input instanceof Mr && n.input.name === "zoom" && (e = n);
                return e instanceof Yo || n.eachChild(i => {
                    const a = gh(i);
                    a instanceof Yo ? e = a : e && a && e !== a && (e = new Yo("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
                }), e
            }

            var fm, gy, pm = function () {
                if (gy) return fm;
                gy = 1, fm = e;
                var n = 3;

                function e(i, a, c) {
                    var d = this.cells = [];
                    if (i instanceof ArrayBuffer) {
                        this.arrayBuffer = i;
                        var f = new Int32Array(this.arrayBuffer);
                        i = f[0], this.d = (a = f[1]) + 2 * (c = f[2]);
                        for (var _ = 0; _ < this.d * this.d; _++) {
                            var x = f[n + _], w = f[n + _ + 1];
                            d.push(x === w ? null : f.subarray(x, w))
                        }
                        var E = f[n + d.length + 1];
                        this.keys = f.subarray(f[n + d.length], E), this.bboxes = f.subarray(E), this.insert = this._insertReadonly
                    } else {
                        this.d = a + 2 * c;
                        for (var I = 0; I < this.d * this.d; I++) d.push([]);
                        this.keys = [], this.bboxes = []
                    }
                    this.n = a, this.extent = i, this.padding = c, this.scale = a / i, this.uid = 0;
                    var C = c / a * i;
                    this.min = -C, this.max = i + C
                }

                return e.prototype.insert = function (i, a, c, d, f) {
                    this._forEachCell(a, c, d, f, this._insertCell, this.uid++), this.keys.push(i), this.bboxes.push(a), this.bboxes.push(c), this.bboxes.push(d), this.bboxes.push(f)
                }, e.prototype._insertReadonly = function () {
                    throw "Cannot insert into a GridIndex created from an ArrayBuffer."
                }, e.prototype._insertCell = function (i, a, c, d, f, _) {
                    this.cells[f].push(_)
                }, e.prototype.query = function (i, a, c, d, f) {
                    var _ = this.min, x = this.max;
                    if (i <= _ && a <= _ && x <= c && x <= d && !f) return Array.prototype.slice.call(this.keys);
                    var w = [];
                    return this._forEachCell(i, a, c, d, this._queryCell, w, {}, f), w
                }, e.prototype._queryCell = function (i, a, c, d, f, _, x, w) {
                    var E = this.cells[f];
                    if (E !== null) for (var I = this.keys, C = this.bboxes, z = 0; z < E.length; z++) {
                        var L = E[z];
                        if (x[L] === void 0) {
                            var F = 4 * L;
                            (w ? w(C[F + 0], C[F + 1], C[F + 2], C[F + 3]) : i <= C[F + 2] && a <= C[F + 3] && c >= C[F + 0] && d >= C[F + 1]) ? (x[L] = !0, _.push(I[L])) : x[L] = !1
                        }
                    }
                }, e.prototype._forEachCell = function (i, a, c, d, f, _, x, w) {
                    for (var E = this._convertToCellCoord(i), I = this._convertToCellCoord(a), C = this._convertToCellCoord(c), z = this._convertToCellCoord(d), L = E; L <= C; L++) for (var F = I; F <= z; F++) {
                        var N = this.d * F + L;
                        if ((!w || w(this._convertFromCellCoord(L), this._convertFromCellCoord(F), this._convertFromCellCoord(L + 1), this._convertFromCellCoord(F + 1))) && f.call(this, i, a, c, d, N, _, x, w)) return
                    }
                }, e.prototype._convertFromCellCoord = function (i) {
                    return (i - this.padding) / this.scale
                }, e.prototype._convertToCellCoord = function (i) {
                    return Math.max(0, Math.min(this.d - 1, Math.floor(i * this.scale) + this.padding))
                }, e.prototype.toArrayBuffer = function () {
                    if (this.arrayBuffer) return this.arrayBuffer;
                    for (var i = this.cells, a = n + this.cells.length + 1 + 1, c = 0, d = 0; d < this.cells.length; d++) c += this.cells[d].length;
                    var f = new Int32Array(a + c + this.keys.length + this.bboxes.length);
                    f[0] = this.extent, f[1] = this.n, f[2] = this.padding;
                    for (var _ = a, x = 0; x < i.length; x++) {
                        var w = i[x];
                        f[n + x] = _, f.set(w, _), _ += w.length
                    }
                    return f[n + i.length] = _, f.set(this.keys, _), f[n + i.length + 1] = _ += this.keys.length, f.set(this.bboxes, _), _ += this.bboxes.length, f.buffer
                }, fm
            }(), sl = pa(pm);
            const _h = {};

            function Pt(n, e, i = {}) {
                Object.defineProperty(n, "_classRegistryKey", {value: e, writable: !1}), _h[e] = {
                    klass: n,
                    omit: i.omit || []
                }
            }

            Pt(Object, "Object"), sl.serialize = function (n, e) {
                const i = n.toArrayBuffer();
                return e && e.add(i), {buffer: i}
            }, sl.deserialize = function (n) {
                return new sl(n.buffer)
            }, Object.defineProperty(sl, "name", {value: "Grid"}), Pt(sl, "Grid"), delete Ze.prototype.constructor, typeof DOMMatrix < "u" && Pt(DOMMatrix, "DOMMatrix"), Pt(Ji, "Color"), Pt(Error, "Error"), Pt(fo, "Formatted"), Pt(yd, "FormattedSection"), Pt(Vi, "AJAXError"), Pt(Ao, "ResolvedImage"), Pt(ql, "StylePropertyFunction"), Pt(um, "StyleExpression", {omit: ["_evaluator"]}), Pt(Lo, "ImageId"), Pt(va, "ImageVariant"), Pt(ol, "ZoomDependentExpression"), Pt(Hd, "ZoomConstantExpression"), Pt(Mr, "CompoundExpression", {omit: ["_evaluate"]});
            for (const n in Oc) _h[Oc[n]._classRegistryKey] || Pt(Oc[n], `Expression${n}`);

            function qd(n) {
                return n && typeof ArrayBuffer < "u" && (n instanceof ArrayBuffer || n.constructor && n.constructor.name === "ArrayBuffer")
            }

            function yh(n) {
                return self.ImageBitmap && n instanceof ImageBitmap
            }

            function xa(n, e) {
                if (n == null || typeof n == "boolean" || typeof n == "number" || typeof n == "string" || n instanceof Boolean || n instanceof Number || n instanceof String || n instanceof Date || n instanceof RegExp) return n;
                if (qd(n) || yh(n)) return e && e.add(n), n;
                if (ArrayBuffer.isView(n)) return e && e.add(n.buffer), n;
                if (n instanceof ImageData) return e && e.add(n.data.buffer), n;
                if (Array.isArray(n)) {
                    const i = [];
                    for (const a of n) i.push(xa(a, e));
                    return i
                }
                if (n instanceof Map) {
                    const i = {$name: "Map", entries: []};
                    for (const [a, c] of n.entries()) i.entries.push(xa(a), xa(c, e));
                    return i
                }
                if (n instanceof Set) {
                    const i = {$name: "Set"};
                    let a = 0;
                    for (const c of n.values()) i[++a] = xa(c);
                    return i
                }
                if (n instanceof DOMMatrix) {
                    const i = {$name: "DOMMatrix"},
                        a = ["is2D", "m11", "m12", "m13", "m14", "m21", "m22", "m23", "m24", "m31", "m32", "m33", "m34", "m41", "m42", "m43", "m44", "a", "b", "c", "d", "e", "f"];
                    for (const c of a) i[c] = n[c];
                    return i
                }
                if (typeof n == "bigint") return {$name: "BigInt", value: n.toString()};
                if (typeof n == "object") {
                    const i = n.constructor, a = i._classRegistryKey;
                    if (!a) throw new Error(`Can't serialize object of unregistered class "${i.name}".`);
                    const c = i.serialize ? i.serialize(n, e) : {};
                    if (!i.serialize) {
                        for (const d in n) n.hasOwnProperty(d) && (_h[a].omit.indexOf(d) >= 0 || (c[d] = xa(n[d], e)));
                        n instanceof Error && (c.message = n.message)
                    }
                    if (c.$name) throw new Error("$name property is reserved for worker serialization logic.");
                    return a !== "Object" && (c.$name = a), c
                }
                throw new Error("can't serialize object of type " + typeof n)
            }

            function Co(n) {
                if (n == null || typeof n == "boolean" || typeof n == "number" || typeof n == "string" || n instanceof Boolean || n instanceof Number || n instanceof String || n instanceof Date || n instanceof RegExp || qd(n) || yh(n) || ArrayBuffer.isView(n) || n instanceof ImageData) return n;
                if (Array.isArray(n)) return n.map(Co);
                if (typeof n == "object") {
                    const e = n.$name || "Object";
                    if (e === "Map") {
                        const c = n.entries || [], d = new Map;
                        for (let f = 0; f < c.length; f += 2) d.set(Co(c[f]), Co(c[f + 1]));
                        return d
                    }
                    if (e === "Set") {
                        const c = new Set;
                        for (const d of Object.keys(n)) d !== "$name" && c.add(Co(n[d]));
                        return c
                    }
                    if (e === "DOMMatrix") {
                        let c;
                        return c = n.is2D ? [n.a, n.b, n.c, n.d, n.e, n.f] : [n.m11, n.m12, n.m13, n.m14, n.m21, n.m22, n.m23, n.m24, n.m31, n.m32, n.m33, n.m34, n.m41, n.m42, n.m43, n.m44], new DOMMatrix(c)
                    }
                    if (e === "BigInt") return BigInt(n.value);
                    const {klass: i} = _h[e];
                    if (!i) throw new Error(`Can't deserialize unregistered class "${e}".`);
                    if (i.deserialize) return i.deserialize(n);
                    const a = Object.create(i.prototype);
                    for (const c of Object.keys(n)) c !== "$name" && (a[c] = Co(n[c]));
                    return a
                }
                throw new Error("can't deserialize object of type " + typeof n)
            }

            const Qt = {
                "Latin-1 Supplement": n => n >= 128 && n <= 255,
                Arabic: n => n >= 1536 && n <= 1791,
                "Arabic Supplement": n => n >= 1872 && n <= 1919,
                "Arabic Extended-A": n => n >= 2208 && n <= 2303,
                "Hangul Jamo": n => n >= 4352 && n <= 4607,
                "Unified Canadian Aboriginal Syllabics": n => n >= 5120 && n <= 5759,
                Khmer: n => n >= 6016 && n <= 6143,
                "Unified Canadian Aboriginal Syllabics Extended": n => n >= 6320 && n <= 6399,
                "General Punctuation": n => n >= 8192 && n <= 8303,
                "Letterlike Symbols": n => n >= 8448 && n <= 8527,
                "Number Forms": n => n >= 8528 && n <= 8591,
                "Miscellaneous Technical": n => n >= 8960 && n <= 9215,
                "Control Pictures": n => n >= 9216 && n <= 9279,
                "Optical Character Recognition": n => n >= 9280 && n <= 9311,
                "Enclosed Alphanumerics": n => n >= 9312 && n <= 9471,
                "Geometric Shapes": n => n >= 9632 && n <= 9727,
                "Miscellaneous Symbols": n => n >= 9728 && n <= 9983,
                "Miscellaneous Symbols and Arrows": n => n >= 11008 && n <= 11263,
                "CJK Radicals Supplement": n => n >= 11904 && n <= 12031,
                "Kangxi Radicals": n => n >= 12032 && n <= 12255,
                "Ideographic Description Characters": n => n >= 12272 && n <= 12287,
                "CJK Symbols and Punctuation": n => n >= 12288 && n <= 12351,
                Hiragana: n => n >= 12352 && n <= 12447,
                Katakana: n => n >= 12448 && n <= 12543,
                Bopomofo: n => n >= 12544 && n <= 12591,
                "Hangul Compatibility Jamo": n => n >= 12592 && n <= 12687,
                Kanbun: n => n >= 12688 && n <= 12703,
                "Bopomofo Extended": n => n >= 12704 && n <= 12735,
                "CJK Strokes": n => n >= 12736 && n <= 12783,
                "Katakana Phonetic Extensions": n => n >= 12784 && n <= 12799,
                "Enclosed CJK Letters and Months": n => n >= 12800 && n <= 13055,
                "CJK Compatibility": n => n >= 13056 && n <= 13311,
                "CJK Unified Ideographs Extension A": n => n >= 13312 && n <= 19903,
                "Yijing Hexagram Symbols": n => n >= 19904 && n <= 19967,
                "CJK Unified Ideographs": n => n >= 19968 && n <= 40959,
                "Yi Syllables": n => n >= 40960 && n <= 42127,
                "Yi Radicals": n => n >= 42128 && n <= 42191,
                "Hangul Jamo Extended-A": n => n >= 43360 && n <= 43391,
                "Hangul Syllables": n => n >= 44032 && n <= 55215,
                "Hangul Jamo Extended-B": n => n >= 55216 && n <= 55295,
                "Private Use Area": n => n >= 57344 && n <= 63743,
                "CJK Compatibility Ideographs": n => n >= 63744 && n <= 64255,
                "Arabic Presentation Forms-A": n => n >= 64336 && n <= 65023,
                "Vertical Forms": n => n >= 65040 && n <= 65055,
                "CJK Compatibility Forms": n => n >= 65072 && n <= 65103,
                "Small Form Variants": n => n >= 65104 && n <= 65135,
                "Arabic Presentation Forms-B": n => n >= 65136 && n <= 65279,
                "Halfwidth and Fullwidth Forms": n => n >= 65280 && n <= 65519,
                Osage: n => n >= 66736 && n <= 66815,
                "CJK Unified Ideographs Extension B": n => n >= 131072 && n <= 173791
            };

            function mm(n) {
                for (const e of n) if (Wd(e.charCodeAt(0))) return !0;
                return !1
            }

            function n1(n) {
                for (const e of n) if (!r1(e.charCodeAt(0))) return !1;
                return !0
            }

            function r1(n) {
                return !(Qt.Arabic(n) || Qt["Arabic Supplement"](n) || Qt["Arabic Extended-A"](n) || Qt["Arabic Presentation Forms-A"](n) || Qt["Arabic Presentation Forms-B"](n))
            }

            function Wd(n) {
                return !(n !== 746 && n !== 747 && (n < 4352 || !(Qt["Bopomofo Extended"](n) || Qt.Bopomofo(n) || Qt["CJK Compatibility Forms"](n) && !(n >= 65097 && n <= 65103) || Qt["CJK Compatibility Ideographs"](n) || Qt["CJK Compatibility"](n) || Qt["CJK Radicals Supplement"](n) || Qt["CJK Strokes"](n) || !(!Qt["CJK Symbols and Punctuation"](n) || n >= 12296 && n <= 12305 || n >= 12308 && n <= 12319 || n === 12336) || Qt["CJK Unified Ideographs Extension A"](n) || Qt["CJK Unified Ideographs"](n) || Qt["Enclosed CJK Letters and Months"](n) || Qt["Hangul Compatibility Jamo"](n) || Qt["Hangul Jamo Extended-A"](n) || Qt["Hangul Jamo Extended-B"](n) || Qt["Hangul Jamo"](n) || Qt["Hangul Syllables"](n) || Qt.Hiragana(n) || Qt["Ideographic Description Characters"](n) || Qt.Kanbun(n) || Qt["Kangxi Radicals"](n) || Qt["Katakana Phonetic Extensions"](n) || Qt.Katakana(n) && n !== 12540 || !(!Qt["Halfwidth and Fullwidth Forms"](n) || n === 65288 || n === 65289 || n === 65293 || n >= 65306 && n <= 65310 || n === 65339 || n === 65341 || n === 65343 || n >= 65371 && n <= 65503 || n === 65507 || n >= 65512 && n <= 65519) || !(!Qt["Small Form Variants"](n) || n >= 65112 && n <= 65118 || n >= 65123 && n <= 65126) || Qt["Unified Canadian Aboriginal Syllabics"](n) || Qt["Unified Canadian Aboriginal Syllabics Extended"](n) || Qt["Vertical Forms"](n) || Qt["Yijing Hexagram Symbols"](n) || Qt["Yi Syllables"](n) || Qt["Yi Radicals"](n))))
            }

            function Zd(n) {
                return !(Wd(n) || function (e) {
                    return !!(Qt["Latin-1 Supplement"](e) && (e === 167 || e === 169 || e === 174 || e === 177 || e === 188 || e === 189 || e === 190 || e === 215 || e === 247) || Qt["General Punctuation"](e) && (e === 8214 || e === 8224 || e === 8225 || e === 8240 || e === 8241 || e === 8251 || e === 8252 || e === 8258 || e === 8263 || e === 8264 || e === 8265 || e === 8273) || Qt["Letterlike Symbols"](e) || Qt["Number Forms"](e) || Qt["Miscellaneous Technical"](e) && (e >= 8960 && e <= 8967 || e >= 8972 && e <= 8991 || e >= 8996 && e <= 9e3 || e === 9003 || e >= 9085 && e <= 9114 || e >= 9150 && e <= 9165 || e === 9167 || e >= 9169 && e <= 9179 || e >= 9186 && e <= 9215) || Qt["Control Pictures"](e) && e !== 9251 || Qt["Optical Character Recognition"](e) || Qt["Enclosed Alphanumerics"](e) || Qt["Geometric Shapes"](e) || Qt["Miscellaneous Symbols"](e) && !(e >= 9754 && e <= 9759) || Qt["Miscellaneous Symbols and Arrows"](e) && (e >= 11026 && e <= 11055 || e >= 11088 && e <= 11097 || e >= 11192 && e <= 11243) || Qt["CJK Symbols and Punctuation"](e) || Qt.Katakana(e) || Qt["Private Use Area"](e) || Qt["CJK Compatibility Forms"](e) || Qt["Small Form Variants"](e) || Qt["Halfwidth and Fullwidth Forms"](e) || e === 8734 || e === 8756 || e === 8757 || e >= 9984 && e <= 10087 || e >= 10102 && e <= 10131 || e === 65532 || e === 65533)
                }(n))
            }

            function _y(n) {
                return Qt.Arabic(n) || Qt["Arabic Supplement"](n) || Qt["Arabic Extended-A"](n) || Qt["Arabic Presentation Forms-A"](n) || Qt["Arabic Presentation Forms-B"](n)
            }

            function Xd(n) {
                return n >= 1424 && n <= 2303 || Qt["Arabic Presentation Forms-A"](n) || Qt["Arabic Presentation Forms-B"](n)
            }

            function o1(n, e) {
                return !(!e && Xd(n) || n >= 2304 && n <= 3583 || n >= 3840 && n <= 4255 || Qt.Khmer(n))
            }

            function s1(n) {
                for (const e of n) if (Xd(e.charCodeAt(0))) return !0;
                return !1
            }

            const Oo = {
                unavailable: "unavailable",
                deferred: "deferred",
                loading: "loading",
                parsing: "parsing",
                parsed: "parsed",
                loaded: "loaded",
                error: "error"
            };
            let gm = null, mo = Oo.unavailable, al = null;
            const yy = function (n) {
                n && typeof n == "string" && n.indexOf("NetworkError") > -1 && (mo = Oo.error), gm && gm(n)
            };

            function _m() {
                ym.fire(new _a("pluginStateChange", {pluginStatus: mo, pluginURL: al}))
            }

            const ym = new Ol, vm = function () {
                return mo
            }, vy = function () {
                if (mo !== Oo.deferred || !al) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
                mo = Oo.loading, _m(), al && Ku({url: al}, n => {
                    n ? yy(n) : (mo = Oo.loaded, _m())
                })
            }, Qs = {
                applyArabicShaping: null,
                processBidirectionalText: null,
                processStyledBidirectionalText: null,
                isLoaded: () => mo === Oo.loaded || Qs.applyArabicShaping != null,
                isLoading: () => mo === Oo.loading,
                setState(n) {
                    mo = n.pluginStatus, al = n.pluginURL
                },
                isParsing: () => mo === Oo.parsing,
                isParsed: () => mo === Oo.parsed,
                getPluginURL: () => al
            };

            class sn {
                constructor(e, i) {
                    this.zoom = e, i ? (this.now = i.now, this.fadeDuration = i.fadeDuration, this.transition = i.transition, this.pitch = i.pitch, this.brightness = i.brightness, this.worldview = i.worldview) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0)
                }

                isSupportedScript(e) {
                    return function (i, a) {
                        for (const c of i) if (!o1(c.charCodeAt(0), a)) return !1;
                        return !0
                    }(e, Qs.isLoaded())
                }
            }

            class vh {
                constructor(e, i, a, c) {
                    this.property = e, this.value = i, this.expression = function (d, f, _, x) {
                        if ($d(d)) return new ql(d, f);
                        if (hm(d) || Array.isArray(d) && d.length > 0) {
                            const w = dm(d, f, _, x);
                            if (w.result === "error") throw new Error(w.value.map(E => `${E.key}: ${E.message}`).join(", "));
                            return w.value
                        }
                        {
                            let w = d;
                            return typeof d == "string" && f.type === "color" && (w = Ji.parse(d)), {
                                kind: "constant",
                                configDependencies: new Set,
                                evaluate: () => w
                            }
                        }
                    }(i === void 0 ? e.specification.default : i, e.specification, a, c)
                }

                isDataDriven() {
                    return this.expression.kind === "source" || this.expression.kind === "composite"
                }

                possiblyEvaluate(e, i, a) {
                    return this.property.possiblyEvaluate(this, e, i, a)
                }
            }

            class Yd {
                constructor(e, i, a) {
                    this.property = e, this.value = new vh(e, void 0, i, a)
                }

                transitioned(e, i) {
                    return new xy(this.property, this.value, i, Ne({}, e.transition, this.transition), e.now)
                }

                untransitioned() {
                    return new xy(this.property, this.value, null, {}, 0)
                }
            }

            class xh {
                constructor(e, i, a) {
                    this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues), this._scope = i, this._options = a, this.configDependencies = new Set
                }

                getValue(e) {
                    return Ti(this._values[e].value.value)
                }

                setValue(e, i) {
                    this._values.hasOwnProperty(e) || (this._values[e] = new Yd(this._values[e].property, this._scope, this._options)), this._values[e].value = new vh(this._values[e].property, i === null ? void 0 : Ti(i), this._scope, this._options), this._values[e].value.expression.configDependencies && (this.configDependencies = new Set([...this.configDependencies, ...this._values[e].value.expression.configDependencies]))
                }

                setTransitionOrValue(e, i) {
                    i && (this._options = i);
                    const a = this._properties.properties;
                    if (e) for (const c in e) {
                        const d = e[c];
                        if (c.endsWith("-transition")) {
                            const f = c.slice(0, -11);
                            a[f] && this.setTransition(f, d)
                        } else a.hasOwnProperty(c) && this.setValue(c, d)
                    }
                }

                getTransition(e) {
                    return Ti(this._values[e].transition)
                }

                setTransition(e, i) {
                    this._values.hasOwnProperty(e) || (this._values[e] = new Yd(this._values[e].property)), this._values[e].transition = Ti(i) || void 0
                }

                serialize() {
                    const e = {};
                    for (const i of Object.keys(this._values)) {
                        const a = this.getValue(i);
                        a !== void 0 && (e[i] = a);
                        const c = this.getTransition(i);
                        c !== void 0 && (e[`${i}-transition`] = c)
                    }
                    return e
                }

                transitioned(e, i) {
                    const a = new wy(this._properties);
                    for (const c of Object.keys(this._values)) a._values[c] = this._values[c].transitioned(e, i._values[c]);
                    return a
                }

                untransitioned() {
                    const e = new wy(this._properties);
                    for (const i of Object.keys(this._values)) e._values[i] = this._values[i].untransitioned();
                    return e
                }
            }

            class xy {
                constructor(e, i, a, c, d) {
                    const f = c.delay || 0, _ = c.duration || 0;
                    d = d || 0, this.property = e, this.value = i, this.begin = d + f, this.end = this.begin + _, e.specification.transition && (c.delay || c.duration) && (this.prior = a)
                }

                possiblyEvaluate(e, i, a) {
                    const c = e.now || 0, d = this.value.possiblyEvaluate(e, i, a), f = this.prior;
                    if (f) {
                        if (c > this.end) return this.prior = null, d;
                        if (this.value.isDataDriven()) return this.prior = null, d;
                        if (c < this.begin) return f.possiblyEvaluate(e, i, a);
                        {
                            const _ = (c - this.begin) / (this.end - this.begin);
                            return this.property.interpolate(f.possiblyEvaluate(e, i, a), d, W(_))
                        }
                    }
                    return d
                }
            }

            class wy {
                constructor(e) {
                    this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues)
                }

                possiblyEvaluate(e, i, a) {
                    const c = new Bs(this._properties);
                    for (const d of Object.keys(this._values)) c._values[d] = this._values[d].possiblyEvaluate(e, i, a);
                    return c
                }

                hasTransition() {
                    for (const e of Object.keys(this._values)) if (this._values[e].prior) return !0;
                    return !1
                }
            }

            class ll {
                constructor(e, i, a) {
                    this._properties = e, this._values = Object.create(e.defaultPropertyValues), this._scope = i, this._options = a, this.configDependencies = new Set
                }

                getValue(e) {
                    return Ti(this._values[e].value)
                }

                setValue(e, i) {
                    this._values[e] = new vh(this._values[e].property, i === null ? void 0 : Ti(i), this._scope, this._options), this._values[e].expression.configDependencies && (this.configDependencies = new Set([...this.configDependencies, ...this._values[e].expression.configDependencies]))
                }

                serialize() {
                    const e = {};
                    for (const i of Object.keys(this._values)) {
                        const a = this.getValue(i);
                        a !== void 0 && (e[i] = a)
                    }
                    return e
                }

                possiblyEvaluate(e, i, a) {
                    const c = new Bs(this._properties);
                    for (const d of Object.keys(this._values)) c._values[d] = this._values[d].possiblyEvaluate(e, i, a);
                    return c
                }
            }

            class Wl {
                constructor(e, i, a) {
                    this.property = e, this.value = i, this.parameters = a
                }

                isConstant() {
                    return this.value.kind === "constant"
                }

                constantOr(e) {
                    return this.value.kind === "constant" ? this.value.value : e
                }

                evaluate(e, i, a, c) {
                    return this.property.evaluate(this.value, this.parameters, e, i, a, c)
                }
            }

            class Bs {
                constructor(e) {
                    this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues)
                }

                get(e) {
                    return this._values[e]
                }
            }

            class dt {
                constructor(e) {
                    this.specification = e
                }

                possiblyEvaluate(e, i) {
                    return e.expression.evaluate(i)
                }

                interpolate(e, i, a) {
                    const c = ih[this.specification.type];
                    return c ? c(e, i, a) : e
                }
            }

            class Tt {
                constructor(e, i) {
                    this.specification = e, this.overrides = i
                }

                possiblyEvaluate(e, i, a, c) {
                    return new Wl(this, e.expression.kind === "constant" || e.expression.kind === "camera" ? {
                        kind: "constant",
                        value: e.expression.evaluate(i, null, {}, a, c)
                    } : e.expression, i)
                }

                interpolate(e, i, a) {
                    if (e.value.kind !== "constant" || i.value.kind !== "constant") return e;
                    if (e.value.value === void 0 || i.value.value === void 0) return new Wl(this, {
                        kind: "constant",
                        value: void 0
                    }, e.parameters);
                    const c = ih[this.specification.type];
                    return c ? new Wl(this, {
                        kind: "constant",
                        value: c(e.value.value, i.value.value, a)
                    }, e.parameters) : e
                }

                evaluate(e, i, a, c, d, f) {
                    return e.kind === "constant" ? e.value : e.evaluate(i, a, c, d, f)
                }
            }

            class Fc {
                constructor(e) {
                    this.specification = e
                }

                possiblyEvaluate(e, i, a, c) {
                    return !!e.expression.evaluate(i, null, {}, a, c)
                }

                interpolate() {
                    return !1
                }
            }

            class qn {
                constructor(e) {
                    this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
                    const i = new sn(0, {});
                    for (const a in e) {
                        const c = e[a];
                        c.specification.overridable && this.overridableProperties.push(a);
                        const d = this.defaultPropertyValues[a] = new vh(c, void 0),
                            f = this.defaultTransitionablePropertyValues[a] = new Yd(c);
                        this.defaultTransitioningPropertyValues[a] = f.untransitioned(), this.defaultPossiblyEvaluatedValues[a] = d.possiblyEvaluate(i)
                    }
                }
            }

            Pt(Tt, "DataDrivenProperty"), Pt(dt, "DataConstantProperty"), Pt(Fc, "ColorRampProperty");
            var ze = JSON.parse('{"$version":8,"$root":{"version":{"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"snow":{"type":"snow"},"rain":{"type":"rain"},"camera":{"type":"camera"},"color-theme":{"type":"colorTheme"},"indoor":{"type":"indoor"},"imports":{"type":"array","value":"import"},"iconsets":{"type":"iconsets"},"schema":{"type":"schema"},"sources":{"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"type":"array","value":"layer"},"models":{"type":"models"},"featuresets":{"type":"featuresets"}},"featuresets":{"*":{"type":"featureset"}},"featureset":{"metadata":{"type":"*"},"selectors":{"type":"array","value":"selector"}},"selector":{"layer":{"type":"string"},"properties":{"type":"selectorProperty"},"featureNamespace":{"type":"string"},"_uniqueFeatureID":{"type":"boolean"}},"selectorProperty":{"*":{"type":"*"}},"model":{"type":"string"},"import":{"id":{"type":"string"},"url":{"type":"string"},"config":{"type":"config"},"data":{"type":"$root"},"color-theme":{"type":"colorTheme","optional":true}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","expression":{}},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string"},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"use-theme":true,"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false},"shadow-quality":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"parameters":["zoom"]}},"shadow-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_ambient":{"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"use-theme":true,"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"use-theme":true,"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"iconsets":{"*":{"type":"iconset"}},"iconset":["iconset_sprite","iconset_source"],"iconset_sprite":{"type":{"type":"enum","values":{"sprite":1}},"url":{"type":"string"}},"iconset_source":{"type":{"type":"enum","values":{"source":1}},"source":{"type":"string"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"type":{"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"},"dynamic":{"type":"boolean","default":false}},"source_video":{"type":{"type":"enum","values":{"video":1}},"urls":{"type":"array","value":"string"},"coordinates":{"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"type":"enum","values":{"image":1}},"url":{"type":"string"},"coordinates":{"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_model":{"type":{"type":"enum","values":{"model":1,"batched-model":1}},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"}},"layer":{"id":{"type":"string"},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"building":{},"raster":{},"raster-particle":{},"hillshade":{},"model":{},"background":{},"sky":{},"slot":{},"clip":{}}},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"},"appearances":{"type":"array","value":"appearance","supported-layer-types":["symbol"]}},"appearance":{"condition":{"type":"expression"},"name":{"type":"string"},"properties":{"type":"*"}},"layout":["layout_clip","layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_building","layout_symbol","layout_raster","layout_raster-particle","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}}},"layout_clip":{"clip-layer-types":{"type":"array","value":"enum","values":{"model":1,"symbol":1},"default":[],"expression":{}},"clip-layer-scope":{"type":"array","value":"string","default":[],"expression":{}}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"fill-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-base":1,"hd-road-markup":1},"default":"none","expression":{}},"fill-construct-bridge-guard-rail":{"type":"boolean","default":"true","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"circle-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-markup":1},"default":"none","expression":{}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"fill-extrusion-edge-radius":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}}},"layout_building":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"building-facade":{"type":"boolean","default":false,"expression":{"parameters":["feature"]},"property-type":"data-driven"},"building-facade-floors":{"type":"number","minimum":1,"maximum":200,"default":3,"property-type":"data-driven","expression":{"parameters":["feature"]}},"building-facade-window":{"type":"array","length":2,"value":"number","minimum":0.1,"maximum":1,"default":[0.9,0.9],"property-type":"data-driven","expression":{"parameters":["feature"]}},"building-roof-shape":{"type":"enum","values":{"flat":1,"hipped":1,"gabled":1,"parapet":1,"mansard":1,"skillion":1,"pyramidal":1},"default":"flat","expression":{"parameters":["feature"]},"property-type":"data-driven"},"building-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{},"property-type":"data-driven"},"building-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{},"property-type":"data-driven"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1,"none":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]}},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]}},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-z-offset":{"type":"number","default":0,"expression":{"parameters":["zoom","feature","line-progress"]},"property-type":"data-driven"},"line-elevation-reference":{"type":"enum","values":{"none":1,"sea":1,"ground":1,"hd-road-markup":1},"default":"none","expression":{}},"line-cross-slope":{"type":"number","expression":{}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"line-width-unit":{"type":"enum","values":{"pixels":1,"meters":1},"default":"pixels","expression":{"parameters":["zoom"]}}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]}},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]}},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]}},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"symbol-elevation-reference":{"type":"enum","values":{"sea":1,"ground":1,"hd-road-markup":1},"default":"ground","expression":{"parameters":["zoom"]}},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"icon-size":{"type":"number","default":1,"minimum":0,"appearance":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"expression":{}},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"appearance":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"appearance":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]}},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"appearance":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"expression":{}},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]}},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]}},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]}},"text-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]}},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_raster-particle":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_hillshade":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster-particle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_clip":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_model":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_building":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*"}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"high-color":{"type":"color","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"space-color":{"type":"color","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"horizon-blend":{"type":"number","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"snow":{"density":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,0.85],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,0.3],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"center-thinning":{"type":"number","default":0.4,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,50],"minimum":0,"maximum":360,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"flake-size":{"type":"number","default":0.71,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"rain":{"density":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,0.5],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","default":["interpolate",["linear"],["measure-light","brightness"],0,"#03113d",0.3,"#a8adbc"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"opacity":{"type":"number","default":["interpolate",["linear"],["measure-light","brightness"],0,0.88,1,0.7],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","default":["interpolate",["linear"],["measure-light","brightness"],0,"#001736",0.3,"#464646"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"center-thinning":{"type":"number","default":0.57,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,80],"minimum":0,"maximum":360,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"droplet-size":{"type":"array","default":[2.6,18.2],"minimum":0,"maximum":50,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"distortion-strength":{"type":"number","default":0.7,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective"}},"colorTheme":{"data":{"type":"string","expression":{}}},"indoor":{"floorplanFeaturesetId":{"type":"string","expression":{}},"buildingFeaturesetId":{"type":"string","expression":{}}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"use-theme":true,"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator"},"center":{"type":"array","length":2,"value":"number","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string"},"exaggeration":{"type":"number","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_building","paint_symbol","paint_raster","paint_raster-particle","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-pattern-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-bridge-guard-rail-color":{"type":"color","default":"rgba(241, 236, 225, 255)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature"]},"property-type":"data-driven"},"fill-tunnel-structure-color":{"type":"color","default":"rgba(241, 236, 225, 255)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-pattern-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-height-alignment":{"type":"enum","values":{"terrain":1,"flat":1},"default":"flat"},"fill-extrusion-base-alignment":{"type":"enum","values":{"terrain":1,"flat":1},"default":"terrain"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-ambient-occlusion-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"type":"color","default":"#ffffff","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"fill-extrusion-line-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-cast-shadows":{"type":"boolean","default":true}},"paint_building":{"building-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"building-ambient-occlusion-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"parameters":[]},"transition":true},"building-ambient-occlusion-ground-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"building-ambient-occlusion-ground-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"building-ambient-occlusion-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"building-vertical-scale":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"building-cast-shadows":{"type":"boolean","default":true},"building-color":{"type":"color","default":"rgba(193, 154, 127, 1)","use-theme":true,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"property-type":"data-driven"},"building-emissive-strength":{"type":"number","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"property-type":"data-driven"},"building-facade-emissive-chance":{"type":"number","default":0.35,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["measure-light","zoom"]}},"building-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light","line-progress"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-gradient":{"type":"color","use-theme":true,"expression":{"interpolated":true,"parameters":["line-progress"]}},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1]},"line-trim-fade-range":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-trim-color":{"type":"color","default":"transparent","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-border-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","default":"rgba(0, 0, 0, 0)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-occlusion-opacity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]}},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"use-theme":true,"expression":{"interpolated":true,"parameters":["heatmap-density"]}},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"icon-image-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"icon-color-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{}},"icon-color-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{}},"icon-color-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"icon-color-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{}},"symbol-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color":{"type":"color","use-theme":true,"expression":{"interpolated":true,"parameters":["raster-value"]}},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]}},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"raster-array-band":{"type":"string"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_raster-particle":{"raster-particle-array-band":{"type":"string"},"raster-particle-count":{"type":"number","default":512,"minimum":1},"raster-particle-color":{"type":"color","use-theme":true,"expression":{"interpolated":true,"parameters":["raster-particle-speed"]}},"raster-particle-max-speed":{"type":"number","default":1,"minimum":1},"raster-particle-speed-factor":{"type":"number","default":0.2,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-particle-fade-opacity-factor":{"type":"number","default":0.98,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-particle-reset-rate-factor":{"type":"number","default":0.8,"minimum":0,"maximum":1},"raster-particle-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]}},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]}},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"hillshade-shadow-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"hillshade-accent-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}}},"paint_background":{"background-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":[]}},"background-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]}},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]}},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]}},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]}},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]}},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"use-theme":true,"expression":{"interpolated":true,"parameters":["sky-radial-progress"]}},"sky-atmosphere-halo-color":{"type":"color","default":"white","use-theme":true},"sky-atmosphere-color":{"type":"color","default":"white","use-theme":true},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"property-type":"data-driven"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"use-theme":true,"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d"},"model-cast-shadows":{"type":"boolean","default":true},"model-receive-shadows":{"type":"boolean","default":true},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"model-front-cutoff":{"type":"array","value":"number","expression":{"interpolated":true,"parameters":["zoom"]},"length":3,"default":[0,0,1],"minimum":[0,0,0],"maximum":[1,1,1]}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"promoteId":{"*":{"type":"*"}}}');

            function by(n) {
                return n instanceof Number || n instanceof String || n instanceof Boolean ? n.valueOf() : n
            }

            function wh(n) {
                if (Array.isArray(n)) return n.map(wh);
                if (n instanceof Object && !(n instanceof Number || n instanceof String || n instanceof Boolean)) {
                    const e = {};
                    for (const i in n) e[i] = wh(n[i]);
                    return e
                }
                return by(n)
            }

            function bh(n) {
                if (n === !0 || n === !1) return !0;
                if (!Array.isArray(n) || n.length === 0) return !1;
                switch (n[0]) {
                    case"has":
                        return n.length >= 2 && n[1] !== "$id" && n[1] !== "$type";
                    case"in":
                        return n.length >= 3 && (typeof n[1] != "string" || Array.isArray(n[2]));
                    case"!in":
                    case"!has":
                    case"none":
                        return !1;
                    case"==":
                    case"!=":
                    case">":
                    case">=":
                    case"<":
                    case"<=":
                        return n.length !== 3 || Array.isArray(n[1]) || Array.isArray(n[2]);
                    case"any":
                    case"all":
                        for (const e of n.slice(1)) if (!bh(e) && typeof e != "boolean") return !1;
                        return !0;
                    default:
                        return !0
                }
            }

            function Bc(n, e = "", i = null, a = "fill") {
                if (n == null) return {filter: () => !0, needGeometry: !1, needFeature: !1};
                bh(n) || (n = Qd(n));
                const c = n;
                let d = !0;
                try {
                    d = function (E) {
                        if (!Nc(E)) return E;
                        let I = wh(E);
                        return Kd(I), I = xm(I), I
                    }(c)
                } catch {
                    console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(c, null, 2)}
        `)
                }
                let f = null, _ = null;
                if (a !== "background" && a !== "sky" && a !== "slot") {
                    _ = ze[`filter_${a}`];
                    const E = Hl(d, _, e, i);
                    if (E.result === "error") throw new Error(E.value.map(I => `${I.key}: ${I.message}`).join(", "));
                    f = (I, C, z) => E.value.evaluate(I, C, {}, z)
                }
                let x = null, w = null;
                if (d !== c) {
                    const E = Hl(c, _, e, i);
                    if (E.result === "error") throw new Error(E.value.map(I => `${I.key}: ${I.message}`).join(", "));
                    x = (I, C, z, L, F) => E.value.evaluate(I, C, {}, z, void 0, void 0, L, F), w = !Mc(E.value.expression)
                }
                return {filter: f, dynamicFilter: x || void 0, needGeometry: wm(d), needFeature: !!w}
            }

            function xm(n) {
                if (!Array.isArray(n)) return n;
                const e = function (i) {
                    if (Js.has(i[0])) {
                        for (let a = 1; a < i.length; a++) if (Nc(i[a])) return !0
                    }
                    return i
                }(n);
                return e === !0 ? e : e.map(i => xm(i))
            }

            function Kd(n) {
                let e = !1;
                const i = [];
                if (n[0] === "case") {
                    for (let a = 1; a < n.length - 1; a += 2) e = e || Nc(n[a]), i.push(n[a + 1]);
                    i.push(n[n.length - 1])
                } else if (n[0] === "match") {
                    e = e || Nc(n[1]);
                    for (let a = 2; a < n.length - 1; a += 2) i.push(n[a + 1]);
                    i.push(n[n.length - 1])
                } else if (n[0] === "step") {
                    e = e || Nc(n[1]);
                    for (let a = 1; a < n.length - 1; a += 2) i.push(n[a + 1])
                }
                e && (n.length = 0, n.push("any", ...i));
                for (let a = 1; a < n.length; a++) Kd(n[a])
            }

            function Nc(n) {
                if (!Array.isArray(n)) return !1;
                if ((e = n[0]) === "pitch" || e === "distance-from-center") return !0;
                var e;
                for (let i = 1; i < n.length; i++) if (Nc(n[i])) return !0;
                return !1
            }

            const Js = new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);

            function a1(n, e) {
                return n < e ? -1 : n > e ? 1 : 0
            }

            function wm(n) {
                if (!Array.isArray(n)) return !1;
                if (n[0] === "within" || n[0] === "distance") return !0;
                for (let e = 1; e < n.length; e++) if (wm(n[e])) return !0;
                return !1
            }

            function Qd(n) {
                if (!n) return !0;
                const e = n[0];
                return n.length <= 1 ? e !== "any" : e === "==" ? bm(n[1], n[2], "==") : e === "!=" ? Jd(bm(n[1], n[2], "==")) : e === "<" || e === ">" || e === "<=" || e === ">=" ? bm(n[1], n[2], e) : e === "any" ? (i = n.slice(1), ["any"].concat(i.map(Qd))) : e === "all" ? ["all"].concat(n.slice(1).map(Qd)) : e === "none" ? ["all"].concat(n.slice(1).map(Qd).map(Jd)) : e === "in" ? Ty(n[1], n.slice(2)) : e === "!in" ? Jd(Ty(n[1], n.slice(2))) : e === "has" ? Sy(n[1]) : e !== "!has" || Jd(Sy(n[1]));
                var i
            }

            function bm(n, e, i) {
                switch (n) {
                    case"$type":
                        return [`filter-type-${i}`, e];
                    case"$id":
                        return [`filter-id-${i}`, e];
                    default:
                        return [`filter-${i}`, n, e]
                }
            }

            function Ty(n, e) {
                if (e.length === 0) return !1;
                switch (n) {
                    case"$type":
                        return ["filter-type-in", ["literal", e]];
                    case"$id":
                        return ["filter-id-in", ["literal", e]];
                    default:
                        return e.length > 200 && !e.some(i => typeof i != typeof e[0]) ? ["filter-in-large", n, ["literal", e.sort(a1)]] : ["filter-in-small", n, ["literal", e]]
                }
            }

            function Sy(n) {
                switch (n) {
                    case"$type":
                        return !0;
                    case"$id":
                        return ["filter-has-id"];
                    default:
                        return ["filter-has", n]
                }
            }

            function Jd(n) {
                return ["!", n]
            }

            const Th = "";

            function jc(n, e) {
                return e ? `${n}${Th}${e}` : n
            }

            const Ey = "-transition", l1 = new Set(["fill", "line", "background", "hillshade", "raster"]);

            class to extends Ol {
                constructor(e, i, a, c, d) {
                    if (super(), this.id = e.id, this.fqid = jc(this.id, a), this.type = e.type, this.scope = a, this.lut = c, this.options = d, this._featureFilter = {
                        filter: () => !0,
                        needGeometry: !1,
                        needFeature: !1
                    }, this._filterCompiled = !1, this.configDependencies = new Set, e.type !== "custom") {
                        if (this.metadata = e.metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, e.type && e.type !== "background" && e.type !== "sky" && e.type !== "slot") {
                            this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter;
                            const f = Hl(this.filter, ze[`filter_${e.type}`]);
                            f.result !== "error" && (this.configDependencies = new Set([...this.configDependencies, ...f.value.configDependencies]))
                        }
                        if (e.slot && (this.slot = e.slot), i.layout && (this._unevaluatedLayout = new ll(i.layout, this.scope, d), this.configDependencies = new Set([...this.configDependencies, ...this._unevaluatedLayout.configDependencies])), i.paint) {
                            this._transitionablePaint = new xh(i.paint, this.scope, d);
                            for (const f in e.paint) this.setPaintProperty(f, e.paint[f]);
                            for (const f in e.layout) this.setLayoutProperty(f, e.layout[f]);
                            this.configDependencies = new Set([...this.configDependencies, ...this._transitionablePaint.configDependencies]), this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Bs(i.paint)
                        }
                    }
                }

                onAdd(e) {
                }

                onRemove(e) {
                }

                isDraped(e) {
                    return !this.is3D(!0) && l1.has(this.type)
                }

                getLayoutProperty(e) {
                    return e === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(e)
                }

                setLayoutProperty(e, i) {
                    if (this.type === "custom" && e === "visibility") return void (this.visibility = i);
                    const a = this._unevaluatedLayout;
                    a._properties.properties[e] && (a.setValue(e, i), this.configDependencies = new Set([...this.configDependencies, ...a.configDependencies]), e === "visibility" && this.possiblyEvaluateVisibility())
                }

                possiblyEvaluateVisibility() {
                    this._unevaluatedLayout._values.visibility && (this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({zoom: 0}))
                }

                getPaintProperty(e) {
                    return e.endsWith(Ey) ? this._transitionablePaint.getTransition(e.slice(0, -11)) : this._transitionablePaint.getValue(e)
                }

                setPaintProperty(e, i) {
                    const a = this._transitionablePaint, c = a._properties.properties;
                    if (e.endsWith(Ey)) {
                        const I = e.slice(0, -11);
                        return c[I] && a.setTransition(I, i || void 0), !1
                    }
                    if (!c[e]) return !1;
                    const d = a._values[e], f = d.value.isDataDriven(), _ = d.value;
                    a.setValue(e, i), this.configDependencies = new Set([...this.configDependencies, ...a.configDependencies]), this._handleSpecialPaintPropertyUpdate(e);
                    const x = a._values[e].value, w = x.isDataDriven(),
                        E = e.endsWith("pattern") || e === "line-dasharray";
                    return w || f || E || this._handleOverridablePaintPropertyUpdate(e, _, x)
                }

                _handleSpecialPaintPropertyUpdate(e) {
                }

                getProgramIds() {
                    return null
                }

                getDefaultProgramParams(e, i, a) {
                    return null
                }

                _handleOverridablePaintPropertyUpdate(e, i, a) {
                    return !1
                }

                isHidden(e) {
                    return !!(this.minzoom && e < this.minzoom) || !!(this.maxzoom && e >= this.maxzoom) || this.visibility === "none"
                }

                updateTransitions(e) {
                    this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint)
                }

                hasTransition() {
                    return this._transitioningPaint.hasTransition()
                }

                recalculate(e, i) {
                    this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, i)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, i)
                }

                serialize() {
                    return zi({
                        id: this.id,
                        type: this.type,
                        slot: this.slot,
                        source: this.source,
                        "source-layer": this.sourceLayer,
                        metadata: this.metadata,
                        minzoom: this.minzoom,
                        maxzoom: this.maxzoom,
                        filter: this.filter,
                        layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
                        paint: this._transitionablePaint && this._transitionablePaint.serialize()
                    }, (e, i) => !(e === void 0 || i === "layout" && !Object.keys(e).length || i === "paint" && !Object.keys(e).length))
                }

                is3D(e) {
                    return !1
                }

                hasElevation() {
                    return !1
                }

                isSky() {
                    return !1
                }

                isTileClipped() {
                    return !1
                }

                hasOffscreenPass() {
                    return !1
                }

                hasShadowPass() {
                    return !1
                }

                canCastShadows() {
                    return !1
                }

                hasLightBeamPass() {
                    return !1
                }

                cutoffRange() {
                    return 0
                }

                tileCoverLift() {
                    return 0
                }

                resize() {
                }

                _clear() {
                }

                isStateDependent() {
                    for (const e in this.paint._values) {
                        const i = this.paint.get(e);
                        if (i instanceof Wl && Ud(i.property.specification) && (i.value.kind === "source" || i.value.kind === "composite") && i.value.isStateDependent) return !0
                    }
                    return !1
                }

                compileFilter(e) {
                    this._filterCompiled || (this._featureFilter = Bc(this.filter, this.scope, e), this._filterCompiled = !0)
                }

                invalidateCompiledFilter() {
                    this._filterCompiled = !1
                }

                dynamicFilter() {
                    return this._featureFilter.dynamicFilter
                }

                dynamicFilterNeedsFeature() {
                    return this._featureFilter.needFeature
                }

                getLayerRenderingStats() {
                    return this._stats
                }

                resetLayerRenderingStats(e) {
                    this._stats && (e.renderPass === "shadow" ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0)
                }

                queryRadius(e) {
                }

                queryIntersectsFeature(e, i, a, c, d, f, _, x, w) {
                }
            }

            const c1 = {
                Int8: Int8Array,
                Uint8: Uint8Array,
                Int16: Int16Array,
                Uint16: Uint16Array,
                Int32: Int32Array,
                Uint32: Uint32Array,
                Float32: Float32Array
            };

            class Sh {
                constructor(e, i) {
                    this._structArray = e, this._pos1 = i * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8
                }
            }

            class In {
                constructor() {
                    this.capacity = -1, this.resize(0)
                }

                static serialize(e, i) {
                    return e._trim(), i && i.add(e.arrayBuffer), {length: e.length, arrayBuffer: e.arrayBuffer}
                }

                static deserialize(e) {
                    const i = Object.create(this.prototype);
                    return i.arrayBuffer = e.arrayBuffer, i.length = e.length, i.capacity = e.arrayBuffer.byteLength / i.bytesPerElement, i._refreshViews(), i
                }

                _trim() {
                    this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews())
                }

                clear() {
                    this.length = 0
                }

                resize(e) {
                    this.reserve(e), this.length = e
                }

                reserve(e) {
                    if (e > this.capacity) {
                        this.capacity = Math.max(e, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                        const i = this.uint8;
                        this._refreshViews(), i && this.uint8.set(i)
                    }
                }

                _refreshViews() {
                    throw new Error("StructArray#_refreshViews() must be implemented by each concrete StructArray layout")
                }

                emplace(...e) {
                    throw new Error("StructArray#emplace() must be implemented by each concrete StructArray layout")
                }

                emplaceBack(...e) {
                    throw new Error("StructArray#emplaceBack() must be implemented by each concrete StructArray layout")
                }

                destroy() {
                    this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null
                }
            }

            function Fi(n, e = 1) {
                let i = 0, a = 0;
                return {
                    members: n.map(c => {
                        const d = c1[c.type].BYTES_PER_ELEMENT, f = i = Tm(i, Math.max(e, d)), _ = c.components || 1;
                        return a = Math.max(a, d), i += d * _, {name: c.name, type: c.type, components: _, offset: f}
                    }), size: Tm(i, Math.max(a, e)), alignment: e
                }
            }

            function Tm(n, e) {
                return Math.ceil(n / e) * e
            }

            class Po extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
                }

                emplaceBack(e, i) {
                    const a = this.length;
                    return this.resize(a + 1), this.emplace(a, e, i)
                }

                emplace(e, i, a) {
                    const c = 2 * e;
                    return this.int16[c + 0] = i, this.int16[c + 1] = a, e
                }
            }

            Po.prototype.bytesPerElement = 4, Pt(Po, "StructArrayLayout2i4");

            class Vc extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a) {
                    const c = this.length;
                    return this.resize(c + 1), this.emplace(c, e, i, a)
                }

                emplace(e, i, a, c) {
                    const d = 3 * e;
                    return this.int16[d + 0] = i, this.int16[d + 1] = a, this.int16[d + 2] = c, e
                }
            }

            Vc.prototype.bytesPerElement = 6, Pt(Vc, "StructArrayLayout3i6");

            class Uc extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c) {
                    const d = this.length;
                    return this.resize(d + 1), this.emplace(d, e, i, a, c)
                }

                emplace(e, i, a, c, d) {
                    const f = 4 * e;
                    return this.int16[f + 0] = i, this.int16[f + 1] = a, this.int16[f + 2] = c, this.int16[f + 3] = d, e
                }
            }

            Uc.prototype.bytesPerElement = 8, Pt(Uc, "StructArrayLayout4i8");

            class Zl extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e) {
                    const i = this.length;
                    return this.resize(i + 1), this.emplace(i, e)
                }

                emplace(e, i) {
                    return this.float32[1 * e + 0] = i, e
                }
            }

            Zl.prototype.bytesPerElement = 4, Pt(Zl, "StructArrayLayout1f4");

            class Sm extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a) {
                    const c = this.length;
                    return this.resize(c + 1), this.emplace(c, e, i, a)
                }

                emplace(e, i, a, c) {
                    const d = 4 * e, f = 2 * e;
                    return this.int16[d + 0] = i, this.int16[d + 1] = a, this.float32[f + 1] = c, e
                }
            }

            Sm.prototype.bytesPerElement = 8, Pt(Sm, "StructArrayLayout2i1f8");

            class Em extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a) {
                    const c = this.length;
                    return this.resize(c + 1), this.emplace(c, e, i, a)
                }

                emplace(e, i, a, c) {
                    const d = 4 * e;
                    return this.int16[d + 0] = i, this.int16[d + 1] = a, this.int16[d + 2] = c, e
                }
            }

            Em.prototype.bytesPerElement = 8, Pt(Em, "StructArrayLayout3i8");

            class ef extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c, d) {
                    const f = this.length;
                    return this.resize(f + 1), this.emplace(f, e, i, a, c, d)
                }

                emplace(e, i, a, c, d, f) {
                    const _ = 5 * e;
                    return this.int16[_ + 0] = i, this.int16[_ + 1] = a, this.int16[_ + 2] = c, this.int16[_ + 3] = d, this.int16[_ + 4] = f, e
                }
            }

            ef.prototype.bytesPerElement = 10, Pt(ef, "StructArrayLayout5i10");

            class tf extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c, d, f, _) {
                    const x = this.length;
                    return this.resize(x + 1), this.emplace(x, e, i, a, c, d, f, _)
                }

                emplace(e, i, a, c, d, f, _, x) {
                    const w = 6 * e, E = 12 * e, I = 3 * e;
                    return this.int16[w + 0] = i, this.int16[w + 1] = a, this.uint8[E + 4] = c, this.uint8[E + 5] = d, this.uint8[E + 6] = f, this.uint8[E + 7] = _, this.float32[I + 2] = x, e
                }
            }

            tf.prototype.bytesPerElement = 12, Pt(tf, "StructArrayLayout2i4ub1f12");

            class Qo extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a) {
                    const c = this.length;
                    return this.resize(c + 1), this.emplace(c, e, i, a)
                }

                emplace(e, i, a, c) {
                    const d = 3 * e;
                    return this.float32[d + 0] = i, this.float32[d + 1] = a, this.float32[d + 2] = c, e
                }
            }

            Qo.prototype.bytesPerElement = 12, Pt(Qo, "StructArrayLayout3f12");

            class cl extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c, d) {
                    const f = this.length;
                    return this.resize(f + 1), this.emplace(f, e, i, a, c, d)
                }

                emplace(e, i, a, c, d, f) {
                    const _ = 6 * e, x = 3 * e;
                    return this.uint16[_ + 0] = i, this.uint16[_ + 1] = a, this.uint16[_ + 2] = c, this.uint16[_ + 3] = d, this.float32[x + 2] = f, e
                }
            }

            cl.prototype.bytesPerElement = 12, Pt(cl, "StructArrayLayout4ui1f12");

            class Gc extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c) {
                    const d = this.length;
                    return this.resize(d + 1), this.emplace(d, e, i, a, c)
                }

                emplace(e, i, a, c, d) {
                    const f = 4 * e;
                    return this.uint16[f + 0] = i, this.uint16[f + 1] = a, this.uint16[f + 2] = c, this.uint16[f + 3] = d, e
                }
            }

            Gc.prototype.bytesPerElement = 8, Pt(Gc, "StructArrayLayout4ui8");

            class nf extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c, d, f) {
                    const _ = this.length;
                    return this.resize(_ + 1), this.emplace(_, e, i, a, c, d, f)
                }

                emplace(e, i, a, c, d, f, _) {
                    const x = 6 * e;
                    return this.int16[x + 0] = i, this.int16[x + 1] = a, this.int16[x + 2] = c, this.int16[x + 3] = d, this.int16[x + 4] = f, this.int16[x + 5] = _, e
                }
            }

            nf.prototype.bytesPerElement = 12, Pt(nf, "StructArrayLayout6i12");

            class rf extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c, d, f, _, x, w, E, I, C) {
                    const z = this.length;
                    return this.resize(z + 1), this.emplace(z, e, i, a, c, d, f, _, x, w, E, I, C)
                }

                emplace(e, i, a, c, d, f, _, x, w, E, I, C, z) {
                    const L = 12 * e;
                    return this.int16[L + 0] = i, this.int16[L + 1] = a, this.int16[L + 2] = c, this.int16[L + 3] = d, this.uint16[L + 4] = f, this.uint16[L + 5] = _, this.uint16[L + 6] = x, this.uint16[L + 7] = w, this.int16[L + 8] = E, this.int16[L + 9] = I, this.int16[L + 10] = C, this.int16[L + 11] = z, e
                }
            }

            rf.prototype.bytesPerElement = 24, Pt(rf, "StructArrayLayout4i4ui4i24");

            class $c extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c, d, f) {
                    const _ = this.length;
                    return this.resize(_ + 1), this.emplace(_, e, i, a, c, d, f)
                }

                emplace(e, i, a, c, d, f, _) {
                    const x = 10 * e, w = 5 * e;
                    return this.int16[x + 0] = i, this.int16[x + 1] = a, this.int16[x + 2] = c, this.float32[w + 2] = d, this.float32[w + 3] = f, this.float32[w + 4] = _, e
                }
            }

            $c.prototype.bytesPerElement = 20, Pt($c, "StructArrayLayout3i3f20");

            class ul extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c) {
                    const d = this.length;
                    return this.resize(d + 1), this.emplace(d, e, i, a, c)
                }

                emplace(e, i, a, c, d) {
                    const f = 4 * e;
                    return this.float32[f + 0] = i, this.float32[f + 1] = a, this.float32[f + 2] = c, this.float32[f + 3] = d, e
                }
            }

            ul.prototype.bytesPerElement = 16, Pt(ul, "StructArrayLayout4f16");

            class Am extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer)
                }

                emplaceBack(e) {
                    const i = this.length;
                    return this.resize(i + 1), this.emplace(i, e)
                }

                emplace(e, i) {
                    return this.uint32[1 * e + 0] = i, e
                }
            }

            Am.prototype.bytesPerElement = 4, Pt(Am, "StructArrayLayout1ul4");

            class ea extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }

                emplaceBack(e, i) {
                    const a = this.length;
                    return this.resize(a + 1), this.emplace(a, e, i)
                }

                emplace(e, i, a) {
                    const c = 2 * e;
                    return this.uint16[c + 0] = i, this.uint16[c + 1] = a, e
                }
            }

            ea.prototype.bytesPerElement = 4, Pt(ea, "StructArrayLayout2ui4");

            class Im extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c, d, f, _, x, w, E, I, C, z) {
                    const L = this.length;
                    return this.resize(L + 1), this.emplace(L, e, i, a, c, d, f, _, x, w, E, I, C, z)
                }

                emplace(e, i, a, c, d, f, _, x, w, E, I, C, z, L) {
                    const F = 20 * e, N = 10 * e;
                    return this.int16[F + 0] = i, this.int16[F + 1] = a, this.int16[F + 2] = c, this.int16[F + 3] = d, this.int16[F + 4] = f, this.float32[N + 3] = _, this.float32[N + 4] = x, this.float32[N + 5] = w, this.float32[N + 6] = E, this.int16[F + 14] = I, this.uint32[N + 8] = C, this.uint16[F + 18] = z, this.uint16[F + 19] = L, e
                }
            }

            Im.prototype.bytesPerElement = 40, Pt(Im, "StructArrayLayout5i4f1i1ul2ui40");

            class of extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c, d, f, _) {
                    const x = this.length;
                    return this.resize(x + 1), this.emplace(x, e, i, a, c, d, f, _)
                }

                emplace(e, i, a, c, d, f, _, x) {
                    const w = 8 * e;
                    return this.int16[w + 0] = i, this.int16[w + 1] = a, this.int16[w + 2] = c, this.int16[w + 4] = d, this.int16[w + 5] = f, this.int16[w + 6] = _, this.int16[w + 7] = x, e
                }
            }

            of.prototype.bytesPerElement = 16, Pt(of, "StructArrayLayout3i2i2i16");

            class Hc extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c, d) {
                    const f = this.length;
                    return this.resize(f + 1), this.emplace(f, e, i, a, c, d)
                }

                emplace(e, i, a, c, d, f) {
                    const _ = 4 * e, x = 8 * e;
                    return this.float32[_ + 0] = i, this.float32[_ + 1] = a, this.float32[_ + 2] = c, this.int16[x + 6] = d, this.int16[x + 7] = f, e
                }
            }

            Hc.prototype.bytesPerElement = 16, Pt(Hc, "StructArrayLayout2f1f2i16");

            class qc extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c, d, f) {
                    const _ = this.length;
                    return this.resize(_ + 1), this.emplace(_, e, i, a, c, d, f)
                }

                emplace(e, i, a, c, d, f, _) {
                    const x = 20 * e, w = 5 * e;
                    return this.uint8[x + 0] = i, this.uint8[x + 1] = a, this.float32[w + 1] = c, this.float32[w + 2] = d, this.float32[w + 3] = f, this.float32[w + 4] = _, e
                }
            }

            qc.prototype.bytesPerElement = 20, Pt(qc, "StructArrayLayout2ub4f20");

            class Mn extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a) {
                    const c = this.length;
                    return this.resize(c + 1), this.emplace(c, e, i, a)
                }

                emplace(e, i, a, c) {
                    const d = 3 * e;
                    return this.uint16[d + 0] = i, this.uint16[d + 1] = a, this.uint16[d + 2] = c, e
                }
            }

            Mn.prototype.bytesPerElement = 6, Pt(Mn, "StructArrayLayout3ui6");

            class Wc extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c, d, f, _, x, w, E, I, C, z, L, F, N, H, Y, X, J, xe) {
                    const ge = this.length;
                    return this.resize(ge + 1), this.emplace(ge, e, i, a, c, d, f, _, x, w, E, I, C, z, L, F, N, H, Y, X, J, xe)
                }

                emplace(e, i, a, c, d, f, _, x, w, E, I, C, z, L, F, N, H, Y, X, J, xe, ge) {
                    const ye = 30 * e, Ee = 15 * e, Ie = 60 * e;
                    return this.int16[ye + 0] = i, this.int16[ye + 1] = a, this.int16[ye + 2] = c, this.float32[Ee + 2] = d, this.float32[Ee + 3] = f, this.uint16[ye + 8] = _, this.uint16[ye + 9] = x, this.uint32[Ee + 5] = w, this.uint32[Ee + 6] = E, this.uint32[Ee + 7] = I, this.uint16[ye + 16] = C, this.uint16[ye + 17] = z, this.uint16[ye + 18] = L, this.float32[Ee + 10] = F, this.float32[Ee + 11] = N, this.uint8[Ie + 48] = H, this.uint8[Ie + 49] = Y, this.uint8[Ie + 50] = X, this.uint32[Ee + 13] = J, this.int16[ye + 28] = xe, this.uint8[Ie + 58] = ge, e
                }
            }

            Wc.prototype.bytesPerElement = 60, Pt(Wc, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");

            class Cm extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c, d, f, _, x, w, E, I, C, z, L, F, N, H, Y, X, J, xe, ge, ye, Ee, Ie, We, De, Ye, ht, Qe, ot, ct, He) {
                    const st = this.length;
                    return this.resize(st + 1), this.emplace(st, e, i, a, c, d, f, _, x, w, E, I, C, z, L, F, N, H, Y, X, J, xe, ge, ye, Ee, Ie, We, De, Ye, ht, Qe, ot, ct, He)
                }

                emplace(e, i, a, c, d, f, _, x, w, E, I, C, z, L, F, N, H, Y, X, J, xe, ge, ye, Ee, Ie, We, De, Ye, ht, Qe, ot, ct, He, st) {
                    const ke = 20 * e, qe = 40 * e, pt = 80 * e;
                    return this.float32[ke + 0] = i, this.float32[ke + 1] = a, this.int16[qe + 4] = c, this.int16[qe + 5] = d, this.int16[qe + 6] = f, this.int16[qe + 7] = _, this.int16[qe + 8] = x, this.int16[qe + 9] = w, this.int16[qe + 10] = E, this.int16[qe + 11] = I, this.int16[qe + 12] = C, this.uint16[qe + 13] = z, this.uint16[qe + 14] = L, this.uint16[qe + 15] = F, this.uint16[qe + 16] = N, this.uint16[qe + 17] = H, this.uint16[qe + 18] = Y, this.uint16[qe + 19] = X, this.uint16[qe + 20] = J, this.uint16[qe + 21] = xe, this.uint16[qe + 22] = ge, this.uint16[qe + 23] = ye, this.uint16[qe + 24] = Ee, this.uint16[qe + 25] = Ie, this.uint16[qe + 26] = We, this.uint16[qe + 27] = De, this.uint32[ke + 14] = Ye, this.float32[ke + 15] = ht, this.float32[ke + 16] = Qe, this.float32[ke + 17] = ot, this.float32[ke + 18] = ct, this.uint8[pt + 76] = He, this.uint16[qe + 39] = st, e
                }
            }

            Cm.prototype.bytesPerElement = 80, Pt(Cm, "StructArrayLayout2f9i15ui1ul4f1ub1ui80");

            class Pm extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c, d, f) {
                    const _ = this.length;
                    return this.resize(_ + 1), this.emplace(_, e, i, a, c, d, f)
                }

                emplace(e, i, a, c, d, f, _) {
                    const x = 6 * e;
                    return this.float32[x + 0] = i, this.float32[x + 1] = a, this.float32[x + 2] = c, this.float32[x + 3] = d, this.float32[x + 4] = f, this.float32[x + 5] = _, e
                }
            }

            Pm.prototype.bytesPerElement = 24, Pt(Pm, "StructArrayLayout6f24");

            class Xl extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c, d) {
                    const f = this.length;
                    return this.resize(f + 1), this.emplace(f, e, i, a, c, d)
                }

                emplace(e, i, a, c, d, f) {
                    const _ = 5 * e;
                    return this.float32[_ + 0] = i, this.float32[_ + 1] = a, this.float32[_ + 2] = c, this.float32[_ + 3] = d, this.float32[_ + 4] = f, e
                }
            }

            Xl.prototype.bytesPerElement = 20, Pt(Xl, "StructArrayLayout5f20");

            class Mm extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c, d, f, _) {
                    const x = this.length;
                    return this.resize(x + 1), this.emplace(x, e, i, a, c, d, f, _)
                }

                emplace(e, i, a, c, d, f, _, x) {
                    const w = 7 * e;
                    return this.float32[w + 0] = i, this.float32[w + 1] = a, this.float32[w + 2] = c, this.float32[w + 3] = d, this.float32[w + 4] = f, this.float32[w + 5] = _, this.float32[w + 6] = x, e
                }
            }

            Mm.prototype.bytesPerElement = 28, Pt(Mm, "StructArrayLayout7f28");

            class Eh extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c, d, f, _, x, w, E, I) {
                    const C = this.length;
                    return this.resize(C + 1), this.emplace(C, e, i, a, c, d, f, _, x, w, E, I)
                }

                emplace(e, i, a, c, d, f, _, x, w, E, I, C) {
                    const z = 11 * e;
                    return this.float32[z + 0] = i, this.float32[z + 1] = a, this.float32[z + 2] = c, this.float32[z + 3] = d, this.float32[z + 4] = f, this.float32[z + 5] = _, this.float32[z + 6] = x, this.float32[z + 7] = w, this.float32[z + 8] = E, this.float32[z + 9] = I, this.float32[z + 10] = C, e
                }
            }

            Eh.prototype.bytesPerElement = 44, Pt(Eh, "StructArrayLayout11f44");

            class Rm extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c, d, f, _, x, w) {
                    const E = this.length;
                    return this.resize(E + 1), this.emplace(E, e, i, a, c, d, f, _, x, w)
                }

                emplace(e, i, a, c, d, f, _, x, w, E) {
                    const I = 9 * e;
                    return this.float32[I + 0] = i, this.float32[I + 1] = a, this.float32[I + 2] = c, this.float32[I + 3] = d, this.float32[I + 4] = f, this.float32[I + 5] = _, this.float32[I + 6] = x, this.float32[I + 7] = w, this.float32[I + 8] = E, e
                }
            }

            Rm.prototype.bytesPerElement = 36, Pt(Rm, "StructArrayLayout9f36");

            class hl extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e, i) {
                    const a = this.length;
                    return this.resize(a + 1), this.emplace(a, e, i)
                }

                emplace(e, i, a) {
                    const c = 2 * e;
                    return this.float32[c + 0] = i, this.float32[c + 1] = a, e
                }
            }

            hl.prototype.bytesPerElement = 8, Pt(hl, "StructArrayLayout2f8");

            class zm extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c) {
                    const d = this.length;
                    return this.resize(d + 1), this.emplace(d, e, i, a, c)
                }

                emplace(e, i, a, c, d) {
                    const f = 6 * e;
                    return this.uint32[3 * e + 0] = i, this.uint16[f + 2] = a, this.uint16[f + 3] = c, this.uint16[f + 4] = d, e
                }
            }

            zm.prototype.bytesPerElement = 12, Pt(zm, "StructArrayLayout1ul3ui12");

            class Dm extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer)
                }

                emplaceBack(e) {
                    const i = this.length;
                    return this.resize(i + 1), this.emplace(i, e)
                }

                emplace(e, i) {
                    return this.uint16[1 * e + 0] = i, e
                }
            }

            Dm.prototype.bytesPerElement = 2, Pt(Dm, "StructArrayLayout1ui2");

            class sf extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c, d, f, _, x, w, E, I, C, z, L, F, N) {
                    const H = this.length;
                    return this.resize(H + 1), this.emplace(H, e, i, a, c, d, f, _, x, w, E, I, C, z, L, F, N)
                }

                emplace(e, i, a, c, d, f, _, x, w, E, I, C, z, L, F, N, H) {
                    const Y = 16 * e;
                    return this.float32[Y + 0] = i, this.float32[Y + 1] = a, this.float32[Y + 2] = c, this.float32[Y + 3] = d, this.float32[Y + 4] = f, this.float32[Y + 5] = _, this.float32[Y + 6] = x, this.float32[Y + 7] = w, this.float32[Y + 8] = E, this.float32[Y + 9] = I, this.float32[Y + 10] = C, this.float32[Y + 11] = z, this.float32[Y + 12] = L, this.float32[Y + 13] = F, this.float32[Y + 14] = N, this.float32[Y + 15] = H, e
                }
            }

            sf.prototype.bytesPerElement = 64, Pt(sf, "StructArrayLayout16f64");

            class Zc extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer)
                }

                emplaceBack(e, i, a, c, d, f, _) {
                    const x = this.length;
                    return this.resize(x + 1), this.emplace(x, e, i, a, c, d, f, _)
                }

                emplace(e, i, a, c, d, f, _, x) {
                    const w = 10 * e, E = 5 * e;
                    return this.uint16[w + 0] = i, this.uint16[w + 1] = a, this.uint16[w + 2] = c, this.uint16[w + 3] = d, this.float32[E + 2] = f, this.float32[E + 3] = _, this.float32[E + 4] = x, e
                }
            }

            Zc.prototype.bytesPerElement = 20, Pt(Zc, "StructArrayLayout4ui3f20");

            class Lm extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer)
                }

                emplaceBack(e) {
                    const i = this.length;
                    return this.resize(i + 1), this.emplace(i, e)
                }

                emplace(e, i) {
                    return this.int16[1 * e + 0] = i, e
                }
            }

            Lm.prototype.bytesPerElement = 2, Pt(Lm, "StructArrayLayout1i2");

            class af extends In {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer)
                }

                emplaceBack(e) {
                    const i = this.length;
                    return this.resize(i + 1), this.emplace(i, e)
                }

                emplace(e, i) {
                    return this.uint8[1 * e + 0] = i, e
                }
            }

            af.prototype.bytesPerElement = 1, Pt(af, "StructArrayLayout1ub1");

            class km extends Sh {
                get projectedAnchorX() {
                    return this._structArray.int16[this._pos2 + 0]
                }

                get projectedAnchorY() {
                    return this._structArray.int16[this._pos2 + 1]
                }

                get projectedAnchorZ() {
                    return this._structArray.int16[this._pos2 + 2]
                }

                get tileAnchorX() {
                    return this._structArray.int16[this._pos2 + 3]
                }

                get tileAnchorY() {
                    return this._structArray.int16[this._pos2 + 4]
                }

                get x1() {
                    return this._structArray.float32[this._pos4 + 3]
                }

                get y1() {
                    return this._structArray.float32[this._pos4 + 4]
                }

                get x2() {
                    return this._structArray.float32[this._pos4 + 5]
                }

                get y2() {
                    return this._structArray.float32[this._pos4 + 6]
                }

                get padding() {
                    return this._structArray.int16[this._pos2 + 14]
                }

                get featureIndex() {
                    return this._structArray.uint32[this._pos4 + 8]
                }

                get sourceLayerIndex() {
                    return this._structArray.uint16[this._pos2 + 18]
                }

                get bucketIndex() {
                    return this._structArray.uint16[this._pos2 + 19]
                }
            }

            km.prototype.size = 40;

            class Ay extends Im {
                get(e) {
                    return new km(this, e)
                }
            }

            Pt(Ay, "CollisionBoxArray");

            class lf extends Sh {
                get projectedAnchorX() {
                    return this._structArray.int16[this._pos2 + 0]
                }

                get projectedAnchorY() {
                    return this._structArray.int16[this._pos2 + 1]
                }

                get projectedAnchorZ() {
                    return this._structArray.int16[this._pos2 + 2]
                }

                get tileAnchorX() {
                    return this._structArray.float32[this._pos4 + 2]
                }

                get tileAnchorY() {
                    return this._structArray.float32[this._pos4 + 3]
                }

                get glyphStartIndex() {
                    return this._structArray.uint16[this._pos2 + 8]
                }

                get numGlyphs() {
                    return this._structArray.uint16[this._pos2 + 9]
                }

                get vertexStartIndex() {
                    return this._structArray.uint32[this._pos4 + 5]
                }

                get lineStartIndex() {
                    return this._structArray.uint32[this._pos4 + 6]
                }

                get lineLength() {
                    return this._structArray.uint32[this._pos4 + 7]
                }

                get segment() {
                    return this._structArray.uint16[this._pos2 + 16]
                }

                get lowerSize() {
                    return this._structArray.uint16[this._pos2 + 17]
                }

                get upperSize() {
                    return this._structArray.uint16[this._pos2 + 18]
                }

                get lineOffsetX() {
                    return this._structArray.float32[this._pos4 + 10]
                }

                get lineOffsetY() {
                    return this._structArray.float32[this._pos4 + 11]
                }

                get writingMode() {
                    return this._structArray.uint8[this._pos1 + 48]
                }

                get placedOrientation() {
                    return this._structArray.uint8[this._pos1 + 49]
                }

                set placedOrientation(e) {
                    this._structArray.uint8[this._pos1 + 49] = e
                }

                get hidden() {
                    return this._structArray.uint8[this._pos1 + 50]
                }

                set hidden(e) {
                    this._structArray.uint8[this._pos1 + 50] = e
                }

                get crossTileID() {
                    return this._structArray.uint32[this._pos4 + 13]
                }

                set crossTileID(e) {
                    this._structArray.uint32[this._pos4 + 13] = e
                }

                get associatedIconIndex() {
                    return this._structArray.int16[this._pos2 + 28]
                }

                get flipState() {
                    return this._structArray.uint8[this._pos1 + 58]
                }

                set flipState(e) {
                    this._structArray.uint8[this._pos1 + 58] = e
                }
            }

            lf.prototype.size = 60;

            class Ah extends Wc {
                get(e) {
                    return new lf(this, e)
                }
            }

            Pt(Ah, "PlacedSymbolArray");

            class Om extends Sh {
                get tileAnchorX() {
                    return this._structArray.float32[this._pos4 + 0]
                }

                get tileAnchorY() {
                    return this._structArray.float32[this._pos4 + 1]
                }

                get projectedAnchorX() {
                    return this._structArray.int16[this._pos2 + 4]
                }

                get projectedAnchorY() {
                    return this._structArray.int16[this._pos2 + 5]
                }

                get projectedAnchorZ() {
                    return this._structArray.int16[this._pos2 + 6]
                }

                get rightJustifiedTextSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 7]
                }

                get centerJustifiedTextSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 8]
                }

                get leftJustifiedTextSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 9]
                }

                get verticalPlacedTextSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 10]
                }

                get placedIconSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 11]
                }

                get verticalPlacedIconSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 12]
                }

                get key() {
                    return this._structArray.uint16[this._pos2 + 13]
                }

                get textBoxStartIndex() {
                    return this._structArray.uint16[this._pos2 + 14]
                }

                get textBoxEndIndex() {
                    return this._structArray.uint16[this._pos2 + 15]
                }

                get verticalTextBoxStartIndex() {
                    return this._structArray.uint16[this._pos2 + 16]
                }

                get verticalTextBoxEndIndex() {
                    return this._structArray.uint16[this._pos2 + 17]
                }

                get iconBoxStartIndex() {
                    return this._structArray.uint16[this._pos2 + 18]
                }

                get iconBoxEndIndex() {
                    return this._structArray.uint16[this._pos2 + 19]
                }

                get verticalIconBoxStartIndex() {
                    return this._structArray.uint16[this._pos2 + 20]
                }

                get verticalIconBoxEndIndex() {
                    return this._structArray.uint16[this._pos2 + 21]
                }

                get featureIndex() {
                    return this._structArray.uint16[this._pos2 + 22]
                }

                get numHorizontalGlyphVertices() {
                    return this._structArray.uint16[this._pos2 + 23]
                }

                get numVerticalGlyphVertices() {
                    return this._structArray.uint16[this._pos2 + 24]
                }

                get numIconVertices() {
                    return this._structArray.uint16[this._pos2 + 25]
                }

                get numVerticalIconVertices() {
                    return this._structArray.uint16[this._pos2 + 26]
                }

                get useRuntimeCollisionCircles() {
                    return this._structArray.uint16[this._pos2 + 27]
                }

                get crossTileID() {
                    return this._structArray.uint32[this._pos4 + 14]
                }

                set crossTileID(e) {
                    this._structArray.uint32[this._pos4 + 14] = e
                }

                get textOffset0() {
                    return this._structArray.float32[this._pos4 + 15]
                }

                get textOffset1() {
                    return this._structArray.float32[this._pos4 + 16]
                }

                get collisionCircleDiameter() {
                    return this._structArray.float32[this._pos4 + 17]
                }

                get zOffset() {
                    return this._structArray.float32[this._pos4 + 18]
                }

                set zOffset(e) {
                    this._structArray.float32[this._pos4 + 18] = e
                }

                get hasIconTextFit() {
                    return this._structArray.uint8[this._pos1 + 76]
                }

                get elevationFeatureIndex() {
                    return this._structArray.uint16[this._pos2 + 39]
                }
            }

            Om.prototype.size = 80;

            class Iy extends Cm {
                get(e) {
                    return new Om(this, e)
                }
            }

            Pt(Iy, "SymbolInstanceArray");

            class Fm extends Zl {
                getoffsetX(e) {
                    return this.float32[1 * e + 0]
                }
            }

            Pt(Fm, "GlyphOffsetArray");

            class Cy extends Po {
                getx(e) {
                    return this.int16[2 * e + 0]
                }

                gety(e) {
                    return this.int16[2 * e + 1]
                }
            }

            Pt(Cy, "SymbolLineVertexArray");

            class cf extends Sh {
                get featureIndex() {
                    return this._structArray.uint32[this._pos4 + 0]
                }

                get sourceLayerIndex() {
                    return this._structArray.uint16[this._pos2 + 2]
                }

                get bucketIndex() {
                    return this._structArray.uint16[this._pos2 + 3]
                }

                get layoutVertexArrayOffset() {
                    return this._structArray.uint16[this._pos2 + 4]
                }
            }

            cf.prototype.size = 12;

            class Py extends zm {
                get(e) {
                    return new cf(this, e)
                }
            }

            Pt(Py, "FeatureIndexArray");

            class My extends ea {
                geta_centroid_pos0(e) {
                    return this.uint16[2 * e + 0]
                }

                geta_centroid_pos1(e) {
                    return this.uint16[2 * e + 1]
                }
            }

            Pt(My, "FillExtrusionCentroidArray");

            class Ry extends Sh {
                get a_join_normal_inside0() {
                    return this._structArray.int16[this._pos2 + 0]
                }

                get a_join_normal_inside1() {
                    return this._structArray.int16[this._pos2 + 1]
                }

                get a_join_normal_inside2() {
                    return this._structArray.int16[this._pos2 + 2]
                }
            }

            Ry.prototype.size = 6;

            class zy extends Vc {
                get(e) {
                    return new Ry(this, e)
                }
            }

            Pt(zy, "FillExtrusionWallArray");
            const Dy = Fi([{name: "a_pos", components: 2, type: "Int16"}], 4),
                u1 = Fi([{name: "a_circle_z_offset", components: 1, type: "Float32"}], 4),
                h1 = Fi([{name: "a_pos_3", components: 3, type: "Int16"}, {
                    name: "a_pos_normal_3",
                    components: 3,
                    type: "Int16"
                }]);

            class Ln {
                constructor(e = []) {
                    this.segments = e
                }

                _prepareSegment(e, i, a, c) {
                    let d = this.segments[this.segments.length - 1];
                    return e > Ln.MAX_VERTEX_ARRAY_LENGTH && Li(`Max vertices per segment is ${Ln.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}`), (!d || d.vertexLength + e > Ln.MAX_VERTEX_ARRAY_LENGTH || d.sortKey !== c) && (d = {
                        vertexOffset: i,
                        primitiveOffset: a,
                        vertexLength: 0,
                        primitiveLength: 0
                    }, c !== void 0 && (d.sortKey = c), this.segments.push(d)), d
                }

                prepareSegment(e, i, a, c) {
                    return this._prepareSegment(e, i.length, a.length, c)
                }

                get() {
                    return this.segments
                }

                destroy() {
                    for (const e of this.segments) for (const i in e.vaos) e.vaos[i].destroy()
                }

                static simpleSegment(e, i, a, c) {
                    return new Ln([{
                        vertexOffset: e,
                        primitiveOffset: i,
                        vertexLength: a,
                        primitiveLength: c,
                        vaos: {},
                        sortKey: 0
                    }])
                }
            }

            function Ly(n, e) {
                return 256 * (n = se(Math.floor(n), 0, 255)) + se(Math.floor(e), 0, 255)
            }

            Ln.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Pt(Ln, "SegmentVector");
            const d1 = Fi([{name: "a_pattern", components: 4, type: "Uint16"}, {
                    name: "a_pixel_ratio",
                    components: 1,
                    type: "Float32"
                }]), Bm = Fi([{name: "a_pattern_b", components: 4, type: "Uint16"}]),
                f1 = Fi([{name: "a_dash", components: 4, type: "Uint16"}]);

            class Ih {
                constructor() {
                    this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = !1
                }

                add(e, i, a, c) {
                    this.ids.push(Ch(e)), this.positions.push(i, a, c)
                }

                eachPosition(e, i) {
                    const a = Ch(e);
                    let c = 0, d = this.ids.length - 1;
                    for (; c < d;) {
                        const f = c + d >> 1;
                        this.ids[f] >= a ? d = f : c = f + 1
                    }
                    for (; this.ids[c] === a;) i(this.positions[3 * c], this.positions[3 * c + 1], this.positions[3 * c + 2]), c++
                }

                static serialize(e, i) {
                    const a = new Float64Array(e.ids), c = new Uint32Array(e.positions);
                    return Nm(a, c, 0, a.length - 1), i && (i.add(a.buffer), i.add(c.buffer)), {ids: a, positions: c}
                }

                static deserialize(e) {
                    const i = new Ih;
                    let a;
                    i.ids = e.ids, i.positions = e.positions;
                    for (const c of i.ids) c !== a && i.uniqueIds.push(c), a = c;
                    return i.indexed = !0, i
                }
            }

            function Ch(n) {
                const e = +n;
                return !isNaN(e) && Number.MIN_SAFE_INTEGER <= e && e <= Number.MAX_SAFE_INTEGER ? e : xc(String(n))
            }

            function Nm(n, e, i, a) {
                for (; i < a;) {
                    const c = n[i + a >> 1];
                    let d = i - 1, f = a + 1;
                    for (; ;) {
                        do d++; while (n[d] < c);
                        do f--; while (n[f] > c);
                        if (d >= f) break;
                        uf(n, d, f), uf(e, 3 * d, 3 * f), uf(e, 3 * d + 1, 3 * f + 1), uf(e, 3 * d + 2, 3 * f + 2)
                    }
                    f - i < a - f ? (Nm(n, e, i, f), i = f + 1) : (Nm(n, e, f + 1, a), a = f)
                }
            }

            function uf(n, e, i) {
                const a = n[e];
                n[e] = n[i], n[i] = a
            }

            Pt(Ih, "FeaturePositionMap");

            class bs {
                constructor(e) {
                    this.gl = e.gl, this.initialized = !1
                }

                fetchUniformLocation(e, i) {
                    return this.location || this.initialized || (this.location = this.gl.getUniformLocation(e, i), this.initialized = !0), !!this.location
                }

                set(e, i, a) {
                    throw new Error("Uniform#set() must be implemented by each concrete Uniform")
                }
            }

            class hf extends bs {
                constructor(e) {
                    super(e), this.current = 0
                }

                set(e, i, a) {
                    this.fetchUniformLocation(e, i) && this.current !== a && (this.current = a, this.gl.uniform1i(this.location, a))
                }
            }

            class tr extends bs {
                constructor(e) {
                    super(e), this.current = 0
                }

                set(e, i, a) {
                    this.fetchUniformLocation(e, i) && this.current !== a && (this.current = a, this.gl.uniform1f(this.location, a))
                }
            }

            class ta extends bs {
                constructor(e) {
                    super(e), this.current = [0, 0]
                }

                set(e, i, a) {
                    this.fetchUniformLocation(e, i) && (a[0] === this.current[0] && a[1] === this.current[1] || (this.current = a, this.gl.uniform2f(this.location, a[0], a[1])))
                }
            }

            class Xc extends bs {
                constructor(e) {
                    super(e), this.current = [0, 0, 0]
                }

                set(e, i, a) {
                    this.fetchUniformLocation(e, i) && (a[0] === this.current[0] && a[1] === this.current[1] && a[2] === this.current[2] || (this.current = a, this.gl.uniform3f(this.location, a[0], a[1], a[2])))
                }
            }

            class Ph extends bs {
                constructor(e) {
                    super(e), this.current = [0, 0, 0, 0]
                }

                set(e, i, a) {
                    this.fetchUniformLocation(e, i) && (a[0] === this.current[0] && a[1] === this.current[1] && a[2] === this.current[2] && a[3] === this.current[3] || (this.current = a, this.gl.uniform4f(this.location, a[0], a[1], a[2], a[3])))
                }
            }

            class jm extends bs {
                constructor(e) {
                    super(e), this.current = Ji.transparent.toPremultipliedRenderColor(null)
                }

                set(e, i, a) {
                    this.fetchUniformLocation(e, i) && (a.r === this.current.r && a.g === this.current.g && a.b === this.current.b && a.a === this.current.a || (this.current = a, this.gl.uniform4f(this.location, a.r, a.g, a.b, a.a)))
                }
            }

            const ky = new Float32Array(16);

            class Mh extends bs {
                constructor(e) {
                    super(e), this.current = ky
                }

                set(e, i, a) {
                    if (this.fetchUniformLocation(e, i)) {
                        if (a[12] !== this.current[12] || a[0] !== this.current[0]) return this.current = a, void this.gl.uniformMatrix4fv(this.location, !1, a);
                        for (let c = 1; c < 16; c++) if (a[c] !== this.current[c]) {
                            this.current = a, this.gl.uniformMatrix4fv(this.location, !1, a);
                            break
                        }
                    }
                }
            }

            const p1 = new Float32Array(9), Oy = new Float32Array(4);

            class Vm extends bs {
                constructor(e) {
                    super(e), this.current = Oy
                }

                set(e, i, a) {
                    if (this.fetchUniformLocation(e, i)) {
                        for (let c = 0; c < 4; c++) if (a[c] !== this.current[c]) {
                            this.current = a, this.gl.uniformMatrix2fv(this.location, !1, a);
                            break
                        }
                    }
                }
            }

            function Um(n) {
                return [Ly(255 * n.r, 255 * n.g), Ly(255 * n.b, 255 * n.a)]
            }

            class Rh {
                constructor(e, i, a, c) {
                    this.value = e, this.uniformNames = i.map(d => `u_${d}`), this.type = a, this.context = c
                }

                setUniform(e, i, a, c, d) {
                    const f = c.constantOr(this.value);
                    i.set(e, d, f instanceof Ji ? f.toPremultipliedRenderColor(this.lutExpression && this.lutExpression.value === "none" ? null : this.context.lut) : f)
                }

                getBinding(e, i) {
                    return this.type === "color" ? new jm(e) : new tr(e)
                }
            }

            class Yc {
                constructor(e, i) {
                    this.uniformNames = i.map(a => `u_${a}`), this.pattern = null, this.patternTransition = null, this.pixelRatio = 1
                }

                setConstantPatternPositions(e, i) {
                    this.pixelRatio = e.pixelRatio || 1, this.pattern = e.tl.concat(e.br), this.patternTransition = i ? i.tl.concat(i.br) : this.pattern
                }

                setUniform(e, i, a, c, d) {
                    let f = null;
                    d !== "u_pattern" && d !== "u_dash" || (f = this.pattern), d === "u_pattern_b" && (f = this.patternTransition), d === "u_pixel_ratio" && (f = this.pixelRatio), f && i.set(e, d, f)
                }

                getBinding(e, i) {
                    return i === "u_pattern" || i === "u_pattern_b" || i === "u_dash" ? new Ph(e) : new tr(e)
                }
            }

            class wa {
                constructor(e, i, a, c) {
                    this.expression = e, this.type = a, this.maxValue = 0, this.paintVertexAttributes = i.map(d => ({
                        name: `a_${d}`,
                        type: "Float32",
                        components: a === "color" ? 2 : 1,
                        offset: 0
                    })), this.paintVertexArray = new c
                }

                populatePaintArray(e, i, a, c, d, f, _, x) {
                    const w = this.paintVertexArray.length,
                        E = this.expression.kind === "composite" || this.expression.kind === "source" ? this.expression.evaluate(new sn(0, {
                            brightness: f,
                            worldview: x
                        }), i, {}, d, c, _) : this.expression.kind === "constant" && this.expression.value,
                        I = !!this.lutExpression && (this.lutExpression.kind === "composite" || this.lutExpression.kind === "source" ? this.lutExpression.evaluate(new sn(0, {
                            brightness: f,
                            worldview: x
                        }), i, {}, d, c, _) : this.lutExpression.value) === "none";
                    this.paintVertexArray.resize(e), this._setPaintValue(w, e, E, I ? null : this.context.lut)
                }

                updatePaintArray(e, i, a, c, d, f, _, x) {
                    const w = this.expression.kind === "composite" || this.expression.kind === "source" ? this.expression.evaluate({
                            zoom: 0,
                            brightness: _,
                            worldview: x
                        }, a, c, void 0, d) : this.expression.kind === "constant" && this.expression.value,
                        E = !!this.lutExpression && (this.lutExpression.kind === "composite" || this.lutExpression.kind === "source" ? this.lutExpression.evaluate(new sn(0, {
                            brightness: _,
                            worldview: x
                        }), a, c, void 0, d) : this.lutExpression.value) === "none";
                    this._setPaintValue(e, i, w, E ? null : this.context.lut)
                }

                _setPaintValue(e, i, a, c) {
                    if (this.type === "color") {
                        const d = Um(a.toPremultipliedRenderColor(c));
                        for (let f = e; f < i; f++) this.paintVertexArray.emplace(f, d[0], d[1])
                    } else {
                        for (let d = e; d < i; d++) this.paintVertexArray.emplace(d, a);
                        this.maxValue = Math.max(this.maxValue, Math.abs(a))
                    }
                }

                upload(e) {
                    this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.lutExpression && this.lutExpression.kind !== "constant" && (this.lutExpression.isStateDependent || !this.lutExpression.isLightConstant) || this.expression.kind !== "constant" && (this.expression.isStateDependent || !this.expression.isLightConstant)))
                }

                destroy() {
                    this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                }
            }

            class Ts {
                constructor(e, i, a, c, d, f) {
                    this.expression = e, this.uniformNames = i.map(_ => `u_${_}_t`), this.type = a, this.useIntegerZoom = c, this.context = d, this.maxValue = 0, this.paintVertexAttributes = i.map(_ => ({
                        name: `a_${_}`,
                        type: "Float32",
                        components: a === "color" ? 4 : 2,
                        offset: 0
                    })), this.paintVertexArray = new f
                }

                populatePaintArray(e, i, a, c, d, f, _, x) {
                    const w = this.expression.evaluate(new sn(this.context.zoom, {
                            brightness: f,
                            worldview: x
                        }), i, {}, d, c, _), E = this.expression.evaluate(new sn(this.context.zoom + 1, {
                            brightness: f,
                            worldview: x
                        }), i, {}, d, c, _),
                        I = !!this.lutExpression && (this.lutExpression.kind === "composite" || this.lutExpression.kind === "source" ? this.lutExpression.evaluate(new sn(0, {
                            brightness: f,
                            worldview: x
                        }), i, {}, d, c, _) : this.lutExpression.value) === "none", C = this.paintVertexArray.length;
                    this.paintVertexArray.resize(e), this._setPaintValue(C, e, w, E, I ? null : this.context.lut)
                }

                updatePaintArray(e, i, a, c, d, f, _, x) {
                    const w = this.expression.evaluate({
                            zoom: this.context.zoom,
                            brightness: _,
                            worldview: x
                        }, a, c, void 0, d), E = this.expression.evaluate({
                            zoom: this.context.zoom + 1,
                            brightness: _,
                            worldview: x
                        }, a, c, void 0, d),
                        I = !!this.lutExpression && (this.lutExpression.kind === "composite" || this.lutExpression.kind === "source" ? this.lutExpression.evaluate(new sn(0, {
                            brightness: _,
                            worldview: x
                        }), a, c, void 0, d) : this.lutExpression.value) === "none";
                    this._setPaintValue(e, i, w, E, I ? null : this.context.lut)
                }

                _setPaintValue(e, i, a, c, d) {
                    if (this.type === "color") {
                        const f = Um(a.toPremultipliedRenderColor(d)), _ = Um(a.toPremultipliedRenderColor(d));
                        for (let x = e; x < i; x++) this.paintVertexArray.emplace(x, f[0], f[1], _[0], _[1])
                    } else {
                        for (let f = e; f < i; f++) this.paintVertexArray.emplace(f, a, c);
                        this.maxValue = Math.max(this.maxValue, Math.abs(a), Math.abs(c))
                    }
                }

                upload(e) {
                    this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant))
                }

                destroy() {
                    this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                }

                setUniform(e, i, a, c, d) {
                    const f = this.useIntegerZoom ? Math.floor(a.zoom) : a.zoom,
                        _ = se(this.expression.interpolationFactor(f, this.context.zoom, this.context.zoom + 1), 0, 1);
                    i.set(e, d, _)
                }

                getBinding(e, i) {
                    return new tr(e)
                }
            }

            class Jo {
                constructor(e, i, a, c, d) {
                    this.expression = e, this.layerId = d, this.paintVertexAttributes = (a === "array" ? f1 : d1).members;
                    for (let f = 0; f < i.length; ++f) ;
                    this.paintVertexArray = new c, this.paintTransitionVertexArray = new Gc
                }

                populatePaintArray(e, i, a, c) {
                    const d = this.paintVertexArray.length;
                    this.paintVertexArray.resize(e), this._setPaintValues(d, e, i.patterns && i.patterns[this.layerId], a)
                }

                updatePaintArray(e, i, a, c, d, f, _) {
                    this._setPaintValues(e, i, a.patterns && a.patterns[this.layerId], f)
                }

                _setPaintValues(e, i, a, c) {
                    if (!c || !a) return;
                    const d = c[a[0]], f = c[a[1]];
                    if (d) {
                        if (d) {
                            const {tl: _, br: x, pixelRatio: w} = d;
                            for (let E = e; E < i; E++) this.paintVertexArray.emplace(E, _[0], _[1], x[0], x[1], w)
                        }
                        if (f) {
                            this.paintTransitionVertexArray.resize(this.paintVertexArray.length);
                            const {tl: _, br: x} = f;
                            for (let w = e; w < i; w++) this.paintTransitionVertexArray.emplace(w, _[0], _[1], x[0], x[1])
                        }
                    }
                }

                upload(e) {
                    const i = this.expression.isStateDependent || !this.expression.isLightConstant;
                    this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, i)), this.paintTransitionVertexArray && this.paintTransitionVertexArray.length && (this.paintTransitionVertexBuffer = e.createVertexBuffer(this.paintTransitionVertexArray, Bm.members, i))
                }

                destroy() {
                    this.paintVertexBuffer && this.paintVertexBuffer.destroy(), this.paintTransitionVertexBuffer && this.paintTransitionVertexBuffer.destroy()
                }
            }

            class go {
                constructor(e, i, a = () => !0) {
                    this.binders = {}, this._buffers = [], this.context = i;
                    const c = [];
                    for (const d in e.paint._values) {
                        const f = e.paint.get(d);
                        if (d.endsWith("-use-theme") || !a(d) || !(f instanceof Wl && Ud(f.property.specification))) continue;
                        const _ = g1(d, e.type), x = f.value, w = f.property.specification.type,
                            E = !!f.property.useIntegerZoom, I = d === "line-dasharray" || d.endsWith("pattern"),
                            C = e.paint.get(`${d}-use-theme`),
                            z = d === "line-dasharray" && e.layout.get("line-cap").value.kind !== "constant" || C && C.value.kind !== "constant";
                        if (x.kind !== "constant" || z) if (x.kind === "source" || z || I) {
                            const L = Fy(d, w, "source");
                            this.binders[d] = I ? new Jo(x, _, w, L, e.id) : new wa(x, _, w, L), c.push(`/a_${d}`)
                        } else {
                            const L = Fy(d, w, "composite");
                            this.binders[d] = new Ts(x, _, w, E, i, L), c.push(`/z_${d}`)
                        } else this.binders[d] = I ? new Yc(x.value, _) : new Rh(x.value, _, w, i), c.push(`/u_${d}`);
                        C && (this.binders[d].lutExpression = C.value)
                    }
                    this.cacheKey = c.sort().join("")
                }

                getMaxValue(e) {
                    const i = this.binders[e];
                    return i instanceof wa || i instanceof Ts ? i.maxValue : 0
                }

                populatePaintArrays(e, i, a, c, d, f, _, x) {
                    for (const w in this.binders) {
                        const E = this.binders[w];
                        E.context = this.context, (E instanceof wa || E instanceof Ts || E instanceof Jo) && E.populatePaintArray(e, i, a, c, d, f, _, x)
                    }
                }

                setConstantPatternPositions(e, i) {
                    for (const a in this.binders) {
                        const c = this.binders[a];
                        c instanceof Yc && c.setConstantPatternPositions(e, i)
                    }
                }

                getPatternTransitionVertexBuffer(e) {
                    const i = this.binders[e];
                    return i instanceof Jo ? i.paintTransitionVertexBuffer : null
                }

                updatePaintArrays(e, i, a, c, d, f, _, x, w, E) {
                    let I = !1;
                    const C = Object.keys(e), z = C.length !== 0 && !x, L = z ? C : i.uniqueIds;
                    this.context.lut = d.lut;
                    for (const F in this.binders) {
                        const N = this.binders[F];
                        if (N.context = this.context, (N instanceof wa || N instanceof Ts || N instanceof Jo) && N.expression && N.expression.kind && N.expression.kind !== "constant" && (N.expression.isStateDependent === !0 || N.expression.isLightConstant === !1)) {
                            const H = d.paint.get(F);
                            N.expression = H.value;
                            for (const Y of L) {
                                const X = e[Y.toString()];
                                i.eachPosition(Y, (J, xe, ge) => {
                                    const ye = c.feature(J);
                                    N.updatePaintArray(xe, ge, ye, X, f, _, w, E)
                                })
                            }
                            if (!z) for (const Y of a.uniqueIds) {
                                const X = e[Y.toString()];
                                a.eachPosition(Y, (J, xe, ge) => {
                                    const ye = c.feature(J);
                                    N.updatePaintArray(xe, ge, ye, X, f, _, w, E)
                                })
                            }
                            I = !0
                        }
                    }
                    return I
                }

                defines() {
                    const e = [];
                    for (const i in this.binders) {
                        const a = this.binders[i];
                        (a instanceof Rh || a instanceof Yc) && e.push(...a.uniformNames.map(c => `#define HAS_UNIFORM_${c}`))
                    }
                    return e
                }

                getBinderAttributes() {
                    const e = [];
                    for (const i in this.binders) {
                        const a = this.binders[i];
                        if (a instanceof wa || a instanceof Ts || a instanceof Jo) for (let c = 0; c < a.paintVertexAttributes.length; c++) e.push(a.paintVertexAttributes[c].name);
                        if (a instanceof Jo) for (let c = 0; c < Bm.members.length; c++) e.push(Bm.members[c].name)
                    }
                    return e
                }

                getBinderUniforms() {
                    const e = [];
                    for (const i in this.binders) {
                        const a = this.binders[i];
                        if (a instanceof Rh || a instanceof Yc || a instanceof Ts) for (const c of a.uniformNames) e.push(c)
                    }
                    return e
                }

                getPaintVertexBuffers() {
                    return this._buffers
                }

                getUniforms(e) {
                    const i = [];
                    for (const a in this.binders) {
                        const c = this.binders[a];
                        if (c instanceof Rh || c instanceof Yc || c instanceof Ts) for (const d of c.uniformNames) i.push({
                            name: d,
                            property: a,
                            binding: c.getBinding(e, d)
                        })
                    }
                    return i
                }

                setUniforms(e, i, a, c, d) {
                    for (const {name: f, property: _, binding: x} of a) this.binders[_].setUniform(e, x, d, c.get(_), f)
                }

                updatePaintBuffers() {
                    this._buffers = [];
                    for (const e in this.binders) {
                        const i = this.binders[e];
                        (i instanceof wa || i instanceof Ts || i instanceof Jo) && i.paintVertexBuffer && this._buffers.push(i.paintVertexBuffer), i instanceof Jo && i.paintTransitionVertexBuffer && this._buffers.push(i.paintTransitionVertexBuffer)
                    }
                }

                upload(e) {
                    for (const i in this.binders) {
                        const a = this.binders[i];
                        (a instanceof wa || a instanceof Ts || a instanceof Jo) && a.upload(e)
                    }
                    this.updatePaintBuffers()
                }

                destroy() {
                    for (const e in this.binders) {
                        const i = this.binders[e];
                        (i instanceof wa || i instanceof Ts || i instanceof Jo) && i.destroy()
                    }
                }
            }

            class es {
                constructor(e, i, a = () => !0) {
                    this.programConfigurations = {};
                    for (const c of e) this.programConfigurations[c.id] = new go(c, i, a);
                    this.needsUpload = !1, this._featureMap = new Ih, this._featureMapWithoutIds = new Ih, this._bufferOffset = 0, this._idlessCounter = 0
                }

                populatePaintArrays(e, i, a, c, d, f, _, x, w) {
                    for (const E in this.programConfigurations) this.programConfigurations[E].populatePaintArrays(e, i, c, d, f, _, x, w);
                    i.id !== void 0 ? this._featureMap.add(i.id, a, this._bufferOffset, e) : (this._featureMapWithoutIds.add(this._idlessCounter, a, this._bufferOffset, e), this._idlessCounter += 1), this._bufferOffset = e, this.needsUpload = !0
                }

                updatePaintArrays(e, i, a, c, d, f, _, x) {
                    for (const w of a) this.needsUpload = this.programConfigurations[w.id].updatePaintArrays(e, this._featureMap, this._featureMapWithoutIds, i, w, c, d, f, _ || 0, x) || this.needsUpload
                }

                get(e) {
                    return this.programConfigurations[e]
                }

                upload(e) {
                    if (this.needsUpload) {
                        for (const i in this.programConfigurations) this.programConfigurations[i].upload(e);
                        this.needsUpload = !1
                    }
                }

                destroy() {
                    for (const e in this.programConfigurations) this.programConfigurations[e].destroy()
                }
            }

            const m1 = {
                "text-opacity": ["opacity"],
                "icon-opacity": ["opacity"],
                "text-occlusion-opacity": ["occlusion_opacity"],
                "icon-occlusion-opacity": ["occlusion_opacity"],
                "text-color": ["fill_color"],
                "icon-color": ["fill_color"],
                "text-emissive-strength": ["emissive_strength"],
                "icon-emissive-strength": ["emissive_strength"],
                "text-halo-color": ["halo_color"],
                "icon-halo-color": ["halo_color"],
                "text-halo-blur": ["halo_blur"],
                "icon-halo-blur": ["halo_blur"],
                "text-halo-width": ["halo_width"],
                "icon-halo-width": ["halo_width"],
                "symbol-z-offset": ["z_offset"],
                "line-gap-width": ["gapwidth"],
                "line-pattern": ["pattern", "pixel_ratio", "pattern_b"],
                "fill-pattern": ["pattern", "pixel_ratio", "pattern_b"],
                "fill-extrusion-pattern": ["pattern", "pixel_ratio", "pattern_b"],
                "line-dasharray": ["dash"],
                "fill-bridge-guard-rail-color": ["structure_color"],
                "fill-tunnel-structure-color": ["structure_color"]
            };

            function g1(n, e) {
                return m1[n] || [n.replace(`${e}-`, "").replace(/-/g, "_")]
            }

            const _1 = {
                "line-pattern": {source: cl, composite: cl},
                "fill-pattern": {source: cl, composite: cl},
                "fill-extrusion-pattern": {source: cl, composite: cl},
                "line-dasharray": {source: Gc, composite: Gc}
            }, y1 = {color: {source: hl, composite: ul}, number: {source: Zl, composite: hl}};

            function Fy(n, e, i) {
                const a = _1[n];
                return a && a[i] || y1[e][i]
            }

            Pt(Rh, "ConstantBinder"), Pt(Yc, "PatternConstantBinder"), Pt(wa, "SourceExpressionBinder"), Pt(Jo, "PatternCompositeBinder"), Pt(Ts, "CompositeExpressionBinder"), Pt(go, "ProgramConfiguration", {omit: ["_buffers"]}), Pt(es, "ProgramConfigurationSet");
            const io = yt / Math.PI / 2, By = 5, u = 6, t = 16383, s = 64, h = [s, 32, 16], m = -io, g = io;

            function v(n, e, i, a = io) {
                return i = Ai(i), [n * Math.sin(i) * a, -e * a, n * Math.cos(i) * a]
            }

            function b(n, e, i) {
                return v(Math.cos(Ai(n)), Math.sin(Ai(n)), e, i)
            }

            const S = 63710088e-1, P = 2 * Math.PI * S;

            class M {
                constructor(e, i) {
                    if (isNaN(e) || isNaN(i)) throw new Error(`Invalid LngLat object: (${e}, ${i})`);
                    if (this.lng = +e, this.lat = +i, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
                }

                wrap() {
                    return new M(Ve(this.lng, -180, 180), this.lat)
                }

                toArray() {
                    return [this.lng, this.lat]
                }

                toString() {
                    return `LngLat(${this.lng}, ${this.lat})`
                }

                distanceTo(e) {
                    const i = Math.PI / 180, a = this.lat * i, c = e.lat * i,
                        d = Math.sin(a) * Math.sin(c) + Math.cos(a) * Math.cos(c) * Math.cos((e.lng - this.lng) * i);
                    return S * Math.acos(Math.min(d, 1))
                }

                toBounds(e = 0) {
                    const i = 360 * e / 40075017, a = i / Math.cos(Math.PI / 180 * this.lat);
                    return new k({lng: this.lng - a, lat: this.lat - i}, {lng: this.lng + a, lat: this.lat + i})
                }

                toEcef(e) {
                    return b(this.lat, this.lng, io + e * io / S)
                }

                static convert(e) {
                    if (e instanceof M) return e;
                    if (Array.isArray(e) && (e.length === 2 || e.length === 3)) return new M(Number(e[0]), Number(e[1]));
                    if (!Array.isArray(e) && typeof e == "object" && e !== null) return new M(Number("lng" in e ? e.lng : e.lon), Number(e.lat));
                    throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
                }
            }

            class k {
                constructor(e, i) {
                    if (e) if (i) this.setSouthWest(e).setNorthEast(i); else if (e.length === 4) {
                        const a = e;
                        this.setSouthWest([a[0], a[1]]).setNorthEast([a[2], a[3]])
                    } else {
                        const a = e;
                        this.setSouthWest(a[0]).setNorthEast(a[1])
                    }
                }

                setNorthEast(e) {
                    return this._ne = e instanceof M ? new M(e.lng, e.lat) : M.convert(e), this
                }

                setSouthWest(e) {
                    return this._sw = e instanceof M ? new M(e.lng, e.lat) : M.convert(e), this
                }

                extend(e) {
                    const i = this._sw, a = this._ne;
                    let c, d;
                    if (e instanceof M) c = e, d = e; else {
                        if (!(e instanceof k)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(k.convert(e)) : this.extend(M.convert(e)) : typeof e == "object" && e !== null && e.hasOwnProperty("lat") && (e.hasOwnProperty("lon") || e.hasOwnProperty("lng")) ? this.extend(M.convert(e)) : this;
                        if (c = e._sw, d = e._ne, !c || !d) return this
                    }
                    return i || a ? (i.lng = Math.min(c.lng, i.lng), i.lat = Math.min(c.lat, i.lat), a.lng = Math.max(d.lng, a.lng), a.lat = Math.max(d.lat, a.lat)) : (this._sw = new M(c.lng, c.lat), this._ne = new M(d.lng, d.lat)), this
                }

                getCenter() {
                    return new M((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2)
                }

                getSouthWest() {
                    return this._sw
                }

                getNorthEast() {
                    return this._ne
                }

                getNorthWest() {
                    return new M(this.getWest(), this.getNorth())
                }

                getSouthEast() {
                    return new M(this.getEast(), this.getSouth())
                }

                getWest() {
                    return this._sw.lng
                }

                getSouth() {
                    return this._sw.lat
                }

                getEast() {
                    return this._ne.lng
                }

                getNorth() {
                    return this._ne.lat
                }

                toArray() {
                    return [this._sw.toArray(), this._ne.toArray()]
                }

                toString() {
                    return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
                }

                isEmpty() {
                    return !(this._sw && this._ne)
                }

                contains(e) {
                    const {lng: i, lat: a} = M.convert(e);
                    let c = this._sw.lng <= i && i <= this._ne.lng;
                    return this._sw.lng > this._ne.lng && (c = this._sw.lng >= i && i >= this._ne.lng), this._sw.lat <= a && a <= this._ne.lat && c
                }

                static convert(e) {
                    if (e) return e instanceof k ? e : new k(e)
                }
            }

            const R = 0, O = 25.5;

            function V(n) {
                return P * Math.cos(n * Math.PI / 180)
            }

            function B(n) {
                return (180 + n) / 360
            }

            function G(n) {
                return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + n * Math.PI / 360))) / 360
            }

            function U(n, e) {
                return n / V(e)
            }

            function Z(n) {
                return 360 * n - 180
            }

            function Q(n) {
                return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n) * Math.PI / 180)) - 90
            }

            function te(n, e) {
                return n * V(Q(e))
            }

            const ce = 85.051129;

            function _e(n) {
                return Math.cos(Ai(se(n, -ce, ce)))
            }

            function ve(n, e) {
                const i = se(e, R, O), a = Math.pow(2, i);
                return _e(n) * P / (512 * a)
            }

            function ue(n) {
                return 1 / Math.cos(n * Math.PI / 180)
            }

            function he(n, e = 0) {
                const i = Math.exp(Math.PI * (1 - (n.y + e / yt) / (1 << n.z) * 2));
                return 80150034 * i / (i * i + 1) / yt / (1 << n.z)
            }

            class me {
                constructor(e, i, a = 0) {
                    this.x = +e, this.y = +i, this.z = +a
                }

                static fromLngLat(e, i = 0) {
                    const a = M.convert(e);
                    return new me(B(a.lng), G(a.lat), U(i, a.lat))
                }

                toLngLat() {
                    return new M(Z(this.x), Q(this.y))
                }

                toAltitude() {
                    return te(this.z, this.y)
                }

                meterInMercatorCoordinateUnits() {
                    return 1 / P * ue(Q(this.y))
                }
            }

            function Oe(n, e, i, a, c, d, f, _, x) {
                const w = (e + a) / 2, E = (i + c) / 2, I = new Ze(w, E);
                _(I), function (C, z, L, F, N, H) {
                    const Y = L - N, X = F - H;
                    return Math.abs((F - z) * Y - (L - C) * X) / Math.hypot(Y, X)
                }(I.x, I.y, d.x, d.y, f.x, f.y) >= x ? (Oe(n, e, i, w, E, d, I, _, x), Oe(n, w, E, a, c, I, f, _, x)) : n.push(f)
            }

            function Se(n, e, i) {
                let a = n[0], c = a.x, d = a.y;
                e(a);
                const f = [a];
                for (let _ = 1; _ < n.length; _++) {
                    const x = n[_], {x: w, y: E} = x;
                    e(x), Oe(f, c, d, w, E, a, x, e, i), c = w, d = E, a = x
                }
                return f
            }

            function Xe(n, e, i, a) {
                if (a(e, i)) {
                    const c = e.add(i)._mult(.5);
                    Xe(n, e, c, a), Xe(n, c, i, a)
                } else n.push(i)
            }

            function je(n, e) {
                let i = n[0];
                const a = [i];
                for (let c = 1; c < n.length; c++) {
                    const d = n[c];
                    Xe(a, i, d, e), i = d
                }
                return a
            }

            const Ke = Math.pow(2, 14) - 1, ut = -Ke - 1;

            function Fe(n, e) {
                const i = Math.round(n.x * e), a = Math.round(n.y * e);
                return n.x = se(i, ut, Ke), n.y = se(a, ut, Ke), (i < n.x || i > n.x + 1 || a < n.y || a > n.y + 1) && Li("Geometry exceeds allowed extent, reduce your vector tile buffer size"), n
            }

            function Te(n, e, i) {
                const a = n.loadGeometry(), c = n.extent, d = yt / c;
                if (e && i && i.projection.isReprojectedInTileSpace) {
                    const f = 1 << e.z, {scale: _, x, y: w, projection: E} = i, I = C => {
                        const z = Z((e.x + C.x / c) / f), L = Q((e.y + C.y / c) / f), F = E.project(z, L);
                        C.x = (F.x * _ - x) * c, C.y = (F.y * _ - w) * c
                    };
                    for (let C = 0; C < a.length; C++) if (n.type !== 1) a[C] = Se(a[C], I, 1); else {
                        const z = [];
                        for (const L of a[C]) L.x < 0 || L.x >= c || L.y < 0 || L.y >= c || (I(L), z.push(L));
                        a[C] = z
                    }
                }
                for (const f of a) for (const _ of f) Fe(_, d);
                return a
            }

            function $e(n, e) {
                return {type: n.type, id: n.id, properties: n.properties, geometry: e ? Te(n) : []}
            }

            class Be {
                constructor(e, i, a, c, d) {
                    this.properties = {}, this.extent = a, this.type = 0, this.id = void 0, this._pbf = e, this._geometry = -1, this._keys = c, this._values = d, e.readFields(tt, this, i)
                }

                loadGeometry() {
                    const e = this._pbf;
                    e.pos = this._geometry;
                    const i = e.readVarint() + e.pos, a = [];
                    let c, d = 1, f = 0, _ = 0, x = 0;
                    for (; e.pos < i;) {
                        if (f <= 0) {
                            const w = e.readVarint();
                            d = 7 & w, f = w >> 3
                        }
                        if (f--, d === 1 || d === 2) _ += e.readSVarint(), x += e.readSVarint(), d === 1 && (c && a.push(c), c = []), c && c.push(new Ze(_, x)); else {
                            if (d !== 7) throw new Error(`unknown command ${d}`);
                            c && c.push(c[0].clone())
                        }
                    }
                    return c && a.push(c), a
                }

                bbox() {
                    const e = this._pbf;
                    e.pos = this._geometry;
                    const i = e.readVarint() + e.pos;
                    let a = 1, c = 0, d = 0, f = 0, _ = 1 / 0, x = -1 / 0, w = 1 / 0, E = -1 / 0;
                    for (; e.pos < i;) {
                        if (c <= 0) {
                            const I = e.readVarint();
                            a = 7 & I, c = I >> 3
                        }
                        if (c--, a === 1 || a === 2) d += e.readSVarint(), f += e.readSVarint(), d < _ && (_ = d), d > x && (x = d), f < w && (w = f), f > E && (E = f); else if (a !== 7) throw new Error(`unknown command ${a}`)
                    }
                    return [_, w, x, E]
                }

                toGeoJSON(e, i, a) {
                    const c = this.extent * Math.pow(2, a), d = this.extent * e, f = this.extent * i,
                        _ = this.loadGeometry();

                    function x(C) {
                        return [360 * (C.x + d) / c - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (C.y + f) / c) * Math.PI)) - 90]
                    }

                    function w(C) {
                        return C.map(x)
                    }

                    let E;
                    if (this.type === 1) {
                        const C = [];
                        for (const L of _) C.push(L[0]);
                        const z = w(C);
                        E = C.length === 1 ? {type: "Point", coordinates: z[0]} : {type: "MultiPoint", coordinates: z}
                    } else if (this.type === 2) {
                        const C = _.map(w);
                        E = C.length === 1 ? {type: "LineString", coordinates: C[0]} : {
                            type: "MultiLineString",
                            coordinates: C
                        }
                    } else {
                        if (this.type !== 3) throw new Error("unknown feature type");
                        {
                            const C = function (L) {
                                const F = L.length;
                                if (F <= 1) return [L];
                                const N = [];
                                let H, Y;
                                for (let X = 0; X < F; X++) {
                                    const J = it(L[X]);
                                    J !== 0 && (Y === void 0 && (Y = J < 0), Y === J < 0 ? (H && N.push(H), H = [L[X]]) : H && H.push(L[X]))
                                }
                                return H && N.push(H), N
                            }(_), z = [];
                            for (const L of C) z.push(L.map(w));
                            E = z.length === 1 ? {type: "Polygon", coordinates: z[0]} : {
                                type: "MultiPolygon",
                                coordinates: z
                            }
                        }
                    }
                    const I = {type: "Feature", geometry: E, properties: this.properties};
                    return this.id != null && (I.id = this.id), I
                }
            }

            function tt(n, e, i) {
                n === 1 ? e.id = i.readVarint() : n === 2 ? function (a, c) {
                    const d = a.readVarint() + a.pos;
                    for (; a.pos < d;) {
                        const f = c._keys[a.readVarint()], _ = c._values[a.readVarint()];
                        c.properties[f] = _
                    }
                }(i, e) : n === 3 ? e.type = i.readVarint() : n === 4 && (e._geometry = i.pos)
            }

            function it(n) {
                let e = 0;
                for (let i, a, c = 0, d = n.length, f = d - 1; c < d; f = c++) i = n[c], a = n[f], e += (a.x - i.x) * (i.y + a.y);
                return e
            }

            Be.types = ["Unknown", "Point", "LineString", "Polygon"];

            class rt {
                constructor(e, i) {
                    this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = e, this._keys = [], this._values = [], this._features = [], e.readFields(gt, this, i), this.length = this._features.length
                }

                feature(e) {
                    if (e < 0 || e >= this._features.length) throw new Error("feature index out of bounds");
                    this._pbf.pos = this._features[e];
                    const i = this._pbf.readVarint() + this._pbf.pos;
                    return new Be(this._pbf, i, this.extent, this._keys, this._values)
                }
            }

            function gt(n, e, i) {
                n === 15 ? e.version = i.readVarint() : n === 1 ? e.name = i.readString() : n === 5 ? e.extent = i.readVarint() : n === 2 ? e._features.push(i.pos) : n === 3 ? e._keys.push(i.readString()) : n === 4 && e._values.push(function (a) {
                    let c = null;
                    const d = a.readVarint() + a.pos;
                    for (; a.pos < d;) {
                        const f = a.readVarint() >> 3;
                        c = f === 1 ? a.readString() : f === 2 ? a.readFloat() : f === 3 ? a.readDouble() : f === 4 ? a.readVarint64() : f === 5 ? a.readVarint() : f === 6 ? a.readSVarint() : f === 7 ? a.readBoolean() : null
                    }
                    if (c == null) throw new Error("unknown feature value");
                    return c
                }(i))
            }

            class Ot {
                constructor(e, i) {
                    this.layers = e.readFields(Ut, {}, i)
                }
            }

            function Ut(n, e, i) {
                if (n === 3) {
                    const a = new rt(i, i.readVarint() + i.pos);
                    a.length && (e[a.name] = a)
                }
            }

            const St = "3d_elevation_id", Nt = "level";

            class Ft {
                constructor() {
                    this._valid = !1
                }

                reset(e) {
                    return this.feature = e, this._valid = !0, this._geometry = e.loadGeometry(), this._geometry.length !== 0 && this._geometry[0].length !== 0 || (this._valid = !1), this
                }

                geometry(e, i) {
                    return this._valid && e(i(this._geometry)), this
                }

                require(e, i, a) {
                    return this.get(e, !0, i, a)
                }

                optional(e, i, a) {
                    return this.get(e, !1, i, a)
                }

                success() {
                    return this._valid
                }

                get(e, i, a, c) {
                    const d = this.feature.properties.hasOwnProperty(e) ? +this.feature.properties[e] : void 0;
                    return this._valid && d !== void 0 && !Number.isNaN(d) ? a(c ? c(d) : d) : i && (this._valid = !1), this
                }
            }

            class ri {
                constructor(e, i) {
                    this.featureFunc = e, this.vertexFunc = i
                }

                parseFeature(e, i, a) {
                    return this.featureFunc(e, i, a)
                }

                parseVertex(e, i, a) {
                    return this.vertexFunc(e, i, a)
                }
            }

            const di = new ri((n, e, i) => n.reset(e).require(St, a => {
                i.id = a
            }).optional("fixed_height_relative", a => {
                i.constantHeight = a
            }, Ui.decodeRelativeHeight).geometry(a => {
                i.bounds = a
            }, Fp).success(), (n, e, i) => n.reset(e).require(St, a => {
                i.id = a
            }).require("elevation_idx", a => {
                i.idx = a
            }).require("extent", a => {
                i.extent = a
            }).require("height_relative", a => {
                i.height = a
            }, Ui.decodeRelativeHeight).geometry(a => {
                i.position = a
            }, Ui.getPoint).success()), Si = new ri((n, e, i) => n.reset(e).require(St, a => {
                i.id = a
            }).optional("fixed_height", a => {
                i.constantHeight = a
            }, Ui.decodeMetricHeight).geometry(a => {
                i.bounds = a
            }, Fp).success(), (n, e, i) => n.reset(e).require(St, a => {
                i.id = a
            }).require("elevation_idx", a => {
                i.idx = a
            }).require("extent", a => {
                i.extent = a
            }).require("height", a => {
                i.height = a
            }, Ui.decodeMetricHeight).geometry(a => {
                i.position = a
            }, Ui.getPoint).success());

            class Ui {
                static getPoint(e) {
                    return uo(e[0][0].x, e[0][0].y)
                }

                static decodeRelativeHeight(e) {
                    return 1e-4 * e * 5
                }

                static decodeMetricHeight(e) {
                    return 1e-4 * e
                }

                static parse(e) {
                    const i = [], a = [], c = e.length, d = new Ft;
                    for (let _ = 0; _ < c; _++) {
                        const x = e.feature(_), w = x.properties.version,
                            E = (f = w) ? f === "1.0.1" ? Si : void 0 : di;
                        if (E === void 0) {
                            Li(`Unknown elevation feature version number ${w || "(unknown)"}`);
                            continue
                        }
                        const I = x.properties.hasOwnProperty("type") ? x.properties.type : void 0;
                        if (I) {
                            if (Be.types[x.type] === "Point" && I === "curve_point") {
                                const C = {};
                                E.parseVertex(d, x, C) && i.push(C)
                            } else if (Be.types[x.type] === "Polygon" && I === "curve_meta") {
                                const C = {};
                                E.parseFeature(d, x, C) && a.push(C)
                            }
                        }
                    }
                    var f;
                    return {vertices: i, features: a}
                }
            }

            class ci {
                constructor(e, i) {
                    this.pos = e, this.dir = i
                }

                intersectsPlane(e, i, a) {
                    const c = bn(i, this.dir);
                    if (Math.abs(c) < 1e-6) return !1;
                    const d = ((e[0] - this.pos[0]) * i[0] + (e[1] - this.pos[1]) * i[1]) / c;
                    return a[0] = this.pos[0] + this.dir[0] * d, a[1] = this.pos[1] + this.dir[1] * d, !0
                }
            }

            class Gi {
                constructor(e, i) {
                    this.pos = e, this.dir = i
                }

                intersectsPlane(e, i, a) {
                    const c = Ii(i, this.dir);
                    if (Math.abs(c) < 1e-6) return !1;
                    const d = ((e[0] - this.pos[0]) * i[0] + (e[1] - this.pos[1]) * i[1] + (e[2] - this.pos[2]) * i[2]) / c;
                    return a[0] = this.pos[0] + this.dir[0] * d, a[1] = this.pos[1] + this.dir[1] * d, a[2] = this.pos[2] + this.dir[2] * d, !0
                }

                closestPointOnSphere(e, i, a) {
                    if (function (z, L) {
                        var F = z[0], N = z[1], H = z[2], Y = L[0], X = L[1], J = L[2];
                        return Math.abs(F - Y) <= j * Math.max(1, Math.abs(F), Math.abs(Y)) && Math.abs(N - X) <= j * Math.max(1, Math.abs(N), Math.abs(X)) && Math.abs(H - J) <= j * Math.max(1, Math.abs(H), Math.abs(J))
                    }(this.pos, e) || i === 0) return a[0] = a[1] = a[2] = 0, !1;
                    const [c, d, f] = this.dir, _ = this.pos[0] - e[0], x = this.pos[1] - e[1], w = this.pos[2] - e[2],
                        E = c * c + d * d + f * f, I = 2 * (_ * c + x * d + w * f),
                        C = I * I - 4 * E * (_ * _ + x * x + w * w - i * i);
                    if (C < 0) {
                        const z = Math.max(-I / 2, 0), L = _ + c * z, F = x + d * z, N = w + f * z,
                            H = Math.hypot(L, F, N);
                        return a[0] = L * i / H, a[1] = F * i / H, a[2] = N * i / H, !1
                    }
                    {
                        const z = (-I - Math.sqrt(C)) / (2 * E);
                        if (z < 0) {
                            const L = Math.hypot(_, x, w);
                            return a[0] = _ * i / L, a[1] = x * i / L, a[2] = w * i / L, !1
                        }
                        return a[0] = _ + c * z, a[1] = x + d * z, a[2] = w + f * z, !0
                    }
                }
            }

            class qi {
                constructor(e, i, a, c, d) {
                    this.TL = e, this.TR = i, this.BR = a, this.BL = c, this.horizon = d
                }

                static fromInvProjectionMatrix(e, i, a) {
                    const c = [-1, 1, 1], d = [1, 1, 1], f = [1, -1, 1], _ = [-1, -1, 1], x = An(c, c, e),
                        w = An(d, d, e), E = An(f, f, e), I = An(_, _, e);
                    return new qi(x, w, E, I, i / a)
                }
            }

            function pn(n, e, i) {
                let a = 1 / 0, c = -1 / 0;
                const d = [];
                for (const f of n) {
                    Nn(d, f, e);
                    const _ = Ii(d, i);
                    a = Math.min(a, _), c = Math.max(c, _)
                }
                return [a, c]
            }

            function wi(n, e) {
                let i = !0;
                for (let a = 0; a < n.planes.length; a++) {
                    const c = n.planes[a];
                    let d = 0;
                    for (let f = 0; f < e.length; f++) d += Ii(c, e[f]) + c[3] >= 0;
                    if (d === 0) return 0;
                    d !== e.length && (i = !1)
                }
                return i ? 2 : 1
            }

            function $i(n, e) {
                for (const i of n.projections) {
                    const a = pn(e, n.points[0], i.axis);
                    if (i.projection[1] < a[0] || i.projection[0] > a[1]) return 0
                }
                return 1
            }

            function Hi(n, e) {
                let i = 0;
                const a = [0, 0, 0, 0];
                for (let f = 0; f < n.length; f++) a[0] = n[f][0], a[1] = n[f][1], a[2] = n[f][2], a[3] = 1, (c = a)[0] * (d = e)[0] + c[1] * d[1] + c[2] * d[2] + c[3] * d[3] >= 0 && i++;
                var c, d;
                return i
            }

            class Xi {
                constructor(e, i) {
                    this.points = e || new Array(8).fill([0, 0, 0]), this.planes = i || new Array(6).fill([0, 0, 0, 0]), this.bounds = Ei.fromPoints(this.points), this.projections = [], this.frustumEdges = [Nn([], this.points[2], this.points[3]), Nn([], this.points[0], this.points[3]), Nn([], this.points[4], this.points[0]), Nn([], this.points[5], this.points[1]), Nn([], this.points[6], this.points[2]), Nn([], this.points[7], this.points[3])];
                    for (const a of this.frustumEdges) {
                        const c = [0, -a[2], a[1]], d = [a[2], 0, -a[0]];
                        this.projections.push({
                            axis: c,
                            projection: pn(this.points, this.points[0], c)
                        }), this.projections.push({axis: d, projection: pn(this.points, this.points[0], d)})
                    }
                }

                static fromInvProjectionMatrix(e, i, a, c) {
                    const d = Math.pow(2, a),
                        f = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(w => {
                            const E = Ir([], w, e), I = 1 / E[3] / i * d;
                            return (C = E)[0] = (z = E)[0] * (L = [I, I, c ? 1 / E[3] : I, I])[0], C[1] = z[1] * L[1], C[2] = z[2] * L[2], C[3] = z[3] * L[3], C;
                            var C, z, L
                        }), _ = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(w => {
                            const E = Bi([], Bn([], Nn([], f[w[0]], f[w[1]]), Nn([], f[w[2]], f[w[1]]))),
                                I = -Ii(E, f[w[1]]);
                            return E.concat(I)
                        }), x = [];
                    for (let w = 0; w < f.length; w++) x.push([f[w][0], f[w][1], f[w][2]]);
                    return new Xi(x, _)
                }

                intersectsPrecise(e, i, a) {
                    for (let c = 0; c < i.length; c++) if (!Hi(e, i[c])) return 0;
                    for (let c = 0; c < this.planes.length; c++) if (!Hi(e, this.planes[c])) return 0;
                    for (const c of a) for (const d of this.frustumEdges) {
                        const f = Bn([], c, d), _ = Mi(f);
                        if (_ === 0) continue;
                        ai(f, f, 1 / _);
                        const x = pn(this.points, this.points[0], f), w = pn(e, this.points[0], f);
                        if (x[0] > w[1] || w[0] > x[1]) return 0
                    }
                    return 1
                }

                containsPoint(e) {
                    for (const i of this.planes) {
                        const a = i[3];
                        if (Ii([i[0], i[1], i[2]], e) + a < 0) return !1
                    }
                    return !0
                }
            }

            class Ei {
                static fromPoints(e) {
                    const i = [1 / 0, 1 / 0, 1 / 0], a = [-1 / 0, -1 / 0, -1 / 0];
                    for (const c of e) Rt(i, i, c), ni(a, a, c);
                    return new Ei(i, a)
                }

                static fromTileIdAndHeight(e, i, a) {
                    const c = 1 << e.canonical.z, d = e.canonical.x, f = e.canonical.y;
                    return new Ei([d / c, f / c, i], [(d + 1) / c, (f + 1) / c, a])
                }

                static applyTransform(e, i) {
                    const a = e.getCorners();
                    for (let c = 0; c < a.length; ++c) An(a[c], a[c], i);
                    return Ei.fromPoints(a)
                }

                static applyTransformFast(e, i) {
                    const a = [i[12], i[13], i[14]], c = [...a];
                    for (let d = 0; d < 3; d++) for (let f = 0; f < 3; f++) {
                        const _ = i[4 * f + d], x = _ * e.min[f], w = _ * e.max[f];
                        a[d] += Math.min(x, w), c[d] += Math.max(x, w)
                    }
                    return new Ei(a, c)
                }

                static projectAabbCorners(e, i) {
                    const a = e.getCorners();
                    for (let c = 0; c < a.length; ++c) An(a[c], a[c], i);
                    return a
                }

                constructor(e, i) {
                    this.min = e, this.max = i, this.center = ai([], si([], this.min, this.max), .5)
                }

                quadrant(e) {
                    const i = [e % 2 == 0, e < 2], a = hi(this.min), c = hi(this.max);
                    for (let d = 0; d < i.length; d++) a[d] = i[d] ? this.min[d] : this.center[d], c[d] = i[d] ? this.center[d] : this.max[d];
                    return c[2] = this.max[2], new Ei(a, c)
                }

                distanceX(e) {
                    return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0]
                }

                distanceY(e) {
                    return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1]
                }

                distanceZ(e) {
                    return Math.max(Math.min(this.max[2], e[2]), this.min[2]) - e[2]
                }

                getCorners() {
                    const e = this.min, i = this.max;
                    return [[e[0], e[1], e[2]], [i[0], e[1], e[2]], [i[0], i[1], e[2]], [e[0], i[1], e[2]], [e[0], e[1], i[2]], [i[0], e[1], i[2]], [i[0], i[1], i[2]], [e[0], i[1], i[2]]]
                }

                intersects(e) {
                    return this.intersectsAabb(e.bounds) ? wi(e, this.getCorners()) : 0
                }

                intersectsFlat(e) {
                    return this.intersectsAabb(e.bounds) ? wi(e, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0
                }

                intersectsPrecise(e, i) {
                    return i || this.intersects(e) ? $i(e, this.getCorners()) : 0
                }

                intersectsPreciseFlat(e, i) {
                    return i || this.intersectsFlat(e) ? $i(e, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0
                }

                intersectsAabb(e) {
                    for (let i = 0; i < 3; ++i) if (this.min[i] > e.max[i] || e.min[i] > this.max[i]) return !1;
                    return !0
                }

                intersectsAabbXY(e) {
                    return !(this.min[0] > e.max[0] || e.min[0] > this.max[0] || this.min[1] > e.max[1] || e.min[1] > this.max[1])
                }

                encapsulate(e) {
                    for (let i = 0; i < 3; i++) this.min[i] = Math.min(this.min[i], e.min[i]), this.max[i] = Math.max(this.max[i], e.max[i])
                }

                encapsulatePoint(e) {
                    for (let i = 0; i < 3; i++) this.min[i] = Math.min(this.min[i], e[i]), this.max[i] = Math.max(this.max[i], e[i])
                }

                closestPoint(e) {
                    return [Math.max(Math.min(this.max[0], e[0]), this.min[0]), Math.max(Math.min(this.max[1], e[1]), this.min[1]), Math.max(Math.min(this.max[2], e[2]), this.min[2])]
                }
            }

            Pt(Ei, "Aabb");

            class rn {
                constructor(e, i) {
                    this.feature = e, this.metersToTile = i, this.index = 0
                }

                get() {
                    const e = this.feature.vertices[this.index], i = this.feature.vertexProps[this.index].dir, a = i[1],
                        c = -i[0], d = (e.extent + 1) * this.metersToTile;
                    return [new Ze(Math.trunc(e.position[0] + a * d), Math.trunc(e.position[1] + c * d)), new Ze(Math.trunc(e.position[0] - a * d), Math.trunc(e.position[1] - c * d))]
                }

                next() {
                    this.index++
                }

                valid() {
                    return this.index < this.feature.vertices.length
                }
            }

            class Wi {
                constructor(e, i, a, c, d, f) {
                    if (this.vertices = new Array, this.vertexProps = new Array, this.edges = new Array, this.edgeProps = new Array, this.id = e, this.heightRange = {
                        min: a,
                        max: a
                    }, this.safeArea = i, this.constantHeight = a, this.constantHeight == null && (this.constantHeight != null || c.length !== 0)) {
                        this.vertices = c, this.edges = d, this.edges = this.edges.filter(_ => {
                            return _.a < this.vertices.length && _.b < this.vertices.length && !((x = this.vertices[_.a].position)[0] === (w = this.vertices[_.b].position)[0] && x[1] === w[1]);
                            var x, w
                        }), this.heightRange = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};
                        for (const _ of this.vertices) this.vertexProps.push({dir: uo(0, 0)}), this.heightRange.min = Math.min(this.heightRange.min, _.height), this.heightRange.max = Math.max(this.heightRange.max, _.height);
                        for (const _ of this.edges) {
                            const x = this.vertices[_.a].position, w = this.vertices[_.b].position, E = ho(Fr(), w, x),
                                I = bo(E), C = Ls(Fr(), E, 1 / I);
                            this.edgeProps.push({vec: E, dir: C, len: I});
                            const z = this.vertexProps[_.a].dir, L = this.vertexProps[_.b].dir;
                            ms(z, z, C), ms(L, L, C)
                        }
                        for (const _ of this.vertexProps) _.dir[0] === 0 && _.dir[1] === 0 || Ua(_.dir, _.dir);
                        this.tessellate(f)
                    }
                }

                pointElevation(e) {
                    if (this.constantHeight != null) return this.constantHeight;
                    const i = this.getClosestEdge(e);
                    if (i == null) return 0;
                    const [a, c] = i;
                    return qt(this.vertices[this.edges[a].a].height, this.vertices[this.edges[a].b].height, c)
                }

                computeSlopeNormal(e, i) {
                    const a = this.getClosestEdge(e);
                    if (!a) return $t(0, 0, 1);
                    const c = a[0], d = this.edges[c], f = this.edgeProps[c].vec,
                        _ = $t(f[0], f[1], (this.vertices[d.b].height - this.vertices[d.a].height) * i),
                        x = $t(_[1], -_[0], 0);
                    Bn(x, x, _);
                    const w = Mi(x);
                    return w > 0 ? ai(x, x, 1 / w) : $t(0, 0, 1)
                }

                getSafeArea() {
                    return this.safeArea
                }

                isTunnel() {
                    return this.heightRange.max <= -5
                }

                getClosestEdge(e) {
                    if (this.edges.length === 0) return;
                    let i = 0, a = Number.POSITIVE_INFINITY, c = 0;
                    const d = uo(e.x, e.y);
                    for (let f = 0; f < this.edges.length; f++) {
                        const _ = this.edges[f], x = this.edgeProps[f].dir, w = new ci(d, this.edgeProps[f].dir),
                            E = this.vertices[_.a].position, I = this.vertices[_.b].position, C = Fr(), z = Fr(),
                            L = w.intersectsPlane(E, this.vertexProps[_.a].dir, C),
                            F = w.intersectsPlane(I, this.vertexProps[_.b].dir, z);
                        if (!L || !F) continue;
                        const N = ho(Fr(), z, C), H = ho(Fr(), d, C), Y = bn(N, N), X = Y > 0 ? bn(H, N) / Y : 0,
                            J = se(X, 0, 1), xe = Math.abs((X - J) * this.edgeProps[f].len), ge = ho(Fr(), d, E),
                            ye = xe + Math.abs(bn(ge, uo(x[1], -x[0])));
                        ye < a && (i = f, a = ye, c = J)
                    }
                    return [i, c]
                }

                tessellate(e) {
                    for (let i = this.edges.length - 1; i >= 0; --i) {
                        const a = this.edges[i].a, c = this.edges[i].b, {
                                position: d,
                                height: f,
                                extent: _
                            } = this.vertices[a], {position: x, height: w, extent: E} = this.vertices[c],
                            I = this.vertexProps[a].dir, C = this.vertexProps[c].dir, z = $t(d[0] / e, d[1] / e, f),
                            L = $t(x[0] / e, x[1] / e, w), F = $t(I[1], -I[0], 0);
                        ai(F, F, _);
                        const N = $t(C[1], -C[0], 0);
                        if (ai(N, N, E), this.distSqLines($t(z[0] + .5 * F[0], z[1] + .5 * F[1], z[2] + .5 * F[2]), $t(L[0] - .5 * N[0], L[1] - .5 * N[1], L[2] - .5 * N[2]), $t(z[0] - .5 * F[0], z[1] - .5 * F[1], z[2] - .5 * F[2]), $t(L[0] + .5 * N[0], L[1] + .5 * N[1], L[2] + .5 * N[2])) <= .0025000000000000005) continue;
                        const H = this.vertices.length, Y = ms(Fr(), d, x);
                        this.vertices.push({position: Ls(Y, Y, .5), height: .5 * (f + w), extent: .5 * (_ + E)});
                        const X = ms(Fr(), I, C);
                        this.vertexProps.push({dir: Ua(X, X)}), this.edges.splice(i, 1), this.edgeProps.splice(i, 1), this.edges.push({
                            a,
                            b: H
                        }), this.edges.push({a: H, b: c});
                        const J = ho(Fr(), this.vertices[H].position, d), xe = bo(J),
                            ge = {vec: J, dir: Ls(Fr(), J, 1 / xe), len: xe};
                        this.edgeProps.push(ge), this.edgeProps.push(ge)
                    }
                }

                distSqLines(e, i, a, c) {
                    const d = Ri(Ht(), i, e), f = Ri(Ht(), c, a), _ = Ri(Ht(), e, a), x = Ii(d, d), w = Ii(d, f),
                        E = Ii(d, _), I = Ii(f, f), C = Ii(f, _), z = x * I - w * w;
                    if (z === 0) {
                        const N = Ii(_, f) / Ii(f, f);
                        return nn(ar(Ht(), a, c, N), e)
                    }
                    const L = (w * C - E * I) / z, F = (x * C - w * E) / z;
                    return nn(ar(Ht(), e, i, L), ar(Ht(), a, c, F))
                }
            }

            class kn {
                static parseFrom(e, i) {
                    const a = Ui.parse(e);
                    if (!a) return [];
                    let {vertices: c, features: d} = a;
                    const f = 1 / he(i);
                    d.sort((E, I) => E.id - I.id), c.sort((E, I) => E.id - I.id || E.idx - I.idx), c = c.filter((E, I, C) => I === C.findIndex(z => z.id === E.id && z.idx === E.idx));
                    const _ = new Array;
                    let x = 0;
                    const w = c.length;
                    for (const E of d) {
                        if (E.constantHeight) {
                            _.push(new Wi(E.id, E.bounds, E.constantHeight));
                            continue
                        }
                        for (; x !== w && c[x].id < E.id;) x++;
                        if (x === w || c[x].id !== E.id) continue;
                        const I = new Array, C = new Array, z = x;
                        for (; x !== w && c[x].id === E.id;) {
                            const L = c[x];
                            if (I.push({
                                position: L.position,
                                height: L.height,
                                extent: L.extent
                            }), x !== z && c[x - 1].idx === L.idx - 1) {
                                const F = x - z;
                                C.push({a: F - 1, b: F})
                            }
                            x++
                        }
                        _.push(new Wi(E.id, E.bounds, void 0, I, C, f))
                    }
                    return _
                }

                static getElevationFeature(e, i) {
                    if (!i) return;
                    const a = +e.properties[St];
                    return Number.isNaN(a) ? void 0 : i.find(c => c.id === a)
                }
            }

            class ji {
                constructor(e, i) {
                    this.zScale = 1, this.xOffset = 0, this.yOffset = 0, e.equals(i) || (this.zScale = Math.pow(2, i.z - e.z), this.xOffset = (e.x * this.zScale - i.x) * yt, this.yOffset = (e.y * this.zScale - i.y) * yt)
                }

                constantElevation(e, i) {
                    if (e.constantHeight != null) return this.computeBiasedHeight(e.constantHeight, i)
                }

                pointElevation(e, i, a) {
                    const c = this.constantElevation(i, a);
                    return c ?? (e.x = e.x * this.zScale + this.xOffset, e.y = e.y * this.zScale + this.yOffset, this.computeBiasedHeight(i.pointElevation(e), a))
                }

                computeBiasedHeight(e, i) {
                    return i <= 0 ? e : e + i * Ae(0, i, e >= 0 ? e : Math.abs(.5 * e))
                }
            }

            Pt(Wi, "ElevationFeature");

            class Yi {
                constructor(e) {
                    this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(i => i.fqid), this.index = e.index, this.hasPattern = !1, this.projection = e.projection, this.layoutVertexArray = new Po, this.indexArray = new Mn, this.segments = new Ln, this.programConfigurations = new es(e.layers, {
                        zoom: e.zoom,
                        lut: e.lut
                    }), this.stateDependentLayerIds = this.layers.filter(i => i.isStateDependent()).map(i => i.id), this.elevationMode = this.layers[0].layout.get("circle-elevation-reference"), this.hasElevation = !1, this.elevationMode !== "none" && (this.elevatedLayoutVertexArray = new Zl), this.worldview = e.worldview
                }

                updateFootprints(e, i) {
                }

                populate(e, i, a, c) {
                    const d = this.layers[0], f = [];
                    let _ = null;
                    d.type === "circle" && (_ = d.layout.get("circle-sort-key"));
                    for (const {feature: w, id: E, index: I, sourceLayerIndex: C} of e) {
                        const z = this.layers[0]._featureFilter.needGeometry, L = $e(w, z);
                        if (!this.layers[0]._featureFilter.filter(new sn(this.zoom, {worldview: this.worldview}), L, a)) continue;
                        const F = _ ? _.evaluate(L, {}, a) : void 0, N = {
                            id: E,
                            properties: w.properties,
                            type: w.type,
                            sourceLayerIndex: C,
                            index: I,
                            geometry: z ? L.geometry : Te(w, a, c),
                            patterns: {},
                            sortKey: F
                        };
                        f.push(N)
                    }
                    _ && f.sort((w, E) => w.sortKey - E.sortKey);
                    let x = null;
                    c.projection.name === "globe" && (this.globeExtVertexArray = new nf, x = c.projection);
                    for (const w of f) {
                        const {geometry: E, index: I, sourceLayerIndex: C} = w, z = e[I].feature;
                        this.addFeature(w, E, I, i.availableImages, a, x, i.brightness, i.elevationFeatures), i.featureIndex.insert(z, E, I, C, this.index)
                    }
                    this.hasElevation || (this.elevatedLayoutVertexArray = void 0)
                }

                update(e, i, a, c, d, f, _) {
                    this.programConfigurations.updatePaintArrays(e, i, d, a, c, f, _, this.worldview)
                }

                isEmpty() {
                    return this.layoutVertexArray.length === 0
                }

                uploadPending() {
                    return !this.uploaded || this.programConfigurations.needsUpload
                }

                upload(e) {
                    this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Dy.members), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = e.createVertexBuffer(this.globeExtVertexArray, h1.members)), this.elevatedLayoutVertexArray && (this.elevatedLayoutVertexBuffer = e.createVertexBuffer(this.elevatedLayoutVertexArray, u1.members))), this.programConfigurations.upload(e), this.uploaded = !0
                }

                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.elevatedLayoutVertexBuffer && this.elevatedLayoutVertexBuffer.destroy())
                }

                addFeature(e, i, a, c, d, f, _, x) {
                    let w;
                    this.elevationMode !== "none" && (w = kn.getElevationFeature(e, x));
                    for (const E of i) for (const I of E) {
                        const C = I.x, z = I.y;
                        if (C < 0 || C >= yt || z < 0 || z >= yt) continue;
                        if (f) {
                            const N = f.projectTilePoint(C, z, d), H = f.upVector(d, C, z);
                            this.addGlobeExtVertex(N, H), this.addGlobeExtVertex(N, H), this.addGlobeExtVertex(N, H), this.addGlobeExtVertex(N, H)
                        }
                        const L = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, e.sortKey),
                            F = L.vertexLength;
                        if (this.addCircleVertex(C, z, -1, -1), this.addCircleVertex(C, z, 1, -1), this.addCircleVertex(C, z, 1, 1), this.addCircleVertex(C, z, -1, 1), this.elevationMode !== "none") {
                            const N = w ? w.pointElevation(new Ze(C, z)) : 0;
                            this.hasElevation = this.hasElevation || N !== 0;
                            for (let H = 0; H < 4; H++) this.elevatedLayoutVertexArray.emplaceBack(N)
                        }
                        this.indexArray.emplaceBack(F, F + 1, F + 2), this.indexArray.emplaceBack(F, F + 2, F + 3), L.vertexLength += 4, L.primitiveLength += 2
                    }
                    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, a, {}, c, d, _, void 0, this.worldview)
                }

                addCircleVertex(e, i, a, c) {
                    this.layoutVertexArray.emplaceBack(2 * e + (a + 1) / 2, 2 * i + (c + 1) / 2)
                }

                addGlobeExtVertex(e, i) {
                    this.globeExtVertexArray.emplaceBack(e.x, e.y, e.z, i[0] * 16384, i[1] * 16384, i[2] * 16384)
                }
            }

            function hn(n, e) {
                for (let i = 0; i < n.length; i++) if (Gr(e, n[i])) return !0;
                for (let i = 0; i < e.length; i++) if (Gr(n, e[i])) return !0;
                return !!Rr(n, e)
            }

            function ir(n, e, i) {
                return !!Gr(n, e) || !!Ur(e, n, i)
            }

            function er(n, e) {
                if (n.length === 1) return Ss(e, n[0]);
                for (let i = 0; i < e.length; i++) {
                    const a = e[i];
                    for (let c = 0; c < a.length; c++) if (Gr(n, a[c])) return !0
                }
                for (let i = 0; i < n.length; i++) if (Ss(e, n[i])) return !0;
                for (let i = 0; i < e.length; i++) if (Rr(n, e[i])) return !0;
                return !1
            }

            function rr(n, e, i) {
                if (n.length > 1) {
                    if (Rr(n, e)) return !0;
                    for (let a = 0; a < e.length; a++) if (Ur(e[a], n, i)) return !0
                }
                for (let a = 0; a < n.length; a++) if (Ur(n[a], e, i)) return !0;
                return !1
            }

            function Rr(n, e) {
                if (n.length === 0 || e.length === 0) return !1;
                for (let i = 0; i < n.length - 1; i++) {
                    const a = n[i], c = n[i + 1];
                    for (let d = 0; d < e.length - 1; d++) if (Ns(a, c, e[d], e[d + 1])) return !0
                }
                return !1
            }

            function Ns(n, e, i, a) {
                return Xn(n, i, a) !== Xn(e, i, a) && Xn(n, e, i) !== Xn(n, e, a)
            }

            function _o(n, e, i) {
                return (n.x - i.x) * (e.y - i.y) - (n.y - i.y) * (e.x - i.x)
            }

            function Fo(n, e, i, a) {
                const c = _o(n, e, a), d = _o(n, e, i);
                if (Math.sign(c) === Math.sign(d)) return;
                const f = _o(i, a, n), _ = f + d - c;
                return Math.sign(f) !== Math.sign(_) ? [f / (f - _), d / (d - c)] : void 0
            }

            function Ur(n, e, i) {
                const a = i * i;
                if (e.length === 1) return n.distSqr(e[0]) < a;
                for (let c = 1; c < e.length; c++) if (ts(n, e[c - 1], e[c]) < a) return !0;
                return !1
            }

            function ts(n, e, i) {
                const a = e.distSqr(i);
                if (a === 0) return n.distSqr(e);
                const c = ((n.x - e.x) * (i.x - e.x) + (n.y - e.y) * (i.y - e.y)) / a;
                return n.distSqr(c < 0 ? e : c > 1 ? i : i.sub(e)._mult(c)._add(e))
            }

            function Ss(n, e) {
                let i, a, c, d = !1;
                for (let f = 0; f < n.length; f++) {
                    i = n[f];
                    for (let _ = 0, x = i.length - 1; _ < i.length; x = _++) a = i[_], c = i[x], a.y > e.y != c.y > e.y && e.x < (c.x - a.x) * (e.y - a.y) / (c.y - a.y) + a.x && (d = !d)
                }
                return d
            }

            function Gr(n, e) {
                let i = !1;
                for (let a = 0, c = n.length - 1; a < n.length; c = a++) {
                    const d = n[a], f = n[c];
                    d.y > e.y != f.y > e.y && e.x < (f.x - d.x) * (e.y - d.y) / (f.y - d.y) + d.x && (i = !i)
                }
                return i
            }

            function Yn(n, e, i, a, c) {
                for (const f of n) if (e <= f.x && i <= f.y && a >= f.x && c >= f.y) return !0;
                const d = [new Ze(e, i), new Ze(e, c), new Ze(a, c), new Ze(a, i)];
                if (n.length > 2) {
                    for (const f of d) if (Gr(n, f)) return !0
                }
                for (let f = 0; f < n.length - 1; f++) if (Un(n[f], n[f + 1], d)) return !0;
                return !1
            }

            function Un(n, e, i) {
                const a = i[0], c = i[2];
                if (n.x < a.x && e.x < a.x || n.x > c.x && e.x > c.x || n.y < a.y && e.y < a.y || n.y > c.y && e.y > c.y) return !1;
                const d = Xn(n, e, i[0]);
                return d !== Xn(n, e, i[1]) || d !== Xn(n, e, i[2]) || d !== Xn(n, e, i[3])
            }

            function gn(n, e, i, a, c, d) {
                let f = e.y - n.y, _ = n.x - e.x;
                if (d = d || 0) {
                    const x = f * f + _ * _;
                    if (x === 0) return !0;
                    const w = Math.sqrt(x);
                    f /= w, _ /= w
                }
                return !((i.x - n.x) * f + (i.y - n.y) * _ - d < 0 || (a.x - n.x) * f + (a.y - n.y) * _ - d < 0 || (c.x - n.x) * f + (c.y - n.y) * _ - d < 0)
            }

            function ur(n, e, i, a, c, d, f) {
                return !(gn(n, e, a, c, d, f) || gn(e, i, a, c, d, f) || gn(i, n, a, c, d, f) || gn(a, c, n, e, i, f) || gn(c, d, n, e, i, f) || gn(d, a, n, e, i, f))
            }

            function zr(n, e, i) {
                const a = e.paint.get(n).value;
                return a.kind === "constant" ? a.value : i.programConfigurations.get(e.id).getMaxValue(n)
            }

            function Kn(n) {
                return Math.sqrt(n[0] * n[0] + n[1] * n[1])
            }

            function is(n, e, i, a, c) {
                if (!e[0] && !e[1]) return n;
                const d = Ze.convert(e)._mult(c);
                i === "viewport" && d._rotate(-a);
                const f = [];
                for (let _ = 0; _ < n.length; _++) f.push(n[_].sub(d));
                return f
            }

            function Yl(n, e, i, a) {
                const c = Ze.convert(n)._mult(a);
                return e === "viewport" && c._rotate(-i), c
            }

            let dl, Kc;

            function Qc(n, e, i) {
                var a = 2 * Math.PI * 6378137 / 256 / Math.pow(2, i);
                return [n * a - 2 * Math.PI * 6378137 / 2, e * a - 2 * Math.PI * 6378137 / 2]
            }

            Pt(Yi, "CircleBucket", {omit: ["layers"]});

            class ns {
                constructor(e, i, a) {
                    this.z = e, this.x = i, this.y = a, this.key = rs(0, e, e, i, a)
                }

                equals(e) {
                    return this.z === e.z && this.x === e.x && this.y === e.y
                }

                isChildOf(e) {
                    const i = this.z - e.z;
                    return e.z === 0 || e.z < this.z && e.x === this.x >> i && e.y === this.y >> i
                }

                url(e, i) {
                    const a = function (d, f, _) {
                        var x = Qc(256 * d, 256 * (f = Math.pow(2, _) - f - 1), _),
                            w = Qc(256 * (d + 1), 256 * (f + 1), _);
                        return x[0] + "," + x[1] + "," + w[0] + "," + w[1]
                    }(this.x, this.y, this.z), c = function (d, f, _) {
                        let x, w = "";
                        for (let E = d; E > 0; E--) x = 1 << E - 1, w += (f & x ? 1 : 0) + (_ & x ? 2 : 0);
                        return w
                    }(this.z, this.x, this.y);
                    return e[(this.x + this.y) % e.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(i === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", c).replace("{bbox-epsg-3857}", a)
                }

                toString() {
                    return `${this.z}/${this.x}/${this.y}`
                }
            }

            class ia {
                constructor(e, i) {
                    this.wrap = e, this.canonical = i, this.key = rs(e, i.z, i.z, i.x, i.y)
                }
            }

            class hr {
                constructor(e, i, a, c, d) {
                    this.overscaledZ = e, this.wrap = i, this.canonical = new ns(a, +c, +d), this.key = i === 0 && e === a ? this.canonical.key : rs(i, e, a, c, d)
                }

                equals(e) {
                    return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical)
                }

                scaledTo(e) {
                    const i = this.canonical.z - e;
                    return e > this.canonical.z ? new hr(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new hr(e, this.wrap, e, this.canonical.x >> i, this.canonical.y >> i)
                }

                calculateScaledKey(e, i = !0) {
                    if (this.overscaledZ === e && i) return this.key;
                    if (e > this.canonical.z) return rs(this.wrap * +i, e, this.canonical.z, this.canonical.x, this.canonical.y);
                    {
                        const a = this.canonical.z - e;
                        return rs(this.wrap * +i, e, e, this.canonical.x >> a, this.canonical.y >> a)
                    }
                }

                isChildOf(e) {
                    if (e.wrap !== this.wrap) return !1;
                    const i = this.canonical.z - e.canonical.z;
                    return e.overscaledZ === 0 || e.overscaledZ < this.overscaledZ && e.canonical.z < this.canonical.z && e.canonical.x === this.canonical.x >> i && e.canonical.y === this.canonical.y >> i
                }

                children(e) {
                    if (this.overscaledZ >= e) return [new hr(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
                    const i = this.canonical.z + 1, a = 2 * this.canonical.x, c = 2 * this.canonical.y;
                    return [new hr(i, this.wrap, i, a, c), new hr(i, this.wrap, i, a + 1, c), new hr(i, this.wrap, i, a, c + 1), new hr(i, this.wrap, i, a + 1, c + 1)]
                }

                isLessThan(e) {
                    return this.wrap < e.wrap || !(this.wrap > e.wrap) && (this.overscaledZ < e.overscaledZ || !(this.overscaledZ > e.overscaledZ) && (this.canonical.x < e.canonical.x || !(this.canonical.x > e.canonical.x) && this.canonical.y < e.canonical.y))
                }

                wrapped() {
                    return new hr(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y)
                }

                unwrapTo(e) {
                    return new hr(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y)
                }

                overscaleFactor() {
                    return Math.pow(2, this.overscaledZ - this.canonical.z)
                }

                toUnwrapped() {
                    return new ia(this.wrap, this.canonical)
                }

                toString() {
                    return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
                }
            }

            function rs(n, e, i, a, c) {
                const d = 1 << Math.min(i, 22);
                let f = d * (c % d) + a % d;
                return n && i < 22 && (f += d * d * ((n < 0 ? -2 * n - 1 : 2 * n) % (1 << 2 * (22 - i)))), 16 * (32 * f + i) + (e - i)
            }

            const Kl = [n => {
                let e = n.canonical.x - 1, i = n.wrap;
                return e < 0 && (e = (1 << n.canonical.z) - 1, i--), new hr(n.overscaledZ, i, n.canonical.z, e, n.canonical.y)
            }, n => {
                let e = n.canonical.x + 1, i = n.wrap;
                return e === 1 << n.canonical.z && (e = 0, i++), new hr(n.overscaledZ, i, n.canonical.z, e, n.canonical.y)
            }, n => new hr(n.overscaledZ, n.wrap, n.canonical.z, n.canonical.x, (n.canonical.y === 0 ? 1 << n.canonical.z : n.canonical.y) - 1), n => new hr(n.overscaledZ, n.wrap, n.canonical.z, n.canonical.x, n.canonical.y === (1 << n.canonical.z) - 1 ? 0 : n.canonical.y + 1)];
            Pt(ns, "CanonicalTileID"), Pt(hr, "OverscaledTileID", {omit: ["projMatrix", "expandedProjMatrix"]});
            const vL = Fi([{type: "Float32", name: "a_globe_pos", components: 3}, {
                type: "Float32",
                name: "a_uv",
                components: 2
            }]), {members: Ny} = vL, xL = Fi([{name: "a_pos_3", components: 3, type: "Int16"}]);
            var Y2 = Fi([{name: "a_pos", type: "Int16", components: 2}]);

            function jy(n) {
                return n * io / S
            }

            const wL = [new Ei([m, m, m], [g, g, g]), new Ei([m, m, m], [0, 0, g]), new Ei([0, m, m], [g, 0, g]), new Ei([m, 0, m], [0, g, g]), new Ei([0, 0, m], [g, g, g])];

            function K2(n, e, i, a = !0) {
                const c = ai([], n._camera.position, n.worldSize), d = [e, i, 1, 1];
                Ir(d, d, n.pixelMatrixInverse), lo(d, d, 1 / d[3]);
                const f = Bi([], Nn([], d, c)), _ = n.globeMatrix, x = [_[12], _[13], _[14]], w = Nn([], x, c),
                    E = Mi(w), I = Bi([], w), C = n.worldSize / (2 * Math.PI), z = Ii(I, f), L = Math.asin(C / E);
                if (L < Math.acos(z)) {
                    if (!a) return null;
                    const We = [], De = [];
                    ai(We, f, E / z), Bi(De, Nn(De, We, w)), Bi(f, si(f, w, ai(f, De, Math.tan(L) * E)))
                }
                const F = [];
                new Gi(c, f).closestPointOnSphere(x, C, F);
                const N = Bi([], jn(_, 0)), H = Bi([], jn(_, 1)), Y = Bi([], jn(_, 2)), X = Ii(N, F), J = Ii(H, F),
                    xe = Ii(Y, F), ge = Le(Math.asin(-J / C));
                let ye = Le(Math.atan2(X, xe));
                ye = n.center.lng + function (We, De) {
                    const Ye = (De - We + 180) % 360 - 180;
                    return Ye < -180 ? Ye + 360 : Ye
                }(n.center.lng, ye);
                const Ee = B(ye), Ie = se(G(ge), 0, 1);
                return new me(Ee, Ie)
            }

            class bL {
                constructor(e, i, a) {
                    this.a = Nn([], e, a), this.b = Nn([], i, a), this.center = a;
                    const c = Bi([], this.a), d = Bi([], this.b);
                    this.angle = Math.acos(Ii(c, d))
                }
            }

            function v1(n, e) {
                if (n.angle === 0) return null;
                let i;
                return i = n.a[e] === 0 ? 1 / n.angle * .5 * Math.PI : 1 / n.angle * Math.atan(n.b[e] / n.a[e] / Math.sin(n.angle) - 1 / Math.tan(n.angle)), i < 0 || i > 1 ? null : function (a, c, d, f) {
                    const _ = Math.sin(d);
                    return a * (Math.sin((1 - f) * d) / _) + c * (Math.sin(f * d) / _)
                }(n.a[e], n.b[e], n.angle, se(i, 0, 1)) + n.center[e]
            }

            function fl(n) {
                if (n.z <= 1) return wL[n.z + 2 * n.y + n.x];
                const e = x1(Vy(n));
                return Ei.fromPoints(e)
            }

            function Ql(n, e, i) {
                return ai(n, n, 1 - i), fi(n, n, e, i)
            }

            function Q2(n, e, i) {
                for (const a of n) An(a, a, e), ai(a, a, i)
            }

            function J2(n, e, i, a) {
                const c = e / n.worldSize, d = n.globeMatrix;
                if (i.z <= 1) {
                    const Ie = fl(i).getCorners();
                    return Q2(Ie, d, c), Ei.fromPoints(Ie)
                }
                const f = Vy(i, a), _ = x1(f, io + jy(n._tileCoverLift));
                Q2(_, d, c);
                const x = Number.MAX_VALUE, w = [-x, -x, -x], E = [x, x, x];
                if (f.contains(n.center)) {
                    for (const De of _) Rt(E, E, De), ni(w, w, De);
                    w[2] = 0;
                    const Ie = n.point, We = [Ie.x * c, Ie.y * c, 0];
                    return Rt(E, E, We), ni(w, w, We), new Ei(E, w)
                }
                if (n._tileCoverLift > 0) {
                    for (const Ie of _) Rt(E, E, Ie), ni(w, w, Ie);
                    return new Ei(E, w)
                }
                const I = [d[12] * c, d[13] * c, d[14] * c], C = f.getCenter(), z = se(n.center.lat, -ce, ce),
                    L = se(C.lat, -ce, ce), F = B(n.center.lng), N = G(z);
                let H = F - B(C.lng);
                const Y = N - G(L);
                H > .5 ? H -= 1 : H < -.5 && (H += 1);
                let X = 0;
                Math.abs(H) > Math.abs(Y) ? X = H >= 0 ? 1 : 3 : (X = Y >= 0 ? 0 : 2, fi(I, I, [d[4] * c, d[5] * c, d[6] * c], -Math.sin(Ai(Y >= 0 ? f.getSouth() : f.getNorth())) * io));
                const J = _[X], xe = _[(X + 1) % 4], ge = new bL(J, xe, I),
                    ye = [v1(ge, 0) || J[0], v1(ge, 1) || J[1], v1(ge, 2) || J[2]], Ee = Jc(n.zoom);
                if (Ee > 0) {
                    const Ie = function ({x: De, y: Ye, z: ht}, Qe, ot, ct, He) {
                        const st = 1 / (1 << ht);
                        let ke = De * st, qe = ke + st, pt = Ye * st, at = pt + st, Bt = 0;
                        const zt = (ke + qe) / 2 - ct;
                        return zt > .5 ? Bt = -1 : zt < -.5 && (Bt = 1), ke = ((ke + Bt) * Qe - (ct *= Qe)) * ot + ct, qe = ((qe + Bt) * Qe - ct) * ot + ct, pt = (pt * Qe - (He *= Qe)) * ot + He, at = (at * Qe - He) * ot + He, [[ke, at, 0], [qe, at, 0], [qe, pt, 0], [ke, pt, 0]]
                    }(i, e, n._pixelsPerMercatorPixel, F, N);
                    for (let De = 0; De < _.length; De++) Ql(_[De], Ie[De], Ee);
                    const We = si([], Ie[X], Ie[(X + 1) % 4]);
                    ai(We, We, .5), Ql(ye, We, Ee)
                }
                for (const Ie of _) Rt(E, E, Ie), ni(w, w, Ie);
                return E[2] = Math.min(J[2], xe[2]), Rt(E, E, ye), ni(w, w, ye), new Ei(E, w)
            }

            function Vy({x: n, y: e, z: i}, a = !1) {
                const c = 1 / (1 << i), d = new M(Z(n * c), e === (1 << i) - 1 && a ? -90 : Q((e + 1) * c)),
                    f = new M(Z((n + 1) * c), e === 0 && a ? 90 : Q(e * c));
                return new k(d, f)
            }

            function x1(n, e = io) {
                const i = Ai(n.getNorth()), a = Ai(n.getSouth()), c = Math.cos(i), d = Math.cos(a), f = Math.sin(i),
                    _ = Math.sin(a), x = n.getWest(), w = n.getEast();
                return [v(d, _, x, e), v(d, _, w, e), v(c, f, w, e), v(c, f, x, e)]
            }

            function Gm(n, e, i, a) {
                const c = 1 << i.z, d = (n / yt + i.x) / c;
                return b(Q((e / yt + i.y) / c), Z(d), a)
            }

            function Uy({min: n, max: e}) {
                return t / Math.max(e[0] - n[0], e[1] - n[1], e[2] - n[2])
            }

            const eS = new Float64Array(16);

            function Gy(n) {
                const e = Uy(n), i = xt(eS, [e, e, e]);
                return le(i, i, Zn([], n.min))
            }

            function w1(n) {
                const e = (a = n.min, (i = eS)[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = a[0], i[13] = a[1], i[14] = a[2], i[15] = 1, i);
                var i, a;
                const c = 1 / Uy(n);
                return be(e, e, [c, c, c])
            }

            function b1(n) {
                const e = yt / (2 * Math.PI);
                return n / (2 * Math.PI) / e
            }

            function tS(n, e) {
                return yt / (512 * Math.pow(2, n)) * Uy(fl(e))
            }

            function iS(n, e, i, a, c) {
                const d = b1(i), f = [n, e, -i / (2 * Math.PI)], _ = fe(new Float64Array(16));
                return le(_, _, f), be(_, _, [d, d, d]), Ue(_, _, Ai(-c)), et(_, _, Ai(-a)), _
            }

            function Jc(n) {
                return Ae(By, u, n)
            }

            function nS(n, e) {
                const i = b(e.lat, e.lng), a = function (L) {
                    const F = b(L._center.lat, L._center.lng);
                    let N = Bn([], $t(0, 1, 0), F);
                    const H = Mt([], -L.angle, F);
                    N = An(N, N, H), Mt(H, -L._pitch, N);
                    const Y = Bi([], F);
                    return ai(Y, Y, jy(L.cameraToCenterDistance / L.pixelsPerMeter)), An(Y, Y, H), si([], F, Y)
                }(n);
                return f = (c = Ri([], a, i))[0], _ = c[1], x = c[2], w = (d = i)[0], E = d[1], I = d[2], z = (C = Math.sqrt(f * f + _ * _ + x * x) * Math.sqrt(w * w + E * E + I * I)) && Ii(c, d) / C, Math.acos(Math.min(Math.max(z, -1), 1));
                var c, d, f, _, x, w, E, I, C, z
            }

            function T1(n, e) {
                return nS(n, e) > Math.PI / 2 * 1.01
            }

            const rS = Ai(85), TL = Math.cos(rS), SL = Math.sin(rS), EL = Re(), oS = n => {
                const e = [];
                return n.paint.get("circle-pitch-alignment") === "map" && e.push("PITCH_WITH_MAP"), n.paint.get("circle-pitch-scale") === "map" && e.push("SCALE_WITH_MAP"), e
            };

            function sS(n, e, i, a, c, d, f, _, x) {
                if (d && n.queryGeometry.isAboveHorizon) return !1;
                d && (x *= n.pixelToTileUnitsFactor);
                const w = n.tileID.canonical, E = i.projection.upVectorScale(w, i.center.lat, i.worldSize).metersToTile;
                for (const I of e) for (const C of I) {
                    const z = C.add(_),
                        L = c && i.elevation ? i.elevation.exaggeration() * c.getElevationAt(z.x, z.y, !0) : 0,
                        F = i.projection.projectTilePoint(z.x, z.y, w);
                    if (L > 0) {
                        const X = i.projection.upVector(w, z.x, z.y);
                        F.x += X[0] * E * L, F.y += X[1] * E * L, F.z += X[2] * E * L
                    }
                    const N = d ? z : AL(F.x, F.y, F.z, a),
                        H = d ? n.tilespaceRays.map(X => CL(X, L)) : n.queryGeometry.screenGeometry,
                        Y = Ir([], [F.x, F.y, F.z, 1], a);
                    if (!f && d ? x *= Y[3] / i.cameraToCenterDistance : f && !d && (x *= i.cameraToCenterDistance / Y[3]), d) {
                        const X = Q((C.y / yt + w.y) / (1 << w.z));
                        x /= i.projection.pixelsPerMeter(X, 1) / U(1, X)
                    }
                    if (ir(H, N, x)) return !0
                }
                return !1
            }

            function AL(n, e, i, a) {
                const c = Ir([], [n, e, i, 1], a);
                return new Ze(c[0] / c[3], c[1] / c[3])
            }

            const aS = $t(0, 0, 0), IL = $t(0, 0, 1);

            function CL(n, e) {
                const i = Ht();
                return aS[2] = e, n.intersectsPlane(aS, IL, i), new Ze(i[0], i[1])
            }

            class lS extends Yi {
            }

            let cS, uS, hS, dS;

            function fS(n, {width: e, height: i}, a, c) {
                if (c) {
                    if (c instanceof Uint8ClampedArray) c = new Uint8Array(c.buffer); else if (c.length !== e * i * a) throw new RangeError("mismatched image size")
                } else c = new Uint8Array(e * i * a);
                return n.width = e, n.height = i, n.data = c, n
            }

            function pS(n, e, i) {
                const {width: a, height: c} = e;
                a === n.width && c === n.height || (S1(n, e, {x: 0, y: 0}, {x: 0, y: 0}, {
                    width: Math.min(n.width, a),
                    height: Math.min(n.height, c)
                }, i, null), n.width = a, n.height = c, n.data = e.data)
            }

            function S1(n, e, i, a, c, d, f, _) {
                if (c.width === 0 || c.height === 0) return e;
                if (c.width > n.width || c.height > n.height || i.x > n.width - c.width || i.y > n.height - c.height) throw new RangeError("out of range source coordinates for image copy");
                if (c.width > e.width || c.height > e.height || a.x > e.width - c.width || a.y > e.height - c.height) throw new RangeError("out of range destination coordinates for image copy");
                const x = n.data, w = e.data, E = d === 4 && _;
                for (let I = 0; I < c.height; I++) {
                    const C = ((i.y + I) * n.width + i.x) * d, z = ((a.y + I) * e.width + a.x) * d;
                    if (E) for (let L = 0; L < c.width; L++) {
                        const F = C + L * d + 3, N = z + L * d;
                        w[N + 0] = 255, w[N + 1] = 255, w[N + 2] = 255, w[N + 3] = x[F]
                    } else if (f) for (let L = 0; L < c.width; L++) {
                        const F = C + L * d, N = z + L * d,
                            H = new Ji(x[F + 0] / 255, x[F + 1] / 255, x[F + 2] / 255, x[F + 3]).toNonPremultipliedRenderColor(f).toArray();
                        w[N + 0] = H[0], w[N + 1] = H[1], w[N + 2] = H[2], w[N + 3] = H[3]
                    } else for (let L = 0; L < c.width * d; L++) w[z + L] = x[C + L]
                }
                return e
            }

            Pt(lS, "HeatmapBucket", {omit: ["layers"]});

            class eu {
                constructor(e, i) {
                    fS(this, e, 1, i)
                }

                resize(e) {
                    pS(this, new eu(e), 1)
                }

                clone() {
                    return new eu({width: this.width, height: this.height}, new Uint8Array(this.data))
                }

                static copy(e, i, a, c, d) {
                    S1(e, i, a, c, d, 1, null)
                }
            }

            class $r {
                constructor(e, i) {
                    fS(this, e, 4, i)
                }

                resize(e) {
                    pS(this, new $r(e), 4)
                }

                replace(e, i) {
                    i ? this.data.set(e) : this.data = e instanceof Uint8ClampedArray ? new Uint8Array(e.buffer) : e
                }

                clone() {
                    return new $r({width: this.width, height: this.height}, new Uint8Array(this.data))
                }

                static copy(e, i, a, c, d, f, _) {
                    S1(e, i, a, c, d, 4, f, _)
                }
            }

            class mS {
                constructor(e, i) {
                    this.width = e.width, this.height = e.height, this.data = i instanceof Uint8Array ? new Float32Array(i.buffer) : i
                }
            }

            function $m(n) {
                const e = {}, i = n.resolution || 256, a = n.clips ? n.clips.length : 1,
                    c = n.image || new $r({width: i, height: a}), d = (f, _, x) => {
                        e[n.evaluationKey] = x;
                        const w = n.expression.evaluate(e), E = w ? w.toNonPremultipliedRenderColor(null) : null;
                        E && (c.data[f + _ + 0] = Math.floor(255 * E.r), c.data[f + _ + 1] = Math.floor(255 * E.g), c.data[f + _ + 2] = Math.floor(255 * E.b), c.data[f + _ + 3] = Math.floor(255 * E.a))
                    };
                if (n.clips) for (let f = 0, _ = 0; f < a; ++f, _ += 4 * i) for (let x = 0, w = 0; x < i; x++, w += 4) {
                    const E = x / (i - 1), {start: I, end: C} = n.clips[f];
                    d(_, w, I * (1 - E) + C * E)
                } else for (let f = 0, _ = 0; f < i; f++, _ += 4) d(0, _, f / (i - 1));
                return c
            }

            Pt(eu, "AlphaImage"), Pt($r, "RGBAImage");
            const PL = Fi([{name: "a_pos", components: 2, type: "Int16"}], 4),
                ML = Fi([{name: "a_road_z_offset", components: 1, type: "Float32"}], 4),
                RL = Fi([{name: "a_pos", components: 2, type: "Int16"}, {
                    name: "a_height",
                    components: 1,
                    type: "Float32"
                }], 4), zL = Fi([{name: "a_pos_normal_3", components: 3, type: "Int16"}], 4);

            function df(n, e, i = 2) {
                const a = e && e.length, c = a ? e[0] * i : n.length;
                let d = gS(n, 0, c, i, !0);
                const f = [];
                if (!d || d.next === d.prev) return f;
                let _, x, w;
                if (a && (d = function (E, I, C, z) {
                    const L = [];
                    for (let F = 0, N = I.length; F < N; F++) {
                        const H = gS(E, I[F] * z, F < N - 1 ? I[F + 1] * z : E.length, z, !1);
                        H === H.next && (H.steiner = !0), L.push(jL(H))
                    }
                    L.sort(FL);
                    for (let F = 0; F < L.length; F++) C = BL(L[F], C);
                    return C
                }(n, e, d, i)), n.length > 80 * i) {
                    _ = n[0], x = n[1];
                    let E = _, I = x;
                    for (let C = i; C < c; C += i) {
                        const z = n[C], L = n[C + 1];
                        z < _ && (_ = z), L < x && (x = L), z > E && (E = z), L > I && (I = L)
                    }
                    w = Math.max(E - _, I - x), w = w !== 0 ? 32767 / w : 0
                }
                return Hm(d, f, i, _, x, w, 0), f
            }

            function gS(n, e, i, a, c) {
                let d;
                if (c === function (f, _, x, w) {
                    let E = 0;
                    for (let I = _, C = x - w; I < x; I += w) E += (f[C] - f[I]) * (f[I + 1] + f[C + 1]), C = I;
                    return E
                }(n, e, i, a) > 0) for (let f = e; f < i; f += a) d = xS(f / a | 0, n[f], n[f + 1], d); else for (let f = i - a; f >= e; f -= a) d = xS(f / a | 0, n[f], n[f + 1], d);
                return d && ff(d, d.next) && (Zm(d), d = d.next), d
            }

            function zh(n, e) {
                if (!n) return n;
                e || (e = n);
                let i, a = n;
                do if (i = !1, a.steiner || !ff(a, a.next) && br(a.prev, a, a.next) !== 0) a = a.next; else {
                    if (Zm(a), a = e = a.prev, a === a.next) break;
                    i = !0
                } while (i || a !== e);
                return e
            }

            function Hm(n, e, i, a, c, d, f) {
                if (!n) return;
                !f && d && function (x, w, E, I) {
                    let C = x;
                    do C.z === 0 && (C.z = E1(C.x, C.y, w, E, I)), C.prevZ = C.prev, C.nextZ = C.next, C = C.next; while (C !== x);
                    C.prevZ.nextZ = null, C.prevZ = null, function (z) {
                        let L, F = 1;
                        do {
                            let N, H = z;
                            z = null;
                            let Y = null;
                            for (L = 0; H;) {
                                L++;
                                let X = H, J = 0;
                                for (let ge = 0; ge < F && (J++, X = X.nextZ, X); ge++) ;
                                let xe = F;
                                for (; J > 0 || xe > 0 && X;) J !== 0 && (xe === 0 || !X || H.z <= X.z) ? (N = H, H = H.nextZ, J--) : (N = X, X = X.nextZ, xe--), Y ? Y.nextZ = N : z = N, N.prevZ = Y, Y = N;
                                H = X
                            }
                            Y.nextZ = null, F *= 2
                        } while (L > 1)
                    }(C)
                }(n, a, c, d);
                let _ = n;
                for (; n.prev !== n.next;) {
                    const x = n.prev, w = n.next;
                    if (d ? LL(n, a, c, d) : DL(n)) e.push(x.i, n.i, w.i), Zm(n), n = w.next, _ = w.next; else if ((n = w) === _) {
                        f ? f === 1 ? Hm(n = kL(zh(n), e), e, i, a, c, d, 2) : f === 2 && OL(n, e, i, a, c, d) : Hm(zh(n), e, i, a, c, d, 1);
                        break
                    }
                }
            }

            function DL(n) {
                const e = n.prev, i = n, a = n.next;
                if (br(e, i, a) >= 0) return !1;
                const c = e.x, d = i.x, f = a.x, _ = e.y, x = i.y, w = a.y, E = Math.min(c, d, f),
                    I = Math.min(_, x, w), C = Math.max(c, d, f), z = Math.max(_, x, w);
                let L = a.next;
                for (; L !== e;) {
                    if (L.x >= E && L.x <= C && L.y >= I && L.y <= z && qm(c, _, d, x, f, w, L.x, L.y) && br(L.prev, L, L.next) >= 0) return !1;
                    L = L.next
                }
                return !0
            }

            function LL(n, e, i, a) {
                const c = n.prev, d = n, f = n.next;
                if (br(c, d, f) >= 0) return !1;
                const _ = c.x, x = d.x, w = f.x, E = c.y, I = d.y, C = f.y, z = Math.min(_, x, w),
                    L = Math.min(E, I, C), F = Math.max(_, x, w), N = Math.max(E, I, C), H = E1(z, L, e, i, a),
                    Y = E1(F, N, e, i, a);
                let X = n.prevZ, J = n.nextZ;
                for (; X && X.z >= H && J && J.z <= Y;) {
                    if (X.x >= z && X.x <= F && X.y >= L && X.y <= N && X !== c && X !== f && qm(_, E, x, I, w, C, X.x, X.y) && br(X.prev, X, X.next) >= 0 || (X = X.prevZ, J.x >= z && J.x <= F && J.y >= L && J.y <= N && J !== c && J !== f && qm(_, E, x, I, w, C, J.x, J.y) && br(J.prev, J, J.next) >= 0)) return !1;
                    J = J.nextZ
                }
                for (; X && X.z >= H;) {
                    if (X.x >= z && X.x <= F && X.y >= L && X.y <= N && X !== c && X !== f && qm(_, E, x, I, w, C, X.x, X.y) && br(X.prev, X, X.next) >= 0) return !1;
                    X = X.prevZ
                }
                for (; J && J.z <= Y;) {
                    if (J.x >= z && J.x <= F && J.y >= L && J.y <= N && J !== c && J !== f && qm(_, E, x, I, w, C, J.x, J.y) && br(J.prev, J, J.next) >= 0) return !1;
                    J = J.nextZ
                }
                return !0
            }

            function kL(n, e) {
                let i = n;
                do {
                    const a = i.prev, c = i.next.next;
                    !ff(a, c) && yS(a, i, i.next, c) && Wm(a, c) && Wm(c, a) && (e.push(a.i, i.i, c.i), Zm(i), Zm(i.next), i = n = c), i = i.next
                } while (i !== n);
                return zh(i)
            }

            function OL(n, e, i, a, c, d) {
                let f = n;
                do {
                    let _ = f.next.next;
                    for (; _ !== f.prev;) {
                        if (f.i !== _.i && VL(f, _)) {
                            let x = vS(f, _);
                            return f = zh(f, f.next), x = zh(x, x.next), Hm(f, e, i, a, c, d, 0), void Hm(x, e, i, a, c, d, 0)
                        }
                        _ = _.next
                    }
                    f = f.next
                } while (f !== n)
            }

            function FL(n, e) {
                let i = n.x - e.x;
                return i === 0 && (i = n.y - e.y, i === 0) && (i = (n.next.y - n.y) / (n.next.x - n.x) - (e.next.y - e.y) / (e.next.x - e.x)), i
            }

            function BL(n, e) {
                const i = function (c, d) {
                    let f = d;
                    const _ = c.x, x = c.y;
                    let w, E = -1 / 0;
                    if (ff(c, f)) return f;
                    do {
                        if (ff(c, f.next)) return f.next;
                        if (x <= f.y && x >= f.next.y && f.next.y !== f.y) {
                            const F = f.x + (x - f.y) * (f.next.x - f.x) / (f.next.y - f.y);
                            if (F <= _ && F > E && (E = F, w = f.x < f.next.x ? f : f.next, F === _)) return w
                        }
                        f = f.next
                    } while (f !== d);
                    if (!w) return null;
                    const I = w, C = w.x, z = w.y;
                    let L = 1 / 0;
                    f = w;
                    do {
                        if (_ >= f.x && f.x >= C && _ !== f.x && _S(x < z ? _ : E, x, C, z, x < z ? E : _, x, f.x, f.y)) {
                            const F = Math.abs(x - f.y) / (_ - f.x);
                            Wm(f, c) && (F < L || F === L && (f.x > w.x || f.x === w.x && NL(w, f))) && (w = f, L = F)
                        }
                        f = f.next
                    } while (f !== I);
                    return w
                }(n, e);
                if (!i) return e;
                const a = vS(i, n);
                return zh(a, a.next), zh(i, i.next)
            }

            function NL(n, e) {
                return br(n.prev, n, e.prev) < 0 && br(e.next, n, n.next) < 0
            }

            function E1(n, e, i, a, c) {
                return (n = 1431655765 & ((n = 858993459 & ((n = 252645135 & ((n = 16711935 & ((n = (n - i) * c | 0) | n << 8)) | n << 4)) | n << 2)) | n << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - a) * c | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
            }

            function jL(n) {
                let e = n, i = n;
                do (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e), e = e.next; while (e !== n);
                return i
            }

            function _S(n, e, i, a, c, d, f, _) {
                return (c - f) * (e - _) >= (n - f) * (d - _) && (n - f) * (a - _) >= (i - f) * (e - _) && (i - f) * (d - _) >= (c - f) * (a - _)
            }

            function qm(n, e, i, a, c, d, f, _) {
                return !(n === f && e === _) && _S(n, e, i, a, c, d, f, _)
            }

            function VL(n, e) {
                return n.next.i !== e.i && n.prev.i !== e.i && !function (i, a) {
                    let c = i;
                    do {
                        if (c.i !== i.i && c.next.i !== i.i && c.i !== a.i && c.next.i !== a.i && yS(c, c.next, i, a)) return !0;
                        c = c.next
                    } while (c !== i);
                    return !1
                }(n, e) && (Wm(n, e) && Wm(e, n) && function (i, a) {
                    let c = i, d = !1;
                    const f = (i.x + a.x) / 2, _ = (i.y + a.y) / 2;
                    do c.y > _ != c.next.y > _ && c.next.y !== c.y && f < (c.next.x - c.x) * (_ - c.y) / (c.next.y - c.y) + c.x && (d = !d), c = c.next; while (c !== i);
                    return d
                }(n, e) && (br(n.prev, n, e.prev) || br(n, e.prev, e)) || ff(n, e) && br(n.prev, n, n.next) > 0 && br(e.prev, e, e.next) > 0)
            }

            function br(n, e, i) {
                return (e.y - n.y) * (i.x - e.x) - (e.x - n.x) * (i.y - e.y)
            }

            function ff(n, e) {
                return n.x === e.x && n.y === e.y
            }

            function yS(n, e, i, a) {
                const c = Hy(br(n, e, i)), d = Hy(br(n, e, a)), f = Hy(br(i, a, n)), _ = Hy(br(i, a, e));
                return c !== d && f !== _ || !(c !== 0 || !$y(n, i, e)) || !(d !== 0 || !$y(n, a, e)) || !(f !== 0 || !$y(i, n, a)) || !(_ !== 0 || !$y(i, e, a))
            }

            function $y(n, e, i) {
                return e.x <= Math.max(n.x, i.x) && e.x >= Math.min(n.x, i.x) && e.y <= Math.max(n.y, i.y) && e.y >= Math.min(n.y, i.y)
            }

            function Hy(n) {
                return n > 0 ? 1 : n < 0 ? -1 : 0
            }

            function Wm(n, e) {
                return br(n.prev, n, n.next) < 0 ? br(n, e, n.next) >= 0 && br(n, n.prev, e) >= 0 : br(n, e, n.prev) < 0 || br(n, n.next, e) < 0
            }

            function vS(n, e) {
                const i = A1(n.i, n.x, n.y), a = A1(e.i, e.x, e.y), c = n.next, d = e.prev;
                return n.next = e, e.prev = n, i.next = c, c.prev = i, a.next = i, i.prev = a, d.next = a, a.prev = d, a
            }

            function xS(n, e, i, a) {
                const c = A1(n, e, i);
                return a ? (c.next = a.next, c.prev = a, a.next.prev = c, a.next = c) : (c.prev = c, c.next = c), c
            }

            function Zm(n) {
                n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ)
            }

            function A1(n, e, i) {
                return {i: n, x: e, y: i, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1}
            }

            function Xm(n, e) {
                const i = n.length;
                if (i <= 1) return [n];
                const a = [];
                let c, d;
                for (let f = 0; f < i; f++) {
                    const _ = mr(n[f]);
                    _ !== 0 && (n[f].area = Math.abs(_), d === void 0 && (d = _ < 0), d === _ < 0 ? (c && a.push(c), c = [n[f]]) : c.push(n[f]))
                }
                if (c && a.push(c), e > 1) for (let f = 0; f < a.length; f++) a[f].length <= e || (eo(a[f], e, 1, a[f].length - 1, UL), a[f] = a[f].slice(0, e));
                return a
            }

            function UL(n, e) {
                return e.area - n.area
            }

            function wS(n, e, i = 1) {
                if (!n) return null;
                const a = typeof n == "string" ? Ao.from(n).getPrimary() : n.getPrimary(),
                    c = typeof n == "string" ? null : n.getSecondary();
                for (const d of [a, c]) {
                    if (!d) continue;
                    const f = d.id.toString();
                    e.has(f) || e.set(f, []), d.scaleSelf(i), e.get(f).push(d)
                }
                return {primary: a.toString(), secondary: c ? c.toString() : null}
            }

            function I1(n, e, i, a) {
                const c = a.patternDependencies;
                let d = !1;
                for (const f of e) {
                    const _ = f.paint.get(`${n}-pattern`);
                    _.isConstant() || (d = !0), wS(_.constantOr(null), c, i) && (d = !0)
                }
                return d
            }

            function C1(n, e, i, a, c, d) {
                const f = d.patternDependencies;
                for (const _ of e) {
                    const x = _.paint.get(`${n}-pattern`).value;
                    if (x.kind !== "constant") {
                        let w = x.evaluate({zoom: a}, i, {}, d.availableImages);
                        w = w && w.name ? w.name : w;
                        const E = wS(w, f, c);
                        if (!E) continue;
                        const {primary: I, secondary: C} = E;
                        I && (i.patterns[_.id] = [I, C].filter(Boolean))
                    }
                }
                return i
            }

            class bS {
                constructor() {
                    this.polygons = new Map
                }

                add(e, ...i) {
                    this.polygons.has(e) ? this.polygons.get(e).push(...i) : this.polygons.set(e, i)
                }

                merge(e) {
                    for (const [i, a] of e.polygons) this.add(i, ...a)
                }
            }

            class Dh {
                constructor() {
                    this.portals = []
                }

                static evaluate(e) {
                    if (e.length === 0) return new Dh;
                    let i = [];
                    for (const w of e) i.push(...w.portals);
                    if (i.length === 0) return new Dh;
                    const a = (w, E) => w <= 0 && E <= 0 || w >= yt && E >= yt;
                    for (const w of i) {
                        const E = w.va, I = w.vb;
                        (a(E.x, I.x) || a(E.y, I.y)) && (w.type = "border")
                    }
                    const c = i.filter(w => w.type !== "unevaluated"), d = i.filter(w => w.type === "unevaluated");
                    if (d.length === 0) return new Dh;
                    d.sort((w, E) => w.hash === E.hash ? w.isTunnel === E.isTunnel ? 0 : w.isTunnel ? -1 : 1 : w.hash < E.hash ? 1 : -1), i = c.concat(d);
                    let f = c.length, _ = f, x = f;
                    do if (_++, _ === i.length || i[f].hash !== i[_].hash) {
                        if (_ - f == 2) {
                            x < f && (i[x] = i[f], i[f] = null);
                            const w = i[x], E = i[_ - 1];
                            w.type = w.isTunnel !== E.isTunnel ? "tunnel" : "polygon", w.connection = {
                                a: w.connection.a,
                                b: E.connection.a
                            }, x++
                        }
                        f = _
                    } while (f !== i.length);
                    return i.splice(x), i.sort((w, E) => w.hash < E.hash ? 1 : -1), {portals: i}
                }
            }

            Pt(Dh, "ElevationPortalGraph"), Pt(bS, "ElevationPolygons");

            class GL {
                constructor(e, i, a) {
                    this.outPositions = e, this.outNormals = i, this.outIndices = a, this.vertexLookup = new Map, this.buffer = new ArrayBuffer(4), this.view = new DataView(this.buffer)
                }

                addVertex(e, i, a) {
                    let c = e[2];
                    a != null && (c *= a);
                    const d = this.getVec3Bits(e) << 96n | this.getVec3Bits(i), f = this.vertexLookup.get(d);
                    if (f != null) return f;
                    const _ = this.outPositions.length;
                    this.vertexLookup.set(d, _);
                    const x = Math.trunc(16384 * i[0]), w = Math.trunc(16384 * i[1]), E = Math.trunc(16384 * i[2]);
                    return this.outPositions.emplaceBack(e[0], e[1], c), this.outNormals.emplaceBack(x, w, E), _
                }

                addTriangle(e, i, a) {
                    this.outIndices.emplaceBack(e, i, a)
                }

                addTriangles(e, i, a) {
                    if (e.length === 0) return;
                    const c = a.length === 1, d = Ht(), f = Ht();
                    for (let _ = 0; _ < e.length; _ += 3) {
                        const x = i[e[_ + 0]], w = i[e[_ + 1]], E = i[e[_ + 2]], I = c ? a[0] : a[e[_ + 1]],
                            C = c ? a[0] : a[e[_ + 2]];
                        _i(d, x.x, x.y, c ? a[0] : a[e[_ + 0]]);
                        const z = this.addVertex(d, f);
                        _i(d, w.x, w.y, I);
                        const L = this.addVertex(d, f);
                        _i(d, E.x, E.y, C);
                        const F = this.addVertex(d, f);
                        this.outIndices.emplaceBack(z, L, F)
                    }
                }

                addQuad(e, i, a, c, d, f) {
                    const _ = this.addVertex(e, d, f), x = this.addVertex(i, d, f), w = this.addVertex(a, d, f),
                        E = this.addVertex(c, d, f);
                    this.addTriangle(_, x, w), this.addTriangle(w, E, _)
                }

                getVertexCount() {
                    return this.outPositions.length
                }

                clearVertexLookup() {
                    this.vertexLookup.clear()
                }

                getBits(e) {
                    return this.view.setFloat32(0, e), BigInt(this.view.getUint32(0))
                }

                getVec3Bits(e) {
                    return this.getBits(e[0]) << 64n | this.getBits(e[1]) << 32n | this.getBits(e[2])
                }
            }

            class os {
                constructor(e, i, a, c) {
                    this.unevaluatedPortals = new Dh, this.portalPolygons = new bS, this.bridgeFeatureSections = [], this.tunnelFeatureSections = [], this.vertexHashLookup = new Map, this.unevalVertices = [], this.unevalHeights = [], this.unevalTriangles = [], this.unevalTunnelTriangles = [], this.unevalEdges = [], this.vertexPositions = new Sm, this.vertexNormals = new Em, this.indexArray = new Mn, this.tileToMeters = he(e), this.bridgeProgramConfigurations = new es(i, {
                        zoom: a,
                        lut: c
                    }, d => d !== "fill-tunnel-structure-color"), this.tunnelProgramConfigurations = new es(i, {
                        zoom: a,
                        lut: c
                    }, d => d !== "fill-bridge-guard-rail-color")
                }

                addVertices(e, i) {
                    const a = this.unevalVertices.length;
                    for (let c = 0; c < e.length; c++) this.unevalVertices.push(e[c]), this.unevalHeights.push(i[c]);
                    return a
                }

                addTriangles(e, i, a) {
                    const c = a ? this.unevalTunnelTriangles : this.unevalTriangles;
                    for (const d of e) c.push(d + i)
                }

                addRenderableRing(e, i, a, c, d, f) {
                    const _ = [new Ze(d.min.x, d.min.y), new Ze(d.max.x, d.min.y), new Ze(d.max.x, d.max.y), new Ze(d.min.x, d.max.y)];
                    for (let x = 0; x < a - 1; x++) {
                        const w = i + x, E = w + 1, I = this.unevalVertices[w], C = this.unevalVertices[E];
                        if (!(I.x >= d.min.x && I.x <= d.max.x && I.y >= d.min.y && I.y <= d.max.y || C.x >= d.min.x && C.x <= d.max.x && C.y >= d.min.y && C.y <= d.max.y || Un(I, C, _)) || this.isOnBorder(I.x, C.x) || this.isOnBorder(I.y, C.y)) continue;
                        const z = os.computeEdgeHash(this.unevalVertices[w], this.unevalVertices[E]);
                        let L, F = this.vertexHashLookup.get(os.computePosHash(I));
                        F != null ? L = F.next : (F = this.vertexHashLookup.get(os.computePosHash(C)), L = F != null ? F.prev : z), this.unevalEdges.push({
                            polygonIdx: e,
                            a: w,
                            b: E,
                            hash: z,
                            portalHash: L,
                            isTunnel: c,
                            type: "unevaluated",
                            featureInfo: f
                        })
                    }
                }

                addPortalCandidates(e, i, a, c, d) {
                    if (i.length === 0) return;
                    this.portalPolygons.add(e, {geometry: i, zLevel: d});
                    const f = i[0];
                    this.vertexHashLookup.clear();
                    let _ = os.computeEdgeHash(f[f.length - 2], f[f.length - 1]);
                    for (let x = 0; x < f.length - 1; x++) {
                        const w = f[x + 0], E = f[x + 1], I = uo(E.x - w.x, E.y - w.y), C = bo(I);
                        if (C === 0) continue;
                        let z = "unevaluated";
                        const L = c.pointElevation(w), F = c.pointElevation(E);
                        Math.abs(L) < .01 && Math.abs(F) < .01 ? z = "entrance" : (this.isOnBorder(w.x, E.x) || this.isOnBorder(w.y, E.y)) && (z = "border");
                        const N = os.computeEdgeHash(w, E);
                        this.unevaluatedPortals.portals.push({
                            connection: {a: e, b: void 0},
                            va: w,
                            vb: E,
                            vab: I,
                            length: C,
                            hash: N,
                            isTunnel: a,
                            type: z
                        });
                        const H = os.computePosHash(w);
                        this.vertexHashLookup.set(H, {prev: _, next: N}), _ = N
                    }
                }

                construct(e) {
                    if (this.unevalVertices.length === 0) return;
                    const i = () => ({vertexOffset: 0, primitiveOffset: this.indexArray.length}), a = C => {
                        C.primitiveLength = this.indexArray.length - C.primitiveOffset
                    }, c = new GL(this.vertexPositions, this.vertexNormals, this.indexArray);
                    this.prepareEdges(e.portals, this.unevalEdges);
                    const d = i(), f = i(), _ = i(), x = (C, z) => {
                        C.sort((F, N) => F.type === z && N.type !== z ? -1 : F.type !== z && N.type === z ? 1 : 0);
                        const L = C.findIndex(F => F.type !== z);
                        return L >= 0 ? L : C.length
                    };
                    let w = 0;
                    this.unevalEdges.length > 0 && (w = x(this.unevalEdges, "none"), this.constructBridgeStructures(c, this.unevalVertices, this.unevalHeights, this.unevalEdges, {
                        min: 0,
                        max: w
                    }, this.tileToMeters)), a(_);
                    const E = i(), I = i();
                    if (this.unevalEdges.length > 0) {
                        const C = this.unevalEdges.splice(w), z = x(C, "tunnel") + w;
                        this.unevalEdges.push(...C), this.constructTunnelStructures(c, this.unevalVertices, this.unevalHeights, this.unevalEdges, {
                            min: 0,
                            max: w
                        }, {min: w, max: z})
                    }
                    a(E), c.addTriangles(this.unevalTriangles, this.unevalVertices, this.unevalHeights), a(I), c.addTriangles(this.unevalTunnelTriangles, this.unevalVertices, this.unevalHeights), a(f), c.addTriangles(this.unevalTunnelTriangles, this.unevalVertices, [-.1]), a(d), this.maskSegments = Ln.simpleSegment(0, I.primitiveOffset, 0, I.primitiveLength), this.depthSegments = Ln.simpleSegment(0, f.primitiveOffset, 0, f.primitiveLength), this.renderableBridgeSegments = Ln.simpleSegment(0, _.primitiveOffset, 0, _.primitiveLength), this.renderableTunnelSegments = Ln.simpleSegment(0, E.primitiveOffset, 0, E.primitiveLength), this.shadowCasterSegments = Ln.simpleSegment(0, d.primitiveOffset, 0, d.primitiveLength)
                }

                update(e, i, a, c, d, f, _, x) {
                    this.bridgeProgramConfigurations.updatePaintArrays(e, i, d, a, c, f, _, x), this.tunnelProgramConfigurations.updatePaintArrays(e, i, d, a, c, f, _, x)
                }

                upload(e) {
                    this.vertexBuffer || this.vertexPositions.length === 0 || this.vertexNormals.length === 0 || this.indexArray.length === 0 || (this.vertexBuffer = e.createVertexBuffer(this.vertexPositions, RL.members), this.vertexBufferNormal = e.createVertexBuffer(this.vertexNormals, zL.members), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.bridgeProgramConfigurations.upload(e), this.tunnelProgramConfigurations.upload(e))
                }

                destroy() {
                    this.vertexBuffer && (this.vertexBuffer.destroy(), this.vertexBufferNormal.destroy(), this.indexBuffer.destroy()), this.maskSegments && (this.maskSegments.destroy(), this.depthSegments.destroy(), this.renderableBridgeSegments.destroy(), this.renderableTunnelSegments.destroy(), this.shadowCasterSegments.destroy()), this.bridgeProgramConfigurations.destroy(), this.tunnelProgramConfigurations.destroy()
                }

                populatePaintArrays(e, i, a, c, d) {
                    const f = (_, x) => {
                        for (let w = 0; w < x.length - 1; w++) {
                            const E = x[w].featureIndex, I = x[w + 1].vertexStart, C = e.feature(E);
                            _.populatePaintArrays(I, C, E, {}, a, i, c, void 0, d)
                        }
                    };
                    f(this.bridgeProgramConfigurations, this.bridgeFeatureSections), f(this.tunnelProgramConfigurations, this.tunnelFeatureSections)
                }

                computeVertexConnections(e, i, a, c, d) {
                    const f = new Map;
                    for (let _ = c; _ < d; _++) {
                        const x = a[_], w = x.a, E = x.b, I = os.computePosHash(e[w]), C = os.computePosHash(e[E]);
                        let z = f.get(I);
                        z || (z = {}, f.set(I, z));
                        let L = f.get(C);
                        L || (L = {}, f.set(C, L)), i[w] <= 0 && i[E] <= 0 || (z.to = E, L.from = w)
                    }
                    return f
                }

                isTerminalVertex(e, i) {
                    const a = os.computePosHash(this.unevalVertices[e]), c = i.get(a);
                    return !c || !c.from || !c.to
                }

                constructBridgeStructures(e, i, a, c, d, f) {
                    e.clearVertexLookup();
                    const _ = this.computeVertexConnections(i, a, c, d.min, d.max), x = 1 / f, w = .5 * x,
                        E = (ot, ct) => _i(ot, i[ct].x, i[ct].y, a[ct] * x), I = Ht(), C = Ht(), z = Ht(), L = Ht(),
                        F = Ht(), N = (ot, ct) => {
                            const He = _.get(os.computePosHash(i[ct])), st = He.from, ke = He.to;
                            if (!st || !ke) return;
                            E(I, st), E(C, ct), E(z, ke), Do(L), Xr(I, C) || (Nn(F, C, I), Bi(L, F)), Xr(z, C) || (Nn(F, z, C), si(L, L, Bi(F, F)));
                            const qe = fs(L);
                            return qe > 0 ? ai(ot, L, 1 / qe) : void 0
                        };
                    let H = Number.POSITIVE_INFINITY;
                    this.sortSubarray(c, d.min, d.max, (ot, ct) => ot.featureInfo.featureIndex - ct.featureInfo.featureIndex);
                    const Y = Ht(), X = Ht(), J = Ht(), xe = Ht(), ge = Ht(), ye = Ht(), Ee = Ht(), Ie = Ht(),
                        We = Ht(), De = [Ht(), Ht(), Ht(), Ht()], Ye = [Ht(), Ht(), Ht(), Ht()],
                        ht = [{coord: new Ze(0, 0), height: 0}, {coord: new Ze(0, 0), height: 0}],
                        Qe = (ot, ct) => ot > ct;
                    for (let ot = d.min; ot < d.max; ot++) {
                        const ct = c[ot];
                        if (!ct.featureInfo.guardRailEnabled || !this.prepareEdgePoints(ht, i, a, ct, Qe)) continue;
                        const [He, st] = ht;
                        if (_i(Y, He.coord.x, He.coord.y, x * He.height), _i(X, st.coord.x, st.coord.y, x * st.height), Xr(Y, X)) continue;
                        Nn(J, X, Y), Bi(J, J);
                        const ke = N(Ie, ct.a) || J, qe = N(We, ct.b) || J;
                        _i(xe, ke[1], -ke[0], 0), Bi(xe, xe), _i(ge, qe[1], -qe[0], 0), Bi(ge, ge), Bn(Ie, xe, ke), Bi(ye, Ie), Bn(Ie, ge, qe), Bi(Ee, Ie), si(De[0], Y, ai(Ie, Nn(Ie, xe, ye), w)), si(De[1], Y, ai(Ie, si(Ie, xe, ye), w)), si(De[2], Y, ai(Ie, ye, w)), De[3] = Y, si(Ye[0], X, ai(Ie, Nn(Ie, ge, Ee), w)), si(Ye[1], X, ai(Ie, si(Ie, ge, Ee), w)), si(Ye[2], X, ai(Ie, Ee, w)), Ye[3] = X, H = this.addFeatureSection(ct.featureInfo.featureIndex, H, this.bridgeFeatureSections, e);
                        const pt = e.addVertex(De[0], xe, f), at = e.addVertex(De[1], xe, f),
                            Bt = e.addVertex(Ye[0], ge, f), zt = e.addVertex(Ye[1], ge, f);
                        e.addTriangle(pt, at, Bt), e.addTriangle(at, zt, Bt);
                        const nt = e.addVertex(De[1], ye, f), lt = e.addVertex(De[2], ye, f),
                            kt = e.addVertex(Ye[1], Ee, f), Et = e.addVertex(Ye[2], Ee, f);
                        e.addTriangle(nt, lt, kt), e.addTriangle(lt, Et, kt), Zn(xe, xe), Zn(ge, ge);
                        const vt = e.addVertex(De[2], xe, f), At = e.addVertex(De[3], xe, f),
                            Kt = e.addVertex(Ye[2], ge, f), oi = e.addVertex(Ye[3], ge, f);
                        e.addTriangle(vt, At, Kt), e.addTriangle(At, oi, Kt);
                        const pi = this.isTerminalVertex(ct.a, _), ui = this.isTerminalVertex(ct.b, _);
                        He.height < .01 && pi && e.addQuad(De[3], De[2], De[1], De[0], Zn(ke, ke), f), st.height < .01 && ui && e.addQuad(Ye[0], Ye[1], Ye[2], Ye[3], qe, f)
                    }
                    this.bridgeFeatureSections.push({
                        featureIndex: Number.POSITIVE_INFINITY,
                        vertexStart: e.getVertexCount()
                    })
                }

                constructTunnelStructures(e, i, a, c, d, f) {
                    e.clearVertexLookup();
                    let _ = Number.POSITIVE_INFINITY;
                    const x = (H, Y) => H.featureInfo.featureIndex - Y.featureInfo.featureIndex;
                    this.sortSubarray(c, d.min, d.max, x), this.sortSubarray(c, f.min, f.max, x);
                    const w = H => Bi(H, H), E = [{coord: new Ze(0, 0), height: 0}, {coord: new Ze(0, 0), height: 0}],
                        I = (H, Y) => H < Y, C = Ht(), z = Ht(), L = Ht(), F = Ht(), N = Ht();
                    for (let H = d.min; H < d.max; H++) {
                        if (!this.prepareEdgePoints(E, i, a, c[H], I)) continue;
                        const [Y, X] = E, J = w(_i(N, -(X.coord.y - Y.coord.y), X.coord.x - Y.coord.x, 0));
                        _ = this.addFeatureSection(c[H].featureInfo.featureIndex, _, this.tunnelFeatureSections, e), e.addQuad(_i(C, Y.coord.x, Y.coord.y, Y.height), _i(z, X.coord.x, X.coord.y, X.height), _i(L, X.coord.x, X.coord.y, c[H].isTunnel ? -.1 : 0), _i(F, Y.coord.x, Y.coord.y, c[H].isTunnel ? -.1 : 0), J)
                    }
                    for (let H = f.min; H < f.max; H++) {
                        const Y = c[H];
                        Y.isTunnel && ([Y.a, Y.b] = [Y.b, Y.a]);
                        const X = i[Y.a], J = i[Y.b], xe = w(_i(N, -(J.y - X.y), J.x - X.x, 0));
                        _ = this.addFeatureSection(Y.featureInfo.featureIndex, _, this.tunnelFeatureSections, e), e.addQuad(_i(C, J.x, J.y, 0), _i(z, X.x, X.y, 0), _i(L, X.x, X.y, a[Y.a] + 4), _i(F, J.x, J.y, a[Y.b] + 4), xe), e.addQuad(_i(C, X.x, X.y, 0), _i(z, J.x, J.y, 0), _i(L, J.x, J.y, a[Y.b] + 4), _i(F, X.x, X.y, a[Y.a] + 4), xe)
                    }
                    this.tunnelFeatureSections.push({
                        featureIndex: Number.POSITIVE_INFINITY,
                        vertexStart: e.getVertexCount()
                    })
                }

                setElevatedPoint(e, i, a, c) {
                    e.coord.x = i, e.coord.y = a, e.height = c
                }

                prepareEdgePoints(e, i, a, c, d) {
                    let f = i[c.a].x, _ = i[c.a].y, x = i[c.b].x, w = i[c.b].y, E = a[c.a], I = a[c.b];
                    const C = d(E, 0), z = d(I, 0);
                    if (C && z) return this.setElevatedPoint(e[0], f, _, E), this.setElevatedPoint(e[1], x, w, I), !0;
                    if (!C && !z) return !1;
                    if (C) {
                        if (!z) {
                            const L = I / (I - E);
                            x = qt(x, f, L), w = qt(w, _, L), I = qt(I, E, L)
                        }
                    } else {
                        const L = E / (E - I);
                        f = qt(f, x, L), _ = qt(_, w, L), E = qt(E, I, L)
                    }
                    return this.setElevatedPoint(e[0], f, _, E), this.setElevatedPoint(e[1], x, w, I), !0
                }

                prepareEdges(e, i) {
                    if (i.length === 0) return;
                    i.sort((_, x) => _.hash === x.hash ? x.polygonIdx - _.polygonIdx : x.hash > _.hash ? 1 : -1);
                    let a = 0, c = 0, d = 0, f = i[a].polygonIdx;
                    do c++, (c === i.length || i[a].hash !== i[c].hash) && ((c - a == 1 || i[c - 1].polygonIdx !== f) && (d < a && (i[d] = i[a], i[a] = null), i[d].type = "none", d++), a = c, a !== i.length && (f = i[a].polygonIdx)); while (a !== i.length);
                    if (i.splice(d), i.length !== 0 && e.length !== 0) {
                        i.sort((w, E) => w.portalHash < E.portalHash ? 1 : -1);
                        let _ = 0, x = 0;
                        for (; _ !== i.length && x !== e.length;) {
                            const w = i[_], E = e[x];
                            w.portalHash > E.hash ? _++ : E.hash > w.portalHash ? x++ : (w.type = E.type, _++)
                        }
                    }
                }

                isOnBorder(e, i) {
                    return e <= 0 && i <= 0 || e >= yt && i >= yt
                }

                addFeatureSection(e, i, a, c) {
                    return e !== i && (i = e, a.push({
                        featureIndex: e,
                        vertexStart: c.getVertexCount()
                    }), c.clearVertexLookup()), i
                }

                sortSubarray(e, i, a, c) {
                    const d = e.slice(i, a);
                    d.sort(c), e.splice(i, d.length, ...d)
                }

                static computeEdgeHash(e, i) {
                    return (e.y === i.y && e.x > i.x || e.y > i.y) && ([e, i] = [i, e]), BigInt(os.computePosHash(e)) << 32n | BigInt(os.computePosHash(i))
                }

                static computePosHash(e) {
                    return ((65535 & e.x) << 16 | 65535 & e.y) >>> 0
                }
            }

            var TS, SS = {exports: {}}, ES = (TS || (TS = 1, function (n, e) {
                (function (i) {
                    function a(ne, re) {
                        return ne > re ? 1 : ne < re ? -1 : 0
                    }

                    var c = function (ne, re) {
                        ne === void 0 && (ne = a), re === void 0 && (re = !1), this._compare = ne, this._root = null, this._size = 0, this._noDuplicates = !!re
                    }, d = {size: {configurable: !0}};

                    function f(ne, re, Ge, mt, bt) {
                        var wt = bt - mt;
                        if (wt > 0) {
                            var Lt = mt + Math.floor(wt / 2), ti = {key: re[Lt], data: Ge[Lt], parent: ne};
                            return ti.left = f(ti, re, Ge, mt, Lt), ti.right = f(ti, re, Ge, Lt + 1, bt), ti
                        }
                        return null
                    }

                    function _(ne, re, Ge, mt, bt) {
                        if (!(Ge >= mt)) {
                            for (var wt = ne[Ge + mt >> 1], Lt = Ge - 1, ti = mt + 1; ;) {
                                do Lt++; while (bt(ne[Lt], wt) < 0);
                                do ti--; while (bt(ne[ti], wt) > 0);
                                if (Lt >= ti) break;
                                var Ci = ne[Lt];
                                ne[Lt] = ne[ti], ne[ti] = Ci, Ci = re[Lt], re[Lt] = re[ti], re[ti] = Ci
                            }
                            _(ne, re, Ge, ti, bt), _(ne, re, ti + 1, mt, bt)
                        }
                    }

                    c.prototype.rotateLeft = function (ne) {
                        var re = ne.right;
                        re && (ne.right = re.left, re.left && (re.left.parent = ne), re.parent = ne.parent), ne.parent ? ne === ne.parent.left ? ne.parent.left = re : ne.parent.right = re : this._root = re, re && (re.left = ne), ne.parent = re
                    }, c.prototype.rotateRight = function (ne) {
                        var re = ne.left;
                        re && (ne.left = re.right, re.right && (re.right.parent = ne), re.parent = ne.parent), ne.parent ? ne === ne.parent.left ? ne.parent.left = re : ne.parent.right = re : this._root = re, re && (re.right = ne), ne.parent = re
                    }, c.prototype._splay = function (ne) {
                        for (; ne.parent;) {
                            var re = ne.parent;
                            re.parent ? re.left === ne && re.parent.left === re ? (this.rotateRight(re.parent), this.rotateRight(re)) : re.right === ne && re.parent.right === re ? (this.rotateLeft(re.parent), this.rotateLeft(re)) : re.left === ne && re.parent.right === re ? (this.rotateRight(re), this.rotateLeft(re)) : (this.rotateLeft(re), this.rotateRight(re)) : re.left === ne ? this.rotateRight(re) : this.rotateLeft(re)
                        }
                    }, c.prototype.splay = function (ne) {
                        for (var re, Ge, mt, bt, wt; ne.parent;) (Ge = (re = ne.parent).parent) && Ge.parent ? ((mt = Ge.parent).left === Ge ? mt.left = ne : mt.right = ne, ne.parent = mt) : (ne.parent = null, this._root = ne), bt = ne.left, wt = ne.right, ne === re.left ? (Ge && (Ge.left === re ? (re.right ? (Ge.left = re.right, Ge.left.parent = Ge) : Ge.left = null, re.right = Ge, Ge.parent = re) : (bt ? (Ge.right = bt, bt.parent = Ge) : Ge.right = null, ne.left = Ge, Ge.parent = ne)), wt ? (re.left = wt, wt.parent = re) : re.left = null, ne.right = re, re.parent = ne) : (Ge && (Ge.right === re ? (re.left ? (Ge.right = re.left, Ge.right.parent = Ge) : Ge.right = null, re.left = Ge, Ge.parent = re) : (wt ? (Ge.left = wt, wt.parent = Ge) : Ge.left = null, ne.right = Ge, Ge.parent = ne)), bt ? (re.right = bt, bt.parent = re) : re.right = null, ne.left = re, re.parent = ne)
                    }, c.prototype.replace = function (ne, re) {
                        ne.parent ? ne === ne.parent.left ? ne.parent.left = re : ne.parent.right = re : this._root = re, re && (re.parent = ne.parent)
                    }, c.prototype.minNode = function (ne) {
                        if (ne === void 0 && (ne = this._root), ne) for (; ne.left;) ne = ne.left;
                        return ne
                    }, c.prototype.maxNode = function (ne) {
                        if (ne === void 0 && (ne = this._root), ne) for (; ne.right;) ne = ne.right;
                        return ne
                    }, c.prototype.insert = function (ne, re) {
                        var Ge = this._root, mt = null, bt = this._compare;
                        if (this._noDuplicates) for (; Ge;) {
                            if (mt = Ge, bt(Ge.key, ne) === 0) return;
                            Ge = bt(Ge.key, ne) < 0 ? Ge.right : Ge.left
                        } else for (; Ge;) mt = Ge, Ge = bt(Ge.key, ne) < 0 ? Ge.right : Ge.left;
                        return Ge = {
                            key: ne,
                            data: re,
                            left: null,
                            right: null,
                            parent: mt
                        }, mt ? bt(mt.key, Ge.key) < 0 ? mt.right = Ge : mt.left = Ge : this._root = Ge, this.splay(Ge), this._size++, Ge
                    }, c.prototype.find = function (ne) {
                        for (var re = this._root, Ge = this._compare; re;) {
                            var mt = Ge(re.key, ne);
                            if (mt < 0) re = re.right; else {
                                if (!(mt > 0)) return re;
                                re = re.left
                            }
                        }
                        return null
                    }, c.prototype.contains = function (ne) {
                        for (var re = this._root, Ge = this._compare; re;) {
                            var mt = Ge(ne, re.key);
                            if (mt === 0) return !0;
                            re = mt < 0 ? re.left : re.right
                        }
                        return !1
                    }, c.prototype.remove = function (ne) {
                        var re = this.find(ne);
                        if (!re) return !1;
                        if (this.splay(re), re.left) if (re.right) {
                            var Ge = this.minNode(re.right);
                            Ge.parent !== re && (this.replace(Ge, Ge.right), Ge.right = re.right, Ge.right.parent = Ge), this.replace(re, Ge), Ge.left = re.left, Ge.left.parent = Ge
                        } else this.replace(re, re.left); else this.replace(re, re.right);
                        return this._size--, !0
                    }, c.prototype.removeNode = function (ne) {
                        if (!ne) return !1;
                        if (this.splay(ne), ne.left) if (ne.right) {
                            var re = this.minNode(ne.right);
                            re.parent !== ne && (this.replace(re, re.right), re.right = ne.right, re.right.parent = re), this.replace(ne, re), re.left = ne.left, re.left.parent = re
                        } else this.replace(ne, ne.left); else this.replace(ne, ne.right);
                        return this._size--, !0
                    }, c.prototype.erase = function (ne) {
                        var re = this.find(ne);
                        if (re) {
                            this.splay(re);
                            var Ge = re.left, mt = re.right, bt = null;
                            Ge && (Ge.parent = null, bt = this.maxNode(Ge), this.splay(bt), this._root = bt), mt && (Ge ? bt.right = mt : this._root = mt, mt.parent = bt), this._size--
                        }
                    }, c.prototype.pop = function () {
                        var ne = this._root, re = null;
                        if (ne) {
                            for (; ne.left;) ne = ne.left;
                            re = {key: ne.key, data: ne.data}, this.remove(ne.key)
                        }
                        return re
                    }, c.prototype.next = function (ne) {
                        var re = ne;
                        if (re) if (re.right) for (re = re.right; re && re.left;) re = re.left; else for (re = ne.parent; re && re.right === ne;) ne = re, re = re.parent;
                        return re
                    }, c.prototype.prev = function (ne) {
                        var re = ne;
                        if (re) if (re.left) for (re = re.left; re && re.right;) re = re.right; else for (re = ne.parent; re && re.left === ne;) ne = re, re = re.parent;
                        return re
                    }, c.prototype.forEach = function (ne) {
                        for (var re = this._root, Ge = [], mt = !1, bt = 0; !mt;) re ? (Ge.push(re), re = re.left) : Ge.length > 0 ? (ne(re = Ge.pop(), bt++), re = re.right) : mt = !0;
                        return this
                    }, c.prototype.range = function (ne, re, Ge, mt) {
                        for (var bt = [], wt = this._compare, Lt = this._root; bt.length !== 0 || Lt;) if (Lt) bt.push(Lt), Lt = Lt.left; else {
                            if (wt((Lt = bt.pop()).key, re) > 0) break;
                            if (wt(Lt.key, ne) >= 0 && Ge.call(mt, Lt)) return this;
                            Lt = Lt.right
                        }
                        return this
                    }, c.prototype.keys = function () {
                        for (var ne = this._root, re = [], Ge = [], mt = !1; !mt;) ne ? (re.push(ne), ne = ne.left) : re.length > 0 ? (ne = re.pop(), Ge.push(ne.key), ne = ne.right) : mt = !0;
                        return Ge
                    }, c.prototype.values = function () {
                        for (var ne = this._root, re = [], Ge = [], mt = !1; !mt;) ne ? (re.push(ne), ne = ne.left) : re.length > 0 ? (ne = re.pop(), Ge.push(ne.data), ne = ne.right) : mt = !0;
                        return Ge
                    }, c.prototype.at = function (ne) {
                        for (var re = this._root, Ge = [], mt = !1, bt = 0; !mt;) if (re) Ge.push(re), re = re.left; else if (Ge.length > 0) {
                            if (re = Ge.pop(), bt === ne) return re;
                            bt++, re = re.right
                        } else mt = !0;
                        return null
                    }, c.prototype.load = function (ne, re, Ge) {
                        if (ne === void 0 && (ne = []), re === void 0 && (re = []), Ge === void 0 && (Ge = !1), this._size !== 0) throw new Error("bulk-load: tree is not empty");
                        var mt = ne.length;
                        return Ge && _(ne, re, 0, mt - 1, this._compare), this._root = f(null, ne, re, 0, mt), this._size = mt, this
                    }, c.prototype.min = function () {
                        var ne = this.minNode(this._root);
                        return ne ? ne.key : null
                    }, c.prototype.max = function () {
                        var ne = this.maxNode(this._root);
                        return ne ? ne.key : null
                    }, c.prototype.isEmpty = function () {
                        return this._root === null
                    }, d.size.get = function () {
                        return this._size
                    }, c.createTree = function (ne, re, Ge, mt, bt) {
                        return new c(Ge, bt).load(ne, re, mt)
                    }, Object.defineProperties(c.prototype, d);
                    var x = 0, w = 1, E = 2, I = 3, C = 0, z = 1, L = 2, F = 3;

                    function N(ne, re, Ge) {
                        re === null ? (ne.inOut = !1, ne.otherInOut = !0) : (ne.isSubject === re.isSubject ? (ne.inOut = !re.inOut, ne.otherInOut = re.otherInOut) : (ne.inOut = !re.otherInOut, ne.otherInOut = re.isVertical() ? !re.inOut : re.inOut), re && (ne.prevInResult = !H(re, Ge) || re.isVertical() ? re.prevInResult : re));
                        var mt = H(ne, Ge);
                        ne.resultTransition = mt ? function (bt, wt) {
                            var Lt, ti = !bt.inOut, Ci = !bt.otherInOut;
                            switch (wt) {
                                case C:
                                    Lt = ti && Ci;
                                    break;
                                case z:
                                    Lt = ti || Ci;
                                    break;
                                case F:
                                    Lt = ti ^ Ci;
                                    break;
                                case L:
                                    Lt = bt.isSubject ? ti && !Ci : Ci && !ti
                            }
                            return Lt ? 1 : -1
                        }(ne, Ge) : 0
                    }

                    function H(ne, re) {
                        switch (ne.type) {
                            case x:
                                switch (re) {
                                    case C:
                                        return !ne.otherInOut;
                                    case z:
                                        return ne.otherInOut;
                                    case L:
                                        return ne.isSubject && ne.otherInOut || !ne.isSubject && !ne.otherInOut;
                                    case F:
                                        return !0
                                }
                                break;
                            case E:
                                return re === C || re === z;
                            case I:
                                return re === L;
                            case w:
                                return !1
                        }
                        return !1
                    }

                    var Y = function (ne, re, Ge, mt, bt) {
                        this.left = re, this.point = ne, this.otherEvent = Ge, this.isSubject = mt, this.type = bt || x, this.inOut = !1, this.otherInOut = !1, this.prevInResult = null, this.resultTransition = 0, this.otherPos = -1, this.outputContourId = -1, this.isExteriorRing = !0
                    }, X = {inResult: {configurable: !0}};

                    function J(ne, re) {
                        return ne[0] === re[0] && ne[1] === re[1]
                    }

                    Y.prototype.isBelow = function (ne) {
                        var re = this.point, Ge = this.otherEvent.point;
                        return this.left ? (re[0] - ne[0]) * (Ge[1] - ne[1]) - (Ge[0] - ne[0]) * (re[1] - ne[1]) > 0 : (Ge[0] - ne[0]) * (re[1] - ne[1]) - (re[0] - ne[0]) * (Ge[1] - ne[1]) > 0
                    }, Y.prototype.isAbove = function (ne) {
                        return !this.isBelow(ne)
                    }, Y.prototype.isVertical = function () {
                        return this.point[0] === this.otherEvent.point[0]
                    }, X.inResult.get = function () {
                        return this.resultTransition !== 0
                    }, Y.prototype.clone = function () {
                        var ne = new Y(this.point, this.left, this.otherEvent, this.isSubject, this.type);
                        return ne.contourId = this.contourId, ne.resultTransition = this.resultTransition, ne.prevInResult = this.prevInResult, ne.isExteriorRing = this.isExteriorRing, ne.inOut = this.inOut, ne.otherInOut = this.otherInOut, ne
                    }, Object.defineProperties(Y.prototype, X);
                    var xe = 11102230246251565e-32, ge = 134217729, ye = (3 + 8 * xe) * xe;

                    function Ee(ne, re, Ge, mt, bt) {
                        var wt, Lt, ti, Ci, Pi = re[0], yi = mt[0], an = 0, Vn = 0;
                        yi > Pi == yi > -Pi ? (wt = Pi, Pi = re[++an]) : (wt = yi, yi = mt[++Vn]);
                        var mi = 0;
                        if (an < ne && Vn < Ge) for (yi > Pi == yi > -Pi ? (ti = wt - ((Lt = Pi + wt) - Pi), Pi = re[++an]) : (ti = wt - ((Lt = yi + wt) - yi), yi = mt[++Vn]), wt = Lt, ti !== 0 && (bt[mi++] = ti); an < ne && Vn < Ge;) yi > Pi == yi > -Pi ? (ti = wt - ((Lt = wt + Pi) - (Ci = Lt - wt)) + (Pi - Ci), Pi = re[++an]) : (ti = wt - ((Lt = wt + yi) - (Ci = Lt - wt)) + (yi - Ci), yi = mt[++Vn]), wt = Lt, ti !== 0 && (bt[mi++] = ti);
                        for (; an < ne;) ti = wt - ((Lt = wt + Pi) - (Ci = Lt - wt)) + (Pi - Ci), Pi = re[++an], wt = Lt, ti !== 0 && (bt[mi++] = ti);
                        for (; Vn < Ge;) ti = wt - ((Lt = wt + yi) - (Ci = Lt - wt)) + (yi - Ci), yi = mt[++Vn], wt = Lt, ti !== 0 && (bt[mi++] = ti);
                        return wt === 0 && mi !== 0 || (bt[mi++] = wt), mi
                    }

                    function Ie(ne) {
                        return new Float64Array(ne)
                    }

                    var We = 33306690738754716e-32, De = 22204460492503146e-32, Ye = 11093356479670487e-47, ht = Ie(4),
                        Qe = Ie(8), ot = Ie(12), ct = Ie(16), He = Ie(4);

                    function st(ne, re, Ge) {
                        var mt = function (bt, wt, Lt, ti, Ci, Pi) {
                            var yi = (wt - Pi) * (Lt - Ci), an = (bt - Ci) * (ti - Pi), Vn = yi - an;
                            if (yi === 0 || an === 0 || yi > 0 != an > 0) return Vn;
                            var mi = Math.abs(yi + an);
                            return Math.abs(Vn) >= We * mi ? Vn : -function (Cn, _n, tn, On, Sn, yn, wn) {
                                var on, vi, ln, Fn, Jt, Ni, En, Gn, Pn, dr, dn, sr, Bo, Hr, Nr, No, gl, fr,
                                    xr = Cn - Sn, qr = tn - Sn, yo = _n - yn, no = On - yn;
                                ht[0] = (Nr = (Gn = xr - (En = (Ni = ge * xr) - (Ni - xr))) * (dr = no - (Pn = (Ni = ge * no) - (Ni - no))) - ((Hr = xr * no) - En * Pn - Gn * Pn - En * dr)) - ((dn = Nr - (gl = (Gn = yo - (En = (Ni = ge * yo) - (Ni - yo))) * (dr = qr - (Pn = (Ni = ge * qr) - (Ni - qr))) - ((No = yo * qr) - En * Pn - Gn * Pn - En * dr))) + (Jt = Nr - dn)) + (Jt - gl), ht[1] = (Bo = Hr - ((sr = Hr + dn) - (Jt = sr - Hr)) + (dn - Jt)) - ((dn = Bo - No) + (Jt = Bo - dn)) + (Jt - No), ht[2] = sr - ((fr = sr + dn) - (Jt = fr - sr)) + (dn - Jt), ht[3] = fr;
                                var au = function (u8, FI) {
                                    for (var BI = FI[0], Dw = 1; Dw < 4; Dw++) BI += FI[Dw];
                                    return BI
                                }(0, ht), Ag = De * wn;
                                if (au >= Ag || -au >= Ag || (on = Cn - (xr + (Jt = Cn - xr)) + (Jt - Sn), ln = tn - (qr + (Jt = tn - qr)) + (Jt - Sn), vi = _n - (yo + (Jt = _n - yo)) + (Jt - yn), Fn = On - (no + (Jt = On - no)) + (Jt - yn), on === 0 && vi === 0 && ln === 0 && Fn === 0) || (Ag = Ye * wn + ye * Math.abs(au), (au += xr * Fn + no * on - (yo * ln + qr * vi)) >= Ag || -au >= Ag)) return au;
                                He[0] = (Nr = (Gn = on - (En = (Ni = ge * on) - (Ni - on))) * (dr = no - (Pn = (Ni = ge * no) - (Ni - no))) - ((Hr = on * no) - En * Pn - Gn * Pn - En * dr)) - ((dn = Nr - (gl = (Gn = vi - (En = (Ni = ge * vi) - (Ni - vi))) * (dr = qr - (Pn = (Ni = ge * qr) - (Ni - qr))) - ((No = vi * qr) - En * Pn - Gn * Pn - En * dr))) + (Jt = Nr - dn)) + (Jt - gl), He[1] = (Bo = Hr - ((sr = Hr + dn) - (Jt = sr - Hr)) + (dn - Jt)) - ((dn = Bo - No) + (Jt = Bo - dn)) + (Jt - No), He[2] = sr - ((fr = sr + dn) - (Jt = fr - sr)) + (dn - Jt), He[3] = fr;
                                var GO = Ee(4, ht, 4, He, Qe);
                                He[0] = (Nr = (Gn = xr - (En = (Ni = ge * xr) - (Ni - xr))) * (dr = Fn - (Pn = (Ni = ge * Fn) - (Ni - Fn))) - ((Hr = xr * Fn) - En * Pn - Gn * Pn - En * dr)) - ((dn = Nr - (gl = (Gn = yo - (En = (Ni = ge * yo) - (Ni - yo))) * (dr = ln - (Pn = (Ni = ge * ln) - (Ni - ln))) - ((No = yo * ln) - En * Pn - Gn * Pn - En * dr))) + (Jt = Nr - dn)) + (Jt - gl), He[1] = (Bo = Hr - ((sr = Hr + dn) - (Jt = sr - Hr)) + (dn - Jt)) - ((dn = Bo - No) + (Jt = Bo - dn)) + (Jt - No), He[2] = sr - ((fr = sr + dn) - (Jt = fr - sr)) + (dn - Jt), He[3] = fr;
                                var $O = Ee(GO, Qe, 4, He, ot);
                                He[0] = (Nr = (Gn = on - (En = (Ni = ge * on) - (Ni - on))) * (dr = Fn - (Pn = (Ni = ge * Fn) - (Ni - Fn))) - ((Hr = on * Fn) - En * Pn - Gn * Pn - En * dr)) - ((dn = Nr - (gl = (Gn = vi - (En = (Ni = ge * vi) - (Ni - vi))) * (dr = ln - (Pn = (Ni = ge * ln) - (Ni - ln))) - ((No = vi * ln) - En * Pn - Gn * Pn - En * dr))) + (Jt = Nr - dn)) + (Jt - gl), He[1] = (Bo = Hr - ((sr = Hr + dn) - (Jt = sr - Hr)) + (dn - Jt)) - ((dn = Bo - No) + (Jt = Bo - dn)) + (Jt - No), He[2] = sr - ((fr = sr + dn) - (Jt = fr - sr)) + (dn - Jt), He[3] = fr;
                                var HO = Ee($O, ot, 4, He, ct);
                                return ct[HO - 1]
                            }(bt, wt, Lt, ti, Ci, Pi, mi)
                        }(ne[0], ne[1], re[0], re[1], Ge[0], Ge[1]);
                        return mt > 0 ? -1 : mt < 0 ? 1 : 0
                    }

                    function ke(ne, re) {
                        var Ge = ne.point, mt = re.point;
                        return Ge[0] > mt[0] ? 1 : Ge[0] < mt[0] ? -1 : Ge[1] !== mt[1] ? Ge[1] > mt[1] ? 1 : -1 : function (bt, wt, Lt, ti) {
                            return bt.left !== wt.left ? bt.left ? 1 : -1 : st(Lt, bt.otherEvent.point, wt.otherEvent.point) !== 0 ? bt.isBelow(wt.otherEvent.point) ? -1 : 1 : !bt.isSubject && wt.isSubject ? 1 : -1
                        }(ne, re, Ge)
                    }

                    function qe(ne, re, Ge) {
                        var mt = new Y(re, !1, ne, ne.isSubject), bt = new Y(re, !0, ne.otherEvent, ne.isSubject);
                        return J(ne.point, ne.otherEvent.point) && console.warn("what is that, a collapsed segment?", ne), mt.contourId = bt.contourId = ne.contourId, ke(bt, ne.otherEvent) > 0 && (ne.otherEvent.left = !0, bt.left = !1), ne.otherEvent.otherEvent = bt, ne.otherEvent = mt, Ge.push(bt), Ge.push(mt), Ge
                    }

                    function pt(ne, re) {
                        return ne[0] * re[1] - ne[1] * re[0]
                    }

                    function at(ne, re) {
                        return ne[0] * re[0] + ne[1] * re[1]
                    }

                    function Bt(ne, re, Ge) {
                        var mt = function (Ci, Pi, yi, an, Vn) {
                            var mi = [Pi[0] - Ci[0], Pi[1] - Ci[1]], Cn = [an[0] - yi[0], an[1] - yi[1]];

                            function _n(Ni, En, Gn) {
                                return [Ni[0] + En * Gn[0], Ni[1] + En * Gn[1]]
                            }

                            var tn = [yi[0] - Ci[0], yi[1] - Ci[1]], On = pt(mi, Cn), Sn = On * On, yn = at(mi, mi);
                            if (Sn > 0) {
                                var wn = pt(tn, Cn) / On;
                                if (wn < 0 || wn > 1) return null;
                                var on = pt(tn, mi) / On;
                                return on < 0 || on > 1 ? null : wn === 0 || wn === 1 ? [_n(Ci, wn, mi)] : on === 0 || on === 1 ? [_n(yi, on, Cn)] : [_n(Ci, wn, mi)]
                            }
                            if ((Sn = (On = pt(tn, mi)) * On) > 0) return null;
                            var vi = at(mi, tn) / yn, ln = vi + at(mi, Cn) / yn, Fn = Math.min(vi, ln),
                                Jt = Math.max(vi, ln);
                            return Fn <= 1 && Jt >= 0 ? Fn === 1 ? [_n(Ci, Fn > 0 ? Fn : 0, mi)] : Jt === 0 ? [_n(Ci, Jt < 1 ? Jt : 1, mi)] : [_n(Ci, Fn > 0 ? Fn : 0, mi), _n(Ci, Jt < 1 ? Jt : 1, mi)] : null
                        }(ne.point, ne.otherEvent.point, re.point, re.otherEvent.point), bt = mt ? mt.length : 0;
                        if (bt === 0 || bt === 1 && (J(ne.point, re.point) || J(ne.otherEvent.point, re.otherEvent.point)) || bt === 2 && ne.isSubject === re.isSubject) return 0;
                        if (bt === 1) return J(ne.point, mt[0]) || J(ne.otherEvent.point, mt[0]) || qe(ne, mt[0], Ge), J(re.point, mt[0]) || J(re.otherEvent.point, mt[0]) || qe(re, mt[0], Ge), 1;
                        var wt = [], Lt = !1, ti = !1;
                        return J(ne.point, re.point) ? Lt = !0 : ke(ne, re) === 1 ? wt.push(re, ne) : wt.push(ne, re), J(ne.otherEvent.point, re.otherEvent.point) ? ti = !0 : ke(ne.otherEvent, re.otherEvent) === 1 ? wt.push(re.otherEvent, ne.otherEvent) : wt.push(ne.otherEvent, re.otherEvent), Lt && ti || Lt ? (re.type = w, ne.type = re.inOut === ne.inOut ? E : I, Lt && !ti && qe(wt[1].otherEvent, wt[0].point, Ge), 2) : ti ? (qe(wt[0], wt[1].point, Ge), 3) : wt[0] !== wt[3].otherEvent ? (qe(wt[0], wt[1].point, Ge), qe(wt[1], wt[2].point, Ge), 3) : (qe(wt[0], wt[1].point, Ge), qe(wt[3].otherEvent, wt[2].point, Ge), 3)
                    }

                    function zt(ne, re) {
                        if (ne === re) return 0;
                        if (st(ne.point, ne.otherEvent.point, re.point) !== 0 || st(ne.point, ne.otherEvent.point, re.otherEvent.point) !== 0) return J(ne.point, re.point) ? ne.isBelow(re.otherEvent.point) ? -1 : 1 : ne.point[0] === re.point[0] ? ne.point[1] < re.point[1] ? -1 : 1 : ke(ne, re) === 1 ? re.isAbove(ne.point) ? -1 : 1 : ne.isBelow(re.point) ? -1 : 1;
                        if (ne.isSubject !== re.isSubject) return ne.isSubject ? -1 : 1;
                        var Ge = ne.point, mt = re.point;
                        return Ge[0] === mt[0] && Ge[1] === mt[1] ? (Ge = ne.otherEvent.point)[0] === (mt = re.otherEvent.point)[0] && Ge[1] === mt[1] ? 0 : ne.contourId > re.contourId ? 1 : -1 : ke(ne, re) === 1 ? 1 : -1
                    }

                    var nt = function () {
                        this.points = [], this.holeIds = [], this.holeOf = null, this.depth = null
                    };

                    function lt(ne, re, Ge, mt) {
                        var bt, wt = ne + 1, Lt = re[ne].point, ti = re.length;
                        for (wt < ti && (bt = re[wt].point); wt < ti && bt[0] === Lt[0] && bt[1] === Lt[1];) {
                            if (!Ge[wt]) return wt;
                            ++wt < ti && (bt = re[wt].point)
                        }
                        for (wt = ne - 1; Ge[wt] && wt > mt;) wt--;
                        return wt
                    }

                    nt.prototype.isExterior = function () {
                        return this.holeOf == null
                    };
                    var kt = vt, Et = vt;

                    function vt(ne, re) {
                        if (!(this instanceof vt)) return new vt(ne, re);
                        if (this.data = ne || [], this.length = this.data.length, this.compare = re || At, this.length > 0) for (var Ge = (this.length >> 1) - 1; Ge >= 0; Ge--) this._down(Ge)
                    }

                    function At(ne, re) {
                        return ne < re ? -1 : ne > re ? 1 : 0
                    }

                    vt.prototype = {
                        push: function (ne) {
                            this.data.push(ne), this.length++, this._up(this.length - 1)
                        }, pop: function () {
                            if (this.length !== 0) {
                                var ne = this.data[0];
                                return this.length--, this.length > 0 && (this.data[0] = this.data[this.length], this._down(0)), this.data.pop(), ne
                            }
                        }, peek: function () {
                            return this.data[0]
                        }, _up: function (ne) {
                            for (var re = this.data, Ge = this.compare, mt = re[ne]; ne > 0;) {
                                var bt = ne - 1 >> 1, wt = re[bt];
                                if (Ge(mt, wt) >= 0) break;
                                re[ne] = wt, ne = bt
                            }
                            re[ne] = mt
                        }, _down: function (ne) {
                            for (var re = this.data, Ge = this.compare, mt = this.length >> 1, bt = re[ne]; ne < mt;) {
                                var wt = 1 + (ne << 1), Lt = wt + 1, ti = re[wt];
                                if (Lt < this.length && Ge(re[Lt], ti) < 0 && (wt = Lt, ti = re[Lt]), Ge(ti, bt) >= 0) break;
                                re[ne] = ti, ne = wt
                            }
                            re[ne] = bt
                        }
                    }, kt.default = Et;
                    var Kt = Math.max, oi = Math.min, pi = 0;

                    function ui(ne, re, Ge, mt, bt, wt) {
                        var Lt, ti, Ci, Pi, yi, an;
                        for (Lt = 0, ti = ne.length - 1; Lt < ti; Lt++) if (Pi = ne[Lt + 1], yi = new Y(Ci = ne[Lt], !1, void 0, re), an = new Y(Pi, !1, yi, re), yi.otherEvent = an, Ci[0] !== Pi[0] || Ci[1] !== Pi[1]) {
                            yi.contourId = an.contourId = Ge, wt || (yi.isExteriorRing = !1, an.isExteriorRing = !1), ke(yi, an) > 0 ? an.left = !0 : yi.left = !0;
                            var Vn = Ci[0], mi = Ci[1];
                            bt[0] = oi(bt[0], Vn), bt[1] = oi(bt[1], mi), bt[2] = Kt(bt[2], Vn), bt[3] = Kt(bt[3], mi), mt.push(yi), mt.push(an)
                        }
                    }

                    var ki = [];

                    function bi(ne, re, Ge) {
                        typeof ne[0][0][0] == "number" && (ne = [ne]), typeof re[0][0][0] == "number" && (re = [re]);
                        var mt = function (mi, Cn, _n) {
                            var tn = null;
                            return mi.length * Cn.length == 0 && (_n === C ? tn = ki : _n === L ? tn = mi : _n !== z && _n !== F || (tn = mi.length === 0 ? Cn : mi)), tn
                        }(ne, re, Ge);
                        if (mt) return mt === ki ? null : mt;
                        var bt = [1 / 0, 1 / 0, -1 / 0, -1 / 0], wt = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                            Lt = function (mi, Cn, _n, tn, On) {
                                var Sn, yn, wn, on, vi, ln, Fn = new kt(null, ke);
                                for (wn = 0, on = mi.length; wn < on; wn++) for (vi = 0, ln = (Sn = mi[wn]).length; vi < ln; vi++) (yn = vi === 0) && pi++, ui(Sn[vi], !0, pi, Fn, _n, yn);
                                for (wn = 0, on = Cn.length; wn < on; wn++) for (vi = 0, ln = (Sn = Cn[wn]).length; vi < ln; vi++) yn = vi === 0, On === L && (yn = !1), yn && pi++, ui(Sn[vi], !1, pi, Fn, tn, yn);
                                return Fn
                            }(ne, re, bt, wt, Ge);
                        if (mt = function (mi, Cn, _n, tn, On) {
                            var Sn = null;
                            return (_n[0] > tn[2] || tn[0] > _n[2] || _n[1] > tn[3] || tn[1] > _n[3]) && (On === C ? Sn = ki : On === L ? Sn = mi : On !== z && On !== F || (Sn = mi.concat(Cn))), Sn
                        }(ne, re, bt, wt, Ge)) return mt === ki ? null : mt;
                        for (var ti = function (mi) {
                            var Cn, _n, tn = function (wn) {
                                var on, vi, ln, Fn, Jt = [];
                                for (vi = 0, ln = wn.length; vi < ln; vi++) ((on = wn[vi]).left && on.inResult || !on.left && on.otherEvent.inResult) && Jt.push(on);
                                for (var Ni = !1; !Ni;) for (Ni = !0, vi = 0, ln = Jt.length; vi < ln; vi++) vi + 1 < ln && ke(Jt[vi], Jt[vi + 1]) === 1 && (Fn = Jt[vi], Jt[vi] = Jt[vi + 1], Jt[vi + 1] = Fn, Ni = !1);
                                for (vi = 0, ln = Jt.length; vi < ln; vi++) (on = Jt[vi]).otherPos = vi;
                                for (vi = 0, ln = Jt.length; vi < ln; vi++) (on = Jt[vi]).left || (Fn = on.otherPos, on.otherPos = on.otherEvent.otherPos, on.otherEvent.otherPos = Fn);
                                return Jt
                            }(mi), On = {}, Sn = [], yn = function () {
                                if (!On[Cn]) {
                                    var wn = Sn.length, on = function (Jt, Ni, En) {
                                        var Gn = new nt;
                                        if (Jt.prevInResult != null) {
                                            var Pn = Jt.prevInResult, dr = Pn.outputContourId;
                                            if (Pn.resultTransition > 0) {
                                                var dn = Ni[dr];
                                                if (dn.holeOf != null) {
                                                    var sr = dn.holeOf;
                                                    Ni[sr].holeIds.push(En), Gn.holeOf = sr, Gn.depth = Ni[dr].depth
                                                } else Ni[dr].holeIds.push(En), Gn.holeOf = dr, Gn.depth = Ni[dr].depth + 1
                                            } else Gn.holeOf = null, Gn.depth = Ni[dr].depth
                                        } else Gn.holeOf = null, Gn.depth = 0;
                                        return Gn
                                    }(tn[Cn], Sn, wn), vi = function (Jt) {
                                        On[Jt] = !0, Jt < tn.length && tn[Jt] && (tn[Jt].outputContourId = wn)
                                    }, ln = Cn, Fn = Cn;
                                    for (on.points.push(tn[Cn].point); vi(ln), vi(ln = tn[ln].otherPos), on.points.push(tn[ln].point), !((ln = lt(ln, tn, On, Fn)) == Fn || ln >= tn.length) && tn[ln];) ;
                                    Sn.push(on)
                                }
                            };
                            for (Cn = 0, _n = tn.length; Cn < _n; Cn++) yn();
                            return Sn
                        }(function (mi, Cn, _n, tn, On, Sn) {
                            for (var yn, wn, on, vi = new c(zt), ln = [], Fn = Math.min(tn[2], On[2]); mi.length !== 0;) {
                                var Jt = mi.pop();
                                if (ln.push(Jt), Sn === C && Jt.point[0] > Fn || Sn === L && Jt.point[0] > tn[2]) break;
                                if (Jt.left) {
                                    wn = yn = vi.insert(Jt), yn = yn !== (on = vi.minNode()) ? vi.prev(yn) : null, wn = vi.next(wn);
                                    var Ni = yn ? yn.key : null;
                                    if (N(Jt, Ni, Sn), wn && Bt(Jt, wn.key, mi) === 2 && (N(Jt, Ni, Sn), N(wn.key, Jt, Sn)), yn && Bt(yn.key, Jt, mi) === 2) {
                                        var En = yn;
                                        N(Ni, (En = En !== on ? vi.prev(En) : null) ? En.key : null, Sn), N(Jt, Ni, Sn)
                                    }
                                } else wn = yn = vi.find(Jt = Jt.otherEvent), yn && wn && (yn = yn !== on ? vi.prev(yn) : null, wn = vi.next(wn), vi.remove(Jt), wn && yn && Bt(yn.key, wn.key, mi))
                            }
                            return ln
                        }(Lt, 0, 0, bt, wt, Ge)), Ci = [], Pi = 0; Pi < ti.length; Pi++) {
                            var yi = ti[Pi];
                            if (yi.isExterior()) {
                                for (var an = [yi.points], Vn = 0; Vn < yi.holeIds.length; Vn++) an.push(ti[yi.holeIds[Vn]].points);
                                Ci.push(an)
                            }
                        }
                        return Ci
                    }

                    var Tn = {UNION: z, DIFFERENCE: L, INTERSECTION: C, XOR: F};
                    i.diff = function (ne, re) {
                        return bi(ne, re, L)
                    }, i.intersection = function (ne, re) {
                        return bi(ne, re, C)
                    }, i.operations = Tn, i.union = function (ne, re) {
                        return bi(ne, re, z)
                    }, i.xor = function (ne, re) {
                        return bi(ne, re, F)
                    }, Object.defineProperty(i, "__esModule", {value: !0})
                })(e)
            }(0, SS.exports)), SS.exports);

            /**
             * martinez v0.7.4
             * Martinez polygon clipping algorithm, does boolean operation on polygons (multipolygons, polygons with holes etc): intersection, union, difference, xor
             *
             * @author Alex Milevski <info@w8r.name>
             * @license MIT
             * @preserve
             */function qy(n, e, i, a) {
                const c = [], d = a === 0 ? (f, _, x, w, E, I) => {
                    f.push(new Ze(I, x + (I - _) / (w - _) * (E - x)))
                } : (f, _, x, w, E, I) => {
                    f.push(new Ze(_ + (I - x) / (E - x) * (w - _), I))
                };
                for (const f of n) {
                    const _ = [];
                    for (const x of f) {
                        if (x.length <= 2) continue;
                        const w = [];
                        for (let C = 0; C < x.length - 1; C++) {
                            const z = x[C].x, L = x[C].y, F = x[C + 1].x, N = x[C + 1].y, H = a === 0 ? z : L,
                                Y = a === 0 ? F : N;
                            H < e ? Y > e && d(w, z, L, F, N, e) : H > i ? Y < i && d(w, z, L, F, N, i) : w.push(x[C]), Y < e && H >= e && d(w, z, L, F, N, e), Y > i && H <= i && d(w, z, L, F, N, i)
                        }
                        let E = x[x.length - 1];
                        const I = a === 0 ? E.x : E.y;
                        I >= e && I <= i && w.push(E), w.length && (E = w[w.length - 1], w[0].x === E.x && w[0].y === E.y || w.push(w[0]), _.push(w))
                    }
                    _.length && c.push(_)
                }
                return c
            }

            function $L(n, e) {
                const i = P1(n), a = P1([e]), c = ES.intersection(i, a);
                return c == null ? [] : AS(c)
            }

            function HL(n, e) {
                let a = P1(n, 65536);
                for (; e.valid(); e.next()) {
                    const [c, d] = e.get(), f = c.x * 65536, _ = c.y * 65536, x = d.x * 65536, w = d.y * 65536,
                        E = x - f, I = w - _, C = Math.hypot(E, I), z = Math.trunc(I / C * 3),
                        L = -Math.trunc(E / C * 3);
                    a = ES.diff(a, [[[f, _], [x, w], [x + z, w + L], [f + z, _ + L], [f, _]]])
                }
                return AS(a, 1 / 65536)
            }

            function P1(n, e = 1) {
                return [n.map(i => i.map(a => [a.x * e, a.y * e]))]
            }

            function AS(n, e = 1) {
                return n.map(i => i.map((a, c) => {
                    const d = a.map(f => new Ze(f[0] * e, f[1] * e).round());
                    return c > 0 && d.reverse(), d
                }))
            }

            class M1 {
                constructor(e, i) {
                    this.layoutVertexArray = new Po, this.indexArray = new Mn, this.lineIndexArray = new ea, this.triangleSegments = new Ln, this.lineSegments = new Ln, this.programConfigurations = new es(e.layers, {
                        zoom: e.zoom,
                        lut: e.lut
                    }), this.uploaded = !1, i && (this.elevatedLayoutVertexArray = new Zl)
                }

                update(e, i, a, c, d, f, _, x) {
                    this.programConfigurations.updatePaintArrays(e, i, d, a, c, f, _, x)
                }

                isEmpty() {
                    return this.layoutVertexArray.length === 0
                }

                needsUpload() {
                    return this.programConfigurations.needsUpload
                }

                upload(e) {
                    this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, PL.members), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.lineIndexBuffer = e.createIndexBuffer(this.lineIndexArray), this.elevatedLayoutVertexArray && this.elevatedLayoutVertexArray.length > 0 && (this.elevatedLayoutVertexBuffer = e.createVertexBuffer(this.elevatedLayoutVertexArray, ML.members))), this.programConfigurations.upload(e), this.uploaded = !0
                }

                destroy() {
                    this.layoutVertexBuffer && (this.elevatedLayoutVertexBuffer && this.elevatedLayoutVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.lineIndexBuffer.destroy(), this.programConfigurations.destroy(), this.triangleSegments.destroy(), this.lineSegments.destroy())
                }

                populatePaintArrays(e, i, a, c, d, f, _) {
                    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, i, a, c, d, f, void 0, _)
                }
            }

            class R1 {
                constructor(e) {
                    this.zoom = e.zoom, this.pixelRatio = e.pixelRatio, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(i => i.fqid), this.index = e.index, this.hasPattern = !1, this.patternFeatures = [], this.lut = e.lut, this.bufferData = new M1(e, !1), this.elevationBufferData = new M1(e, !0), this.stateDependentLayerIds = this.layers.filter(i => i.isStateDependent()).map(i => i.id), this.projection = e.projection, this.elevationMode = this.layers[0].layout.get("fill-elevation-reference"), this.sourceLayerIndex = e.sourceLayerIndex, this.worldview = e.worldview
                }

                updateFootprints(e, i) {
                }

                populate(e, i, a, c) {
                    this.hasPattern = I1("fill", this.layers, this.pixelRatio, i);
                    const d = this.layers[0].layout.get("fill-sort-key"), f = [];
                    for (const {feature: _, id: x, index: w, sourceLayerIndex: E} of e) {
                        const I = this.layers[0]._featureFilter.needGeometry, C = $e(_, I);
                        if (!this.layers[0]._featureFilter.filter(new sn(this.zoom, {worldview: this.worldview}), C, a)) continue;
                        const z = d ? d.evaluate(C, {}, a, i.availableImages) : void 0, L = {
                            id: x,
                            properties: _.properties,
                            type: _.type,
                            sourceLayerIndex: E,
                            index: w,
                            geometry: I ? C.geometry : Te(_, a, c),
                            patterns: {},
                            sortKey: z
                        };
                        f.push(L)
                    }
                    d && f.sort((_, x) => _.sortKey - x.sortKey);
                    for (const _ of f) {
                        const {geometry: x, index: w, sourceLayerIndex: E} = _;
                        if (this.hasPattern) {
                            const I = C1("fill", this.layers, _, this.zoom, this.pixelRatio, i);
                            this.patternFeatures.push(I)
                        } else this.addFeature(_, x, w, a, {}, i.availableImages, i.brightness, i.elevationFeatures);
                        i.featureIndex.insert(e[w].feature, x, w, E, this.index)
                    }
                }

                update(e, i, a, c, d, f, _) {
                    this.bufferData.update(e, i, a, c, d, f, _, this.worldview), this.elevationBufferData.update(e, i, a, c, d, f, _, this.worldview), this.elevatedStructures && this.elevatedStructures.update(e, i, a, c, d, f, _, this.worldview)
                }

                addFeatures(e, i, a, c, d, f) {
                    for (const _ of this.patternFeatures) this.addFeature(_, _.geometry, _.index, i, a, c, f, e.elevationFeatures)
                }

                isEmpty() {
                    return this.bufferData.isEmpty() && this.elevationBufferData.isEmpty()
                }

                uploadPending() {
                    return !this.uploaded || this.bufferData.needsUpload() || this.elevationBufferData.needsUpload()
                }

                upload(e) {
                    this.bufferData.upload(e), this.elevationBufferData.upload(e), this.elevatedStructures && this.elevatedStructures.upload(e)
                }

                destroy() {
                    this.bufferData.destroy(), this.elevationBufferData.destroy(), this.elevatedStructures && this.elevatedStructures.destroy()
                }

                addFeature(e, i, a, c, d, f = [], _, x) {
                    const w = Xm(i, 500);
                    this.elevationMode !== "none" ? this.addElevatedRoadFeature(e, w, c, a, x) : this.addGeometry(w, this.bufferData), this.bufferData.populatePaintArrays(e, a, d, f, c, _, this.worldview), this.elevationBufferData.populatePaintArrays(e, a, d, f, c, _, this.worldview)
                }

                getUnevaluatedPortalGraph() {
                    return this.elevatedStructures ? this.elevatedStructures.unevaluatedPortals : void 0
                }

                getElevationPolygons() {
                    return this.elevatedStructures ? this.elevatedStructures.portalPolygons : void 0
                }

                setEvaluatedPortalGraph(e, i, a, c, d) {
                    this.elevatedStructures && (this.elevatedStructures.construct(e), this.elevatedStructures.populatePaintArrays(i, a, c, d, this.worldview))
                }

                addElevatedRoadFeature(e, i, a, c, d) {
                    const f = new Array, _ = kn.getElevationFeature(e, d);
                    if (!_) return void this.addGeometry(i, this.bufferData);
                    {
                        const w = this.clipPolygonsToTile(i, 1);
                        w.length > 0 && f.push({polygons: w, elevationFeature: _, elevationTileID: a})
                    }
                    const x = {
                        guardRailEnabled: this.layers[0].layout.get("fill-construct-bridge-guard-rail").evaluate(e, {}, a),
                        featureIndex: c
                    };
                    for (const w of f) if (w.elevationFeature) {
                        if (this.elevationMode === "hd-road-base") {
                            this.elevatedStructures || (this.elevatedStructures = new os(w.elevationTileID, this.layers, this.zoom, this.lut));
                            const I = w.elevationFeature.isTunnel();
                            let C = 0;
                            e.properties.hasOwnProperty(Nt) && (C = +e.properties[Nt]);
                            for (const z of w.polygons) this.elevatedStructures.addPortalCandidates(w.elevationFeature.id, z, I, w.elevationFeature, C)
                        }
                        w.elevationFeature.constantHeight == null && (w.polygons = this.prepareElevatedPolygons(w.polygons, w.elevationFeature, w.elevationTileID));
                        const E = new ji(a, w.elevationTileID);
                        this.addElevatedGeometry(w.polygons, E, w.elevationFeature, this.elevationMode === "hd-road-base" ? 0 : .05, c, x)
                    }
                }

                addElevatedGeometry(e, i, a, c, d, f) {
                    const _ = {
                        elevation: a,
                        elevationSampler: i,
                        bias: c,
                        index: d,
                        featureInfo: f
                    }, [x, w] = this.addGeometry(e, this.elevationBufferData, _);
                    this.elevationBufferData.heightRange == null ? this.elevationBufferData.heightRange = {
                        min: x,
                        max: w
                    } : (this.elevationBufferData.heightRange.min = Math.min(this.elevationBufferData.heightRange.min, x), this.elevationBufferData.heightRange.max = Math.max(this.elevationBufferData.heightRange.max, w))
                }

                addGeometry(e, i, a) {
                    let c = Number.POSITIVE_INFINITY, d = Number.NEGATIVE_INFINITY, f = null;
                    a && (f = a.elevationSampler.constantElevation(a.elevation, a.bias), f != null && (c = f, d = f));
                    const _ = (x, w, E) => {
                        if (a != null) if (w.push(x), f != null) i.elevatedLayoutVertexArray.emplaceBack(f), E.push(f); else {
                            const I = a.elevationSampler.pointElevation(x, a.elevation, a.bias);
                            i.elevatedLayoutVertexArray.emplaceBack(I), E.push(I), c = Math.min(c, I), d = Math.max(d, I)
                        }
                    };
                    for (const x of e) {
                        let w = 0;
                        for (const X of x) w += X.length;
                        const E = i.triangleSegments.prepareSegment(w, i.layoutVertexArray, i.indexArray),
                            I = E.vertexLength, C = [], z = [], L = [], F = [], N = [], H = i.layoutVertexArray.length;
                        for (const X of x) {
                            if (X.length === 0) continue;
                            X !== x[0] && z.push(C.length / 2);
                            const J = i.lineSegments.prepareSegment(X.length, i.layoutVertexArray, i.lineIndexArray),
                                xe = J.vertexLength;
                            a && N.push(i.layoutVertexArray.length - H), _(X[0], L, F), i.layoutVertexArray.emplaceBack(X[0].x, X[0].y), i.lineIndexArray.emplaceBack(xe + X.length - 1, xe), C.push(X[0].x), C.push(X[0].y);
                            for (let ge = 1; ge < X.length; ge++) _(X[ge], L, F), i.layoutVertexArray.emplaceBack(X[ge].x, X[ge].y), i.lineIndexArray.emplaceBack(xe + ge - 1, xe + ge), C.push(X[ge].x), C.push(X[ge].y);
                            J.vertexLength += X.length, J.primitiveLength += X.length
                        }
                        const Y = df(C, z);
                        for (let X = 0; X < Y.length; X += 3) i.indexArray.emplaceBack(I + Y[X], I + Y[X + 1], I + Y[X + 2]);
                        if (Y.length > 0 && a && this.elevationMode === "hd-road-base") {
                            const X = a.elevation.isTunnel(), J = a.elevation.safeArea,
                                xe = this.elevatedStructures.addVertices(L, F);
                            this.elevatedStructures.addTriangles(Y, xe, X);
                            const ge = N.length;
                            if (ge > 0) {
                                for (let ye = 0; ye < ge - 1; ye++) this.elevatedStructures.addRenderableRing(a.index, N[ye] + xe, N[ye + 1] - N[ye], X, J, a.featureInfo);
                                this.elevatedStructures.addRenderableRing(a.index, N[ge - 1] + xe, L.length - N[ge - 1], X, J, a.featureInfo)
                            }
                        }
                        E.vertexLength += w, E.primitiveLength += Y.length / 3
                    }
                    return [c, d]
                }

                prepareElevatedPolygons(e, i, a) {
                    const c = 1 / he(a), d = [];
                    for (const f of e) {
                        const _ = HL(f, new rn(i, c));
                        d.push(..._)
                    }
                    return d
                }

                clipPolygonsToTile(e, i) {
                    const a = -i, c = -i, d = yt + i, f = yt + i;
                    let _ = 0;
                    const x = [], w = [];
                    for (; _ < e.length; _++) {
                        const C = e[_], z = Fp(C);
                        (z.min.x >= a && z.max.x <= d && z.min.y >= c && z.max.y <= f ? x : w).push(C)
                    }
                    if (x.length === e.length) return e;
                    const E = [new Ze(a, c), new Ze(d, c), new Ze(d, f), new Ze(a, f), new Ze(a, c)], I = x;
                    for (const C of w) I.push(...$L(C, E));
                    return I
                }
            }

            let IS, CS, PS, MS;
            Pt(R1, "FillBucket", {omit: ["layers", "patternFeatures"]}), Pt(M1, "FillBufferData"), Pt(os, "ElevatedStructures");

            class Wy {
                constructor(e, i, a, c) {
                    if (this.triangleCount = i.length / 3, this.min = new Ze(0, 0), this.max = new Ze(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], this.triangleCount === 0 || e.length === 0) return;
                    const [d, f] = [e[0].clone(), e[0].clone()];
                    for (let I = 1; I < e.length; ++I) {
                        const C = e[I];
                        d.x = Math.min(d.x, C.x), d.y = Math.min(d.y, C.y), f.x = Math.max(f.x, C.x), f.y = Math.max(f.y, C.y)
                    }
                    if (c) {
                        const I = Math.ceil(Math.max(f.x - d.x, f.y - d.y) / c);
                        a = Math.max(a, I)
                    }
                    if (a === 0) return;
                    this.min = d, this.max = f;
                    const _ = this.max.sub(this.min);
                    _.x = Math.max(_.x, 1), _.y = Math.max(_.y, 1);
                    const x = Math.max(_.x, _.y) / a;
                    this.cellsX = Math.max(1, Math.ceil(_.x / x)), this.cellsY = Math.max(1, Math.ceil(_.y / x)), this.xScale = 1 / x, this.yScale = 1 / x;
                    const w = [];
                    for (let I = 0; I < this.triangleCount; I++) {
                        const C = e[i[3 * I + 0]].sub(this.min), z = e[i[3 * I + 1]].sub(this.min),
                            L = e[i[3 * I + 2]].sub(this.min),
                            F = pl(Math.floor(Math.min(C.x, z.x, L.x)), this.xScale, this.cellsX),
                            N = pl(Math.floor(Math.max(C.x, z.x, L.x)), this.xScale, this.cellsX),
                            H = pl(Math.floor(Math.min(C.y, z.y, L.y)), this.yScale, this.cellsY),
                            Y = pl(Math.floor(Math.max(C.y, z.y, L.y)), this.yScale, this.cellsY), X = new Ze(0, 0),
                            J = new Ze(0, 0), xe = new Ze(0, 0), ge = new Ze(0, 0);
                        for (let ye = H; ye <= Y; ++ye) {
                            X.y = J.y = ye * x, xe.y = ge.y = (ye + 1) * x;
                            for (let Ee = F; Ee <= N; ++Ee) X.x = xe.x = Ee * x, J.x = ge.x = (Ee + 1) * x, (ur(C, z, L, X, J, ge) || ur(C, z, L, X, ge, xe)) && w.push({
                                cellIdx: ye * this.cellsX + Ee,
                                triIdx: I
                            })
                        }
                    }
                    if (w.length === 0) return;
                    w.sort((I, C) => I.cellIdx - C.cellIdx || I.triIdx - C.triIdx);
                    let E = 0;
                    for (; E < w.length;) {
                        const I = w[E].cellIdx, C = {start: this.payload.length, len: 0};
                        for (; E < w.length && w[E].cellIdx === I;) ++C.len, this.payload.push(w[E++].triIdx);
                        this.cells[I] = C
                    }
                }

                _lazyInitLookup() {
                    this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8))), this.lookup.fill(0)
                }

                queryPoint(e, i) {
                    if (this.triangleCount === 0 || this.cells.length === 0 || e.x > this.max.x || this.min.x > e.x || e.y > this.max.y || this.min.y > e.y) return;
                    const a = pl(e.x - this.min.x, this.xScale, this.cellsX),
                        c = pl(e.y - this.min.y, this.yScale, this.cellsY), d = this.cells[c * this.cellsX + a];
                    if (d) {
                        this._lazyInitLookup();
                        for (let f = 0; f < d.len; f++) {
                            const _ = this.payload[d.start + f], x = Math.floor(_ / 8), w = 1 << _ % 8;
                            if (!(this.lookup[x] & w) && (this.lookup[x] |= w, i.push(_), i.length === this.triangleCount)) return
                        }
                    }
                }

                query(e, i, a) {
                    if (this.triangleCount === 0 || this.cells.length === 0 || e.x > this.max.x || this.min.x > i.x || e.y > this.max.y || this.min.y > i.y) return;
                    this._lazyInitLookup();
                    const c = pl(e.x - this.min.x, this.xScale, this.cellsX),
                        d = pl(i.x - this.min.x, this.xScale, this.cellsX),
                        f = pl(e.y - this.min.y, this.yScale, this.cellsY),
                        _ = pl(i.y - this.min.y, this.yScale, this.cellsY);
                    for (let x = f; x <= _; x++) for (let w = c; w <= d; w++) {
                        const E = this.cells[x * this.cellsX + w];
                        if (E) for (let I = 0; I < E.len; I++) {
                            const C = this.payload[E.start + I], z = Math.floor(C / 8), L = 1 << C % 8;
                            if (!(this.lookup[z] & L) && (this.lookup[z] |= L, a.push(C), a.length === this.triangleCount)) return
                        }
                    }
                }
            }

            function pl(n, e, i) {
                return Math.max(0, Math.min(i - 1, Math.floor(n * e)))
            }

            Pt(Wy, "TriangleGridIndex");

            class RS {
                constructor(e) {
                    this.zoom = e.zoom, this.layers = e.layers, this.layerIds = this.layers.map(i => i.fqid), this.index = e.index, this.hasPattern = !1, this.stateDependentLayerIds = this.layers.filter(i => i.isStateDependent()).map(i => i.id), this.footprints = [], this.worldview = e.worldview
                }

                updateFootprints(e, i) {
                    for (const a of this.footprints) i.push({footprint: a, id: e})
                }

                populate(e, i, a, c) {
                    const d = [];
                    for (const {feature: f, id: _, index: x, sourceLayerIndex: w} of e) {
                        const E = this.layers[0]._featureFilter.needGeometry, I = $e(f, E);
                        if (!this.layers[0]._featureFilter.filter(new sn(this.zoom, {worldview: this.worldview}), I, a)) continue;
                        const C = {
                            id: _,
                            properties: f.properties,
                            type: f.type,
                            sourceLayerIndex: w,
                            index: x,
                            geometry: E ? I.geometry : Te(f, a, c),
                            patterns: {}
                        };
                        d.push(C)
                    }
                    for (const f of d) {
                        const {geometry: _, index: x, sourceLayerIndex: w} = f;
                        this.addFeature(f, _, x, a, {}, i.availableImages, i.brightness), i.featureIndex.insert(e[x].feature, _, x, w, this.index)
                    }
                }

                isEmpty() {
                    return this.footprints.length === 0
                }

                uploadPending() {
                    return !1
                }

                upload(e) {
                }

                update(e, i, a, c, d, f, _) {
                }

                destroy() {
                }

                addFeature(e, i, a, c, d, f = [], _) {
                    for (const x of Xm(i, 2)) {
                        const w = [], E = [], I = [], C = new Ze(1 / 0, 1 / 0), z = new Ze(-1 / 0, -1 / 0);
                        for (const N of x) if (N.length !== 0) {
                            N !== x[0] && I.push(E.length / 2);
                            for (let H = 0; H < N.length; H++) E.push(N[H].x), E.push(N[H].y), w.push(N[H]), C.x = Math.min(C.x, N[H].x), C.y = Math.min(C.y, N[H].y), z.x = Math.max(z.x, N[H].x), z.y = Math.max(z.y, N[H].y)
                        }
                        const L = df(E, I), F = new Wy(w, L, 8, 256);
                        this.footprints.push({vertices: w, indices: L, grid: F, min: C, max: z})
                    }
                }
            }

            Pt(RS, "ClipBucket", {omit: ["layers"]});
            const qL = Fi([{name: "a_pos_normal_ed", components: 4, type: "Int16"}]),
                WL = Fi([{name: "a_pos_end", components: 4, type: "Int16"}, {
                    name: "a_angular_offset_factor",
                    components: 1,
                    type: "Int16"
                }]), ZL = Fi([{name: "a_centroid_pos", components: 2, type: "Uint16"}]),
                XL = Fi([{name: "a_join_normal_inside", components: 3, type: "Int16"}]),
                YL = Fi([{name: "a_hidden_by_landmark", components: 1, type: "Uint8"}]),
                KL = Fi([{name: "a_pos_3", components: 3, type: "Int16"}, {
                    name: "a_pos_normal_3",
                    components: 3,
                    type: "Int16"
                }]), {members: QL} = qL, Ym = Number.MAX_SAFE_INTEGER, zS = Ym - 1;

            function DS(n, e, i, a) {
                return n.order < e || n.order === Ym || !(n.clipMask & i) || function (c, d) {
                    return d.length !== 0 && d.find(f => f === c) === void 0
                }(a, n.clipScope)
            }

            function Zy(n, e) {
                return n.x - e.x || n.y - e.y
            }

            function LS(n, e) {
                return Zy(n.min, e.min) === 0 && Zy(n.max, e.max) === 0
            }

            function z1(n, e) {
                return !(n.min.x > e.max.x || n.max.x < e.min.x || n.min.y > e.max.y || n.max.y < e.min.y)
            }

            function Xy(n, e) {
                if (n.length !== e.length) return !1;
                for (let i = 0; i < n.length; i++) if (n[i].sourceId !== e[i].sourceId || !LS(n[i], e[i]) || n[i].order !== e[i].order || n[i].clipMask !== e[i].clipMask || !xn(n[i].clipScope, e[i].clipScope)) return !1;
                return !0
            }

            function kS(n, e, i) {
                const a = 1 / yt, c = 1 / (1 << i.canonical.z), d = (e.x * a + i.canonical.x) * c + i.wrap,
                    f = (e.y * a + i.canonical.y) * c;
                return {
                    min: new Ze((n.x * a + i.canonical.x) * c + i.wrap, (n.y * a + i.canonical.y) * c),
                    max: new Ze(d, f)
                }
            }

            function JL(n, e, i) {
                const a = 1 << i.canonical.z, c = ((e.x - i.wrap) * a - i.canonical.x) * yt,
                    d = (e.y * a - i.canonical.y) * yt;
                return {
                    min: new Ze(((n.x - i.wrap) * a - i.canonical.x) * yt, (n.y * a - i.canonical.y) * yt),
                    max: new Ze(c, d)
                }
            }

            function D1(n, e, i, a, c, d, f) {
                const _ = n.indices, x = n.vertices, w = [];
                for (let E = a; E < a + c; E += 3) {
                    const I = e[i[E + 0] + d], C = e[i[E + 1] + d], z = e[i[E + 2] + d], L = Math.min(I.x, C.x, z.x),
                        F = Math.max(I.x, C.x, z.x), N = Math.min(I.y, C.y, z.y), H = Math.max(I.y, C.y, z.y);
                    w.length = 0, n.grid.query(new Ze(L, N), new Ze(F, H), w);
                    for (let Y = 0; Y < w.length; Y++) {
                        const X = w[Y];
                        if (ur(x[_[3 * X + 0]], x[_[3 * X + 1]], x[_[3 * X + 2]], I, C, z, f)) return !0
                    }
                }
                return !1
            }

            function OS(n, e, i, a) {
                if (!n || !i) return !1;
                let c = n.vertices;
                if (!e.canonical.equals(a.canonical) || e.wrap !== a.wrap) {
                    if (i.vertices.length < n.vertices.length) return OS(i, a, n, e);
                    const d = e.canonical, f = a.canonical, _ = Math.pow(2, f.z - d.z);
                    c = n.vertices.map(x => new Ze((x.x + d.x * yt) * _ - f.x * yt, (x.y + d.y * yt) * _ - f.y * yt))
                }
                return D1(i, c, n.indices, 0, n.indices.length, 0, 0)
            }

            function FS(n, e, i, a) {
                const c = Math.pow(2, a.z - i.z);
                return new Ze((n + i.x * yt) * c - a.x * yt, (e + i.y * yt) * c - a.y * yt)
            }

            function L1(n, e) {
                const i = [];
                e.grid.queryPoint(n, i);
                const a = e.indices, c = e.vertices;
                for (let d = 0; d < i.length; d++) {
                    const f = i[d];
                    if (Gr([c[a[3 * f + 0]], c[a[3 * f + 1]], c[a[3 * f + 2]]], n)) return !0
                }
                return !1
            }

            const k1 = [new Ze(0, 0), new Ze(yt, 0), new Ze(yt, yt), new Ze(0, yt)];

            function BS(n, e) {
                const i = [];
                let a = [];
                if (!e || n.length < 2) return [n];
                if (n.length === 2) return Un(n[0], n[1], k1) ? [n] : [];
                for (let c = 0; c < n.length + 2; c++) {
                    const d = n[c % n.length], f = n[(c + 1) % n.length],
                        _ = Un(c === 0 ? n[n.length - 1] : n[(c - 1) % n.length], d, k1), x = Un(d, f, k1), w = _ || x;
                    w && a.push(d), w && x || a.length > 0 && (a.length > 1 && i.push(a), a = [])
                }
                return a.length > 1 && i.push(a), i
            }

            const O1 = Be.types,
                ek = ["fill-extrusion-base", "fill-extrusion-height", "fill-extrusion-color", "fill-extrusion-pattern", "fill-extrusion-flood-light-wall-radius", "fill-extrusion-line-width", "fill-extrusion-emissive-strength"],
                tk = ["fill-extrusion-flood-light-ground-radius"], ik = Math.pow(2, 13), nk = Math.pow(2, 15) - 1,
                NS = new Ze(0, 1), tu = 2147483648;

            function Km(n, e, i, a, c, d, f, _) {
                n.emplaceBack((e << 1) + f, (i << 1) + d, (Math.floor(a * ik) << 1) + c, Math.round(_))
            }

            function Qm(n, e, i) {
                n.emplaceBack(e.x * yt, e.y * yt, i ? 1 : 0)
            }

            function Yy(n, e, i, a, c, d) {
                n.emplaceBack(e.x, e.y, (i.x << 1) + a, (i.y << 1) + c, d)
            }

            function Jm(n, e, i) {
                n.emplaceBack(e.x, e.y, e.z, i[0] * 16384, i[1] * 16384, i[2] * 16384)
            }

            class jS {
                constructor() {
                    this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0
                }
            }

            class VS {
                constructor() {
                    this.centroidXY = new Ze(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new Ze(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new Ze(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0, this.buildingId = 0
                }

                span() {
                    return new Ze(this.max.x - this.min.x, this.max.y - this.min.y)
                }
            }

            class US {
                constructor() {
                    this.acc = new Ze(0, 0), this.accCount = 0, this.centroidDataIndex = 0
                }

                startRing(e, i) {
                    e.min.x === Number.MAX_VALUE && (e.min.x = e.max.x = i.x, e.min.y = e.max.y = i.y)
                }

                appendEdge(e, i, a) {
                    this.accCount++, this.acc._add(i);
                    let c = !!this.borders;
                    i.x < e.min.x ? (e.min.x = i.x, c = !0) : i.x > e.max.x && (e.max.x = i.x, c = !0), i.y < e.min.y ? (e.min.y = i.y, c = !0) : i.y > e.max.y && (e.max.y = i.y, c = !0), ((i.x === 0 || i.x === yt) && i.x === a.x) != ((i.y === 0 || i.y === yt) && i.y === a.y) && this.processBorderOverlap(i, a), c && this.checkBorderIntersection(i, a)
                }

                checkBorderIntersection(e, i) {
                    i.x < 0 != e.x < 0 && this.addBorderIntersection(0, qt(i.y, e.y, (0 - i.x) / (e.x - i.x))), i.x > yt != e.x > yt && this.addBorderIntersection(1, qt(i.y, e.y, (yt - i.x) / (e.x - i.x))), i.y < 0 != e.y < 0 && this.addBorderIntersection(2, qt(i.x, e.x, (0 - i.y) / (e.y - i.y))), i.y > yt != e.y > yt && this.addBorderIntersection(3, qt(i.x, e.x, (yt - i.y) / (e.y - i.y)))
                }

                addBorderIntersection(e, i) {
                    this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
                    const a = this.borders[e];
                    i < a[0] && (a[0] = i), i > a[1] && (a[1] = i)
                }

                processBorderOverlap(e, i) {
                    if (e.x === i.x) {
                        if (e.y === i.y) return;
                        const a = e.x === 0 ? 0 : 1;
                        this.addBorderIntersection(a, i.y), this.addBorderIntersection(a, e.y)
                    } else {
                        const a = e.y === 0 ? 2 : 3;
                        this.addBorderIntersection(a, i.x), this.addBorderIntersection(a, e.x)
                    }
                }

                centroid() {
                    return this.accCount === 0 ? new Ze(0, 0) : new Ze(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount))
                }

                intersectsCount() {
                    return this.borders ? this.borders.reduce((e, i) => e + +(i[0] !== Number.MAX_VALUE), 0) : 0
                }
            }

            function GS(n, e) {
                const i = n.add(e)._unit(), a = se(n.x * i.x + n.y * i.y, -1, 1);
                var c, d, f;
                return c = Math.acos(a), Math.min(4, Math.max(-4, Math.tan(c))) / 4 * nk * ((d = n).x * (f = e).y - d.y * f.x < 0 ? -1 : 1)
            }

            const rk = [n => n.x < 0, n => n.x > yt, n => n.y < 0, n => n.y > yt];

            function ok(n, e, i, a) {
                const c = [4];
                if (a === 0) return c;
                i._mult(a);
                const d = n.sub(i), f = e.sub(i), _ = [n, e, d, f];
                for (let x = 0; x < 4; x++) for (const w of _) if (rk[x](w)) {
                    c.push(x);
                    break
                }
                return c
            }

            class F1 {
                constructor(e) {
                    this.vertexArray = new ef, this.indexArray = new Mn, this.programConfigurations = new es(e.layers, {
                        zoom: e.zoom,
                        lut: e.lut
                    }, i => tk.includes(i)), this._segments = new Ln, this.hiddenByLandmarkVertexArray = new af, this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0], this.regionSegments = {}, this.regionSegments[4] = new Ln
                }

                getDefaultSegment() {
                    return this.regionSegments[4]
                }

                hasData() {
                    return this.vertexArray.length !== 0
                }

                addData(e, i, a, c = !1) {
                    const d = e.length;
                    if (d > 2) {
                        let f = Math.max(0, this._segments.get().length - 1);
                        const _ = this._segments._prepareSegment(4 * d, this.vertexArray.length, 2 * this._segmentToGroundQuads[f].length);
                        let x;
                        f !== this._segments.get().length - 1 && (f++, this._segmentToGroundQuads[f] = [], this._segmentToRegionTriCounts[f] = [0, 0, 0, 0, 0]);
                        {
                            const w = e[0], E = e[1];
                            x = GS(w.sub(e[d - 1])._perp()._unit(), E.sub(w)._perp()._unit())
                        }
                        for (let w = 0; w < d; w++) {
                            const E = w === d - 1 ? 0 : w + 1, I = e[w], C = e[E], z = e[E === d - 1 ? 0 : E + 1],
                                L = C.sub(I)._perp()._unit(), F = GS(L, z.sub(C)._perp()._unit()), N = x, H = F;
                            if (B1(I, C, i) || c && qS(I, i) && qS(C, i)) {
                                x = F;
                                continue
                            }
                            const Y = _.vertexLength;
                            Yy(this.vertexArray, I, C, 1, 1, N), Yy(this.vertexArray, I, C, 1, 0, N), Yy(this.vertexArray, I, C, 0, 1, H), Yy(this.vertexArray, I, C, 0, 0, H), _.vertexLength += 4;
                            const X = ok(I, C, L, a);
                            for (const J of X) this._segmentToGroundQuads[f].push({
                                id: Y,
                                region: J
                            }), this._segmentToRegionTriCounts[f][J] += 2, _.primitiveLength += 2;
                            x = F
                        }
                    }
                }

                prepareBorderSegments() {
                    if (!this.hasData()) return;
                    const e = this._segments.get(), i = e.length;
                    for (let a = 0; a < i; a++) this._segmentToGroundQuads[a].sort((c, d) => c.region - d.region);
                    for (let a = 0; a < i; a++) {
                        const c = this._segmentToGroundQuads[a], d = e[a], f = this._segmentToRegionTriCounts[a];
                        f.reduce((x, w) => x + w, 0);
                        let _ = 0;
                        for (let x = 0; x <= 4; x++) {
                            const w = f[x];
                            if (w !== 0) {
                                let E = this.regionSegments[x];
                                E || (E = this.regionSegments[x] = new Ln);
                                const I = {
                                    vertexOffset: d.vertexOffset,
                                    primitiveOffset: d.primitiveOffset + _,
                                    vertexLength: d.vertexLength,
                                    primitiveLength: w
                                };
                                E.get().push(I)
                            }
                            _ += w
                        }
                        for (let x = 0; x < c.length; x++) {
                            const w = c[x].id;
                            this.indexArray.emplaceBack(w, w + 1, w + 3), this.indexArray.emplaceBack(w, w + 3, w + 2)
                        }
                    }
                    this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null
                }

                addPaintPropertiesData(e, i, a, c, d, f, _) {
                    this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, e, i, a, c, d, f, void 0, _)
                }

                upload(e) {
                    this.hasData() && (this.vertexBuffer = e.createVertexBuffer(this.vertexArray, WL.members), this.indexBuffer = e.createIndexBuffer(this.indexArray))
                }

                uploadPaintProperties(e) {
                    this.hasData() && this.programConfigurations.upload(e)
                }

                update(e, i, a, c, d, f, _, x) {
                    this.hasData() && this.programConfigurations.updatePaintArrays(e, i, a, c, d, f, _, x)
                }

                updateHiddenByLandmark(e) {
                    this.updateHiddenByLandmarkRange(e.groundVertexArrayOffset, e.groundVertexCount, !!(e.flags & tu))
                }

                updateHiddenByLandmarkRange(e, i, a) {
                    if (!this.hasData()) return;
                    const c = i + e;
                    if (i !== 0) {
                        for (let d = e; d < c; ++d) this.hiddenByLandmarkVertexArray.emplace(d, a ? 1 : 0);
                        this._needsHiddenByLandmarkUpdate = !0
                    }
                }

                uploadHiddenByLandmark(e) {
                    this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = e.createVertexBuffer(this.hiddenByLandmarkVertexArray, YL.members, !0) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = !1)
                }

                destroy() {
                    if (this.vertexBuffer) {
                        this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();
                        for (let e = 0; e <= 4; e++) {
                            const i = this.regionSegments[e];
                            i && i.destroy()
                        }
                    }
                }
            }

            class Ky {
                constructor(e) {
                    this.zoom = e.zoom, this.canonical = e.canonical, this.overscaling = e.overscaling, this.layers = e.layers, this.pixelRatio = e.pixelRatio, this.layerIds = this.layers.map(i => i.fqid), this.index = e.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = e.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new Mn, this.footprintVertices = new Po, this.footprintSegments = [], this.layoutVertexArray = new Uc, this.centroidVertexArray = new My, this.wallVertexArray = new zy, this.indexArray = new Mn, this.programConfigurations = new es(e.layers, {
                        zoom: e.zoom,
                        lut: e.lut
                    }, i => ek.includes(i)), this.segments = new Ln, this.stateDependentLayerIds = this.layers.filter(i => i.isStateDependent()).map(i => i.id), this.groundEffect = new F1(e), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [], this.worldview = e.worldview
                }

                updateFootprints(e, i) {
                }

                populate(e, i, a, c) {
                    this.features = [], this.hasPattern = I1("fill-extrusion", this.layers, this.pixelRatio, i), this.featuresOnBorder = [], this.borderFeatureIndices = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.selfDEMTileTimestamp = Number.MAX_VALUE, this.borderDEMTileTimestamp = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], this.tileToMeter = he(a), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter, this.wallMode = this.layers[0].paint.get("fill-extrusion-line-width").constantOr(1) !== 0;
                    for (const {feature: d, id: f, index: _, sourceLayerIndex: x} of e) {
                        const w = this.layers[0]._featureFilter.needGeometry, E = $e(d, w);
                        if (!this.layers[0]._featureFilter.filter(new sn(this.zoom, {worldview: this.worldview}), E, a)) continue;
                        const I = {
                            id: f,
                            sourceLayerIndex: x,
                            index: _,
                            geometry: w ? E.geometry : Te(d, a, c),
                            properties: d.properties,
                            type: d.type,
                            patterns: {}
                        }, C = this.layoutVertexArray.length, z = O1[I.type] === "Polygon";
                        if (this.hasPattern) this.features.push({
                            featureId: d.id,
                            feature: C1("fill-extrusion", this.layers, I, this.zoom, this.pixelRatio, i)
                        }); else if (this.wallMode) for (const L of I.geometry) for (const F of BS(L, z)) this.addFeature(d.id, I, [F], _, a, {}, i.availableImages, c, i.brightness); else this.addFeature(d.id, I, I.geometry, _, a, {}, i.availableImages, c, i.brightness);
                        i.featureIndex.insert(d, I.geometry, _, x, this.index, C)
                    }
                    this.sortBorders(), this.projection.name === "mercator" && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0
                }

                addFeatures(e, i, a, c, d, f) {
                    for (const {featureId: _, feature: x} of this.features) {
                        const w = O1[x.type] === "Polygon", {geometry: E} = x;
                        if (this.wallMode) for (const I of E) for (const C of BS(I, w)) this.addFeature(_, x, [C], x.index, i, a, c, d, f); else this.addFeature(_, x, E, x.index, i, a, c, d, f)
                    }
                    this.sortBorders(), this.projection.name === "mercator" && this.splitToSubtiles()
                }

                update(e, i, a, c, d, f, _) {
                    this.programConfigurations.updatePaintArrays(e, i, d, a, c, f, _, this.worldview), this.groundEffect.update(e, i, d, a, c, f, _, this.worldview)
                }

                isEmpty() {
                    return this.layoutVertexArray.length === 0
                }

                uploadPending() {
                    return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload
                }

                upload(e) {
                    this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, QL), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.wallVertexBuffer = e.createVertexBuffer(this.wallVertexArray, XL.members), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = e.createVertexBuffer(this.layoutVertexExtArray, KL.members, !0)), this.groundEffect.upload(e)), this.groundEffect.uploadPaintProperties(e), this.programConfigurations.upload(e), this.uploaded = !0
                }

                uploadCentroid(e) {
                    this.groundEffect.uploadHiddenByLandmark(e), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, ZL.members, !0) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = !1)
                }

                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
                }

                addFeature(e, i, a, c, d, f, _, x, w) {
                    const E = this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(i, {}) / this.tileToMeter,
                        I = [new Ze(0, 0), new Ze(yt, yt)], C = x.projection, z = C.name === "globe",
                        L = this.wallMode || O1[i.type] === "Polygon", F = new US;
                    F.centroidDataIndex = this.centroidData.length;
                    const N = new VS;
                    N.buildingId = e, i.properties && i.properties.hasOwnProperty("building_id") && (N.buildingId = i.properties.building_id);
                    const H = this.layers[0].paint.get("fill-extrusion-base").evaluate(i, {}, d) <= 0,
                        Y = this.layers[0].paint.get("fill-extrusion-height").evaluate(i, {}, d);
                    let X;
                    if (N.height = Y, N.vertexArrayOffset = this.layoutVertexArray.length, N.groundVertexArrayOffset = this.groundEffect.vertexArray.length, z && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new nf), this.wallMode) {
                        if (z) return void Li("Non zero fill-extrusion-line-width is not yet supported on globe.");
                        if (a.length !== 1) return;
                        X = function (De) {
                            const Ye = De[0].x === De[De.length - 1].x && De[0].y === De[De.length - 1].y;
                            (function (lt) {
                                let kt = 0;
                                const Et = lt.length;
                                for (let vt = 0; vt < Et; vt++) kt += (lt[(vt + 1) % Et].x - lt[vt].x) * (lt[(vt + 1) % Et].y + lt[vt].y);
                                return kt >= 0
                            })(De) || (De = De.reverse());
                            const Qe = {geometry: [], joinNormals: [], indices: []}, ot = [], ct = [], He = [];
                            let st = De.length;
                            for (; st >= 2 && De[st - 1].equals(De[st - 2]);) st--;
                            if (st < (Ye ? 3 : 2)) return Qe;
                            let ke, qe, pt, at, Bt, zt = 0;
                            for (; zt < st - 1 && De[zt].equals(De[zt + 1]);) zt++;
                            Ye && (ke = De[st - 2], Bt = De[zt].sub(ke)._unit()._perp());
                            for (let lt = zt; lt < st; lt++) {
                                if (pt = lt === st - 1 ? Ye ? De[zt + 1] : void 0 : De[lt + 1], pt && De[lt].equals(pt)) continue;
                                Bt && (at = Bt), ke && (qe = ke), ke = De[lt], Bt = pt ? pt.sub(ke)._unit()._perp() : at, at = at || Bt;
                                let kt = at.add(Bt);
                                kt.x === 0 && kt.y === 0 || kt._unit();
                                const Et = kt.x * Bt.x + kt.y * Bt.y, vt = Et !== 0 ? 1 / Et : 1 / 0,
                                    At = at.x * Bt.y - at.y * Bt.x > 0;
                                let Kt = "miter";
                                const oi = 2;
                                Kt === "miter" && vt > oi && (Kt = "bevel"), Kt === "bevel" && (vt > 100 && (Kt = "flipbevel"), vt < oi && (Kt = "miter"));
                                const pi = (ui, ki, bi, Tn) => {
                                    const ne = new Ze(ui.x, ui.y), re = new Ze(ui.x, ui.y);
                                    ne.x += ki.x * Tn, ne.y += ki.y * Tn, re.x -= ki.x * Math.max(bi, 1), re.y -= ki.y * Math.max(bi, 1), He.push(ki), ot.push(ne), ct.push(re)
                                };
                                if (Kt === "miter") kt._mult(vt), pi(ke, kt, 0, 0); else if (Kt === "flipbevel") kt = Bt.mult(-1), pi(ke, kt, 0, 0), pi(ke, kt.mult(-1), 0, 0); else {
                                    const ui = -Math.sqrt(vt * vt - 1), ki = At ? ui : 0, bi = At ? 0 : ui;
                                    qe && pi(ke, at, ki, bi), pt && pi(ke, Bt, ki, bi)
                                }
                            }
                            Qe.geometry = [...ot, ...ct.reverse(), ot[0]], Qe.joinNormals = [...He, ...He.reverse(), He[He.length - 1]];
                            const nt = Qe.geometry.length - 1;
                            for (let lt = 0; lt < nt / 2; lt++) if (lt + 1 < nt / 2) {
                                let kt = lt, Et = lt + 1, vt = nt - 1 - lt, At = nt - 2 - lt;
                                kt = kt === 0 ? nt - 1 : kt - 1, Et = Et === 0 ? nt - 1 : Et - 1, vt = vt === 0 ? nt - 1 : vt - 1, At = At === 0 ? nt - 1 : At - 1, Qe.indices.push(vt), Qe.indices.push(Et), Qe.indices.push(kt), Qe.indices.push(vt), Qe.indices.push(At), Qe.indices.push(Et)
                            }
                            return Qe
                        }(a[0]), a = [X.geometry]
                    }
                    const J = (De, Ye) => De < (Ye.length - 1) / 2 || De === Ye.length - 1,
                        xe = this.wallMode ? [a] : Xm(a, 500);
                    for (let De = xe.length - 1; De >= 0; De--) {
                        const Ye = xe[De];
                        (Ye.length === 0 || (ge = Ye[0]).every(ht => ht.x <= 0) || ge.every(ht => ht.x >= yt) || ge.every(ht => ht.y <= 0) || ge.every(ht => ht.y >= yt)) && xe.splice(De, 1)
                    }
                    var ge;
                    let ye;
                    if (z) ye = YS(xe, I, d); else {
                        ye = [];
                        for (const De of xe) ye.push({polygon: De, bounds: I})
                    }
                    const Ee = L ? this.edgeRadius : 0, Ie = Ee > 0 && this.zoom < 17, We = (De, Ye) => {
                        if (De.length === 0) return !1;
                        const ht = De[De.length - 1];
                        return Ye.x === ht.x && Ye.y === ht.y
                    };
                    for (const {polygon: De, bounds: Ye} of ye) {
                        let ht = 0, Qe = 0;
                        for (const st of De) L && !st[0].equals(st[st.length - 1]) && st.push(st[0]), Qe += L ? st.length - 1 : st.length;
                        const ot = this.segments.prepareSegment((L ? 5 : 4) * Qe, this.layoutVertexArray, this.indexArray);
                        N.footprintSegIdx < 0 && (N.footprintSegIdx = this.footprintSegments.length), N.polygonSegIdx < 0 && (N.polygonSegIdx = this.polygonSegments.length);
                        const ct = {
                            triangleArrayOffset: this.indexArray.length,
                            triangleCount: 0,
                            triangleSegIdx: this.segments.segments.length - 1
                        }, He = new jS;
                        if (He.vertexOffset = this.footprintVertices.length, He.indexOffset = 3 * this.footprintIndices.length, He.ringIndices = [], L) {
                            const st = [], ke = [];
                            ht = ot.vertexLength;
                            for (let pt = 0; pt < De.length; pt++) {
                                const at = De[pt];
                                at.length && pt !== 0 && ke.push(st.length / 2);
                                const Bt = [];
                                let zt, nt;
                                zt = at[1].sub(at[0])._perp()._unit(), He.ringIndices.push(at.length - 1);
                                for (let lt = 1; lt < at.length; lt++) {
                                    const kt = at[lt], Et = at[lt === at.length - 1 ? 1 : lt + 1], vt = kt.clone();
                                    if (Ee) {
                                        nt = Et.sub(kt)._perp()._unit();
                                        const At = zt.add(nt)._unit(),
                                            Kt = Ee * Math.min(4, 1 / (zt.x * At.x + zt.y * At.y));
                                        vt.x += Kt * At.x, vt.y += Kt * At.y, vt.x = Math.round(vt.x), vt.y = Math.round(vt.y), zt = nt
                                    }
                                    if (!H || Ee !== 0 && !Ie || We(Bt, vt) || Bt.push(vt), Km(this.layoutVertexArray, vt.x, vt.y, 0, 0, 1, 1, 0), this.wallMode) {
                                        const At = J(lt, at);
                                        Qm(this.wallVertexArray, X.joinNormals[lt], !At)
                                    }
                                    ot.vertexLength++, this.footprintVertices.emplaceBack(kt.x, kt.y), st.push(kt.x, kt.y), z && Jm(this.layoutVertexExtArray, C.projectTilePoint(vt.x, vt.y, d), C.upVector(d, vt.x, vt.y))
                                }
                                H && (Ee === 0 || Ie) && (Bt.length !== 0 && We(Bt, Bt[0]) && Bt.pop(), this.groundEffect.addData(Bt, Ye, E))
                            }
                            const qe = this.wallMode ? X.indices : df(st, ke);
                            for (let pt = 0; pt < qe.length; pt += 3) this.footprintIndices.emplaceBack(He.vertexOffset + qe[pt + 0], He.vertexOffset + qe[pt + 1], He.vertexOffset + qe[pt + 2]), this.indexArray.emplaceBack(ht + qe[pt], ht + qe[pt + 2], ht + qe[pt + 1]), ot.primitiveLength++;
                            He.indexCount += qe.length, He.vertexCount += this.footprintVertices.length - He.vertexOffset
                        }
                        for (let st = 0; st < De.length; st++) {
                            const ke = De[st];
                            F.startRing(N, ke[0]);
                            let qe = ke.length > 4 && WS(ke[ke.length - 2], ke[0], ke[1]),
                                pt = Ee ? sk(ke[ke.length - 2], ke[0], ke[1], Ee) : 0;
                            const at = [];
                            let Bt, zt, nt;
                            zt = ke[1].sub(ke[0])._perp()._unit();
                            let lt = !0;
                            for (let kt = 1, Et = 0; kt < ke.length; kt++) {
                                let vt = ke[kt - 1], At = ke[kt];
                                const Kt = ke[kt === ke.length - 1 ? 1 : kt + 1];
                                if (F.appendEdge(N, At, vt), B1(At, vt, Ye)) {
                                    Ee && (zt = Kt.sub(At)._perp()._unit(), lt = !lt);
                                    continue
                                }
                                const oi = At.sub(vt)._perp(), pi = oi.x / (Math.abs(oi.x) + Math.abs(oi.y)),
                                    ui = oi.y > 0 ? 1 : 0, ki = vt.dist(At);
                                if (Et + ki > 32768 && (Et = 0), Ee) {
                                    nt = Kt.sub(At)._perp()._unit();
                                    let re = HS(vt, At, Kt, $S(zt, nt), Ee);
                                    isNaN(re) && (re = 0);
                                    const Ge = At.sub(vt)._unit();
                                    vt = vt.add(Ge.mult(pt))._round(), At = At.add(Ge.mult(-re))._round(), pt = re, zt = nt, H && this.zoom >= 17 && (We(at, vt) || at.push(vt), We(at, At) || at.push(At))
                                }
                                const bi = ot.vertexLength, Tn = ke.length > 4 && WS(vt, At, Kt);
                                let ne = ZS(Et, qe, lt);
                                if (Km(this.layoutVertexArray, vt.x, vt.y, pi, ui, 0, 0, ne), Km(this.layoutVertexArray, vt.x, vt.y, pi, ui, 0, 1, ne), this.wallMode) {
                                    const re = J(kt - 1, ke), Ge = X.joinNormals[kt - 1];
                                    Qm(this.wallVertexArray, Ge, re), Qm(this.wallVertexArray, Ge, re)
                                }
                                if (Et += ki, ne = ZS(Et, Tn, !lt), qe = Tn, Km(this.layoutVertexArray, At.x, At.y, pi, ui, 0, 0, ne), Km(this.layoutVertexArray, At.x, At.y, pi, ui, 0, 1, ne), this.wallMode) {
                                    const re = J(kt, ke), Ge = X.joinNormals[kt];
                                    Qm(this.wallVertexArray, Ge, re), Qm(this.wallVertexArray, Ge, re)
                                }
                                if (ot.vertexLength += 4, this.indexArray.emplaceBack(bi + 0, bi + 1, bi + 2), this.indexArray.emplaceBack(bi + 1, bi + 3, bi + 2), ot.primitiveLength += 2, Ee) {
                                    const re = ht + (kt === 1 ? ke.length - 2 : kt - 2), Ge = kt === 1 ? ht : re + 1;
                                    if (this.indexArray.emplaceBack(bi + 1, re, bi + 3), this.indexArray.emplaceBack(re, Ge, bi + 3), ot.primitiveLength += 2, Bt === void 0 && (Bt = bi), !B1(Kt, ke[kt], Ye)) {
                                        const mt = kt === ke.length - 1 ? Bt : ot.vertexLength;
                                        this.indexArray.emplaceBack(bi + 2, bi + 3, mt), this.indexArray.emplaceBack(bi + 3, mt + 1, mt), this.indexArray.emplaceBack(bi + 3, Ge, mt + 1), ot.primitiveLength += 3
                                    }
                                    lt = !lt
                                }
                                if (z) {
                                    const re = this.layoutVertexExtArray, Ge = C.projectTilePoint(vt.x, vt.y, d),
                                        mt = C.projectTilePoint(At.x, At.y, d), bt = C.upVector(d, vt.x, vt.y),
                                        wt = C.upVector(d, At.x, At.y);
                                    Jm(re, Ge, bt), Jm(re, Ge, bt), Jm(re, mt, wt), Jm(re, mt, wt)
                                }
                            }
                            L && (ht += ke.length - 1), H && Ee && this.zoom >= 17 && (at.length !== 0 && We(at, at[0]) && at.pop(), this.groundEffect.addData(at, Ye, E, Ee > 0))
                        }
                        this.footprintSegments.push(He), ct.triangleCount = this.indexArray.length - ct.triangleArrayOffset, this.polygonSegments.push(ct), ++N.footprintSegLen, ++N.polygonSegLen
                    }
                    if (N.vertexCount = this.layoutVertexArray.length - N.vertexArrayOffset, N.groundVertexCount = this.groundEffect.vertexArray.length - N.groundVertexArrayOffset, N.vertexCount !== 0) {
                        if (N.centroidXY = F.borders ? NS : this.encodeCentroid(F, N), this.centroidData.push(N), F.borders) {
                            this.featuresOnBorder.push(F);
                            const De = this.featuresOnBorder.length - 1;
                            for (let Ye = 0; Ye < F.borders.length; Ye++) F.borders[Ye][0] !== Number.MAX_VALUE && this.borderFeatureIndices[Ye].push(De)
                        }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, i, c, f, _, d, w, void 0, this.worldview), this.groundEffect.addPaintPropertiesData(i, c, f, _, d, w, this.worldview), this.maxHeight = Math.max(this.maxHeight, Y)
                    }
                }

                sortBorders() {
                    for (let e = 0; e < this.borderFeatureIndices.length; e++) this.borderFeatureIndices[e].sort((i, a) => this.featuresOnBorder[i].borders[e][0] - this.featuresOnBorder[a].borders[e][0])
                }

                splitToSubtiles() {
                    const e = [];
                    for (let _ = 0; _ < this.centroidData.length; _++) {
                        const x = this.centroidData[_], w = +(x.min.y + x.max.y > yt),
                            E = 2 * w + (+(x.min.x + x.max.x > yt) ^ w);
                        for (let I = 0; I < x.polygonSegLen; I++) {
                            const C = x.polygonSegIdx + I;
                            e.push({
                                centroidIdx: _,
                                subtile: E,
                                polygonSegmentIdx: C,
                                triangleSegmentIdx: this.polygonSegments[C].triangleSegIdx
                            })
                        }
                    }
                    const i = new Mn;
                    e.sort((_, x) => _.triangleSegmentIdx === x.triangleSegmentIdx ? _.subtile - x.subtile : _.triangleSegmentIdx - x.triangleSegmentIdx);
                    let a = 0, c = 0, d = 0;
                    for (const _ of e) {
                        if (_.triangleSegmentIdx !== a) break;
                        d++
                    }
                    const f = e.length;
                    for (; c !== e.length;) {
                        a = e[c].triangleSegmentIdx;
                        let _ = 0, x = c, w = c;
                        for (let E = x; E < d && e[E].subtile === _; E++) w++;
                        for (; x !== d;) {
                            const E = e[x];
                            _ = E.subtile;
                            const I = this.centroidData[E.centroidIdx].min.clone(),
                                C = this.centroidData[E.centroidIdx].max.clone(), z = {
                                    vertexOffset: this.segments.segments[a].vertexOffset,
                                    primitiveOffset: i.length,
                                    vertexLength: this.segments.segments[a].vertexLength,
                                    primitiveLength: 0,
                                    sortKey: void 0,
                                    vaos: {}
                                };
                            for (let L = x; L < w; L++) {
                                const F = e[L], N = this.polygonSegments[F.polygonSegmentIdx],
                                    H = this.centroidData[F.centroidIdx].min, Y = this.centroidData[F.centroidIdx].max,
                                    X = this.indexArray.uint16;
                                for (let J = N.triangleArrayOffset; J < N.triangleArrayOffset + N.triangleCount; J++) i.emplaceBack(X[3 * J], X[3 * J + 1], X[3 * J + 2]);
                                z.primitiveLength += N.triangleCount, I.x = Math.min(I.x, H.x), I.y = Math.min(I.y, H.y), C.x = Math.max(C.x, Y.x), C.y = Math.max(C.y, Y.y)
                            }
                            z.primitiveLength > 0 && this.triangleSubSegments.push({segment: z, min: I, max: C}), x = w;
                            for (let L = x; L < d && e[L].subtile === e[x].subtile; L++) w++
                        }
                        c = d;
                        for (let E = c; E < f && e[E].triangleSegmentIdx === e[c].triangleSegmentIdx; E++) d++
                    }
                    i._trim(), this.indexArray = i
                }

                getVisibleSegments(e, i, a) {
                    const c = new Ln;
                    if (this.wallMode) {
                        for (const F of this.triangleSubSegments) c.segments.push(F.segment);
                        return c
                    }
                    let d = 0, f = 0;
                    const _ = 1 << e.canonical.z;
                    if (i) {
                        const F = i.getMinMaxForTile(e);
                        F && (d = F.min, f = F.max)
                    }
                    f += this.maxHeight;
                    const x = e.toUnwrapped();
                    let w;
                    const E = [x.canonical.x / _ + x.wrap, x.canonical.y / _],
                        I = [(x.canonical.x + 1) / _ + x.wrap, (x.canonical.y + 1) / _],
                        C = (F, N, H) => [F[0] * (1 - H[0]) + N[0] * H[0], F[1] * (1 - H[1]) + N[1] * H[1]], z = [],
                        L = [];
                    for (const F of this.triangleSubSegments) {
                        z[0] = F.min.x / yt, z[1] = F.min.y / yt, L[0] = F.max.x / yt, L[1] = F.max.y / yt;
                        const N = C(E, I, z), H = C(E, I, L);
                        if (new Ei([N[0], N[1], d], [H[0], H[1], f]).intersectsPrecise(a) === 0) {
                            w && (c.segments.push(w), w = void 0);
                            continue
                        }
                        const Y = F.segment;
                        w && w.vertexOffset !== Y.vertexOffset && (c.segments.push(w), w = void 0), w ? (w.vertexLength += Y.vertexLength, w.primitiveLength += Y.primitiveLength) : w = {
                            vertexOffset: Y.vertexOffset,
                            primitiveLength: Y.primitiveLength,
                            vertexLength: Y.vertexLength,
                            primitiveOffset: Y.primitiveOffset,
                            sortKey: void 0,
                            vaos: {}
                        }
                    }
                    return w && c.segments.push(w), c
                }

                encodeCentroid(e, i) {
                    const a = e.centroid(), c = i.span(), d = Math.min(7, Math.round(c.x * this.tileToMeter / 10)),
                        f = Math.min(7, Math.round(c.y * this.tileToMeter / 10));
                    return new Ze(se(a.x, 1, yt - 1) << 3 | d, se(a.y, 1, yt - 1) << 3 | f)
                }

                encodeBorderCentroid(e) {
                    if (!e.borders) return new Ze(0, 0);
                    const i = e.borders, a = Number.MAX_VALUE;
                    if (i[0][0] !== a || i[1][0] !== a) {
                        const c = i[0][0] !== a ? 0 : 1;
                        return new Ze(6 | (i[0][0] !== a ? 0 : 65528), (i[c][0] + i[c][1]) / 2 << 3 | 6)
                    }
                    {
                        const c = i[2][0] !== a ? 2 : 3;
                        return new Ze((i[c][0] + i[c][1]) / 2 << 3 | 6, 6 | (i[2][0] !== a ? 0 : 65528))
                    }
                }

                showCentroid(e) {
                    const i = this.centroidData[e.centroidDataIndex];
                    i.flags &= 2147483647, i.centroidXY.x = 0, i.centroidXY.y = 0, this.writeCentroidToBuffer(i)
                }

                writeCentroidToBuffer(e) {
                    this.groundEffect.updateHiddenByLandmark(e);
                    const i = e.vertexArrayOffset, a = e.vertexCount + e.vertexArrayOffset,
                        c = e.flags & tu ? NS : e.centroidXY, d = this.centroidVertexArray.geta_centroid_pos0(i);
                    if (this.centroidVertexArray.geta_centroid_pos1(i) !== c.y || d !== c.x) {
                        for (let f = i; f < a; ++f) this.centroidVertexArray.emplace(f, c.x, c.y);
                        this.needsCentroidUpdate = !0
                    }
                }

                createCentroidsBuffer() {
                    this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
                    for (const e of this.centroidData) this.writeCentroidToBuffer(e)
                }

                updateReplacement(e, i, a) {
                    if (i.updateTime === this.replacementUpdateTime) return;
                    this.replacementUpdateTime = i.updateTime;
                    const c = i.getReplacementRegionsForTile(e.toUnwrapped());
                    if (Xy(this.activeReplacements, c)) return;
                    if (this.activeReplacements = c, this.centroidVertexArray.length === 0) this.createCentroidsBuffer(); else for (const f of this.centroidData) f.flags &= 2147483647;
                    const d = [];
                    for (const f of this.activeReplacements) {
                        if (f.order < a) continue;
                        const _ = Math.max(1, Math.pow(2, f.footprintTileId.canonical.z - e.canonical.z));
                        if (f.footprint.buildingId) {
                            const x = f.footprint.buildingId;
                            for (const w of this.centroidData) w.buildingId === x && (w.flags |= tu)
                        } else for (const x of this.centroidData) if (!(x.flags & tu || f.min.x > x.max.x || x.min.x > f.max.x || f.min.y > x.max.y || x.min.y > f.max.y)) for (let w = 0; w < x.footprintSegLen; w++) {
                            const E = this.footprintSegments[x.footprintSegIdx + w];
                            if (d.length = 0, ak(this.footprintVertices, E.vertexOffset, E.vertexCount, f.footprintTileId.canonical, e.canonical, d), D1(f.footprint, d, this.footprintIndices.uint16, E.indexOffset, E.indexCount, -E.vertexOffset, -_)) {
                                x.flags |= tu;
                                break
                            }
                        }
                    }
                    for (const f of this.centroidData) this.writeCentroidToBuffer(f);
                    this.borderDoneWithNeighborZ = [-1, -1, -1, -1]
                }

                footprintContainsPoint(e, i, a) {
                    let c = !1;
                    for (let d = 0; d < a.footprintSegLen; d++) {
                        const f = this.footprintSegments[a.footprintSegIdx + d];
                        let _ = 0;
                        for (const x of f.ringIndices) {
                            for (let w = _, E = x + _ - 1; w < x + _; E = w++) {
                                const I = this.footprintVertices.int16[2 * (w + f.vertexOffset) + 0],
                                    C = this.footprintVertices.int16[2 * (w + f.vertexOffset) + 1],
                                    z = this.footprintVertices.int16[2 * (E + f.vertexOffset) + 1];
                                C > i != z > i && e < (this.footprintVertices.int16[2 * (E + f.vertexOffset) + 0] - I) * (i - C) / (z - C) + I && (c = !c)
                            }
                            _ = x
                        }
                    }
                    return c
                }

                getHeightAtTileCoord(e, i) {
                    let a = Number.NEGATIVE_INFINITY, c = !0;
                    const d = 4 * (e + yt) * yt + (i + yt);
                    if (this.partLookup.hasOwnProperty(d)) {
                        const f = this.partLookup[d];
                        return f ? {height: f.height, hidden: !!(f.flags & tu)} : void 0
                    }
                    for (const f of this.centroidData) e > f.max.x || f.min.x > e || i > f.max.y || f.min.y > i || f.height <= a || this.footprintContainsPoint(e, i, f) && (a = f.height, this.partLookup[d] = f, c = !!(f.flags & tu));
                    if (a !== Number.NEGATIVE_INFINITY) return {height: a, hidden: c};
                    this.partLookup[d] = void 0
                }
            }

            function $S(n, e) {
                const i = n.add(e)._unit();
                return n.x * i.x + n.y * i.y
            }

            function sk(n, e, i, a) {
                const c = e.sub(n)._perp()._unit(), d = i.sub(e)._perp()._unit();
                return HS(n, e, i, $S(c, d), a)
            }

            function HS(n, e, i, a, c) {
                const d = Math.sqrt(1 - a * a);
                return Math.min(n.dist(e) / 3, e.dist(i) / 3, c * d / a)
            }

            function B1(n, e, i) {
                return n.x < i[0].x && e.x < i[0].x || n.x > i[1].x && e.x > i[1].x || n.y < i[0].y && e.y < i[0].y || n.y > i[1].y && e.y > i[1].y
            }

            function qS(n, e) {
                return n.x < e[0].x || n.x > e[1].x || n.y < e[0].y || n.y > e[1].y
            }

            function WS(n, e, i) {
                if (n.x < 0 || n.x >= yt || e.x < 0 || e.x >= yt || i.x < 0 || i.x >= yt) return !1;
                const a = i.sub(e), c = a.perp(), d = n.sub(e);
                return (a.x * d.x + a.y * d.y) / Math.sqrt((a.x * a.x + a.y * a.y) * (d.x * d.x + d.y * d.y)) > -.866 && c.x * d.x + c.y * d.y < 0
            }

            function ZS(n, e, i) {
                const a = e ? 2 | n : -3 & n;
                return i ? 1 | a : -2 & a
            }

            function XS() {
                const n = Math.PI / 32, e = Math.tan(n), i = S;
                return i * Math.sqrt(1 + 2 * e * e) - i
            }

            function YS(n, e, i) {
                const a = 1 << i.z, c = Z(i.x / a), d = Z((i.x + 1) / a), f = Q(i.y / a), _ = Q((i.y + 1) / a);
                return function (x, w, E, I, C = 0, z) {
                    const L = [];
                    if (!x.length || !E || !I) return L;
                    const F = (ge, ye) => {
                        for (const Ee of ge) L.push({polygon: Ee, bounds: ye})
                    }, N = Math.ceil(Math.log2(E)), H = Math.ceil(Math.log2(I)), Y = N - H, X = [];
                    for (let ge = 0; ge < Math.abs(Y); ge++) X.push(Y > 0 ? 0 : 1);
                    for (let ge = 0; ge < Math.min(N, H); ge++) X.push(0), X.push(1);
                    let J = x;
                    if (J = qy(J, w[0].y - C, w[1].y + C, 1), J = qy(J, w[0].x - C, w[1].x + C, 0), !J.length) return L;
                    const xe = [];
                    for (X.length ? xe.push({polygons: J, bounds: w, depth: 0}) : F(J, w); xe.length;) {
                        const ge = xe.pop(), ye = ge.depth, Ee = X[ye], Ie = ge.bounds[0], We = ge.bounds[1],
                            De = Ee === 0 ? Ie.x : Ie.y, Ye = Ee === 0 ? We.x : We.y,
                            ht = z ? z(Ee, De, Ye) : .5 * (De + Ye), Qe = qy(ge.polygons, De - C, ht + C, Ee),
                            ot = qy(ge.polygons, ht - C, Ye + C, Ee);
                        if (Qe.length) {
                            const ct = [Ie, new Ze(Ee === 0 ? ht : We.x, Ee === 1 ? ht : We.y)];
                            X.length > ye + 1 ? xe.push({polygons: Qe, bounds: ct, depth: ye + 1}) : F(Qe, ct)
                        }
                        if (ot.length) {
                            const ct = [new Ze(Ee === 0 ? ht : Ie.x, Ee === 1 ? ht : Ie.y), We];
                            X.length > ye + 1 ? xe.push({polygons: ot, bounds: ct, depth: ye + 1}) : F(ot, ct)
                        }
                    }
                    return L
                }(n, e, Math.ceil((d - c) / 11.25), Math.ceil((f - _) / 11.25), 1, (x, w, E) => {
                    if (x === 0) return .5 * (w + E);
                    {
                        const I = Q((i.y + w / yt) / a);
                        return (G(.5 * (Q((i.y + E / yt) / a) + I)) * a - i.y) * yt
                    }
                })
            }

            function ak(n, e, i, a, c, d) {
                const f = Math.pow(2, a.z - c.z);
                for (let _ = 0; _ < i; _++) {
                    let x = n.int16[2 * (_ + e) + 0], w = n.int16[2 * (_ + e) + 1];
                    x = (x + c.x * yt) * f - a.x * yt, w = (w + c.y * yt) * f - a.y * yt, d.push(new Ze(x, w))
                }
            }

            let KS, QS;
            Pt(Ky, "FillExtrusionBucket", {omit: ["layers", "features"]}), Pt(VS, "PartData"), Pt(jS, "FootprintSegment"), Pt(US, "BorderCentroidData"), Pt(F1, "GroundEffect");

            class Lh extends Ze {
                constructor(e, i, a) {
                    super(e, i), this.z = a
                }
            }

            class JS extends Lh {
                constructor(e, i, a, c) {
                    super(e, i, a), this.w = c
                }
            }

            function eE(n, e, i, a) {
                const c = i === "x" ? "y" : "x", d = (a - n[i]) / (e[i] - n[i]);
                n[c] = Math.round(n[c] + (e[c] - n[c]) * d), n[i] = a, n.hasOwnProperty("z") && (n.z = qt(n.z, e.z, d)), n.hasOwnProperty("w") && (n.w = qt(n.w, e.w, d))
            }

            function tE(n, e, i, a) {
                const c = i, d = a;
                for (const f of ["x", "y"]) {
                    let _ = n, x = e;
                    _[f] >= x[f] && (_ = e, x = n), _[f] < c && x[f] > c && eE(_, x, f, c), _[f] < d && x[f] > d && eE(x, _, f, d)
                }
            }

            function Qy(n, e, i, a, c, d) {
                const f = [];
                for (let _ = 0; _ < n.length; _++) {
                    const x = n[_];
                    let w;
                    const E = f.length;
                    let I = 0;
                    for (let C = 0; C < x.length - 1; C++) {
                        let z = x[C], L = x[C + 1], F = 0;
                        const N = I;
                        let H, Y;
                        d && (F = Math.hypot(L.x - z.x, L.y - z.y), I += F, H = z, Y = L), z.x < e && L.x < e || (z.x < e ? z = new Ze(e, z.y + (e - z.x) / (L.x - z.x) * (L.y - z.y))._round() : L.x < e && (L = new Ze(e, z.y + (e - z.x) / (L.x - z.x) * (L.y - z.y))._round()), z.y < i && L.y < i || (z.y < i ? z = new Ze(z.x + (i - z.y) / (L.y - z.y) * (L.x - z.x), i)._round() : L.y < i && (L = new Ze(z.x + (i - z.y) / (L.y - z.y) * (L.x - z.x), i)._round()), z.x >= a && L.x >= a || (z.x >= a ? z = new Ze(a, z.y + (a - z.x) / (L.x - z.x) * (L.y - z.y))._round() : L.x >= a && (L = new Ze(a, z.y + (a - z.x) / (L.x - z.x) * (L.y - z.y))._round()), z.y >= c && L.y >= c || (z.y >= c ? z = new Ze(z.x + (c - z.y) / (L.y - z.y) * (L.x - z.x), c)._round() : L.y >= c && (L = new Ze(z.x + (c - z.y) / (L.y - z.y) * (L.x - z.x), c)._round()), w && z.equals(w[w.length - 1]) || (w = [z], f.push(w), d && d.push({
                            progress: {
                                min: N + iE(H, Y, z) * F,
                                max: 1
                            }, parentIndex: _, prevPoint: H, nextPoint: Y
                        })), w.push(L), d && (d[d.length - 1].progress.max = N + iE(H, Y, L) * F, d[d.length - 1].nextPoint = Y)))))
                    }
                    if (d && I > 0) for (let C = E; C < f.length; C++) d[C].progress.min /= I, d[C].progress.max /= I
                }
                return f
            }

            function lk(n, e, i, a, c) {
                if (n.length < 2) return void a.push(n);
                const d = [];
                for (; e.valid();) {
                    const [w, E] = e.get();
                    for (let I = 0; I < n.length - 1; I++) {
                        const C = n[I], z = n[I + 1], L = Fo(C, z, w, E);
                        if (L) {
                            const [F] = L, N = new Ze(qt(C.x, z.x, F), qt(C.y, z.y, F));
                            d.push({t: I + F, distance: 0, point: N})
                        }
                    }
                    e.next()
                }
                if (d.length === 0) return void a.push(n);
                d.sort((w, E) => w.t - E.t);
                let f = 0, _ = 0, x = [];
                for (a.push(x); f !== n.length;) {
                    if (_ === d.length) {
                        for (; f !== n.length;) x.length !== 0 && x[x.length - 1].equals(n[f]) || x.push(n[f]), f++;
                        break
                    }
                    d[_].t <= f ? (x.length !== 0 && x[x.length - 1].equals(d[_].point) || x.push(d[_].point), Math.trunc(d[_].t), _++) : (x.length !== 0 && x[x.length - 1].equals(n[f]) || x.push(n[f]), f++)
                }
            }

            function iE(n, e, i) {
                return n.x !== e.x ? (i.x - n.x) / (e.x - n.x) : n.y !== e.y ? (i.y - n.y) / (e.y - n.y) : 0
            }

            function eg(n, e) {
                return n.x * e.x + n.y * e.y
            }

            function nE(n, e) {
                if (n.length === 1) {
                    let i = 0;
                    const a = e[i++];
                    let c;
                    for (; !c || a.equals(c);) if (c = e[i++], !c) return 1 / 0;
                    for (; i < e.length; i++) {
                        const d = e[i], f = n[0], _ = c.sub(a), x = d.sub(a), w = f.sub(a), E = eg(_, _), I = eg(_, x),
                            C = eg(x, x), z = eg(w, _), L = eg(w, x), F = E * C - I * I, N = (C * z - I * L) / F,
                            H = (E * L - I * z) / F, Y = a.z * (1 - N - H) + c.z * N + d.z * H;
                        if (isFinite(Y)) return Y
                    }
                    return 1 / 0
                }
                {
                    let i = 1 / 0;
                    for (const a of e) i = Math.min(i, a.z);
                    return i
                }
            }

            function rE(n, e, i, a, c, d, f, _) {
                const x = f * c.getElevationAt(n, e, !0, !0), w = d[0] !== 0,
                    E = w ? d[1] === 0 ? f * (d[0] / 7 - 450) : f * function (I, C, z) {
                        const L = Math.floor(C[0] / 8), F = Math.floor(C[1] / 8), N = 10 * (C[0] - 8 * L),
                            H = 10 * (C[1] - 8 * F), Y = I.getElevationAt(L, F, !0, !0), X = I.getMeterToDEM(z),
                            J = Math.floor(.5 * (N * X - 1)), xe = Math.floor(.5 * (H * X - 1)),
                            ge = I.tileCoordToPixel(L, F), ye = 2 * J + 1, Ee = 2 * xe + 1,
                            Ie = function (ot, ct, He, st, ke) {
                                return [ot.getElevationAtPixel(ct, He, !0), ot.getElevationAtPixel(ct + ke, He, !0), ot.getElevationAtPixel(ct, He + ke, !0), ot.getElevationAtPixel(ct + st, He + ke, !0)]
                            }(I, ge.x - J, ge.y - xe, ye, Ee), We = Math.abs(Ie[0] - Ie[1]),
                            De = Math.abs(Ie[2] - Ie[3]), Ye = Math.abs(Ie[0] - Ie[2]) + Math.abs(Ie[1] - Ie[3]),
                            ht = Math.min(.25, .5 * X * (We + De) / ye), Qe = Math.min(.25, .5 * X * Ye / Ee);
                        return Y + Math.max(ht * N, Qe * H)
                    }(c, d, _) : x;
                return {base: x + (i === 0 ? -1 : i), top: w ? Math.max(E + a, x + i + 2) : x + a}
            }

            class ck {
                constructor(e) {
                    this._callback = e, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => {
                        this._triggered = !1, this._callback()
                    })
                }

                trigger() {
                    this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
                        this._triggered = !1, this._callback()
                    }, 0))
                }

                remove() {
                    this._channel = void 0, this._callback = () => {
                    }
                }
            }

            class uk {
                constructor() {
                    this.tasks = {}, this.taskQueue = [], ii(["process"], this), this.invoker = new ck(this.process), this.nextId = 0
                }

                add(e, i) {
                    const a = this.nextId++, c = function ({type: d, isSymbolTile: f, zoom: _}) {
                        return _ = _ || 0, d === "message" ? 0 : d !== "maybePrepare" || f ? d !== "parseTile" || f ? d === "parseTile" && f ? 300 - _ : d === "maybePrepare" && f ? 400 - _ : 500 : 200 - _ : 100 - _
                    }(i);
                    if (c === 0) {
                        try {
                            e()
                        } finally {
                        }
                        return null
                    }
                    return this.tasks[a] = {
                        fn: e,
                        metadata: i,
                        priority: c,
                        id: a
                    }, this.taskQueue.push(a), this.invoker.trigger(), {
                        cancel: () => {
                            delete this.tasks[a]
                        }
                    }
                }

                process() {
                    try {
                        if (this.taskQueue = this.taskQueue.filter(a => !!this.tasks[a]), !this.taskQueue.length) return;
                        const e = this.pick();
                        if (e === null) return;
                        const i = this.tasks[e];
                        if (delete this.tasks[e], this.taskQueue.length && this.invoker.trigger(), !i) return;
                        i.fn()
                    } finally {
                    }
                }

                pick() {
                    let e = null, i = 1 / 0;
                    for (let c = 0; c < this.taskQueue.length; c++) {
                        const d = this.tasks[this.taskQueue[c]];
                        d.priority < i && (i = d.priority, e = c)
                    }
                    if (e === null) return null;
                    const a = this.taskQueue[e];
                    return this.taskQueue.splice(e, 1), a
                }

                remove() {
                    this.invoker.remove()
                }
            }

            class oE {
                constructor(e, i, a) {
                    this.target = e, this.parent = i, this.mapId = a, this.callbacks = {}, this.cancelCallbacks = {}, ii(["receive"], this), this.target.addEventListener("message", this.receive, !1), this.scheduler = new uk
                }

                send(e, i, a, c, d = !1, f) {
                    const _ = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
                    a && (a.metadata = f, this.callbacks[_] = a);
                    const x = new Set;
                    return this.target.postMessage({
                        id: _,
                        type: e,
                        hasCallback: !!a,
                        targetMapId: c,
                        mustQueue: d,
                        sourceMapId: this.mapId,
                        data: xa(i, x)
                    }, x), {
                        cancel: () => {
                            a && delete this.callbacks[_], this.target.postMessage({
                                id: _,
                                type: "<cancel>",
                                targetMapId: c,
                                sourceMapId: this.mapId
                            })
                        }
                    }
                }

                receive(e) {
                    const i = e.data;
                    if (!i) return;
                    const a = i.id;
                    if (a && (!i.targetMapId || this.mapId === i.targetMapId)) if (i.type === "<cancel>") {
                        const c = this.cancelCallbacks[a];
                        delete this.cancelCallbacks[a], c && c.cancel()
                    } else if (i.mustQueue || un(self)) {
                        const c = this.callbacks[a],
                            d = this.scheduler.add(() => this.processTask(a, i), c && c.metadata || {type: "message"});
                        d && (this.cancelCallbacks[a] = d)
                    } else this.processTask(a, i)
                }

                processTask(e, i) {
                    if (delete this.cancelCallbacks[e], i.type === "<response>") {
                        const a = this.callbacks[e];
                        delete this.callbacks[e], a && (i.error ? a(Co(i.error)) : a(null, Co(i.data)))
                    } else {
                        const a = new Set, c = i.hasCallback ? (f, _) => {
                            this.target.postMessage({
                                id: e,
                                type: "<response>",
                                sourceMapId: this.mapId,
                                error: f ? xa(f) : null,
                                data: xa(_, a)
                            }, a)
                        } : () => {
                        }, d = Co(i.data);
                        if (this.parent[i.type]) this.parent[i.type](i.sourceMapId, d, c); else if (this.parent.getWorkerSource) {
                            const f = i.type.split("."), {source: _, scope: x} = d;
                            this.parent.getWorkerSource(i.sourceMapId, f[0], _, x)[f[1]](d, c)
                        } else c(new Error(`Could not find function ${i.type}`))
                    }
                }

                remove() {
                    this.scheduler.remove(), this.target.removeEventListener("message", this.receive, !1)
                }
            }

            var tg = {workerUrl: "", workerClass: null, workerParams: void 0};
            const N1 = "mapboxgl_preloaded_worker_pool";

            class kh {
                constructor() {
                    this.active = {}
                }

                acquire(e, i = kh.workerCount) {
                    if (!this.workers) for (this.workers = []; this.workers.length < i;) this.workers.push(tg.workerClass != null ? new tg.workerClass : new self.Worker(tg.workerUrl, tg.workerParams));
                    return this.active[e] = !0, this.workers.slice()
                }

                release(e) {
                    delete this.active[e], this.workers && this.numActive() === 0 && (this.workers.forEach(i => {
                        i.terminate()
                    }), this.workers = null)
                }

                isPreloaded() {
                    return !!this.active[N1]
                }

                numActive() {
                    return Object.keys(this.active).length
                }
            }

            kh.workerCount = 2;

            class pf {
                constructor(e, i, a = "Worker", c = kh.workerCount) {
                    this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = Je();
                    const d = this.workerPool.acquire(this.id, c);
                    for (let f = 0; f < d.length; f++) {
                        const _ = new pf.Actor(d[f], i, this.id);
                        _.name = `${a} ${f}`, this.actors.push(_)
                    }
                    this.ready = !1, this.broadcast("checkIfReady", null, () => {
                        this.ready = !0
                    })
                }

                broadcast(e, i, a) {
                    Pe(this.actors, (c, d) => {
                        c.send(e, i, d)
                    }, a = a || function () {
                    })
                }

                getActor() {
                    return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor]
                }

                remove() {
                    this.actors.forEach(e => {
                        e.remove()
                    }), this.actors = [], this.workerPool.release(this.id)
                }
            }

            let ig, j1;

            function Jy() {
                return ig || (ig = new kh), ig
            }

            pf.Actor = oE;

            class hk {
                constructor(e) {
                    this.module = e
                }

                createIntArray(e) {
                    const i = new Int32Array(e), a = this.module.malloc(i.length * i.BYTES_PER_ELEMENT);
                    return this.module.heap32.set(i, a / i.BYTES_PER_ELEMENT), a
                }

                createFloatArray(e) {
                    const i = new Float32Array(e), a = this.module.malloc(i.length * i.BYTES_PER_ELEMENT);
                    return this.module.heapF32.set(i, a / i.BYTES_PER_ELEMENT), a
                }

                createStringBuffer(e) {
                    const i = this.module.malloc(e.length + 1);
                    for (let a = 0; a < e.length; ++a) this.module.heapU8[i + a] = e.charCodeAt(a);
                    return this.module.heapU8[i + e.length] = 0, i
                }

                readStringBuffer(e) {
                    let i = "";
                    for (; this.module.heapU8[e] !== 0;) i += String.fromCharCode(this.module.heapU8[e]), ++e;
                    return i
                }

                setStyle(e) {
                    const i = e.entranceColorRgb, a = e.facadeGlazingColorRgb, c = e.roofColorRgb, d = e.wallColorRgb,
                        f = e.normalScale;
                    this.module.setStyle(i[0], i[1], i[2], a[0], a[1], a[2], c[0], c[1], c[2], d[0], d[1], d[2], f[0], f[1], f[2], e.tileToMeters)
                }

                setAOOptions(e, i) {
                    this.module.setAOOptions(e ? 1 : 0, i)
                }

                setMetricOptions(e, i) {
                    this.module.setMetricOptions(e ? 1 : 0, i)
                }

                setStructuralOptions(e) {
                    this.module.setStructuralOptions(e ? 1 : 0)
                }

                setFacadeOptions(e, i) {
                    this.module.setFacadeOptions(e, i ? 1 : 0)
                }

                setFauxFacadeOptions(e, i, a) {
                    this.module.setFauxFacadeOptions(e ? 1 : 0, i ? 1 : 0, a)
                }

                setFacadeClassifierOptions(e) {
                    this.module.setFacadeClassifierOptions(e)
                }

                generateMesh(e, i) {
                    for (const _ of e) {
                        const x = this.createStringBuffer(_.roofType), w = [0], E = [];
                        for (const z of _.coordinates) if (Array.isArray(z)) {
                            for (const L of z) E.push(L.x), E.push(L.y);
                            w.push(E.length)
                        }
                        const I = this.createIntArray(w), C = this.createFloatArray(E);
                        this.module.addFeature(_.id, _.sourceId, _.minHeight, _.height, x, _.roofType.length, C, I, w.length - 1), this.module.free(x), this.module.free(I), this.module.free(C)
                    }
                    for (const _ of i) {
                        let x;
                        x = _.entrances ? JSON.parse(_.entrances) : [];
                        const w = this.createFloatArray(x), E = [];
                        for (const C of _.coordinates) E.push(C.x), E.push(C.y);
                        const I = this.createFloatArray(E);
                        this.module.addFacade(_.sourceId, _.crossPerc, _.distanceToRoad, w, x.length, I, E.length), this.module.free(w), this.module.free(I)
                    }
                    if (!this.module.generateMesh()) {
                        const _ = this.module.getLastError();
                        return this.readStringBuffer(_)
                    }
                    const a = this.module.getMeshCount(), c = new Array(a);
                    for (let _ = 0; _ < a; _++) {
                        const x = this.module.getPositionsPtr(_), w = this.module.getPositionsLength(_),
                            E = new Float32Array(this.module.heapF32.buffer, x, w), I = this.module.getNormalsPtr(_),
                            C = this.module.getNormalsLength(_), z = new Float32Array(this.module.heapF32.buffer, I, C),
                            L = this.module.getColorsPtr(_), F = this.module.getColorsLength(_),
                            N = new Uint8Array(this.module.heapU8.buffer, L, F), H = this.module.getAOPtr(_),
                            Y = this.module.getAOLength(_), X = new Float32Array(this.module.heapF32.buffer, H, Y),
                            J = this.module.getUVPtr(_), xe = this.module.getUVLength(_),
                            ge = new Float32Array(this.module.heapF32.buffer, J, xe),
                            ye = this.module.getFauxFacadePtr(_), Ee = this.module.getFauxFacadeLength(_),
                            Ie = new Uint8Array(this.module.heapU8.buffer, ye, Ee), We = this.module.getIndicesPtr(_),
                            De = this.module.getIndicesLength(_),
                            Ye = new Int32Array(this.module.heap32.buffer, We, De), ht = this.module.getBuildingPart(_),
                            Qe = this.readStringBuffer(ht);
                        c[_] = {
                            positions: E,
                            normals: z,
                            colors: N,
                            ao: X,
                            uv: ge,
                            isFauxFacade: Ie,
                            indices: Ye,
                            buildingPart: Qe
                        }
                    }
                    const d = this.module.getRingCount(), f = [];
                    for (let _ = 0; _ < d; _++) {
                        const x = this.module.getRingPtr(_), w = this.module.getRingLength(_),
                            E = new Float32Array(this.module.heapF32.buffer, x, w);
                        f.push(E)
                    }
                    return {meshes: c, modifiedPolygonRings: f}
                }
            }

            let ng, V1, ba, mf, U1, gf = null, _f = null, sE = null, e0 = null;

            function aE() {
                return un(self) && self.worker.dracoUrl ? self.worker.dracoUrl : V1 || Br.DRACO_URL
            }

            function lE() {
                if (un(self) && self.worker.meshoptUrl) return self.worker.meshoptUrl;
                if (mf) return mf;
                const n = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
                if (typeof WebAssembly != "object") throw new Error("WebAssembly not supported, cannot instantiate meshoptimizer");
                return mf = WebAssembly.validate(n) ? Br.MESHOPT_SIMD_URL : Br.MESHOPT_URL, mf
            }

            function dk() {
                return e0
            }

            const t0 = {
                5120: Int8Array,
                5121: Uint8Array,
                5122: Int16Array,
                5123: Uint16Array,
                5125: Uint32Array,
                5126: Float32Array
            }, fk = {
                5120: "DT_INT8",
                5121: "DT_UINT8",
                5122: "DT_INT16",
                5123: "DT_UINT16",
                5125: "DT_UINT32",
                5126: "DT_FLOAT32"
            }, rg = {SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16};

            function cE(n, e, i) {
                const a = i.json.bufferViews.length, c = i.buffers.length;
                e.bufferView = a, i.json.bufferViews[a] = {buffer: c, byteLength: n.byteLength}, i.buffers[c] = n
            }

            const G1 = "KHR_draco_mesh_compression";

            function pk(n, e) {
                const i = n.extensions && n.extensions[G1];
                if (!i) return;
                const a = new ba.Decoder, c = fE(e, i.bufferView), d = new ba.Mesh;
                if (!a.DecodeArrayToMesh(c, c.byteLength, d)) throw new Error("Failed to decode Draco mesh");
                const f = e.json.accessors[n.indices], _ = t0[f.componentType], x = f.count * _.BYTES_PER_ELEMENT,
                    w = ba._malloc(x);
                _ === Uint16Array ? a.GetTrianglesUInt16Array(d, x, w) : a.GetTrianglesUInt32Array(d, x, w), cE(ba.memory.buffer.slice(w, w + x), f, e), ba._free(w);
                for (const E of Object.keys(i.attributes)) {
                    const I = a.GetAttributeByUniqueId(d, i.attributes[E]), C = e.json.accessors[n.attributes[E]],
                        z = fk[C.componentType], L = C.count * rg[C.type] * t0[C.componentType].BYTES_PER_ELEMENT,
                        F = ba._malloc(L);
                    a.GetAttributeDataArrayForAllPoints(d, I, ba[z], L, F), cE(ba.memory.buffer.slice(F, F + L), C, e), ba._free(F)
                }
                a.destroy(), d.destroy(), delete n.extensions[G1]
            }

            const i0 = "EXT_meshopt_compression";

            function mk(n, e) {
                if (!n.extensions || !n.extensions[i0]) return;
                const i = n.extensions[i0],
                    a = new Uint8Array(e.buffers[i.buffer], i.byteOffset || 0, i.byteLength || 0),
                    c = new Uint8Array(i.count * i.byteStride);
                U1.decodeGltfBuffer(c, i.count, i.byteStride, a, i.mode, i.filter), n.buffer = e.buffers.length, n.byteOffset = 0, e.buffers[n.buffer] = c.buffer, delete n.extensions[i0]
            }

            const uE = 1179937895, hE = new TextDecoder("utf8");

            function dE(n, e) {
                return new URL(n, e).href
            }

            function gk(n, e, i, a) {
                return fetch(dE(n.uri, a)).then(c => c.arrayBuffer()).then(c => {
                    e.buffers[i] = c
                })
            }

            function fE(n, e) {
                const i = n.json.bufferViews[e];
                return new Uint8Array(n.buffers[i.buffer], i.byteOffset || 0, i.byteLength)
            }

            function _k(n, e, i, a) {
                if (n.uri) {
                    const c = dE(n.uri, a);
                    return fetch(c).then(d => d.blob()).then(d => createImageBitmap(d)).then(d => {
                        e.images[i] = d
                    })
                }
                if (n.bufferView !== void 0) {
                    const c = fE(e, n.bufferView), d = new Blob([c], {type: n.mimeType});
                    return createImageBitmap(d).then(f => {
                        e.images[i] = f
                    })
                }
            }

            function pE(n, e = 0, i) {
                const a = {json: null, images: [], buffers: []};
                if (new Uint32Array(n, e, 1)[0] === uE) {
                    const E = new Uint32Array(n, e);
                    let I = 2;
                    const C = (E[I++] >> 2) - 3, z = E[I++] >> 2;
                    if (I++, a.json = JSON.parse(hE.decode(E.subarray(I, I + z))), I += z, I < C) {
                        const L = E[I++];
                        I++;
                        const F = e + (I << 2);
                        a.buffers[0] = n.slice(F, F + L)
                    }
                } else a.json = JSON.parse(hE.decode(new Uint8Array(n, e)));
                const {buffers: c, images: d, meshes: f, extensionsUsed: _, bufferViews: x} = a.json;
                let w = Promise.resolve();
                if (c) {
                    const E = [];
                    for (let I = 0; I < c.length; I++) {
                        const C = c[I];
                        C.uri ? E.push(gk(C, a, I, i)) : a.buffers[I] || (a.buffers[I] = null)
                    }
                    w = Promise.all(E)
                }
                return w.then(() => {
                    const E = [], I = _ && _.includes(G1), C = _ && _.includes(i0);
                    if (I && E.push(function () {
                        if (!ba) return ng ?? (ng = function (z) {
                            let L, F = null;

                            function N() {
                                L = new Uint8Array(F.buffer)
                            }

                            function H() {
                                throw new Error("Unexpected Draco error.")
                            }

                            const Y = {
                                a: {
                                    a: H, d: function (X, J, xe) {
                                        return L.copyWithin(X, J, J + xe)
                                    }, c: function (X) {
                                        const J = L.length, xe = Math.max(X >>> 0, Math.ceil(1.2 * J)),
                                            ge = Math.ceil((xe - J) / 65536);
                                        try {
                                            return F.grow(ge), N(), !0
                                        } catch {
                                            return !1
                                        }
                                    }, b: H
                                }
                            };
                            return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(z, Y) : z.then(X => X.arrayBuffer()).then(X => WebAssembly.instantiate(X, Y))).then(X => {
                                const {
                                    Rb: J,
                                    Qb: xe,
                                    P: ge,
                                    T: ye,
                                    X: Ee,
                                    Ja: Ie,
                                    La: We,
                                    Qa: De,
                                    Va: Ye,
                                    Wa: ht,
                                    eb: Qe,
                                    jb: ot,
                                    f: ct,
                                    e: He,
                                    yb: st,
                                    zb: ke,
                                    Ab: qe,
                                    Bb: pt,
                                    Db: at,
                                    Gb: Bt
                                } = X.instance.exports;
                                F = He;
                                const zt = (() => {
                                    let nt = 0, lt = 0, kt = 0, Et = 0;
                                    return vt => {
                                        kt && (J(Et), J(nt), lt += kt, kt = nt = 0), nt || (lt += 128, nt = xe(lt));
                                        const At = vt.length + 7 & -8;
                                        let Kt = nt;
                                        At >= lt && (kt = At, Kt = Et = xe(At));
                                        for (let oi = 0; oi < vt.length; oi++) L[Kt + oi] = vt[oi];
                                        return Kt
                                    }
                                })();
                                return N(), ct(), {
                                    memory: He,
                                    _free: J,
                                    _malloc: xe,
                                    Mesh: class {
                                        constructor() {
                                            this.ptr = ge()
                                        }

                                        destroy() {
                                            ye(this.ptr)
                                        }
                                    },
                                    Decoder: class {
                                        constructor() {
                                            this.ptr = Ie()
                                        }

                                        destroy() {
                                            ot(this.ptr)
                                        }

                                        DecodeArrayToMesh(nt, lt, kt) {
                                            const Et = zt(nt), vt = We(this.ptr, Et, lt, kt.ptr);
                                            return !!Ee(vt)
                                        }

                                        GetAttributeByUniqueId(nt, lt) {
                                            return {ptr: De(this.ptr, nt.ptr, lt)}
                                        }

                                        GetTrianglesUInt16Array(nt, lt, kt) {
                                            Ye(this.ptr, nt.ptr, lt, kt)
                                        }

                                        GetTrianglesUInt32Array(nt, lt, kt) {
                                            ht(this.ptr, nt.ptr, lt, kt)
                                        }

                                        GetAttributeDataArrayForAllPoints(nt, lt, kt, Et, vt) {
                                            Qe(this.ptr, nt.ptr, lt.ptr, kt, Et, vt)
                                        }
                                    },
                                    DT_INT8: st(),
                                    DT_UINT8: ke(),
                                    DT_INT16: qe(),
                                    DT_UINT16: pt(),
                                    DT_UINT32: at(),
                                    DT_FLOAT32: Bt()
                                }
                            })
                        }(fetch(aE())), ng.then(z => {
                            ba = z, ng = void 0
                        }))
                    }()), C && E.push(function () {
                        if (U1) return;
                        const z = function (L) {
                            let F;
                            const N = WebAssembly.instantiateStreaming(L, {}).then(X => {
                                F = X.instance, F.exports.__wasm_call_ctors()
                            }), H = {
                                NONE: "",
                                OCTAHEDRAL: "meshopt_decodeFilterOct",
                                QUATERNION: "meshopt_decodeFilterQuat",
                                EXPONENTIAL: "meshopt_decodeFilterExp"
                            }, Y = {
                                ATTRIBUTES: "meshopt_decodeVertexBuffer",
                                TRIANGLES: "meshopt_decodeIndexBuffer",
                                INDICES: "meshopt_decodeIndexSequence"
                            };
                            return {
                                ready: N, supported: !0, decodeGltfBuffer(X, J, xe, ge, ye, Ee) {
                                    (function (Ie, We, De, Ye, ht, Qe, ot) {
                                        const ct = Ie.exports.sbrk, He = Ye + 3 & -4, st = ct(He * ht),
                                            ke = ct(Qe.length), qe = new Uint8Array(Ie.exports.memory.buffer);
                                        qe.set(Qe, ke);
                                        const pt = We(st, Ye, ht, ke, Qe.length);
                                        if (pt === 0 && ot && ot(st, He, ht), De.set(qe.subarray(st, st + Ye * ht)), ct(st - ct(0)), pt !== 0) throw new Error(`Malformed buffer data: ${pt}`)
                                    })(F, F.exports[Y[ye]], X, J, xe, ge, F.exports[H[Ee]])
                                }
                            }
                        }(fetch(lE()));
                        return z.ready.then(() => {
                            U1 = z
                        })
                    }()), d) for (let z = 0; z < d.length; z++) E.push(_k(d[z], a, z, i));
                    return (E.length ? Promise.all(E) : Promise.resolve()).then(() => {
                        if (I && f) for (const {primitives: z} of f) for (const L of z) pk(L, a);
                        if (C && f && x) for (const z of x) mk(z, a);
                        return a
                    })
                })
            }

            function $1(n) {
                switch (n) {
                    case WebGL2RenderingContext.RGBA8:
                        return WebGL2RenderingContext.RGBA;
                    case WebGL2RenderingContext.DEPTH_COMPONENT16:
                        return WebGL2RenderingContext.DEPTH_COMPONENT;
                    case WebGL2RenderingContext.DEPTH24_STENCIL8:
                        return WebGL2RenderingContext.DEPTH_STENCIL;
                    case WebGL2RenderingContext.R8:
                    case WebGL2RenderingContext.R32F:
                        return WebGL2RenderingContext.RED
                }
            }

            function H1(n) {
                switch (n) {
                    case WebGL2RenderingContext.RGBA8:
                        return WebGL2RenderingContext.UNSIGNED_BYTE;
                    case WebGL2RenderingContext.DEPTH_COMPONENT16:
                        return WebGL2RenderingContext.UNSIGNED_SHORT;
                    case WebGL2RenderingContext.DEPTH24_STENCIL8:
                        return WebGL2RenderingContext.UNSIGNED_INT_24_8;
                    case WebGL2RenderingContext.R8:
                        return WebGL2RenderingContext.UNSIGNED_BYTE;
                    case WebGL2RenderingContext.R32F:
                        return WebGL2RenderingContext.FLOAT
                }
            }

            class q1 {
                constructor(e, i, a, c) {
                    this.context = e, this.format = a, this.useMipmap = c && c.useMipmap, this.texture = e.gl.createTexture(), this.update(i, {premultiply: c && c.premultiply})
                }

                update(e, i) {
                    const a = e && e instanceof HTMLVideoElement && e.width === 0 ? e.videoWidth : e.width,
                        c = e && e instanceof HTMLVideoElement && e.height === 0 ? e.videoHeight : e.height, {context: d} = this, {gl: f} = d, {
                            x: _,
                            y: x
                        } = i && i.position ? i.position : {x: 0, y: 0}, w = _ + a, E = x + c;
                    !this.size || this.size[0] === w && this.size[1] === E || (f.bindTexture(f.TEXTURE_2D, null), f.deleteTexture(this.texture), this.texture = f.createTexture(), this.size = null), f.bindTexture(f.TEXTURE_2D, this.texture), d.pixelStoreUnpackFlipY.set(!1), d.pixelStoreUnpack.set(1), d.pixelStoreUnpackPremultiplyAlpha.set(this.format === f.RGBA8 && (!i || i.premultiply !== !1));
                    const I = e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || ImageBitmap && e instanceof ImageBitmap;
                    if (!this.size && w > 0 && E > 0) {
                        const C = this.useMipmap ? Math.floor(Math.log2(Math.max(w, E))) + 1 : 1;
                        f.texStorage2D(f.TEXTURE_2D, C, this.format, w, E), this.size = [w, E]
                    }
                    if (this.size) if (I) f.texSubImage2D(f.TEXTURE_2D, 0, _, x, $1(this.format), H1(this.format), e); else {
                        const C = e.data;
                        C && f.texSubImage2D(f.TEXTURE_2D, 0, _, x, a, c, $1(this.format), H1(this.format), C)
                    }
                    this.useMipmap && f.generateMipmap(f.TEXTURE_2D)
                }

                bind(e, i, a = !1) {
                    const {context: c} = this, {gl: d} = c;
                    d.bindTexture(d.TEXTURE_2D, this.texture), e !== this.minFilter && (d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, e), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, this.useMipmap && !a ? e === d.NEAREST ? d.NEAREST_MIPMAP_NEAREST : d.LINEAR_MIPMAP_LINEAR : e), this.minFilter = e), i !== this.wrapS && (d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, i), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, i), this.wrapS = i)
                }

                bindExtraParam(e, i, a, c, d) {
                    const {context: f} = this, {gl: _} = f;
                    _.bindTexture(_.TEXTURE_2D, this.texture), i !== this.magFilter && (_.texParameteri(_.TEXTURE_2D, _.TEXTURE_MAG_FILTER, i), this.magFilter = i), e !== this.minFilter && (_.texParameteri(_.TEXTURE_2D, _.TEXTURE_MIN_FILTER, this.useMipmap ? e === _.NEAREST ? _.NEAREST_MIPMAP_NEAREST : _.LINEAR_MIPMAP_LINEAR : e), this.minFilter = e), a !== this.wrapS && (_.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_S, a), this.wrapS = a), c !== this.wrapT && (_.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_T, c), this.wrapT = c), d !== this.compareMode && (d ? (_.texParameteri(_.TEXTURE_2D, _.TEXTURE_COMPARE_MODE, _.COMPARE_REF_TO_TEXTURE), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_COMPARE_FUNC, d)) : _.texParameteri(_.TEXTURE_2D, _.TEXTURE_COMPARE_MODE, _.NONE), this.compareMode = d)
                }

                destroy() {
                    const {gl: e} = this.context;
                    e.deleteTexture(this.texture), this.texture = null
                }
            }

            class og {
                constructor(e, i) {
                    this.context = e, this.texture = i
                }

                bind(e, i) {
                    const {context: a} = this, {gl: c} = a;
                    c.bindTexture(c.TEXTURE_2D, this.texture), e !== this.minFilter && (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, e), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, e), this.minFilter = e), i !== this.wrapS && (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, i), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, i), this.wrapS = i)
                }
            }

            const yk = Fi([{name: "a_pos_3f", components: 3, type: "Float32"}]),
                vk = Fi([{name: "a_color_3f", components: 3, type: "Float32"}]),
                xk = Fi([{name: "a_color_4f", components: 4, type: "Float32"}]),
                wk = Fi([{name: "a_uv_2f", components: 2, type: "Float32"}]),
                bk = Fi([{name: "a_normal_3f", components: 3, type: "Float32"}]),
                Tk = Fi([{name: "a_normal_matrix0", components: 4, type: "Float32"}, {
                    name: "a_normal_matrix1",
                    components: 4,
                    type: "Float32"
                }, {name: "a_normal_matrix2", components: 4, type: "Float32"}, {
                    name: "a_normal_matrix3",
                    components: 4,
                    type: "Float32"
                }]), Sk = Fi([{name: "a_pbr", components: 4, type: "Uint16"}, {
                    name: "a_heightBasedEmissiveStrength",
                    components: 3,
                    type: "Float32"
                }]);

            function mE(n, e) {
                const i = n0(n.projection, n.zoom, n.width, n.height), a = function (d, f, _, x, w) {
                    const E = new M(_.lng - 180 * iu, _.lat), I = new M(_.lng + 180 * iu, _.lat),
                        C = d.project(E.lng, E.lat), z = d.project(I.lng, I.lat), L = -Math.atan2(z.y - C.y, z.x - C.x),
                        F = me.fromLngLat(_);
                    F.y = se(F.y, -1 + iu, 1 - iu);
                    const N = F.toLngLat(), H = d.project(N.lng, N.lat), Y = me.fromLngLat(N);
                    Y.x += iu;
                    const X = Y.toLngLat(), J = d.project(X.lng, X.lat), xe = _E(J.x - H.x, J.y - H.y, L),
                        ge = me.fromLngLat(N);
                    ge.y += iu;
                    const ye = ge.toLngLat(), Ee = d.project(ye.lng, ye.lat), Ie = _E(Ee.x - H.x, Ee.y - H.y, L),
                        We = Math.abs(xe.x) / Math.abs(Ie.y), De = fe([]);
                    _t(De, De, -L * (1 - (w ? 0 : x)));
                    const Ye = fe([]);
                    return be(Ye, Ye, [1, 1 - (1 - We) * x, 1]), Ye[4] = -Ie.x / Ie.y * x, _t(Ye, Ye, L), pe(Ye, De, Ye), Ye
                }(n.projection, 0, n.center, i, e), c = gE(n);
                return be(a, a, [c, c, 1]), a
            }

            function gE(n) {
                const e = n.projection, i = n0(n.projection, n.zoom, n.width, n.height), a = W1(e, n.center),
                    c = W1(e, M.convert(e.center));
                return Math.pow(2, a * i + (1 - i) * c)
            }

            function n0(n, e, i, a, c = 1 / 0) {
                const d = n.range;
                if (!d) return 0;
                const f = Math.min(c, Math.max(i, a)), _ = Math.log(f / 1024) / Math.LN2;
                return Ae(d[0] + _, d[1] + _, e)
            }

            const iu = 1 / 4e4;

            function W1(n, e) {
                const i = se(e.lat, -ce, ce), a = new M(e.lng - 180 * iu, i), c = new M(e.lng + 180 * iu, i),
                    d = n.project(a.lng, i), f = n.project(c.lng, i), _ = me.fromLngLat(a), x = me.fromLngLat(c),
                    w = f.x - d.x, E = f.y - d.y, I = x.x - _.x, C = x.y - _.y,
                    z = Math.sqrt((I * I + C * C) / (w * w + E * E));
                return Math.log(z) / Math.LN2
            }

            function _E(n, e, i) {
                const a = Math.cos(i), c = Math.sin(i);
                return {x: n * a - e * c, y: n * c + e * a}
            }

            function yE(n, e, i) {
                fe(n), _t(n, n, Ai(e[2])), Ue(n, n, Ai(e[0])), et(n, n, Ai(e[1])), be(n, n, i), pe(n, n, [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1])
            }

            function r0(n, e, i, a, c, d, f, _) {
                const x = [i[0] - e[0], i[1] - e[1], 0], w = [a[0] - e[0], a[1] - e[1], 0];
                if (Mi(x) < 1e-12 || Mi(w) < 1e-12) return Yr(n);
                const E = Bn([], x, w);
                Bi(E, E), Ri(w, a, e), x[2] = (d - c) * _, w[2] = (f - c) * _;
                const I = x;
                return Bn(I, x, w), Bi(I, I), Ds(n, E, I)
            }

            function Z1(n, e, i = !1) {
                const a = Jc(e.zoom), c = function (d, f, _) {
                    const x = f.worldSize, w = [d[12], d[13], d[14]], E = Q(w[1] / x), I = Z(w[0] / x), C = fe([]),
                        z = U(1, E) * x, L = U(1, 0) * x * ve(E, f.zoom), F = 1 / b1(x);
                    let N = L * F;
                    if (_) {
                        const J = n0(f.projection, f.zoom, f.width, f.height, 1024);
                        N = F * f.projection.pixelSpaceConversion(f.center.lat, x, J)
                    }
                    const H = b(E, I);
                    si(H, H, ai([], Bi([], H), z * N * w[2]));
                    const Y = function (J) {
                        const xe = [J[0], J[1], J[2]];
                        let ge = [0, 1, 0];
                        const ye = Bn([], ge, xe);
                        return Bn(ge, xe, ye), cn(ge) === 0 && (ge = [0, 1, 0], Bn(ye, xe, ge)), Bi(ye, ye), Bi(ge, ge), Bi(xe, xe), [ye[0], ye[1], ye[2], 0, ge[0], ge[1], ge[2], 0, xe[0], xe[1], xe[2], 0, J[0], J[1], J[2], 1]
                    }(H);
                    be(C, C, [N, N, N * z]), le(C, C, [-w[0], -w[1], -w[2]]);
                    const X = pe([], f.globeMatrix, Y);
                    return pe(X, X, C), pe(X, X, d), X
                }(n, e, i);
                if (a > 0) {
                    const d = function (f, _) {
                        const x = _.worldSize, w = U(1, 0) * x * ve(_.center.lat, _.zoom) / b1(x),
                            E = U(1, _.center.lat) * x, I = fe([]);
                        return et(I, I, Ai(_.center.lng)), Ue(I, I, Ai(_.center.lat)), le(I, I, [0, 0, io]), be(I, I, [w, w, w * E]), le(I, I, [_.point.x - .5 * x, _.point.y - .5 * x, 0]), pe(I, I, f), pe(I, _.globeMatrix, I)
                    }(n, e);
                    return function (f, _, x) {
                        const w = (L, F, N) => {
                                const H = Mi(L), Y = Mi(F), X = Ql(L, F, N);
                                return ai(X, X, 1 / Mi(X) * qt(H, Y, N))
                            }, E = w([f[0], f[1], f[2]], [_[0], _[1], _[2]], x),
                            I = w([f[4], f[5], f[6]], [_[4], _[5], _[6]], x),
                            C = w([f[8], f[9], f[10]], [_[8], _[9], _[10]], x),
                            z = Ql([f[12], f[13], f[14]], [_[12], _[13], _[14]], x);
                        return [E[0], E[1], E[2], 0, I[0], I[1], I[2], 0, C[0], C[1], C[2], 0, z[0], z[1], z[2], 1]
                    }(c, d, a)
                }
                return c
            }

            function vE(n, e, i, a) {
                const c = Ei.projectAabbCorners(a, i);
                let d = Number.MAX_VALUE, f = -1;
                for (let w = 0; w < c.length; ++w) {
                    const E = c[w];
                    E[0] = (.5 * E[0] + .5) * e.width, E[1] = (.5 - .5 * E[1]) * e.height, E[2] < d && (f = w, d = E[2])
                }
                const _ = w => new Ze(c[w][0], c[w][1]);
                let x;
                switch (f) {
                    case 0:
                    case 6:
                        x = [_(1), _(5), _(4), _(7), _(3), _(2), _(1)];
                        break;
                    case 1:
                    case 7:
                        x = [_(0), _(4), _(5), _(6), _(2), _(3), _(0)];
                        break;
                    case 3:
                    case 5:
                        x = [_(1), _(0), _(4), _(7), _(6), _(2), _(1)];
                        break;
                    default:
                        x = [_(1), _(5), _(6), _(7), _(3), _(0), _(1)]
                }
                if (hn(n, x)) return d
            }

            const Oh = 64, yf = {CoordinateSpaceTile: 1, HasMapboxMeshFeatures: 4, HasMeshoptCompression: 8};

            function xE(n, e, i, a, c, d, f, _, x, w = !1) {
                const E = i.zoom, I = i.project(a), C = ve(a.lat, E), z = 1 / C;
                fe(n), le(n, n, [I.x + f[0] * z, I.y + f[1] * z, f[2]]);
                let L = 1, F = 1;
                const N = i.worldSize;
                if (w) {
                    if (i.projection.name === "mercator") {
                        let J = 0;
                        i.elevation && (J = i.elevation.getAtPointOrZero(new me(I.x / N, I.y / N), 0));
                        const xe = Ir([], [I.x, I.y, J, 1], i.projMatrix)[3] / i.cameraToCenterDistance;
                        L = xe, F = xe * ve(i.center.lat, E)
                    } else if (i.projection.name === "globe") {
                        const J = Z1(n, i), xe = [0, 0, 0, 1];
                        Ir(xe, xe, pe([], i.projMatrix, J));
                        const ge = xe[3] / i.cameraToCenterDistance, ye = Jc(E),
                            Ee = i.projection.pixelsPerMeter(a.lat, N) * ve(a.lat, E),
                            Ie = i.projection.pixelsPerMeter(i.center.lat, N) * ve(i.center.lat, E);
                        L = ge / qt(Ee, _e(i.center.lat), ye), F = ge * C / Ee, L *= Ie, F *= Ie
                    }
                } else L = z;
                be(n, n, [L, L, F]);
                const H = [...n], Y = e.orientation, X = [];
                if (yE(X, [Y[0] + c[0], Y[1] + c[1], Y[2] + c[2]], d), pe(n, H, X), _ && i.elevation) {
                    let J = 0;
                    const xe = [];
                    if (x && i.elevation) {
                        J = function (ye, Ee, Ie, We, De) {
                            const Ye = Ee.elevation;
                            if (!Ye) return 0;
                            const ht = Ei.projectAabbCorners(Ie, We), Qe = U(1, De.lat) * Ee.worldSize,
                                ot = function (lt, kt) {
                                    const Et = [0, 0, 1], vt = [{corners: [0, 1, 3, 2], dotProductWithUp: 0}, {
                                        corners: [1, 5, 2, 6],
                                        dotProductWithUp: 0
                                    }, {corners: [0, 4, 1, 5], dotProductWithUp: 0}, {
                                        corners: [2, 6, 3, 7],
                                        dotProductWithUp: 0
                                    }, {corners: [4, 7, 5, 6], dotProductWithUp: 0}, {
                                        corners: [0, 3, 4, 7],
                                        dotProductWithUp: 0
                                    }];
                                    for (const At of vt) {
                                        const Kt = lt[At.corners[0]], oi = lt[At.corners[1]], pi = lt[At.corners[2]],
                                            ui = [oi[0] - Kt[0], oi[1] - Kt[1], kt * (oi[2] - Kt[2])],
                                            ki = Bn(ui, ui, [pi[0] - Kt[0], pi[1] - Kt[1], kt * (pi[2] - Kt[2])]);
                                        Bi(ki, ki), At.dotProductWithUp = Ii(ki, Et)
                                    }
                                    return vt.sort((At, Kt) => At.dotProductWithUp - Kt.dotProductWithUp), vt[0].corners
                                }(ht, Qe), ct = ht[ot[0]], He = ht[ot[1]], st = ht[ot[2]], ke = ht[ot[3]],
                                qe = Ye.getAtPointOrZero(new me(ct[0] / Ee.worldSize, ct[1] / Ee.worldSize), 0),
                                pt = Ye.getAtPointOrZero(new me(He[0] / Ee.worldSize, He[1] / Ee.worldSize), 0),
                                at = Ye.getAtPointOrZero(new me(st[0] / Ee.worldSize, st[1] / Ee.worldSize), 0),
                                Bt = Ye.getAtPointOrZero(new me(ke[0] / Ee.worldSize, ke[1] / Ee.worldSize), 0),
                                zt = (qe + Bt) / 2, nt = (pt + at) / 2;
                            return zt > nt ? pt < at ? r0(ye, He, ke, ct, pt, Bt, qe, Qe) : r0(ye, st, ct, ke, at, qe, Bt, Qe) : qe < Bt ? r0(ye, ct, He, st, qe, pt, at, Qe) : r0(ye, ke, st, He, Bt, at, pt, Qe), Math.max(zt, nt)
                        }(xe, i, e.aabb, n, a);
                        const ge = pe([], Xt([], xe), X);
                        pe(n, H, ge)
                    } else J = i.elevation.getAtPointOrZero(new me(I.x / N, I.y / N), 0);
                    J !== 0 && (n[14] += J)
                }
            }

            function sg(n, e, i = !1) {
                n.uploaded || (n.gfxTexture = new q1(e, n.image, i ? e.gl.R8 : e.gl.RGBA8, {useMipmap: n.sampler.minFilter >= e.gl.NEAREST_MIPMAP_NEAREST}), n.uploaded = !0, n.image = null)
            }

            function Ek(n, e, i) {
                n.indexBuffer = e.createIndexBuffer(n.indexArray, !1, !0), n.vertexBuffer = e.createVertexBuffer(n.vertexArray, yk.members, !1, !0), n.normalArray && (n.normalBuffer = e.createVertexBuffer(n.normalArray, bk.members, !1, !0)), n.texcoordArray && (n.texcoordBuffer = e.createVertexBuffer(n.texcoordArray, wk.members, !1, !0)), n.colorArray && (n.colorBuffer = e.createVertexBuffer(n.colorArray, (n.colorArray.bytesPerElement === 12 ? vk : xk).members, !1, !0)), n.featureArray && (n.pbrBuffer = e.createVertexBuffer(n.featureArray, Sk.members, !0)), n.segments = Ln.simpleSegment(0, 0, n.vertexArray.length, n.indexArray.length);
                const a = n.material;
                a.pbrMetallicRoughness.baseColorTexture && sg(a.pbrMetallicRoughness.baseColorTexture, e), a.pbrMetallicRoughness.metallicRoughnessTexture && sg(a.pbrMetallicRoughness.metallicRoughnessTexture, e), a.normalTexture && sg(a.normalTexture, e), a.occlusionTexture && sg(a.occlusionTexture, e, i), a.emissionTexture && sg(a.emissionTexture, e)
            }

            function X1(n, e, i) {
                if (n.meshes) for (const a of n.meshes) Ek(a, e, i);
                if (n.children) for (const a of n.children) X1(a, e, i)
            }

            function o0(n) {
                if (n.meshes) for (const e of n.meshes) e.indexArray.destroy(), e.vertexArray.destroy(), e.colorArray && e.colorArray.destroy(), e.normalArray && e.normalArray.destroy(), e.texcoordArray && e.texcoordArray.destroy(), e.featureArray && e.featureArray.destroy();
                if (n.children) for (const e of n.children) o0(e)
            }

            function Y1(n) {
                if (n.meshes) for (const i of n.meshes) i.vertexBuffer && (i.vertexBuffer.destroy(), i.indexBuffer.destroy(), i.normalBuffer && i.normalBuffer.destroy(), i.texcoordBuffer && i.texcoordBuffer.destroy(), i.colorBuffer && i.colorBuffer.destroy(), i.pbrBuffer && i.pbrBuffer.destroy(), i.segments.destroy(), i.material && ((e = i.material).pbrMetallicRoughness.baseColorTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), e.pbrMetallicRoughness.metallicRoughnessTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), e.normalTexture && e.normalTexture.gfxTexture && e.normalTexture.gfxTexture.destroy(), e.emissionTexture && e.emissionTexture.gfxTexture && e.emissionTexture.gfxTexture.destroy(), e.occlusionTexture && e.occlusionTexture.gfxTexture && e.occlusionTexture.gfxTexture.destroy()));
                var e;
                if (n.children) for (const i of n.children) Y1(i)
            }

            function Fh(n, e) {
                const i = n.json.bufferViews[e.bufferView], a = t0[e.componentType];
                return new a(n.buffers[i.buffer], (e.byteOffset || 0) + (i.byteOffset || 0), e.count * (i.byteStride && i.byteStride !== rg[e.type] * a.BYTES_PER_ELEMENT ? i.byteStride / a.BYTES_PER_ELEMENT : rg[e.type]))
            }

            function K1(n, e, i, a) {
                const c = t0[e.componentType], d = function (E) {
                        switch (E) {
                            case Int8Array:
                                return 1 / 127;
                            case Uint8Array:
                                return 1 / 255;
                            case Int16Array:
                                return 1 / 32767;
                            case Uint16Array:
                                return 1 / 65535;
                            default:
                                return 1
                        }
                    }(c), f = n.json.bufferViews[e.bufferView],
                    _ = f.byteStride ? f.byteStride / c.BYTES_PER_ELEMENT : rg[e.type], x = i.float32,
                    w = x.length / i.capacity;
                for (let E = 0, I = 0; E < e.count * _; E += _, I += w) for (let C = 0; C < w; C++) x[I + C] = a[E + C] * d;
                i._trim()
            }

            function Ak(n, e, i) {
                const a = n.indices, c = n.attributes, d = {};
                d.indexArray = new Mn;
                const f = e.json.accessors[a], _ = f.count / 3;
                d.indexArray.reserve(_);
                const x = Fh(e, f);
                for (let C = 0; C < _; C++) d.indexArray.emplaceBack(x[3 * C], x[3 * C + 1], x[3 * C + 2]);
                d.indexArray._trim(), d.vertexArray = new Qo;
                const w = e.json.accessors[c.POSITION];
                d.vertexArray.reserve(w.count);
                const E = Fh(e, w);
                for (let C = 0; C < w.count; C++) d.vertexArray.emplaceBack(E[3 * C], E[3 * C + 1], E[3 * C + 2]);
                if (d.vertexArray._trim(), d.aabb = new Ei(w.min, w.max), d.centroid = function (C, z) {
                    const L = [0, 0, 0], F = C.length;
                    if (F > 0) {
                        for (let N = 0; N < F; N++) {
                            const H = 3 * C[N];
                            L[0] += z[H], L[1] += z[H + 1], L[2] += z[H + 2]
                        }
                        L[0] /= F, L[1] /= F, L[2] /= F
                    }
                    return L
                }(x, E), c.COLOR_0 !== void 0) {
                    const C = e.json.accessors[c.COLOR_0], z = rg[C.type], L = Fh(e, C);
                    d.colorArray = z === 3 ? new Qo : new ul, d.colorArray.resize(C.count), K1(e, C, d.colorArray, L)
                }
                if (c.NORMAL !== void 0) {
                    d.normalArray = new Qo;
                    const C = e.json.accessors[c.NORMAL];
                    d.normalArray.resize(C.count);
                    const z = Fh(e, C);
                    K1(e, C, d.normalArray, z)
                }
                if (c.TEXCOORD_0 !== void 0 && i.length > 0) {
                    d.texcoordArray = new hl;
                    const C = e.json.accessors[c.TEXCOORD_0];
                    d.texcoordArray.resize(C.count);
                    const z = Fh(e, C);
                    K1(e, C, d.texcoordArray, z)
                }
                if (c._FEATURE_ID_RGBA4444 !== void 0) {
                    const C = e.json.accessors[c._FEATURE_ID_RGBA4444];
                    e.json.extensionsUsed && e.json.extensionsUsed.includes("EXT_meshopt_compression") && (d.featureData = Fh(e, C))
                }
                c._FEATURE_RGBA4444 !== void 0 && (d.featureData = new Uint32Array(Fh(e, e.json.accessors[c._FEATURE_RGBA4444]).buffer));
                const I = n.material;
                return d.material = function (C, z) {
                    const {
                        emissiveFactor: L = [0, 0, 0],
                        alphaMode: F = "OPAQUE",
                        alphaCutoff: N = .5,
                        normalTexture: H,
                        occlusionTexture: Y,
                        emissiveTexture: X,
                        doubleSided: J
                    } = C, {
                        baseColorFactor: xe = [1, 1, 1, 1],
                        metallicFactor: ge = 1,
                        roughnessFactor: ye = 1,
                        baseColorTexture: Ee,
                        metallicRoughnessTexture: Ie
                    } = C.pbrMetallicRoughness || {}, We = Y ? z[Y.index] : void 0;
                    if (Y && Y.extensions && Y.extensions.KHR_texture_transform && We) {
                        const De = Y.extensions.KHR_texture_transform;
                        We.offsetScale = [De.offset[0], De.offset[1], De.scale[0], De.scale[1]]
                    }
                    return {
                        pbrMetallicRoughness: {
                            baseColorFactor: new Ji(...xe),
                            metallicFactor: ge,
                            roughnessFactor: ye,
                            baseColorTexture: Ee ? z[Ee.index] : void 0,
                            metallicRoughnessTexture: Ie ? z[Ie.index] : void 0
                        },
                        doubleSided: J,
                        emissiveFactor: new Ji(...L),
                        alphaMode: F,
                        alphaCutoff: N,
                        normalTexture: H ? z[H.index] : void 0,
                        occlusionTexture: We,
                        emissionTexture: X ? z[X.index] : void 0,
                        defined: C.defined === void 0
                    }
                }(I !== void 0 ? e.json.materials[I] : {defined: !1}, i), d
            }

            function wE(n, e, i) {
                const {matrix: a, rotation: c, translation: d, scale: f, mesh: _, extras: x, children: w} = n, E = {};
                if (E.matrix = a || function (I, C, z, L) {
                    var F = C[0], N = C[1], H = C[2], Y = C[3], X = F + F, J = N + N, xe = H + H, ge = F * X,
                        ye = F * J, Ee = F * xe, Ie = N * J, We = N * xe, De = H * xe, Ye = Y * X, ht = Y * J,
                        Qe = Y * xe, ot = L[0], ct = L[1], He = L[2];
                    return I[0] = (1 - (Ie + De)) * ot, I[1] = (ye + Qe) * ot, I[2] = (Ee - ht) * ot, I[3] = 0, I[4] = (ye - Qe) * ct, I[5] = (1 - (ge + De)) * ct, I[6] = (We + Ye) * ct, I[7] = 0, I[8] = (Ee + ht) * He, I[9] = (We - Ye) * He, I[10] = (1 - (ge + Ie)) * He, I[11] = 0, I[12] = z[0], I[13] = z[1], I[14] = z[2], I[15] = 1, I
                }([], c || [0, 0, 0, 1], d || [0, 0, 0], f || [1, 1, 1]), _ !== void 0) {
                    E.meshes = i[_];
                    const I = E.anchor = [0, 0];
                    for (const C of E.meshes) {
                        const {min: z, max: L} = C.aabb;
                        I[0] += z[0] + L[0], I[1] += z[1] + L[1]
                    }
                    I[0] = Math.floor(I[0] / E.meshes.length / 2), I[1] = Math.floor(I[1] / E.meshes.length / 2)
                }
                if (x && (x.id && (E.id = x.id), x.lights && (E.lights = function (I) {
                    if (!I.length) return [];
                    const C = function (H) {
                        const Y = atob(H), X = new Uint8Array(Y.length);
                        for (let J = 0; J < Y.length; J++) X[J] = Y.codePointAt(J);
                        return X
                    }(I), z = [], L = C.length / 24, F = new Uint16Array(C.buffer), N = new Float32Array(C.buffer);
                    for (let H = 0; H < L; H++) {
                        const Y = F[2 * H * 6] / 30, X = F[2 * H * 6 + 1] / 30, J = F[2 * H * 6 + 10] / 100,
                            xe = N[6 * H + 1], ge = N[6 * H + 2], ye = N[6 * H + 3], Ee = N[6 * H + 4], Ie = ye - xe,
                            We = Ee - ge, De = Math.hypot(Ie, We);
                        z.push({
                            pos: [xe + .5 * Ie, ge + .5 * We, X],
                            normal: [We / De, -Ie / De, 0],
                            width: De,
                            height: Y,
                            depth: J,
                            points: [xe, ge, ye, Ee]
                        })
                    }
                    return z
                }(x.lights))), w) {
                    const I = [];
                    for (const C of w) I.push(wE(e.json.nodes[C], e, i));
                    E.children = I
                }
                return E
            }

            function Ik(n) {
                if (n.vertices.length === 0 || n.indices.length === 0) return null;
                const e = new Wy(n.vertices, n.indices, 8, 256), [i, a] = [e.min.clone(), e.max.clone()];
                return {vertices: n.vertices, indices: n.indices, grid: e, min: i, max: a}
            }

            function Ck(n) {
                if (!n.extras || !n.extras.ground) return null;
                const e = n.extras.ground;
                if (!e || !Array.isArray(e) || e.length === 0) return null;
                const i = e[0];
                if (!i || !Array.isArray(i) || i.length === 0) return null;
                const a = [];
                for (const f of i) {
                    if (!Array.isArray(f) || f.length !== 2) continue;
                    const _ = f[0], x = f[1];
                    typeof _ == "number" && typeof x == "number" && a.push(new Ze(_, x))
                }
                if (a.length < 3) return null;
                a.length > 1 && a[a.length - 1].equals(a[0]) && a.pop();
                let c = 0;
                for (let f = 0; f < a.length; f++) {
                    const _ = a[f], x = a[(f + 1) % a.length], w = a[(f + 2) % a.length];
                    c += (_.x - x.x) * (w.y - x.y) - (w.x - x.x) * (_.y - x.y)
                }
                c > 0 && a.reverse();
                const d = df(a.flatMap(f => [f.x, f.y]), []);
                return d.length === 0 ? null : {vertices: a, indices: d}
            }

            function Pk(n, e) {
                const i = [], a = [];
                let c = 0;
                const d = [];
                for (const f of n) {
                    c = i.length;
                    const _ = f.vertexArray.float32, x = f.indexArray.uint16;
                    for (let w = 0; w < f.vertexArray.length; w++) d[0] = _[3 * w + 0], d[1] = _[3 * w + 1], d[2] = _[3 * w + 2], An(d, d, e), i.push(new Ze(d[0], d[1]));
                    for (let w = 0; w < 3 * f.indexArray.length; w++) a.push(x[w] + c)
                }
                if (a.length % 3 != 0) return null;
                for (let f = 0; f < a.length; f += 3) {
                    const _ = i[a[f + 0]], x = i[a[f + 1]], w = i[a[f + 2]];
                    (_.x - x.x) * (w.y - x.y) - (w.x - x.x) * (_.y - x.y) > 0 && ([a[f + 1], a[f + 2]] = [a[f + 2], a[f + 1]])
                }
                return {vertices: i, indices: a}
            }

            function bE(n) {
                const e = function (x, w) {
                    const E = [], I = WebGL2RenderingContext;
                    if (x.json.textures) for (const C of x.json.textures) {
                        const z = {magFilter: I.LINEAR, minFilter: I.NEAREST, wrapS: I.REPEAT, wrapT: I.REPEAT};
                        C.sampler !== void 0 && Object.assign(z, x.json.samplers[C.sampler]), E.push({
                            image: w[C.source],
                            sampler: z,
                            uploaded: !1
                        })
                    }
                    return E
                }(n, n.images), i = function (x, w) {
                    const E = [];
                    for (const I of x.json.meshes) {
                        const C = [];
                        for (const z of I.primitives) C.push(Ak(z, x, w));
                        E.push(C)
                    }
                    return E
                }(n, e), {scenes: a, scene: c, nodes: d} = n.json, f = a ? a[c || 0].nodes : d, _ = [];
                for (const x of f) _.push(wE(d[x], n, i));
                return function (x, w, E) {
                    const I = {}, C = new Set;
                    for (let z = 0; z < x.length; z++) {
                        const L = E[w[z]];
                        if (!L.extras) continue;
                        const F = L.extras["mapbox:footprint:version"], N = L.extras["mapbox:footprint:id"];
                        (F || N) && C.add(z), F === "1.0.0" && N && (I[N] = z)
                    }
                    for (let z = 0; z < x.length; z++) {
                        if (C.has(z)) continue;
                        const L = x[z], F = E[w[z]];
                        if (!F.extras) continue;
                        let N = null;
                        L.id in I && (N = Pk(x[I[L.id]].meshes, L.matrix)), N || (N = Ck(F)), N && (L.footprint = Ik(N))
                    }
                    if (C.size > 0) {
                        const z = Array.from(C.values()).sort((L, F) => L - F);
                        for (let L = z.length - 1; L >= 0; L--) x.splice(z[L], 1)
                    }
                }(_, f, n.json.nodes), _
            }

            function Mk(n) {
                n.heightmap = new Float32Array(4096), n.heightmap.fill(-1);
                const e = n.vertexArray.float32, i = n.aabb.min[0] - 1, a = n.aabb.min[1] - 1,
                    c = Oh / (n.aabb.max[0] - i + 2), d = Oh / (n.aabb.max[1] - a + 2);
                for (let f = 0; f < e.length; f += 3) {
                    const _ = e[f + 2], x = (e[f + 0] - i) * c | 0, w = (e[f + 1] - a) * d | 0;
                    _ > n.heightmap[w * Oh + x] && (n.heightmap[w * Oh + x] = _)
                }
            }

            function TE(n, e, i, a, c) {
                i.reserve(i.length + 4 * n.length), a.reserve(a.length + 10 * n.length), c.reserve(c.length + 10 * n.length);
                let d = a.length;
                for (const f of n) {
                    const _ = Math.min(10, Math.max(4, 1.3 * f.height)) * e, x = [-f.normal[1], f.normal[0], 0],
                        w = Math.min(.29, .1 * f.width / f.depth), E = f.width - 2 * f.depth * e * (w + .01),
                        I = fi([], f.pos, x, E / 2), C = fi([], f.pos, x, -E / 2), z = [I[0], I[1], I[2] + f.height],
                        L = [C[0], C[1], C[2] + f.height], F = fi([], f.normal, x, w);
                    ai(F, F, _);
                    const N = fi([], f.normal, x, -w);
                    ai(N, N, _), si(F, I, F), si(N, C, N), I[2] += .1, C[2] += .1, a.emplaceBack(F[0], F[1], F[2]), a.emplaceBack(N[0], N[1], N[2]), a.emplaceBack(I[0], I[1], I[2]), a.emplaceBack(C[0], C[1], C[2]), a.emplaceBack(z[0], z[1], z[2]), a.emplaceBack(L[0], L[1], L[2]), a.emplaceBack(I[0], I[1], I[2]), a.emplaceBack(C[0], C[1], C[2]), a.emplaceBack(F[0], F[1], F[2]), a.emplaceBack(N[0], N[1], N[2]);
                    const H = E / _ / 2;
                    c.emplaceBack(-H - w, -1, H, .8), c.emplaceBack(H + w, -1, H, .8), c.emplaceBack(-H, 0, H, 1.3), c.emplaceBack(H, 0, H, 1.3), c.emplaceBack(H + w, -.8, H, .7), c.emplaceBack(H + w, -.8, H, .7), c.emplaceBack(0, 0, H, 1.3), c.emplaceBack(0, 0, H, 1.3), c.emplaceBack(H + w, -1.2, H, .8), c.emplaceBack(H + w, -1.2, H, .8), i.emplaceBack(6 + d, 4 + d, 8 + d), i.emplaceBack(7 + d, 9 + d, 5 + d), i.emplaceBack(0 + d, 1 + d, 2 + d), i.emplaceBack(1 + d, 3 + d, 2 + d), d += 10
                }
            }

            function Rk(n, e) {
                const i = {};
                i.indexArray = new Mn, i.vertexArray = new Qo, i.colorArray = new ul, TE(n, e, i.indexArray, i.vertexArray, i.colorArray);
                const a = {defined: !0};
                a.emissiveFactor = Ji.black;
                const c = {};
                return c.baseColorFactor = Ji.white, a.pbrMetallicRoughness = c, i.material = a, i.aabb = new Ei([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), i
            }

            const SE = Fi([{name: "a_pos_3f", components: 3, type: "Float32"}]),
                zk = Fi([{name: "a_normal_3", components: 3, type: "Int16"}]),
                EE = Fi([{name: "a_part_color_emissive", components: 2, type: "Uint16"}]),
                Dk = Fi([{name: "a_bloom_attenuation", components: 4, type: "Float32"}]), AE = Be.types, Q1 = 32767;

            function Lk(n, e) {
                const i = yt + e;
                for (const a of n) for (const c of a) if (c.x < -e || c.x > i || c.y < -e || c.y > i) return !1;
                return !0
            }

            class IE {
                constructor(e) {
                    this.layoutAOArray = [], this.indexArrayForConflationUploaded = !1, this.maxHeight = 0, this.replacementUpdateTime = 0, this.activeReplacements = [], this.footprints = [], this.featuresOnBorder = [], this.buildingFeatures = [], this.footprintLookup = {}, this.zoom = e.zoom, this.canonical = e.canonical, this.layers = e.layers, this.layerIds = this.layers.map(i => i.fqid), this.index = e.index, this.hasPattern = !1, this.worldview = e.worldview, this.layoutVertexArray = new Qo, this.layoutNormalArray = new Vc, this.layoutColorArray = new ea, this.indexArray = new Mn, this.indexArrayForConflation = new Mn, this.entranceBloom = {
                        layoutVertexArray: new Qo,
                        layoutVertexBuffer: null,
                        layoutAttenuationArray: new ul,
                        layoutAttenuationBuffer: null,
                        layoutColorArray: new ea,
                        layoutColorBuffer: null,
                        indexArray: new Mn,
                        indexArrayForConflation: new Mn,
                        indexBuffer: null,
                        segmentsBucket: new Ln
                    }, this.programConfigurations = new es(e.layers, {
                        zoom: e.zoom,
                        lut: e.lut
                    }), this.segmentsBucket = new Ln, this.stateDependentLayerIds = this.layers.filter(i => i.isStateDependent()).map(i => i.id), this.projection = e.projection, this.groundEffect = new F1(e)
                }

                get segments() {
                    return this.segmentsBucket
                }

                get bloomGeometry() {
                    return this.entranceBloom
                }

                updateFootprints(e, i) {
                    for (const a of this.footprints) i.push({footprint: a, id: e})
                }

                prepare() {
                    return function () {
                        if (e0 != null || sE != null) return null;
                        if (_f != null) return _f;
                        const e = fetch(Br.BUILDING_GEN_URL);
                        return _f = function (i) {
                            let a, c, d, f;

                            function _() {
                                a = new Uint8Array(f.buffer), c = new Int32Array(f.buffer), d = new Float32Array(f.buffer)
                            }

                            function x() {
                                throw new Error("Unexpected BuildingGen error.")
                            }

                            const w = () => {
                            }, E = {
                                a: {
                                    a: x, f: function (I) {
                                        const C = a.length, z = Math.max(I >>> 0, Math.ceil(1.2 * C)),
                                            L = Math.ceil((z - C) / 65536);
                                        try {
                                            return f.grow(L), _(), !0
                                        } catch {
                                            return !1
                                        }
                                    }, g: x, b: w, c: w, d: w, e: w
                                }
                            };
                            return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(i, E) : i.then(I => I.arrayBuffer()).then(I => WebAssembly.instantiate(I, E))).then(I => {
                                const C = I.instance.exports;
                                return (0, C.g)(), f = C.f, _(), new hk({
                                    setStyle: C.h,
                                    setAOOptions: C.i,
                                    setMetricOptions: C.j,
                                    setStructuralOptions: C.k,
                                    setFacadeOptions: C.l,
                                    setFauxFacadeOptions: C.m,
                                    setFacadeClassifierOptions: C.n,
                                    addFeature: C.o,
                                    addFacade: C.p,
                                    generateMesh: C.q,
                                    getLastError: C.r,
                                    getMeshCount: C.s,
                                    getPositionsPtr: C.t,
                                    getPositionsLength: C.u,
                                    getNormalsPtr: C.v,
                                    getNormalsLength: C.w,
                                    getColorsPtr: C.x,
                                    getColorsLength: C.y,
                                    getAOPtr: C.z,
                                    getAOLength: C.A,
                                    getUVPtr: C.B,
                                    getUVLength: C.C,
                                    getFauxFacadePtr: C.D,
                                    getFauxFacadeLength: C.E,
                                    getIndicesPtr: C.F,
                                    getIndicesLength: C.G,
                                    getBuildingPart: C.H,
                                    getRingCount: C.I,
                                    getRingPtr: C.J,
                                    getRingLength: C.K,
                                    free: C.L,
                                    malloc: C.M,
                                    heapU8: a,
                                    heap32: c,
                                    heapF32: d
                                })
                            })
                        }(e).then(i => (_f = null, e0 = i, e0)).catch(i => {
                            Li("Could not load building-gen"), _f = null, sE = i
                        }), _f
                    }()
                }

                populate(e, i, a, c) {
                    const d = dk();
                    if (!d) return;
                    const f = he(a);
                    this.tileToMeter = f, this.brightness = i.brightness, d.setStyle({
                        convertToMeters: !1,
                        entranceColorRgb: [1, 1, 1],
                        facadeGlazingColorRgb: [.5607843137254902, .6745098039215687, .7215686274509804],
                        normalScale: [1, -1, f],
                        ridgeHeight: 3,
                        roofColorRgb: [.886274516, .784313738, .713725507],
                        tileToMeters: f,
                        tileZoom: 16,
                        wallColorRgb: [.988235294, .933333337, .811764717]
                    }), d.setAOOptions(!1, .3), d.setMetricOptions(!1, 16), d.setStructuralOptions(!0), d.setFacadeOptions(4, !0), d.setFauxFacadeOptions(!1, !1, 1), d.setFacadeClassifierOptions(3);
                    const _ = new Map;
                    for (const {feature: x} of e) {
                        if (AE[x.type] !== "LineString") continue;
                        const w = this.layers[0]._featureFilter.needGeometry, E = $e(x, w);
                        if (!this.layers[0]._featureFilter.filter(new sn(this.zoom), E, a)) continue;
                        const I = w ? E.geometry : Te(x, a, c), C = [];
                        for (const N of I) for (const H of N) C.push({x: H.x, y: H.y});
                        const z = {
                            coordinates: C,
                            crossPerc: x.properties.cross_perc,
                            distanceToRoad: x.properties.distance_to_road,
                            entrances: x.properties.entrances,
                            sourceId: 0
                        }, L = x.properties.source_id;
                        let F = _.get(L);
                        F || (F = [], _.set(L, F)), F.push(z)
                    }
                    this.maxHeight = 0;
                    for (const {feature: x, index: w} of e) {
                        if (AE[x.type] === "LineString") continue;
                        const E = this.layers[0]._featureFilter.needGeometry, I = $e(x, E);
                        if (!this.layers[0]._featureFilter.filter(new sn(this.zoom), I, a)) continue;
                        const C = E ? I.geometry : Te(x, a, c), z = Xm(C, 500);
                        if (!Lk(C, 163)) continue;
                        const L = this.layers[0], F = L.layout.get("building-base").evaluate(x, {}, a),
                            N = L.layout.get("building-height").evaluate(x, {}, a),
                            H = L.layout.get("building-roof-shape").evaluate(x, {}, a),
                            Y = L.paint.get("building-ambient-occlusion-intensity"),
                            X = L.paint.get("building-ambient-occlusion-ground-radius") / this.tileToMeter;
                        if (H === "flat") continue;
                        const J = x.properties.source_id;
                        let xe;
                        xe = _.has(J) ? _.get(J) : [];
                        const ge = [], ye = new Ze(1 / 0, 1 / 0), Ee = new Ze(-1 / 0, -1 / 0);
                        for (const nt of z) if (nt.length > 0) {
                            const lt = [];
                            for (const kt of nt) {
                                const Et = [];
                                for (let vt = kt.length - 1; vt >= 0; vt--) {
                                    const At = kt[vt];
                                    Et.push({
                                        x: At.x,
                                        y: At.y
                                    }), ye.x = Math.min(ye.x, At.x), ye.y = Math.min(ye.y, At.y), Ee.x = Math.max(Ee.x, At.x), Ee.y = Math.max(Ee.y, At.y)
                                }
                                lt.push(Et)
                            }
                            ge.push({id: x.id, height: N, minHeight: F, sourceId: 0, roofType: H, coordinates: lt})
                        }
                        const Ie = d.generateMesh(ge, xe);
                        if (typeof Ie == "string" || Ie.meshes.length === 0 || Ie.modifiedPolygonRings.length === 0) continue;
                        let We = 0;
                        for (const nt of Ie.meshes) We += nt.positions.length / 3;
                        const De = this.segmentsBucket.prepareSegment(We, this.layoutVertexArray, this.indexArray),
                            Ye = [];
                        let ht = null, Qe = 0, ot = -1;
                        const ct = this.indexArray.length;
                        let He = 0;
                        for (const nt of Ie.meshes) {
                            const lt = this.layoutVertexArray.length;
                            if (nt.buildingPart === "entrance") {
                                const Et = new Array;
                                for (let oi = 0; oi < nt.indices.length; oi += 12) {
                                    const pi = nt.positions[oi + 0], ui = nt.positions[oi + 1],
                                        ki = nt.positions[oi + 3], bi = nt.positions[oi + 4], Tn = nt.positions[oi + 2],
                                        ne = nt.positions[oi + 8] - Tn, re = 1, Ge = ki - pi, mt = bi - ui,
                                        bt = Math.hypot(Ge, mt);
                                    Et.push({
                                        pos: [pi + .5 * Ge, ui + .5 * mt, Tn],
                                        normal: [mt / bt, -Ge / bt, 0],
                                        width: bt,
                                        height: ne,
                                        depth: re,
                                        points: [pi, ui, ki, bi]
                                    })
                                }
                                const vt = this.entranceBloom.segmentsBucket.prepareSegment(10 * Et.length, this.entranceBloom.layoutVertexArray, this.entranceBloom.indexArray),
                                    At = this.entranceBloom.layoutVertexArray.length;
                                Qe = this.entranceBloom.indexArray.length, TE(Et, .5 / this.tileToMeter, this.entranceBloom.indexArray, this.entranceBloom.layoutVertexArray, this.entranceBloom.layoutAttenuationArray);
                                const Kt = this.entranceBloom.layoutVertexArray.length - At;
                                ot = this.entranceBloom.indexArray.length - Qe;
                                for (let oi = 0; oi < Kt; oi++) this.entranceBloom.layoutColorArray.emplaceBack(65535, 65535);
                                vt.vertexLength += Kt, vt.primitiveLength += ot, ht = {
                                    part: nt.buildingPart,
                                    vertexOffset: At,
                                    vertexLength: Kt
                                }
                            }
                            for (let Et = 0; Et < nt.positions.length; Et += 3) He = Math.max(He, nt.positions[Et + 2]), this.layoutVertexArray.emplaceBack(nt.positions[Et], nt.positions[Et + 1], nt.positions[Et + 2]);
                            for (let Et = 0; Et < nt.normals.length; Et += 3) this.layoutNormalArray.emplaceBack(nt.normals[Et + 0] * Q1, nt.normals[Et + 1] * Q1, nt.normals[Et + 2] * Q1);
                            for (let Et = 0; Et < nt.ao.length; Et++) this.layoutAOArray.push(nt.ao[Et]);
                            for (let Et = 0; Et < nt.colors.length; Et += 3) {
                                const vt = 1 + (nt.ao[Et / 3] - 1) * Y;
                                this.layoutColorArray.emplaceBack(nt.colors[Et] * vt << 8 | nt.colors[Et + 1] * vt, nt.colors[Et + 2] * vt << 8)
                            }
                            const kt = De.vertexLength;
                            for (let Et = 0; Et < nt.indices.length; Et += 3) this.indexArray.emplaceBack(kt + nt.indices[Et], kt + nt.indices[Et + 1], kt + nt.indices[Et + 2]);
                            De.vertexLength += nt.positions.length / 3, De.primitiveLength += nt.indices.length / 3, (nt.buildingPart === "roof" || nt.buildingPart === "wall" || nt.buildingPart === "facade_glazing" || nt.buildingPart === "entrance") && Ye.push({
                                part: nt.buildingPart,
                                vertexOffset: lt,
                                vertexLength: nt.positions.length / 3
                            })
                        }
                        this.maxHeight = Math.max(this.maxHeight, He), this.buildingFeatures.push({
                            feature: I,
                            segment: De,
                            parts: Ye,
                            buildingBloom: ht
                        });
                        const st = this.indexArray.length - ct, ke = [], qe = [], pt = new Ze(1 / 0, 1 / 0),
                            at = new Ze(-1 / 0, -1 / 0), Bt = this.groundEffect.vertexArray.length;
                        for (const nt of Ie.modifiedPolygonRings) {
                            const lt = [], kt = new Ze(1 / 0, 1 / 0), Et = new Ze(-1 / 0, -1 / 0);
                            for (let vt = 0; vt < nt.length; vt += 2) {
                                const At = nt.length - vt - 2;
                                kt.x = Math.min(kt.x, nt[At]), kt.y = Math.min(kt.y, nt[At + 1]), Et.x = Math.max(Et.x, nt[At]), Et.y = Math.max(Et.y, nt[At + 1]);
                                const Kt = new Ze(nt[At], nt[At + 1]);
                                lt.push(Kt), ke.push(Kt.x, Kt.y), qe.push(Kt.clone())
                            }
                            pt.x = Math.min(pt.x, kt.x), pt.y = Math.min(pt.y, kt.y), at.x = Math.max(at.x, Et.x), at.y = Math.max(at.y, Et.y), this.groundEffect.addData(lt, [kt, Et], X)
                        }
                        const zt = this.groundEffect.vertexArray.length - Bt;
                        (ye.x < 0 || Ee.x > yt || ye.y < 0 || Ee.y > yt) && this.featuresOnBorder.push({
                            featureId: x.id,
                            footprintIndex: this.footprints.length
                        });
                        {
                            const nt = df(ke, null, 2), lt = new Wy(qe, nt, 8, 256);
                            let kt = x.id;
                            x.properties && x.properties.hasOwnProperty("building_id") && (kt = x.properties.building_id), this.footprints.push({
                                vertices: qe,
                                indices: nt,
                                grid: lt,
                                min: pt,
                                max: at,
                                buildingId: kt,
                                hiddenFlags: 0,
                                indicesOffset: ct,
                                indicesLength: st,
                                bloomIndicesOffset: Qe,
                                bloomIndicesLength: ot,
                                groundEffectVertexOffset: Bt,
                                groundEffectVertexLength: zt,
                                segment: De,
                                height: He
                            })
                        }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, x, w, {}, i.availableImages, a, i.brightness), this.groundEffect.addPaintPropertiesData(x, w, {}, i.availableImages, a, i.brightness)
                    }
                    this.groundEffect.prepareBorderSegments(), this.evaluate(this.layers[0])
                }

                update(e, i, a, c, d, f, _) {
                    this.programConfigurations.updatePaintArrays(e, i, d, a, c, f, _), this.groundEffect.update(e, i, d, a, c, f, _)
                }

                isEmpty() {
                    return this.layoutVertexArray.length === 0
                }

                uploadPending() {
                    return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload
                }

                upload(e) {
                    this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, SE.members), this.layoutNormalBuffer = e.createVertexBuffer(this.layoutNormalArray, zk.members), this.entranceBloom.layoutVertexBuffer = e.createVertexBuffer(this.entranceBloom.layoutVertexArray, SE.members), this.entranceBloom.layoutAttenuationBuffer = e.createVertexBuffer(this.entranceBloom.layoutAttenuationArray, Dk.members), this.uploadUpdatedColorBuffer(e), this.uploadUpdatedIndexBuffer(e), this.groundEffect.upload(e)), this.groundEffect.uploadPaintProperties(e), this.programConfigurations.upload(e), this.uploaded = !0
                }

                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.layoutNormalBuffer.destroy(), this.layoutColorBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segmentsBucket.destroy(), this.entranceBloom.layoutVertexBuffer.destroy(), this.entranceBloom.layoutColorBuffer.destroy(), this.entranceBloom.layoutAttenuationBuffer.destroy(), this.entranceBloom.indexBuffer.destroy(), this.entranceBloom.segmentsBucket.destroy())
                }

                updateFootprintHiddenFlags(e, i, a = !0) {
                    let c = !1;
                    const d = a ? i : 0, f = 0 | (a ? -1 : ~i);
                    this.groundEffect.hiddenByLandmarkVertexArray.length === 0 && this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
                    for (const _ of e) {
                        const x = this.footprints[_], w = x.hiddenFlags & f | d;
                        x.hiddenFlags !== w && (x.hiddenFlags = w, c = !0, this.groundEffect.updateHiddenByLandmarkRange(x.groundEffectVertexOffset, x.groundEffectVertexLength, x.hiddenFlags !== 0))
                    }
                    return c && (this.indexArrayForConflationUploaded = !1), c
                }

                uploadUpdatedIndexBuffer(e) {
                    if (this.groundEffect.uploadHiddenByLandmark(e), !this.indexArrayForConflationUploaded && this.indexArray.length !== 0) {
                        this.indexArrayForConflation.resize(this.indexArray.length), this.indexArrayForConflation.uint16.set(this.indexArray.uint16), this.entranceBloom.indexArrayForConflation.resize(this.entranceBloom.indexArray.length), this.entranceBloom.indexArrayForConflation.uint16.set(this.entranceBloom.indexArray.uint16);
                        for (const i of this.footprints) {
                            const a = i.indicesOffset + i.indicesLength;
                            if (i.hiddenFlags !== 0) {
                                for (let d = i.indicesOffset; d < a; d++) this.indexArrayForConflation.uint16[3 * d + 0] = 0, this.indexArrayForConflation.uint16[3 * d + 1] = 0, this.indexArrayForConflation.uint16[3 * d + 2] = 0;
                                const c = i.bloomIndicesOffset + i.bloomIndicesLength;
                                for (let d = i.bloomIndicesOffset; d < c; d++) this.entranceBloom.indexArrayForConflation.uint16[3 * d + 0] = 0, this.entranceBloom.indexArrayForConflation.uint16[3 * d + 1] = 0, this.entranceBloom.indexArrayForConflation.uint16[3 * d + 2] = 0
                            }
                        }
                        this.indexBuffer ? this.indexBuffer.updateData(this.indexArrayForConflation) : this.indexBuffer = e.createIndexBuffer(this.indexArrayForConflation, !0), this.entranceBloom.indexBuffer ? this.entranceBloom.indexBuffer.updateData(this.entranceBloom.indexArrayForConflation) : this.entranceBloom.indexBuffer = e.createIndexBuffer(this.entranceBloom.indexArrayForConflation, !0), this.indexArrayForConflationUploaded = !0
                    }
                }

                uploadUpdatedColorBuffer(e) {
                    this.layoutColorBuffer ? this.layoutColorBuffer.updateData(this.layoutColorArray) : this.layoutColorBuffer = e.createVertexBuffer(this.layoutColorArray, EE.members, !0), this.entranceBloom.layoutColorBuffer ? this.entranceBloom.layoutColorBuffer.updateData(this.entranceBloom.layoutColorArray) : this.entranceBloom.layoutColorBuffer = e.createVertexBuffer(this.entranceBloom.layoutColorArray, EE.members, !0)
                }

                evaluate(e) {
                    const i = e.paint.get("building-ambient-occlusion-intensity");
                    for (const a of this.buildingFeatures) {
                        const c = a.feature;
                        c.properties["building-part"] = "roof";
                        const d = e.paint.get("building-color").evaluate(c, {}, this.canonical),
                            f = e.paint.get("building-emissive-strength").evaluate(c, {}, this.canonical);
                        c.properties["building-part"] = "wall";
                        const _ = e.paint.get("building-color").evaluate(c, {}, this.canonical),
                            x = e.paint.get("building-emissive-strength").evaluate(c, {}, this.canonical);
                        c.properties["building-part"] = "window";
                        const w = e.paint.get("building-color").evaluate(c, {}, this.canonical),
                            E = e.paint.get("building-emissive-strength").evaluate(c, {}, this.canonical);
                        c.properties["building-part"] = "door";
                        const I = e.paint.get("building-color").evaluate(c, {}, this.canonical),
                            C = e.paint.get("building-emissive-strength").evaluate(c, {}, this.canonical);
                        for (const L of a.parts) {
                            let F, N = d;
                            L.part === "roof" ? (N = d, F = f) : L.part === "wall" ? (N = _, F = x) : L.part === "facade_glazing" ? (N = w, F = E) : L.part === "entrance" && (N = I, F = C), F = se(F, 0, 1);
                            for (let H = 0; H < L.vertexLength; H++) {
                                const Y = L.vertexOffset + H, X = 1 + (this.layoutAOArray[Y] - 1) * i;
                                this.layoutColorArray.emplace(Y, N.r * X * 255 << 8 | N.g * X * 255, N.b * X * 255 << 8 | 255 * F)
                            }
                        }
                        const z = a.buildingBloom;
                        if (z) for (let L = 0; L < z.vertexLength; L++) this.bloomGeometry.layoutColorArray.emplace(z.vertexOffset + L, 255 * I.r << 8 | 255 * I.g, 255 * I.b << 8 | 51 * C)
                    }
                }

                needsEvaluation(e, i) {
                    const a = e.transform.projectionOptions, c = e.style.getBrightness();
                    return !(this.uploaded && a.name === this.projection.name && this.brightness === c || (this.projection = a, this.brightness = c, 0))
                }

                updateReplacement(e, i, a) {
                    if (i.updateTime === this.replacementUpdateTime) return;
                    this.replacementUpdateTime = i.updateTime;
                    const c = i.getReplacementRegionsForTile(e.toUnwrapped());
                    if (Xy(this.activeReplacements, c)) return;
                    this.activeReplacements = c;
                    for (const f of this.footprints) f.hiddenFlags &= -2;
                    const d = [];
                    for (const f of this.activeReplacements) {
                        if (f.order <= zS) continue;
                        const _ = Math.max(1, Math.pow(2, f.footprintTileId.canonical.z - e.canonical.z));
                        for (const x of this.footprints) x.min.x > f.max.x || x.max.x < f.min.x || x.min.y > f.max.y || x.max.y < f.min.y || (d.length = 0, kk(x.vertices, 0, x.vertices.length, f.footprintTileId.canonical, e.canonical, d), D1(f.footprint, d, x.indices, 0, x.indices.length, 0, -_) && (x.hiddenFlags |= 1))
                    }
                    this.groundEffect.hiddenByLandmarkVertexArray.length === 0 && this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
                    for (const f of this.footprints) this.groundEffect.updateHiddenByLandmarkRange(f.groundEffectVertexOffset, f.groundEffectVertexLength, f.hiddenFlags !== 0);
                    this.indexArrayForConflationUploaded = !1
                }

                getHeightAtTileCoord(e, i) {
                    let a = Number.NEGATIVE_INFINITY, c = !0;
                    const d = 4 * (e + yt) * yt + (i + yt);
                    if (this.footprintLookup.hasOwnProperty(d)) {
                        const _ = this.footprintLookup[d];
                        return _ ? {height: _.height, hidden: _.hiddenFlags !== 0} : void 0
                    }
                    const f = new Ze(e, i);
                    for (const _ of this.footprints) e > _.max.x || _.min.x > e || i > _.max.y || _.min.y > i || _.height <= a || L1(f, _) && (a = _.height, this.footprintLookup[d] = _, c = _.hiddenFlags !== 0);
                    if (a !== Number.NEGATIVE_INFINITY) return {height: a, hidden: c};
                    this.footprintLookup[d] = void 0
                }
            }

            function kk(n, e, i, a, c, d) {
                const f = Math.pow(2, a.z - c.z);
                for (let _ = 0; _ < i; _++) {
                    let x = n[_ + e].x, w = n[_ + e].y;
                    x = (x + c.x * yt) * f - a.x * yt, w = (w + c.y * yt) * f - a.y * yt, d.push(new Ze(x, w))
                }
            }

            let CE, PE;
            Pt(IE, "BuildingBucket", {omit: ["layers"]});
            const Ok = Fi([{name: "a_pos_normal", components: 2, type: "Int16"}, {
                    name: "a_data",
                    components: 4,
                    type: "Uint8"
                }, {name: "a_linesofar", components: 1, type: "Float32"}], 4),
                Fk = Fi([{name: "a_z_offset_width", components: 3, type: "Float32"}], 4), {members: Bk} = Ok,
                Nk = Fi([{name: "a_packed", components: 3, type: "Float32"}]), {members: jk} = Nk,
                Vk = Fi([{name: "a_pattern_data", components: 3, type: "Float32"}]), {members: Uk} = Vk;

            class ME {
                constructor(e, i) {
                    this.width = e, this.height = i, this.nextRow = 0, this.image = new eu({
                        width: e,
                        height: i
                    }), this.positions = {}, this.uploaded = !1
                }

                getDash(e, i) {
                    const a = this.getKey(e, i);
                    return this.positions[a]
                }

                trim() {
                    const e = this.width, i = this.height = Gt(this.nextRow);
                    this.image.resize({width: e, height: i})
                }

                getKey(e, i) {
                    return e.join(",") + i
                }

                getDashRanges(e, i, a) {
                    const c = [];
                    let d = e.length % 2 == 1 ? -e[e.length - 1] * a : 0, f = e[0] * a, _ = !0;
                    c.push({left: d, right: f, isDash: _, zeroLength: e[0] === 0});
                    let x = e[0];
                    for (let w = 1; w < e.length; w++) {
                        _ = !_;
                        const E = e[w];
                        d = x * a, x += E, f = x * a, c.push({left: d, right: f, isDash: _, zeroLength: E === 0})
                    }
                    return c
                }

                addRoundDash(e, i, a) {
                    const c = i / 2;
                    for (let d = -a; d <= a; d++) {
                        const f = this.width * (this.nextRow + a + d);
                        let _ = 0, x = e[_];
                        for (let w = 0; w < this.width; w++) {
                            w / x.right > 1 && (x = e[++_]);
                            const E = Math.abs(w - x.left), I = Math.abs(w - x.right), C = Math.min(E, I);
                            let z;
                            const L = d / a * (c + 1);
                            if (x.isDash) {
                                const F = c - Math.abs(L);
                                z = Math.sqrt(C * C + F * F)
                            } else z = c - Math.sqrt(C * C + L * L);
                            this.image.data[f + w] = Math.max(0, Math.min(255, z + 128))
                        }
                    }
                }

                addRegularDash(e, i) {
                    for (let x = e.length - 1; x >= 0; --x) {
                        const w = e[x], E = e[x + 1];
                        w.zeroLength ? e.splice(x, 1) : E && E.isDash === w.isDash && (E.left = w.left, e.splice(x, 1))
                    }
                    const a = e[0], c = e[e.length - 1];
                    a.isDash === c.isDash && (a.left = c.left - this.width, c.right = a.right + this.width);
                    const d = this.width * this.nextRow;
                    let f = 0, _ = e[f];
                    for (let x = 0; x < this.width; x++) {
                        x / _.right > 1 && (_ = e[++f]);
                        const w = Math.abs(x - _.left), E = Math.abs(x - _.right), I = Math.min(w, E);
                        this.image.data[d + x] = Math.max(0, Math.min(255, (_.isDash ? I : -I) + i + 128))
                    }
                }

                addDash(e, i) {
                    const a = this.getKey(e, i);
                    if (this.positions[a]) return this.positions[a];
                    const c = i === "round", d = c ? 7 : 0, f = 2 * d + 1;
                    if (this.nextRow + f > this.height) return Li("LineAtlas out of space"), null;
                    e.length === 0 && e.push(1);
                    let _ = 0;
                    for (let E = 0; E < e.length; E++) e[E] < 0 && (Li("Negative value is found in line dasharray, replacing values with 0"), e[E] = 0), _ += e[E];
                    if (_ !== 0) {
                        const E = this.width / _, I = this.getDashRanges(e, this.width, E);
                        c ? this.addRoundDash(I, E, d) : this.addRegularDash(I, i === "square" ? .5 * E : 0)
                    }
                    const x = this.nextRow + d;
                    this.nextRow += f;
                    const w = {tl: [x, d], br: [_, 0]};
                    return this.positions[a] = w, w
                }
            }

            Pt(ME, "LineAtlas");
            const Gk = Be.types, $k = Math.cos(Math.PI / 180 * 37.5), Hk = Math.cos(Math.PI / 180 * 5);

            class J1 {
                constructor(e) {
                    this.evaluationGlobals = {
                        zoom: 0,
                        lineProgress: void 0
                    }, this.elevationType = "none", this.zoom = e.zoom, this.evaluationGlobals.zoom = this.zoom, this.overscaling = e.overscaling, this.pixelRatio = e.pixelRatio, this.layers = e.layers, this.layerIds = this.layers.map(i => i.fqid), this.index = e.index, this.projection = e.projection, this.hasPattern = !1, this.hasCrossSlope = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(i => {
                        this.gradients[i.id] = {}
                    }), this.layoutVertexArray = new tf, this.layoutVertexArray2 = new Qo, this.patternVertexArray = new Qo, this.indexArray = new Mn, this.programConfigurations = new es(e.layers, {
                        zoom: e.zoom,
                        lut: e.lut
                    }), this.segments = new Ln, this.maxLineLength = 0, this.zOffsetVertexArray = new Qo, this.stateDependentLayerIds = this.layers.filter(i => i.isStateDependent()).map(i => i.id), this.tessellationStep = e.tessellationStep ? e.tessellationStep : yt / 64, this.worldview = e.worldview
                }

                updateFootprints(e, i) {
                }

                populate(e, i, a, c) {
                    this.hasPattern = I1("line", this.layers, this.pixelRatio, i);
                    const d = this.layers[0].layout.get("line-sort-key");
                    this.tileToMeter = he(a);
                    const f = this.layers[0].layout.get("line-elevation-reference");
                    if (f === "hd-road-markup") this.elevationType = "road"; else {
                        const C = this.layers[0].layout.get("line-z-offset"), z = C.isConstant() && !C.constantOr(0);
                        this.elevationType = f !== "sea" && f !== "ground" && z ? "none" : "offset", this.elevationType === "offset" && f === "none" && Li(`line-elevation-reference: ground is used for the layer ${this.layerIds[0]} because non-zero line-z-offset value was found.`)
                    }
                    const _ = this.layers[0].layout.get("line-cross-slope");
                    this.hasCrossSlope = this.elevationType === "offset" && _ !== void 0;
                    const x = [];
                    for (const {feature: C, id: z, index: L, sourceLayerIndex: F} of e) {
                        const N = this.layers[0]._featureFilter.needGeometry, H = $e(C, N);
                        if (!this.layers[0]._featureFilter.filter(new sn(this.zoom, {worldview: this.worldview}), H, a)) continue;
                        const Y = d ? d.evaluate(H, {}, a) : void 0, X = {
                            id: z,
                            properties: C.properties,
                            type: C.type,
                            sourceLayerIndex: F,
                            index: L,
                            geometry: N ? H.geometry : Te(C, a, c),
                            patterns: {},
                            sortKey: Y
                        };
                        x.push(X)
                    }
                    d && x.sort((C, z) => C.sortKey - z.sortKey);
                    const {lineAtlas: w, featureIndex: E} = i, I = this.addConstantDashes(w);
                    for (const C of x) {
                        const {geometry: z, index: L, sourceLayerIndex: F} = C;
                        if (I && this.addFeatureDashes(C, w), this.hasPattern) {
                            const N = C1("line", this.layers, C, this.zoom, this.pixelRatio, i);
                            this.patternFeatures.push(N)
                        } else this.addFeature(C, z, L, a, w.positions, i.availableImages, i.brightness, i.elevationFeatures);
                        E.insert(e[L].feature, z, L, F, this.index)
                    }
                }

                addConstantDashes(e) {
                    let i = !1;
                    for (const a of this.layers) {
                        const c = a.paint.get("line-dasharray").value, d = a.layout.get("line-cap").value;
                        if (c.kind !== "constant" || d.kind !== "constant") i = !0; else {
                            const f = d.value, _ = c.value;
                            if (!_) continue;
                            e.addDash(_, f)
                        }
                    }
                    return i
                }

                addFeatureDashes(e, i) {
                    const a = this.zoom;
                    for (const c of this.layers) {
                        const d = c.paint.get("line-dasharray").value, f = c.layout.get("line-cap").value;
                        if (d.kind === "constant" && f.kind === "constant") continue;
                        let _, x;
                        if (d.kind === "constant") {
                            if (_ = d.value, !_) continue
                        } else _ = d.evaluate({zoom: a}, e);
                        x = f.kind === "constant" ? f.value : f.evaluate({zoom: a}, e), i.addDash(_, x), e.patterns[c.id] = [i.getKey(_, x)]
                    }
                }

                update(e, i, a, c, d, f, _, x) {
                    this.programConfigurations.updatePaintArrays(e, i, d, a, c, f, _, x)
                }

                addFeatures(e, i, a, c, d, f) {
                    for (const _ of this.patternFeatures) this.addFeature(_, _.geometry, _.index, i, a, c, f)
                }

                isEmpty() {
                    return this.layoutVertexArray.length === 0
                }

                uploadPending() {
                    return !this.uploaded || this.programConfigurations.needsUpload
                }

                upload(e) {
                    this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, jk)), this.patternVertexArray.length !== 0 && (this.patternVertexBuffer = e.createVertexBuffer(this.patternVertexArray, Uk)), !this.zOffsetVertexBuffer && this.zOffsetVertexArray.length > 0 && (this.zOffsetVertexBuffer = e.createVertexBuffer(this.zOffsetVertexArray, Fk.members, !0)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Bk), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0
                }

                destroy() {
                    this.layoutVertexBuffer && (this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy())
                }

                lineFeatureClips(e) {
                    if (e.properties && e.properties.hasOwnProperty("mapbox_clip_start") && e.properties.hasOwnProperty("mapbox_clip_end")) return {
                        start: +e.properties.mapbox_clip_start,
                        end: +e.properties.mapbox_clip_end
                    }
                }

                addFeature(e, i, a, c, d, f, _, x) {
                    const w = this.layers[0].layout, E = w.get("line-join").evaluate(e, {}),
                        I = w.get("line-cap").evaluate(e, {}), C = w.get("line-miter-limit"),
                        z = w.get("line-round-limit");
                    this.lineClips = this.lineFeatureClips(e), this.lineFeature = e, this.zOffsetValue = w.get("line-z-offset").value;
                    const L = this.layers[0].paint.get("line-width").value;
                    if (L.kind !== "constant" && L.isLineProgressConstant === !1 && (this.variableWidthValue = L), this.elevationType === "road") {
                        const F = this.layoutVertexArray.length;
                        if (!this.addElevatedRoadFeature(e, i, c, x, E, I, C, z)) {
                            const [N, H] = this.clipRuntimeLinesToTile(i, 1);
                            for (let Y = 0; Y < N.length; Y++) {
                                const X = N[Y], J = H[Y], xe = {
                                    progress: {min: J.progress.min, max: J.progress.max},
                                    nextDir: this.computeSegNextDir(J, X),
                                    prevDir: this.computeSegPrevDir(J, X)
                                };
                                this.addLine(X, e, c, E, I, C, z, xe)
                            }
                            this.fillNonElevatedRoadSegment(F)
                        }
                    } else for (const F of i) this.addLine(F, e, c, E, I, C, z);
                    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, a, d, f, c, _, void 0, this.worldview)
                }

                computeSegNextDir(e, i) {
                    return e.nextPoint.sub(i.at(-2)).unit()
                }

                computeSegPrevDir(e, i) {
                    return i[1].sub(e.prevPoint).unit()
                }

                clipLinesToTile(e, i) {
                    return Qy(e, -i, -i, yt + i, yt + i)
                }

                clipRuntimeLinesToTile(e, i) {
                    const a = [];
                    return [Qy(e, -i, -i, yt + i, yt + i, a), a]
                }

                addElevatedRoadFeature(e, i, a, c, d, f, _, x) {
                    const w = [], E = kn.getElevationFeature(e, c);
                    if (E) {
                        const I = this.clipLinesToTile(i, 1), C = this.prepareElevatedLines(I, E, a);
                        for (const z of C) w.push({
                            geometry: z,
                            elevation: E,
                            elevationTileID: a,
                            segment: {progress: {min: 0, max: 1}, nextDir: void 0, prevDir: void 0}
                        })
                    }
                    if (w.length === 0) return !1;
                    for (const I of w) {
                        const C = this.layoutVertexArray.length;
                        this.addLine(I.geometry, e, a, d, f, _, x);
                        const z = new ji(a, I.elevationTileID);
                        if (I.elevation) for (let L = C; L < this.layoutVertexArray.length; L++) {
                            const F = new Ze(this.layoutVertexArray.int16[6 * L] >> 1, this.layoutVertexArray.int16[6 * L + 1] >> 1),
                                N = z.pointElevation(F, I.elevation, .05);
                            this.updateHeightRange(N), this.zOffsetVertexArray.emplaceBack(N, 0, 0)
                        } else this.fillNonElevatedRoadSegment(C)
                    }
                    return !0
                }

                prepareElevatedLines(e, i, a) {
                    if (i.constantHeight != null) return e;
                    const c = [], d = 1 / he(a);
                    for (const f of e) lk(f, new rn(i, d), 0, c);
                    return c
                }

                fillNonElevatedRoadSegment(e) {
                    for (let i = e; i < this.layoutVertexArray.length; i++) this.zOffsetVertexArray.emplaceBack(0, 0, 0)
                }

                updateHeightRange(e) {
                    this.heightRange ? (this.heightRange.min = Math.min(this.heightRange.min, e), this.heightRange.max = Math.max(this.heightRange.max, e)) : this.heightRange = {
                        min: e,
                        max: e
                    }
                }

                addLine(e, i, a, c, d, f, _, x) {
                    this.distance = 0, this.prevDistance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.totalFeatureLength = 0, this.lineSoFar = 0, this.currentVertex = void 0;
                    const w = c === "none";
                    this.patternJoinNone = this.hasPattern && w, this.segmentStart = 0, this.segmentStartf32 = 0, this.segmentPoints = [];
                    const E = x && x.progress.min > 0, I = x && x.progress.max < 1;
                    if (this.lineClips) {
                        let Ee = {min: this.lineClips.start, max: this.lineClips.end}, Ie = 1;
                        if (x) {
                            const Ye = this.lineClips.end - this.lineClips.start;
                            Ee = function (ht, Qe, ot) {
                                return {min: Gu(ht.min, Qe, ot), max: Gu(ht.max, Qe, ot)}
                            }(x.progress, {min: 0, max: 1}, Ee), Ye > 0 && (Ie = (Ee.max - Ee.min) / Ye)
                        }
                        const We = +i.properties.mapbox_clip_feature_len, De = +i.properties.mapbox_clip_seg_len;
                        if (Number.isNaN(We) || Number.isNaN(De)) {
                            for (let ht = 0; ht < e.length - 1; ht++) this.totalDistance += e[ht].dist(e[ht + 1]);
                            const Ye = this.totalDistance / (Ee.max - Ee.min);
                            this.totalFeatureLength = Number.isFinite(Ye) ? Ye : 0, this.lineClips.start = Ee.min, this.lineClips.end = Ee.max, this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
                        } else this.totalFeatureLength = We, this.distance = De * Ie, this.lineClips.start = Ee.min, this.lineClips.end = Ee.max, this.maxLineLength = Math.max(this.maxLineLength, this.distance);
                        this.lineClipsArray.push(this.lineClips), this.updateScaledDistance()
                    }
                    const C = Gk[i.type] === "Polygon";
                    let z = e.length;
                    for (; z >= 2 && e[z - 1].equals(e[z - 2]);) z--;
                    let L = 0;
                    for (; L < z - 1 && e[L].equals(e[L + 1]);) L++;
                    if (z < (C ? 3 : 2)) return;
                    c === "bevel" && (f = 1.05);
                    const F = this.segments.prepareSegment(10 * z, this.layoutVertexArray, this.indexArray);
                    let N, H, Y, X, J, xe, ge, ye;
                    x && x.prevDir && (xe = x.prevDir.perp()), x && x.nextDir && (ge = x.nextDir.perp()), this.e1 = this.e2 = -1, C && (N = e[z - 2], J = e[L].sub(N)._unit()._perp());
                    for (let Ee = L; Ee < z; Ee++) {
                        if (Y = Ee === z - 1 ? C ? e[L + 1] : void 0 : e[Ee + 1], Y && e[Ee].equals(Y)) continue;
                        J && (X = J), N && (H = N), N = e[Ee], ye = this.evaluateLineProgressFeatures(H ? H.dist(N) : 0), J = Y ? Y.sub(N)._unit()._perp() : X, X = X || J;
                        const Ie = H && Y;
                        let We = Ie ? c : C || w ? "butt" : d;
                        const De = X.x * J.x + X.y * J.y;
                        if (w) {
                            const ke = function (qe) {
                                if (qe.patternJoinNone) {
                                    const pt = qe.segmentPoints.length / 2, at = qe.lineSoFar - qe.segmentStart;
                                    for (let Bt = 0; Bt < pt; ++Bt) {
                                        const zt = qe.segmentPoints[2 * Bt + 1],
                                            nt = Math.round(qe.segmentPoints[2 * Bt]) + .5 + .25 * zt;
                                        qe.patternVertexArray.emplaceBack(nt, at, qe.segmentStart), qe.patternVertexArray.emplaceBack(nt, at, qe.segmentStart)
                                    }
                                    qe.segmentPoints.length = 0
                                }
                                qe.e1 = qe.e2 = -1
                            };
                            if (Ie && De < Hk) {
                                this.updateDistance(H, N), this.addCurrentVertex(N, X, 1, 1, F, ye), ke(this), this.addCurrentVertex(N, J, -1, -1, F, ye);
                                continue
                            }
                            if (H) {
                                if (!Y) {
                                    this.updateDistance(H, N), this.addCurrentVertex(N, X, 1, 1, F, ye), ke(this);
                                    continue
                                }
                                We = "miter"
                            }
                        }
                        let Ye = X.add(J);
                        Ye.x === 0 && Ye.y === 0 || Ye._unit();
                        const ht = Ye.x * J.x + Ye.y * J.y, Qe = ht !== 0 ? 1 / ht : 1 / 0,
                            ot = 2 * Math.sqrt(2 - 2 * ht), ct = ht < $k && H && Y, He = X.x * J.y - X.y * J.x > 0,
                            st = this.overscaling <= 16 ? 15 * yt / (512 * this.overscaling) : 0;
                        if (Ie && We === "round") {
                            if (Qe < _) We = "miter"; else if (Qe <= 2) {
                                const ke = ew(N, -10, yt + 10);
                                We = this.elevationType === "offset" && (ke || this.hasCrossSlope) ? "miter" : "fakeround"
                            }
                        }
                        if (We === "miter" && Qe > f && (We = "bevel"), We === "bevel" && (Qe > 2 && (We = "flipbevel"), Qe < f && (We = "miter")), H && !(We === "miter" && ct) && this.updateDistance(H, N), We === "miter") if (ct) {
                            const ke = N.dist(H);
                            if (ke > 2 * st) {
                                const pt = N.sub(N.sub(H)._mult(st / ke)._round());
                                this.updateDistance(H, pt), this.addCurrentVertex(pt, X, 0, 0, F, ye), H = pt
                            }
                            this.updateDistance(H, N), Ye._mult(Qe), this.addCurrentVertex(N, Ye, 0, 0, F, ye);
                            const qe = N.dist(Y);
                            if (qe > 2 * st) {
                                const pt = N.add(Y.sub(N)._mult(st / qe)._round());
                                this.updateDistance(N, pt), this.addCurrentVertex(pt, J, 0, 0, F, ye), N = pt
                            }
                        } else Ye._mult(Qe), this.addCurrentVertex(N, Ye, 0, 0, F, ye); else if (We === "flipbevel") {
                            if (Qe > 100) Ye = J.mult(-1); else {
                                const ke = Qe * X.add(J).mag() / X.sub(J).mag();
                                Ye._perp()._mult(ke * (He ? -1 : 1))
                            }
                            this.addCurrentVertex(N, Ye, 0, 0, F, ye), this.addCurrentVertex(N, Ye.mult(-1), 0, 0, F, ye)
                        } else if (We === "bevel" || We === "fakeround") {
                            ye != null && H && this.addCurrentVertex(N, ge || X, -1, -1, F, ye);
                            const ke = N.dist(H) <= 2 * st && We !== "bevel", qe = Ye.mult(He ? 1 : -1);
                            qe._mult(Qe);
                            const pt = J.mult(He ? -1 : 1), at = X.mult(He ? -1 : 1),
                                Bt = this.evaluateLineProgressFeatures(this.distance);
                            if (ye == null && (this.addHalfVertex(N, qe.x, qe.y, !1, !He, 0, F, Bt), ke || this.addHalfVertex(N, qe.x + 2 * at.x, qe.y + 2 * at.y, !1, He, 0, F, Bt)), We === "fakeround") {
                                const zt = Math.round(180 * ot / Math.PI / 20);
                                this.addHalfVertex(N, at.x, at.y, !1, He, 0, F, Bt);
                                for (let nt = 0; nt < zt; nt++) {
                                    let lt = nt / zt;
                                    if (lt !== .5) {
                                        const Et = lt - .5;
                                        lt += lt * Et * (lt - 1) * ((1.0904 + De * (De * (3.55645 - 1.43519 * De) - 3.2452)) * Et * Et + (.848013 + De * (.215638 * De - 1.06021)))
                                    }
                                    const kt = pt.sub(at)._mult(lt)._add(at)._unit();
                                    this.addHalfVertex(N, kt.x, kt.y, !1, He, 0, F, Bt)
                                }
                                this.addHalfVertex(N, pt.x, pt.y, !1, He, 0, F, Bt)
                            }
                            ke || ye != null || this.addHalfVertex(N, qe.x + 2 * pt.x, qe.y + 2 * pt.y, !1, He, 0, F, Bt), ye != null && Y && this.addCurrentVertex(N, xe || J, 1, 1, F, ye)
                        } else if (We === "butt") this.addCurrentVertex(N, Ye, 0, 0, F, ye); else if (We === "square") {
                            if (!H) {
                                const ke = E ? 0 : -1;
                                this.addCurrentVertex(N, Ye, ke, ke, F, ye)
                            }
                            if (this.addCurrentVertex(N, Ye, 0, 0, F, ye), H) {
                                const ke = I ? 0 : 1;
                                this.addCurrentVertex(N, Ye, ke, ke, F, ye)
                            }
                        } else if (We === "round") {
                            if (H) {
                                const ke = !Ie && ge ? ge : X;
                                this.addCurrentVertex(N, ke, 0, 0, F, ye), !Ie && I || this.addCurrentVertex(N, ke, 1, 1, F, ye, !0)
                            }
                            if (Y) {
                                const ke = !Ie && xe ? xe : J;
                                !Ie && E || this.addCurrentVertex(N, ke, -1, -1, F, ye, !0), this.addCurrentVertex(N, ke, 0, 0, F, ye)
                            }
                        }
                    }
                }

                addVerticesTo(e, i, a, c, d, f, _, x, w, E) {
                    const I = (i.w - e.w) / this.tessellationStep | 0;
                    let C = 0;
                    const z = this.scaledDistance;
                    if (I > 1) {
                        this.lineSoFar = e.w;
                        const F = (i.x - e.x) / I, N = (i.y - e.y) / I, H = (i.z - e.z) / I, Y = (i.w - e.w) / I;
                        for (let X = 1; X < I; ++X) {
                            e.x += F, e.y += N, e.z += H, this.lineSoFar += Y, C += Y;
                            const J = this.evaluateLineProgressFeatures(this.prevDistance + C);
                            this.scaledDistance = (this.prevDistance + C) / this.totalDistance, this.addHalfVertex(e, a, c, E, !1, _, w, J), this.addHalfVertex(e, d, f, E, !0, -x, w, J)
                        }
                    }
                    this.lineSoFar = i.w, this.scaledDistance = z;
                    const L = this.evaluateLineProgressFeatures(this.distance);
                    this.addHalfVertex(i, a, c, E, !1, _, w, L), this.addHalfVertex(i, d, f, E, !0, -x, w, L)
                }

                evaluateLineProgressFeatures(e) {
                    if (!this.variableWidthValue && this.elevationType !== "offset") return null;
                    this.evaluationGlobals.lineProgress = 0, this.lineClips ? this.evaluationGlobals.lineProgress = Math.min(1, (this.totalFeatureLength * this.lineClips.start + e) / this.totalFeatureLength) : Li(`line-progress evaluation for ${this.layerIds[0]} requires enabling 'lineMetrics' for the source.`);
                    let i = 0;
                    return this.variableWidthValue && this.variableWidthValue.kind !== "constant" && (i = this.variableWidthValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0), this.elevationType !== "offset" ? {
                        zOffset: 0,
                        variableWidth: i
                    } : this.zOffsetValue.kind === "constant" ? {
                        zOffset: this.zOffsetValue.value,
                        variableWidth: i
                    } : {
                        zOffset: this.zOffsetValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0,
                        variableWidth: i
                    }
                }

                addCurrentVertex(e, i, a, c, d, f, _ = !1) {
                    const x = i.x + i.y * a, w = i.y - i.x * a, E = i.y * c - i.x, I = -i.y - i.x * c;
                    if (f != null) {
                        const C = this.elevationType === "offset", z = -10, L = yt + 10, F = f.zOffset,
                            N = new JS(e.x, e.y, F, this.lineSoFar), H = !!C && ew(e, z, L), Y = this.lineSoFar,
                            X = this.distance;
                        if (this.currentVertex) if (H) {
                            const J = this.currentVertexIsOutside, xe = this.currentVertex,
                                ge = new JS(e.x, e.y, F, this.lineSoFar);
                            if (tE(xe, ge, z, L), !ew(ge, z, L)) {
                                if (J) {
                                    this.e1 = this.e2 = -1, this.distance -= xe.dist(N), this.lineSoFar = xe.w;
                                    const ye = this.evaluateLineProgressFeatures(xe.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                                    this.addHalfVertex(xe, x, w, _, !1, a, d, ye), this.addHalfVertex(xe, E, I, _, !0, -c, d, ye), this.prevDistance = this.distance
                                }
                                this.distance = this.prevDistance + xe.dist(ge), this.scaledDistance = this.distance / this.totalDistance, this.addVerticesTo(xe, ge, x, w, E, I, a, c, d, _), this.distance = X, this.scaledDistance = this.distance / this.totalDistance
                            }
                        } else {
                            const J = this.currentVertex;
                            if (this.currentVertexIsOutside) {
                                tE(J, N, z, L), this.e1 = this.e2 = -1, this.distance -= J.dist(N), this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = J.w;
                                const xe = this.evaluateLineProgressFeatures(J.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                                this.addHalfVertex(J, x, w, _, !1, a, d, xe), this.addHalfVertex(J, E, I, _, !0, -c, d, xe), this.prevDistance = this.distance, this.distance = X, this.scaledDistance = this.distance / this.totalDistance
                            }
                            this.addVerticesTo(J, N, x, w, E, I, a, c, d, _)
                        } else H || (this.addHalfVertex(e, x, w, _, !1, a, d, f), this.addHalfVertex(e, E, I, _, !0, -c, d, f));
                        this.currentVertex = N, this.currentVertexIsOutside = H, this.lineSoFar = Y
                    } else this.addHalfVertex(e, x, w, _, !1, a, d, f), this.addHalfVertex(e, E, I, _, !0, -c, d, f)
                }

                addHalfVertex({x: e, y: i}, a, c, d, f, _, x, w) {
                    if (this.patternJoinNone && (this.segmentPoints.length === 0 && (this.segmentStart = this.lineSoFar, this.segmentStartf32 = Math.fround(this.lineSoFar)), f || this.segmentPoints.push(this.lineSoFar - this.segmentStart, _)), this.layoutVertexArray.emplaceBack((e << 1) + (d ? 1 : 0), (i << 1) + (f ? 1 : 0), Math.round(63 * a) + 128, Math.round(63 * c) + 128, 1 + (_ === 0 ? 0 : _ < 0 ? -1 : 1), 0, this.lineSoFar - this.segmentStartf32), this.lineClips) {
                        const I = qt(this.lineClips.start, this.lineClips.end, this.scaledDistance);
                        this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, I)
                    }
                    const E = x.vertexLength++;
                    this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, E), x.primitiveLength++), f ? this.e2 = E : this.e1 = E, w != null && this.zOffsetVertexArray.emplaceBack(w.zOffset, w.variableWidth, w.variableWidth)
                }

                updateScaledDistance() {
                    this.lineClips ? (this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = this.totalFeatureLength * this.lineClips.start + this.distance) : this.lineSoFar = this.distance
                }

                updateDistance(e, i) {
                    this.prevDistance = this.distance, this.distance += e.dist(i), this.updateScaledDistance()
                }
            }

            function ew(n, e, i) {
                return n.x < e || n.x > i || n.y < e || n.y > i
            }

            let RE, zE;

            function DE(n, e, i) {
                return e * (yt / (n.tileSize * Math.pow(2, i - n.tileID.overscaledZ)))
            }

            Pt(J1, "LineBucket", {omit: ["layers", "patternFeatures", "currentVertex", "currentVertexIsOutside"]});
            const LE = (n, e, i) => (1 - i) * n + i * e;

            function kE(n, e) {
                return 1 / DE(n, 1, e.tileZoom)
            }

            function OE(n, e, i, a) {
                return n.translatePosMatrix(a || e.tileID.projMatrix, e, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"))
            }

            const FE = n => {
                const e = [];
                BE(n) && e.push("RENDER_LINE_DASH"), n.paint.get("line-gradient") && e.push("RENDER_LINE_GRADIENT");
                const i = n.paint.get("line-trim-offset");
                i[0] === 0 && i[1] === 0 || e.push("RENDER_LINE_TRIM_OFFSET"), n.paint.get("line-border-width").constantOr(1) !== 0 && e.push("RENDER_LINE_BORDER");
                const a = n.layout.get("line-join").constantOr("miter") === "none",
                    c = !!n.paint.get("line-pattern").constantOr(1);
                return a && c && e.push("LINE_JOIN_NONE"), e
            };

            function BE(n) {
                const e = n.paint.get("line-dasharray").value;
                return e.value || e.kind !== "constant"
            }

            let tw;
            const NE = () => tw || (tw = {
                layout: RE || (RE = new qn({
                    "line-cap": new Tt(ze.layout_line["line-cap"]),
                    "line-join": new Tt(ze.layout_line["line-join"]),
                    "line-miter-limit": new dt(ze.layout_line["line-miter-limit"]),
                    "line-round-limit": new dt(ze.layout_line["line-round-limit"]),
                    "line-sort-key": new Tt(ze.layout_line["line-sort-key"]),
                    "line-z-offset": new Tt(ze.layout_line["line-z-offset"]),
                    "line-elevation-reference": new dt(ze.layout_line["line-elevation-reference"]),
                    "line-cross-slope": new dt(ze.layout_line["line-cross-slope"]),
                    visibility: new dt(ze.layout_line.visibility),
                    "line-width-unit": new dt(ze.layout_line["line-width-unit"])
                })), paint: zE || (zE = new qn({
                    "line-opacity": new Tt(ze.paint_line["line-opacity"]),
                    "line-color": new Tt(ze.paint_line["line-color"]),
                    "line-translate": new dt(ze.paint_line["line-translate"]),
                    "line-translate-anchor": new dt(ze.paint_line["line-translate-anchor"]),
                    "line-width": new Tt(ze.paint_line["line-width"]),
                    "line-gap-width": new Tt(ze.paint_line["line-gap-width"]),
                    "line-offset": new Tt(ze.paint_line["line-offset"]),
                    "line-blur": new Tt(ze.paint_line["line-blur"]),
                    "line-dasharray": new Tt(ze.paint_line["line-dasharray"]),
                    "line-pattern": new Tt(ze.paint_line["line-pattern"]),
                    "line-pattern-cross-fade": new dt(ze.paint_line["line-pattern-cross-fade"]),
                    "line-gradient": new Fc(ze.paint_line["line-gradient"]),
                    "line-trim-offset": new dt(ze.paint_line["line-trim-offset"]),
                    "line-trim-fade-range": new dt(ze.paint_line["line-trim-fade-range"]),
                    "line-trim-color": new dt(ze.paint_line["line-trim-color"]),
                    "line-emissive-strength": new dt(ze.paint_line["line-emissive-strength"]),
                    "line-border-width": new Tt(ze.paint_line["line-border-width"]),
                    "line-border-color": new Tt(ze.paint_line["line-border-color"]),
                    "line-occlusion-opacity": new dt(ze.paint_line["line-occlusion-opacity"]),
                    "line-color-use-theme": new Tt({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "line-gradient-use-theme": new Tt({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "line-trim-color-use-theme": new Tt({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "line-border-color-use-theme": new Tt({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    })
                }))
            }, tw);

            class qk extends Tt {
                possiblyEvaluate(e, i) {
                    return i = new sn(Math.floor(i.zoom), {
                        now: i.now,
                        fadeDuration: i.fadeDuration,
                        transition: i.transition,
                        worldview: i.worldview
                    }), super.possiblyEvaluate(e, i)
                }

                evaluate(e, i, a, c) {
                    return i = Ne({}, i, {zoom: Math.floor(i.zoom)}), super.evaluate(e, i, a, c)
                }
            }

            let ag;

            function jE(n, e) {
                return e > 0 ? e + 2 * n : n
            }

            const Wk = Fi([{name: "a_pos_offset", components: 4, type: "Int16"}, {
                    name: "a_tex_size",
                    components: 4,
                    type: "Uint16"
                }, {name: "a_pixeloffset", components: 4, type: "Int16"}], 4),
                Zk = Fi([{name: "a_globe_anchor", components: 3, type: "Int16"}, {
                    name: "a_globe_normal",
                    components: 3,
                    type: "Float32"
                }], 4), Xk = Fi([{name: "a_projected_pos", components: 4, type: "Float32"}], 4);
            Fi([{name: "a_fade_opacity", components: 1, type: "Uint32"}], 4);
            const Yk = Fi([{name: "a_auto_z_offset", components: 1, type: "Float32"}], 4),
                Kk = Fi([{name: "a_x_axis", components: 3, type: "Float32"}, {
                    name: "a_y_axis",
                    components: 3,
                    type: "Float32"
                }]), Qk = Fi([{name: "a_texb", components: 2, type: "Uint16"}]),
                Jk = Fi([{name: "a_placed", components: 2, type: "Uint8"}, {
                    name: "a_shift",
                    components: 2,
                    type: "Float32"
                }, {name: "a_elevation_from_sea", components: 2, type: "Float32"}]),
                e3 = Fi([{name: "a_size_scale", components: 1, type: "Float32"}, {
                    name: "a_padding",
                    components: 2,
                    type: "Float32"
                }, {name: "a_auto_z_offset", components: 1, type: "Float32"}]);
            Fi([{type: "Int16", name: "projectedAnchorX"}, {type: "Int16", name: "projectedAnchorY"}, {
                type: "Int16",
                name: "projectedAnchorZ"
            }, {type: "Int16", name: "tileAnchorX"}, {type: "Int16", name: "tileAnchorY"}, {
                type: "Float32",
                name: "x1"
            }, {type: "Float32", name: "y1"}, {type: "Float32", name: "x2"}, {
                type: "Float32",
                name: "y2"
            }, {type: "Int16", name: "padding"}, {type: "Uint32", name: "featureIndex"}, {
                type: "Uint16",
                name: "sourceLayerIndex"
            }, {type: "Uint16", name: "bucketIndex"}]);
            const VE = Fi([{name: "a_pos", components: 3, type: "Int16"}, {
                    name: "a_anchor_pos",
                    components: 2,
                    type: "Int16"
                }, {name: "a_extrude", components: 2, type: "Int16"}], 4),
                t3 = Fi([{name: "a_pos_2f", components: 2, type: "Float32"}, {
                    name: "a_radius",
                    components: 1,
                    type: "Float32"
                }, {name: "a_flags", components: 2, type: "Int16"}], 4);
            Fi([{name: "triangle", components: 3, type: "Uint16"}]), Fi([{
                type: "Int16",
                name: "projectedAnchorX"
            }, {type: "Int16", name: "projectedAnchorY"}, {type: "Int16", name: "projectedAnchorZ"}, {
                type: "Float32",
                name: "tileAnchorX"
            }, {type: "Float32", name: "tileAnchorY"}, {type: "Uint16", name: "glyphStartIndex"}, {
                type: "Uint16",
                name: "numGlyphs"
            }, {type: "Uint32", name: "vertexStartIndex"}, {type: "Uint32", name: "lineStartIndex"}, {
                type: "Uint32",
                name: "lineLength"
            }, {type: "Uint16", name: "segment"}, {type: "Uint16", name: "lowerSize"}, {
                type: "Uint16",
                name: "upperSize"
            }, {type: "Float32", name: "lineOffsetX"}, {type: "Float32", name: "lineOffsetY"}, {
                type: "Uint8",
                name: "writingMode"
            }, {type: "Uint8", name: "placedOrientation"}, {type: "Uint8", name: "hidden"}, {
                type: "Uint32",
                name: "crossTileID"
            }, {type: "Int16", name: "associatedIconIndex"}, {type: "Uint8", name: "flipState"}]), Fi([{
                type: "Float32",
                name: "tileAnchorX"
            }, {type: "Float32", name: "tileAnchorY"}, {type: "Int16", name: "projectedAnchorX"}, {
                type: "Int16",
                name: "projectedAnchorY"
            }, {type: "Int16", name: "projectedAnchorZ"}, {
                type: "Int16",
                name: "rightJustifiedTextSymbolIndex"
            }, {type: "Int16", name: "centerJustifiedTextSymbolIndex"}, {
                type: "Int16",
                name: "leftJustifiedTextSymbolIndex"
            }, {type: "Int16", name: "verticalPlacedTextSymbolIndex"}, {
                type: "Int16",
                name: "placedIconSymbolIndex"
            }, {type: "Int16", name: "verticalPlacedIconSymbolIndex"}, {type: "Uint16", name: "key"}, {
                type: "Uint16",
                name: "textBoxStartIndex"
            }, {type: "Uint16", name: "textBoxEndIndex"}, {
                type: "Uint16",
                name: "verticalTextBoxStartIndex"
            }, {type: "Uint16", name: "verticalTextBoxEndIndex"}, {
                type: "Uint16",
                name: "iconBoxStartIndex"
            }, {type: "Uint16", name: "iconBoxEndIndex"}, {
                type: "Uint16",
                name: "verticalIconBoxStartIndex"
            }, {type: "Uint16", name: "verticalIconBoxEndIndex"}, {
                type: "Uint16",
                name: "featureIndex"
            }, {type: "Uint16", name: "numHorizontalGlyphVertices"}, {
                type: "Uint16",
                name: "numVerticalGlyphVertices"
            }, {type: "Uint16", name: "numIconVertices"}, {
                type: "Uint16",
                name: "numVerticalIconVertices"
            }, {type: "Uint16", name: "useRuntimeCollisionCircles"}, {
                type: "Uint32",
                name: "crossTileID"
            }, {type: "Float32", components: 2, name: "textOffset"}, {
                type: "Float32",
                name: "collisionCircleDiameter"
            }, {type: "Float32", name: "zOffset"}, {type: "Uint8", name: "hasIconTextFit"}, {
                type: "Uint16",
                name: "elevationFeatureIndex"
            }]), Fi([{type: "Float32", name: "offsetX"}]), Fi([{type: "Int16", name: "x"}, {type: "Int16", name: "y"}]);
            var Dr = 24;

            function i3(n, e, i) {
                return n.sections.forEach(a => {
                    a.text = function (c, d, f) {
                        const _ = d.layout.get("text-transform").evaluate(f, {});
                        return _ === "uppercase" ? c = c.toLocaleUpperCase() : _ === "lowercase" && (c = c.toLocaleLowerCase()), Qs.applyArabicShaping && (c = Qs.applyArabicShaping(c)), c
                    }(a.text, e, i)
                }), n
            }

            const lg = {
                "!": "︕",
                "#": "＃",
                $: "＄",
                "%": "％",
                "&": "＆",
                "(": "︵",
                ")": "︶",
                "*": "＊",
                "+": "＋",
                ",": "︐",
                "-": "︲",
                ".": "・",
                "/": "／",
                ":": "︓",
                ";": "︔",
                "<": "︿",
                "=": "＝",
                ">": "﹀",
                "?": "︖",
                "@": "＠",
                "[": "﹇",
                "\\": "＼",
                "]": "﹈",
                "^": "＾",
                _: "︳",
                "`": "｀",
                "{": "︷",
                "|": "―",
                "}": "︸",
                "~": "～",
                "¢": "￠",
                "£": "￡",
                "¥": "￥",
                "¦": "￤",
                "¬": "￢",
                "¯": "￣",
                "–": "︲",
                "—": "︱",
                "‘": "﹃",
                "’": "﹄",
                "“": "﹁",
                "”": "﹂",
                "…": "︙",
                "‧": "・",
                "₩": "￦",
                "、": "︑",
                "。": "︒",
                "〈": "︿",
                "〉": "﹀",
                "《": "︽",
                "》": "︾",
                "「": "﹁",
                "」": "﹂",
                "『": "﹃",
                "』": "﹄",
                "【": "︻",
                "】": "︼",
                "〔": "︹",
                "〕": "︺",
                "〖": "︗",
                "〗": "︘",
                "！": "︕",
                "（": "︵",
                "）": "︶",
                "，": "︐",
                "－": "︲",
                "．": "・",
                "：": "︓",
                "；": "︔",
                "＜": "︿",
                "＞": "﹀",
                "？": "︖",
                "［": "﹇",
                "］": "﹈",
                "＿": "︳",
                "｛": "︷",
                "｜": "―",
                "｝": "︸",
                "｟": "︵",
                "｠": "︶",
                "｡": "︒",
                "｢": "﹁",
                "｣": "﹂",
                "←": "↑",
                "→": "↓"
            };

            function n3(n) {
                return n === "︶" || n === "﹈" || n === "︸" || n === "﹄" || n === "﹂" || n === "︾" || n === "︼" || n === "︺" || n === "︘" || n === "﹀" || n === "︐" || n === "︓" || n === "︔" || n === "｀" || n === "￣" || n === "︑" || n === "︒"
            }

            function r3(n) {
                return n === "︵" || n === "﹇" || n === "︷" || n === "﹃" || n === "﹁" || n === "︽" || n === "︻" || n === "︹" || n === "︗" || n === "︿"
            }

            const iw = 4294967296, UE = 1 / iw, GE = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
            let s0 = class {
                constructor(n = new Uint8Array(16)) {
                    this.buf = ArrayBuffer.isView(n) ? n : new Uint8Array(n), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length
                }

                readFields(n, e, i = this.length) {
                    for (; this.pos < i;) {
                        const a = this.readVarint(), c = a >> 3, d = this.pos;
                        this.type = 7 & a, n(c, e, this), this.pos === d && this.skip(a)
                    }
                    return e
                }

                readMessage(n, e) {
                    return this.readFields(n, e, this.readVarint() + this.pos)
                }

                readFixed32() {
                    const n = this.dataView.getUint32(this.pos, !0);
                    return this.pos += 4, n
                }

                readSFixed32() {
                    const n = this.dataView.getInt32(this.pos, !0);
                    return this.pos += 4, n
                }

                readFixed64() {
                    const n = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * iw;
                    return this.pos += 8, n
                }

                readSFixed64() {
                    const n = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * iw;
                    return this.pos += 8, n
                }

                readFloat() {
                    const n = this.dataView.getFloat32(this.pos, !0);
                    return this.pos += 4, n
                }

                readDouble() {
                    const n = this.dataView.getFloat64(this.pos, !0);
                    return this.pos += 8, n
                }

                readVarint(n) {
                    const e = this.buf;
                    let i, a;
                    return a = e[this.pos++], i = 127 & a, a < 128 ? i : (a = e[this.pos++], i |= (127 & a) << 7, a < 128 ? i : (a = e[this.pos++], i |= (127 & a) << 14, a < 128 ? i : (a = e[this.pos++], i |= (127 & a) << 21, a < 128 ? i : (a = e[this.pos], i |= (15 & a) << 28, function (c, d, f) {
                        const _ = f.buf;
                        let x, w;
                        if (w = _[f.pos++], x = (112 & w) >> 4, w < 128 || (w = _[f.pos++], x |= (127 & w) << 3, w < 128) || (w = _[f.pos++], x |= (127 & w) << 10, w < 128) || (w = _[f.pos++], x |= (127 & w) << 17, w < 128) || (w = _[f.pos++], x |= (127 & w) << 24, w < 128) || (w = _[f.pos++], x |= (1 & w) << 31, w < 128)) return vf(c, x, d);
                        throw new Error("Expected varint not more than 10 bytes")
                    }(i, n, this)))))
                }

                readVarint64() {
                    return this.readVarint(!0)
                }

                readSVarint() {
                    const n = this.readVarint();
                    return n % 2 == 1 ? (n + 1) / -2 : n / 2
                }

                readBoolean() {
                    return !!this.readVarint()
                }

                readString() {
                    const n = this.readVarint() + this.pos, e = this.pos;
                    return this.pos = n, n - e >= 12 && GE ? GE.decode(this.buf.subarray(e, n)) : function (i, a, c) {
                        let d = "", f = a;
                        for (; f < c;) {
                            const _ = i[f];
                            let x, w, E, I = null, C = _ > 239 ? 4 : _ > 223 ? 3 : _ > 191 ? 2 : 1;
                            if (f + C > c) break;
                            C === 1 ? _ < 128 && (I = _) : C === 2 ? (x = i[f + 1], (192 & x) == 128 && (I = (31 & _) << 6 | 63 & x, I <= 127 && (I = null))) : C === 3 ? (x = i[f + 1], w = i[f + 2], (192 & x) == 128 && (192 & w) == 128 && (I = (15 & _) << 12 | (63 & x) << 6 | 63 & w, (I <= 2047 || I >= 55296 && I <= 57343) && (I = null))) : C === 4 && (x = i[f + 1], w = i[f + 2], E = i[f + 3], (192 & x) == 128 && (192 & w) == 128 && (192 & E) == 128 && (I = (15 & _) << 18 | (63 & x) << 12 | (63 & w) << 6 | 63 & E, (I <= 65535 || I >= 1114112) && (I = null))), I === null ? (I = 65533, C = 1) : I > 65535 && (I -= 65536, d += String.fromCharCode(I >>> 10 & 1023 | 55296), I = 56320 | 1023 & I), d += String.fromCharCode(I), f += C
                        }
                        return d
                    }(this.buf, e, n)
                }

                readBytes() {
                    const n = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, n);
                    return this.pos = n, e
                }

                readPackedVarint(n = [], e) {
                    const i = this.readPackedEnd();
                    for (; this.pos < i;) n.push(this.readVarint(e));
                    return n
                }

                readPackedSVarint(n = []) {
                    const e = this.readPackedEnd();
                    for (; this.pos < e;) n.push(this.readSVarint());
                    return n
                }

                readPackedBoolean(n = []) {
                    const e = this.readPackedEnd();
                    for (; this.pos < e;) n.push(this.readBoolean());
                    return n
                }

                readPackedFloat(n = []) {
                    const e = this.readPackedEnd();
                    for (; this.pos < e;) n.push(this.readFloat());
                    return n
                }

                readPackedDouble(n = []) {
                    const e = this.readPackedEnd();
                    for (; this.pos < e;) n.push(this.readDouble());
                    return n
                }

                readPackedFixed32(n = []) {
                    const e = this.readPackedEnd();
                    for (; this.pos < e;) n.push(this.readFixed32());
                    return n
                }

                readPackedSFixed32(n = []) {
                    const e = this.readPackedEnd();
                    for (; this.pos < e;) n.push(this.readSFixed32());
                    return n
                }

                readPackedFixed64(n = []) {
                    const e = this.readPackedEnd();
                    for (; this.pos < e;) n.push(this.readFixed64());
                    return n
                }

                readPackedSFixed64(n = []) {
                    const e = this.readPackedEnd();
                    for (; this.pos < e;) n.push(this.readSFixed64());
                    return n
                }

                readPackedEnd() {
                    return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1
                }

                skip(n) {
                    const e = 7 & n;
                    if (e === 0) for (; this.buf[this.pos++] > 127;) ; else if (e === 2) this.pos = this.readVarint() + this.pos; else if (e === 5) this.pos += 4; else {
                        if (e !== 1) throw new Error(`Unimplemented type: ${e}`);
                        this.pos += 8
                    }
                }

                writeTag(n, e) {
                    this.writeVarint(n << 3 | e)
                }

                realloc(n) {
                    let e = this.length || 16;
                    for (; e < this.pos + n;) e *= 2;
                    if (e !== this.length) {
                        const i = new Uint8Array(e);
                        i.set(this.buf), this.buf = i, this.dataView = new DataView(i.buffer), this.length = e
                    }
                }

                finish() {
                    return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length)
                }

                writeFixed32(n) {
                    this.realloc(4), this.dataView.setInt32(this.pos, n, !0), this.pos += 4
                }

                writeSFixed32(n) {
                    this.realloc(4), this.dataView.setInt32(this.pos, n, !0), this.pos += 4
                }

                writeFixed64(n) {
                    this.realloc(8), this.dataView.setInt32(this.pos, -1 & n, !0), this.dataView.setInt32(this.pos + 4, Math.floor(n * UE), !0), this.pos += 8
                }

                writeSFixed64(n) {
                    this.realloc(8), this.dataView.setInt32(this.pos, -1 & n, !0), this.dataView.setInt32(this.pos + 4, Math.floor(n * UE), !0), this.pos += 8
                }

                writeVarint(n) {
                    (n = +n || 0) > 268435455 || n < 0 ? function (e, i) {
                        let a, c;
                        if (e >= 0 ? (a = e % 4294967296 | 0, c = e / 4294967296 | 0) : (a = ~(-e % 4294967296), c = ~(-e / 4294967296), 4294967295 ^ a ? a = a + 1 | 0 : (a = 0, c = c + 1 | 0)), e >= 18446744073709552e3 || e < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
                        i.realloc(10), function (d, f, _) {
                            _.buf[_.pos++] = 127 & d | 128, d >>>= 7, _.buf[_.pos++] = 127 & d | 128, d >>>= 7, _.buf[_.pos++] = 127 & d | 128, d >>>= 7, _.buf[_.pos++] = 127 & d | 128, _.buf[_.pos] = 127 & (d >>>= 7)
                        }(a, 0, i), function (d, f) {
                            const _ = (7 & d) << 4;
                            f.buf[f.pos++] |= _ | ((d >>>= 3) ? 128 : 0), d && (f.buf[f.pos++] = 127 & d | ((d >>>= 7) ? 128 : 0), d && (f.buf[f.pos++] = 127 & d | ((d >>>= 7) ? 128 : 0), d && (f.buf[f.pos++] = 127 & d | ((d >>>= 7) ? 128 : 0), d && (f.buf[f.pos++] = 127 & d | ((d >>>= 7) ? 128 : 0), d && (f.buf[f.pos++] = 127 & d)))))
                        }(c, i)
                    }(n, this) : (this.realloc(4), this.buf[this.pos++] = 127 & n | (n > 127 ? 128 : 0), n <= 127 || (this.buf[this.pos++] = 127 & (n >>>= 7) | (n > 127 ? 128 : 0), n <= 127 || (this.buf[this.pos++] = 127 & (n >>>= 7) | (n > 127 ? 128 : 0), n <= 127 || (this.buf[this.pos++] = n >>> 7 & 127))))
                }

                writeSVarint(n) {
                    this.writeVarint(n < 0 ? 2 * -n - 1 : 2 * n)
                }

                writeBoolean(n) {
                    this.writeVarint(+n)
                }

                writeString(n) {
                    n = String(n), this.realloc(4 * n.length), this.pos++;
                    const e = this.pos;
                    this.pos = function (a, c, d) {
                        for (let f, _, x = 0; x < c.length; x++) {
                            if (f = c.charCodeAt(x), f > 55295 && f < 57344) {
                                if (!_) {
                                    f > 56319 || x + 1 === c.length ? (a[d++] = 239, a[d++] = 191, a[d++] = 189) : _ = f;
                                    continue
                                }
                                if (f < 56320) {
                                    a[d++] = 239, a[d++] = 191, a[d++] = 189, _ = f;
                                    continue
                                }
                                f = _ - 55296 << 10 | f - 56320 | 65536, _ = null
                            } else _ && (a[d++] = 239, a[d++] = 191, a[d++] = 189, _ = null);
                            f < 128 ? a[d++] = f : (f < 2048 ? a[d++] = f >> 6 | 192 : (f < 65536 ? a[d++] = f >> 12 | 224 : (a[d++] = f >> 18 | 240, a[d++] = f >> 12 & 63 | 128), a[d++] = f >> 6 & 63 | 128), a[d++] = 63 & f | 128)
                        }
                        return d
                    }(this.buf, n, this.pos);
                    const i = this.pos - e;
                    i >= 128 && $E(e, i, this), this.pos = e - 1, this.writeVarint(i), this.pos += i
                }

                writeFloat(n) {
                    this.realloc(4), this.dataView.setFloat32(this.pos, n, !0), this.pos += 4
                }

                writeDouble(n) {
                    this.realloc(8), this.dataView.setFloat64(this.pos, n, !0), this.pos += 8
                }

                writeBytes(n) {
                    const e = n.length;
                    this.writeVarint(e), this.realloc(e);
                    for (let i = 0; i < e; i++) this.buf[this.pos++] = n[i]
                }

                writeRawMessage(n, e) {
                    this.pos++;
                    const i = this.pos;
                    n(e, this);
                    const a = this.pos - i;
                    a >= 128 && $E(i, a, this), this.pos = i - 1, this.writeVarint(a), this.pos += a
                }

                writeMessage(n, e, i) {
                    this.writeTag(n, 2), this.writeRawMessage(e, i)
                }

                writePackedVarint(n, e) {
                    e.length && this.writeMessage(n, o3, e)
                }

                writePackedSVarint(n, e) {
                    e.length && this.writeMessage(n, s3, e)
                }

                writePackedBoolean(n, e) {
                    e.length && this.writeMessage(n, c3, e)
                }

                writePackedFloat(n, e) {
                    e.length && this.writeMessage(n, a3, e)
                }

                writePackedDouble(n, e) {
                    e.length && this.writeMessage(n, l3, e)
                }

                writePackedFixed32(n, e) {
                    e.length && this.writeMessage(n, u3, e)
                }

                writePackedSFixed32(n, e) {
                    e.length && this.writeMessage(n, h3, e)
                }

                writePackedFixed64(n, e) {
                    e.length && this.writeMessage(n, d3, e)
                }

                writePackedSFixed64(n, e) {
                    e.length && this.writeMessage(n, f3, e)
                }

                writeBytesField(n, e) {
                    this.writeTag(n, 2), this.writeBytes(e)
                }

                writeFixed32Field(n, e) {
                    this.writeTag(n, 5), this.writeFixed32(e)
                }

                writeSFixed32Field(n, e) {
                    this.writeTag(n, 5), this.writeSFixed32(e)
                }

                writeFixed64Field(n, e) {
                    this.writeTag(n, 1), this.writeFixed64(e)
                }

                writeSFixed64Field(n, e) {
                    this.writeTag(n, 1), this.writeSFixed64(e)
                }

                writeVarintField(n, e) {
                    this.writeTag(n, 0), this.writeVarint(e)
                }

                writeSVarintField(n, e) {
                    this.writeTag(n, 0), this.writeSVarint(e)
                }

                writeStringField(n, e) {
                    this.writeTag(n, 2), this.writeString(e)
                }

                writeFloatField(n, e) {
                    this.writeTag(n, 5), this.writeFloat(e)
                }

                writeDoubleField(n, e) {
                    this.writeTag(n, 1), this.writeDouble(e)
                }

                writeBooleanField(n, e) {
                    this.writeVarintField(n, +e)
                }
            };

            function vf(n, e, i) {
                return i ? 4294967296 * e + (n >>> 0) : 4294967296 * (e >>> 0) + (n >>> 0)
            }

            function $E(n, e, i) {
                const a = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));
                i.realloc(a);
                for (let c = i.pos - 1; c >= n; c--) i.buf[c + a] = i.buf[c]
            }

            function o3(n, e) {
                for (let i = 0; i < n.length; i++) e.writeVarint(n[i])
            }

            function s3(n, e) {
                for (let i = 0; i < n.length; i++) e.writeSVarint(n[i])
            }

            function a3(n, e) {
                for (let i = 0; i < n.length; i++) e.writeFloat(n[i])
            }

            function l3(n, e) {
                for (let i = 0; i < n.length; i++) e.writeDouble(n[i])
            }

            function c3(n, e) {
                for (let i = 0; i < n.length; i++) e.writeBoolean(n[i])
            }

            function u3(n, e) {
                for (let i = 0; i < n.length; i++) e.writeFixed32(n[i])
            }

            function h3(n, e) {
                for (let i = 0; i < n.length; i++) e.writeSFixed32(n[i])
            }

            function d3(n, e) {
                for (let i = 0; i < n.length; i++) e.writeFixed64(n[i])
            }

            function f3(n, e) {
                for (let i = 0; i < n.length; i++) e.writeSFixed64(n[i])
            }

            const nw = 3;

            function p3(n, e, i) {
                e.glyphs = [], n === 1 && i.readMessage(m3, e)
            }

            function m3(n, e, i) {
                if (n === 3) {
                    const {id: a, bitmap: c, width: d, height: f, left: _, top: x, advance: w} = i.readMessage(g3, {});
                    e.glyphs.push({
                        id: a,
                        bitmap: new eu({width: d + 2 * nw, height: f + 2 * nw}, c),
                        metrics: {width: d, height: f, left: _, top: x, advance: w}
                    })
                } else n === 4 ? e.ascender = i.readSVarint() : n === 5 && (e.descender = i.readSVarint())
            }

            function g3(n, e, i) {
                n === 1 ? e.id = i.readVarint() : n === 2 ? e.bitmap = i.readBytes() : n === 3 ? e.width = i.readVarint() : n === 4 ? e.height = i.readVarint() : n === 5 ? e.left = i.readSVarint() : n === 6 ? e.top = i.readSVarint() : n === 7 && (e.advance = i.readVarint())
            }

            const HE = nw, ss = {horizontal: 1, vertical: 2, horizontalOnly: 3};

            class cg {
                constructor() {
                    this.scale = 1, this.fontStack = "", this.image = null
                }

                static forText(e, i) {
                    const a = new cg;
                    return a.scale = e || 1, a.fontStack = i, a
                }

                static forImage(e) {
                    const i = new cg;
                    return i.image = e, i
                }
            }

            class xf {
                constructor() {
                    this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null
                }

                static fromFeature(e, i, a) {
                    const c = new xf;
                    for (let d = 0; d < e.sections.length; d++) {
                        const f = e.sections[d];
                        f.image ? c.addImageSection(f, a) : c.addTextSection(f, i)
                    }
                    return c
                }

                length() {
                    return this.text.length
                }

                getSection(e) {
                    return this.sections[this.sectionIndex[e]]
                }

                getSections() {
                    return this.sections
                }

                getSectionIndex(e) {
                    return this.sectionIndex[e]
                }

                getCodePoint(e) {
                    return this.text.codePointAt(e)
                }

                verticalizePunctuation(e) {
                    this.text = function (i, a) {
                        let c = "";
                        for (let d = 0; d < i.length; d++) {
                            const f = i.charCodeAt(d + 1) || null, _ = i.charCodeAt(d - 1) || null;
                            c += !a && (f && Zd(f) && !lg[i[d + 1]] || _ && Zd(_) && !lg[i[d - 1]]) || !lg[i[d]] ? i[d] : lg[i[d]]
                        }
                        return c
                    }(this.text, e)
                }

                trim() {
                    let e = 0;
                    for (let a = 0; a < this.text.length && a0[this.text.charCodeAt(a)]; a++) e++;
                    let i = this.text.length;
                    for (let a = this.text.length - 1; a >= 0 && a >= e && a0[this.text.charCodeAt(a)]; a--) i--;
                    this.text = this.text.substring(e, i), this.sectionIndex = this.sectionIndex.slice(e, i)
                }

                substring(e, i) {
                    const a = new xf;
                    return a.text = this.text.substring(e, i), a.sectionIndex = this.sectionIndex.slice(e, i), a.sections = this.sections, a
                }

                toString() {
                    return this.text
                }

                getMaxScale() {
                    return this.sectionIndex.reduce((e, i) => Math.max(e, this.sections[i].scale), 0)
                }

                addTextSection(e, i) {
                    this.text += e.text, this.sections.push(cg.forText(e.scale, e.fontStack || i));
                    const a = this.sections.length - 1;
                    for (let c = 0; c < e.text.length; ++c) this.sectionIndex.push(a)
                }

                addImageSection(e, i) {
                    const a = e.image ? e.image.getPrimary() : null;
                    if (!a) return void Li("Can't add FormattedSection with an empty image.");
                    a.scaleSelf(i);
                    const c = this.getNextImageSectionCharCode();
                    c ? (this.text += String.fromCodePoint(c), this.sections.push(cg.forImage(a)), this.sectionIndex.push(this.sections.length - 1)) : Li("Reached maximum number of images 6401")
                }

                getNextImageSectionCharCode() {
                    return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID)
                }
            }

            function rw(n, e, i, a, c, d, f, _, x, w, E, I, C, z, L, F = 1) {
                const N = xf.fromFeature(n, c, F);
                I === ss.vertical && N.verticalizePunctuation(C);
                let H = [];
                const Y = function (ye, Ee, Ie, We, De, Ye) {
                    if (!ye) return [];
                    const ht = [], Qe = function (st, ke, qe, pt, at, Bt) {
                        let zt = 0;
                        for (let nt = 0; nt < st.length(); nt++) {
                            const lt = st.getSection(nt);
                            zt += qE(st.getCodePoint(nt), lt, pt, at, ke, Bt)
                        }
                        return zt / Math.max(1, Math.ceil(zt / qe))
                    }(ye, Ee, Ie, We, De, Ye), ot = ye.text.indexOf("​") >= 0;
                    let ct = 0;
                    for (let st = 0; st < ye.length(); st++) {
                        const ke = ye.getSection(st), qe = ye.getCodePoint(st);
                        if (a0[qe] || (ct += qE(qe, ke, We, De, Ee, Ye)), st < ye.length() - 1) {
                            const pt = !((He = qe) < 11904 || !(Qt["Bopomofo Extended"](He) || Qt.Bopomofo(He) || Qt["CJK Compatibility Forms"](He) || Qt["CJK Compatibility Ideographs"](He) || Qt["CJK Compatibility"](He) || Qt["CJK Radicals Supplement"](He) || Qt["CJK Strokes"](He) || Qt["CJK Symbols and Punctuation"](He) || Qt["CJK Unified Ideographs Extension A"](He) || Qt["CJK Unified Ideographs"](He) || Qt["Enclosed CJK Letters and Months"](He) || Qt["Halfwidth and Fullwidth Forms"](He) || Qt.Hiragana(He) || Qt["Ideographic Description Characters"](He) || Qt["Kangxi Radicals"](He) || Qt["Katakana Phonetic Extensions"](He) || Qt.Katakana(He) || Qt["Vertical Forms"](He) || Qt["Yi Radicals"](He) || Qt["Yi Syllables"](He)));
                            (_3[qe] || pt || ke.image) && ht.push(ZE(st + 1, ct, Qe, ht, y3(qe, ye.getCodePoint(st + 1), pt && ot), !1))
                        }
                    }
                    var He;
                    return XE(ZE(ye.length(), ct, Qe, ht, 0, !0))
                }(N, w, d, e, a, z), {processBidirectionalText: X, processStyledBidirectionalText: J} = Qs;
                if (X && N.sections.length === 1) {
                    const ye = X(N.toString(), Y);
                    for (const Ee of ye) {
                        const Ie = new xf;
                        Ie.text = Ee, Ie.sections = N.sections;
                        for (let We = 0; We < Ee.length; We++) Ie.sectionIndex.push(0);
                        H.push(Ie)
                    }
                } else if (J) {
                    const ye = J(N.text, N.sectionIndex, Y);
                    for (const Ee of ye) {
                        const Ie = new xf;
                        Ie.text = Ee[0], Ie.sectionIndex = Ee[1], Ie.sections = N.sections, H.push(Ie)
                    }
                } else H = function (ye, Ee) {
                    const Ie = [], We = ye.text;
                    let De = 0;
                    for (const Ye of Ee) Ie.push(ye.substring(De, Ye)), De = Ye;
                    return De < We.length && Ie.push(ye.substring(De, We.length)), Ie
                }(N, Y);
                const xe = [], ge = {
                    positionedLines: xe,
                    text: N.toString(),
                    top: E[1],
                    bottom: E[1],
                    left: E[0],
                    right: E[0],
                    writingMode: I,
                    iconsInText: !1,
                    verticalizable: !1,
                    hasBaseline: !1
                };
                if (function (ye, Ee, Ie, We, De, Ye, ht, Qe, ot, ct, He, st) {
                    let ke = 0, qe = 0, pt = 0;
                    const at = Qe === "right" ? 1 : Qe === "left" ? 0 : .5;
                    let Bt = !1;
                    for (const vt of De) {
                        const At = vt.getSections();
                        for (const Kt of At) {
                            if (Kt.image) continue;
                            const oi = Ee[Kt.fontStack];
                            if (oi && (Bt = oi.ascender !== void 0 && oi.descender !== void 0, !Bt)) break
                        }
                        if (!Bt) break
                    }
                    let zt = 0;
                    for (const vt of De) {
                        vt.trim();
                        const At = vt.getMaxScale(), Kt = (At - 1) * Dr, oi = {positionedGlyphs: [], lineOffset: 0};
                        ye.positionedLines[zt] = oi;
                        const pi = oi.positionedGlyphs;
                        let ui = 0;
                        if (!vt.length()) {
                            qe += Ye, ++zt;
                            continue
                        }
                        let ki = 0, bi = 0;
                        for (let ne = 0; ne < vt.length(); ne++) {
                            const re = vt.getSection(ne), Ge = vt.getSectionIndex(ne), mt = vt.getCodePoint(ne);
                            let bt = re.scale, wt = null, Lt = null, ti = null, Ci = Dr, Pi = 0, yi = ot;
                            yi === ss.vertical && ((nt = mt) === 12312 || nt === 12313 || nt === 12316 || nt === 12540 || nt === 12448) && (yi = ss.horizontal);
                            const an = !(yi === ss.horizontal || !He && !Wd(mt) || He && (a0[mt] || _y(mt)));
                            if (re.image) {
                                const Vn = We.get(re.image.toString());
                                if (!Vn) continue;
                                ti = re.image, ye.iconsInText = ye.iconsInText || !0, Lt = Vn.paddedRect;
                                const mi = Vn.displaySize;
                                bt = bt * Dr / st, wt = {
                                    width: mi[0],
                                    height: mi[1],
                                    left: 0,
                                    top: -HE,
                                    advance: an ? mi[1] : mi[0],
                                    localGlyph: !1
                                }, Pi = Bt ? -wt.height * bt : At * Dr - 17 - mi[1] * bt, Ci = wt.advance;
                                const Cn = (an ? mi[0] : mi[1]) * bt - Dr * At;
                                Cn > 0 && Cn > ui && (ui = Cn)
                            } else {
                                const Vn = Ie[re.fontStack];
                                if (!Vn) continue;
                                Vn[mt] && (Lt = Vn[mt]);
                                const mi = Ee[re.fontStack];
                                if (!mi) continue;
                                const Cn = mi.glyphs[mt];
                                if (!Cn) continue;
                                if (wt = Cn.metrics, Ci = mt !== 8203 ? Dr : 0, Bt) {
                                    const _n = mi.ascender !== void 0 ? Math.abs(mi.ascender) : 0,
                                        tn = mi.descender !== void 0 ? Math.abs(mi.descender) : 0, On = (_n + tn) * bt;
                                    ki < On && (ki = On, bi = (_n - tn) / 2 * bt), Pi = -_n * bt
                                } else Pi = (At - bt) * Dr - 17
                            }
                            an ? (ye.verticalizable = !0, pi.push({
                                glyph: mt,
                                image: ti,
                                x: ke,
                                y: qe + Pi,
                                vertical: an,
                                scale: bt,
                                localGlyph: wt.localGlyph,
                                fontStack: re.fontStack,
                                sectionIndex: Ge,
                                metrics: wt,
                                rect: Lt
                            }), ke += Ci * bt + ct) : (pi.push({
                                glyph: mt,
                                image: ti,
                                x: ke,
                                y: qe + Pi,
                                vertical: an,
                                scale: bt,
                                localGlyph: wt.localGlyph,
                                fontStack: re.fontStack,
                                sectionIndex: Ge,
                                metrics: wt,
                                rect: Lt
                            }), ke += wt.advance * bt + ct)
                        }
                        pi.length !== 0 && (pt = Math.max(ke - ct, pt), Bt ? YE(pi, at, ui, bi, Ye * At / 2) : YE(pi, at, ui, 0, Ye / 2)), ke = 0;
                        const Tn = Ye * At + ui;
                        oi.lineOffset = Math.max(ui, Kt), qe += Tn, ++zt
                    }
                    var nt;
                    const lt = qe, {horizontalAlign: kt, verticalAlign: Et} = ow(ht);
                    (function (vt, At, Kt, oi, pi, ui) {
                        const ki = (At - Kt) * pi, bi = -ui * oi;
                        for (const Tn of vt) for (const ne of Tn.positionedGlyphs) ne.x += ki, ne.y += bi
                    })(ye.positionedLines, at, kt, Et, pt, lt), ye.top += -Et * lt, ye.bottom = ye.top + lt, ye.left += -kt * pt, ye.right = ye.left + pt, ye.hasBaseline = Bt
                }(ge, e, i, a, H, f, _, x, I, w, C, L), !function (ye) {
                    for (const Ee of ye) if (Ee.positionedGlyphs.length !== 0) return !1;
                    return !0
                }(xe)) return ge
            }

            const a0 = {9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0}, _3 = {
                10: !0,
                32: !0,
                38: !0,
                40: !0,
                41: !0,
                43: !0,
                45: !0,
                47: !0,
                173: !0,
                183: !0,
                8203: !0,
                8208: !0,
                8211: !0,
                8231: !0
            };

            function qE(n, e, i, a, c, d) {
                if (e.image) {
                    const f = a.get(e.image.toString());
                    return f ? f.displaySize[0] * e.scale * Dr / d + c : 0
                }
                {
                    const f = i[e.fontStack], _ = f && f.glyphs[n];
                    return _ ? _.metrics.advance * e.scale + c : 0
                }
            }

            function WE(n, e, i, a) {
                const c = Math.pow(n - e, 2);
                return a ? n < e ? c / 2 : 2 * c : c + Math.abs(i) * i
            }

            function y3(n, e, i) {
                let a = 0;
                return n === 10 && (a -= 1e4), i && (a += 150), n !== 40 && n !== 65288 || (a += 50), e !== 41 && e !== 65289 || (a += 50), a
            }

            function ZE(n, e, i, a, c, d) {
                let f = null, _ = WE(e, i, c, d);
                for (const x of a) {
                    const w = WE(e - x.x, i, c, d) + x.badness;
                    w <= _ && (f = x, _ = w)
                }
                return {index: n, x: e, priorBreak: f, badness: _}
            }

            function XE(n) {
                return n ? XE(n.priorBreak).concat(n.index) : []
            }

            function ow(n) {
                let e = .5, i = .5;
                switch (n) {
                    case"right":
                    case"top-right":
                    case"bottom-right":
                        e = 1;
                        break;
                    case"left":
                    case"top-left":
                    case"bottom-left":
                        e = 0
                }
                switch (n) {
                    case"bottom":
                    case"bottom-right":
                    case"bottom-left":
                        i = 1;
                        break;
                    case"top":
                    case"top-right":
                    case"top-left":
                        i = 0
                }
                return {horizontalAlign: e, verticalAlign: i}
            }

            function YE(n, e, i, a, c) {
                if (!(e || i || a || c)) return;
                const d = n.length - 1, f = n[d], _ = (f.x + f.metrics.advance * f.scale) * e;
                for (let x = 0; x <= d; x++) n[x].x -= _, n[x].y += i + a + c
            }

            function KE(n) {
                return n.imagePrimary !== void 0 && n.top !== void 0 && n.bottom !== void 0 && n.left !== void 0 && n.right !== void 0
            }

            function v3(n, e, i, a) {
                const {horizontalAlign: c, verticalAlign: d} = ow(a), f = i[0] - n.displaySize[0] * c,
                    _ = i[1] - n.displaySize[1] * d;
                return {
                    imagePrimary: n,
                    imageSecondary: e,
                    top: _,
                    bottom: _ + n.displaySize[1],
                    left: f,
                    right: f + n.displaySize[0]
                }
            }

            function QE(n, e, i, a, c, d) {
                const f = n.imagePrimary;
                let _;
                if (f.content) {
                    const N = f.content, H = f.pixelRatio || 1;
                    _ = [N[0] / H, N[1] / H, f.displaySize[0] - N[2] / H, f.displaySize[1] - N[3] / H]
                }
                const x = e.left * d, w = e.right * d;
                let E, I, C, z;
                i === "width" || i === "both" ? (z = c[0] + x - a[3], I = c[0] + w + a[1]) : (z = c[0] + (x + w - f.displaySize[0]) / 2, I = z + f.displaySize[0]);
                const L = e.top * d, F = e.bottom * d;
                return i === "height" || i === "both" ? (E = c[1] + L - a[0], C = c[1] + F + a[2]) : (E = c[1] + (L + F - f.displaySize[1]) / 2, C = E + f.displaySize[1]), {
                    imagePrimary: f,
                    imageSecondary: void 0,
                    top: E,
                    right: I,
                    bottom: C,
                    left: z,
                    collisionPadding: _
                }
            }

            function JE(n) {
                return !n.imagePrimary.stretchX
            }

            function eA(n) {
                return !n.imagePrimary.stretchY
            }

            function tA(n) {
                return {width: n.right - n.left, height: n.bottom - n.top}
            }

            const ml = 128;

            function iA(n, e, i) {
                const {expression: a} = e;
                if (a.kind === "constant") return {
                    kind: "constant",
                    layoutSize: a.evaluate(new sn(n + 1, {worldview: i}))
                };
                if (a.kind === "source") return {kind: "source"};
                {
                    const {zoomStops: c, interpolationType: d} = a;
                    let f = 0;
                    for (; f < c.length && c[f] <= n;) f++;
                    f = Math.max(0, f - 1);
                    let _ = f;
                    for (; _ < c.length && c[_] < n + 1;) _++;
                    _ = Math.min(c.length - 1, _);
                    const x = c[f], w = c[_];
                    return a.kind === "composite" ? {
                        kind: "composite",
                        minZoom: x,
                        maxZoom: w,
                        interpolationType: d
                    } : {
                        kind: "camera",
                        minZoom: x,
                        maxZoom: w,
                        minSize: a.evaluate(new sn(x, {worldview: i})),
                        maxSize: a.evaluate(new sn(w, {worldview: i})),
                        interpolationType: d
                    }
                }
            }

            function sw(n, {uSize: e, uSizeT: i}, {lowerSize: a, upperSize: c}) {
                return n.kind === "source" ? a / ml : n.kind === "composite" ? qt(a / ml, c / ml, i) : e
            }

            function ug(n, e, i = 1) {
                let a = 0, c = 0;
                if (n.kind === "constant") c = n.layoutSize * i; else if (n.kind !== "source") {
                    const {interpolationType: d, minZoom: f, maxZoom: _} = n,
                        x = d ? se(Io.interpolationFactor(d, e, f, _), 0, 1) : 0;
                    n.kind === "camera" ? c = qt(n.minSize, n.maxSize, x) * i : a = x * i
                }
                return {uSizeT: a, uSize: c}
            }

            class Jl extends Ze {
                constructor(e, i, a, c, d) {
                    super(e, i), this.angle = c, this.z = a, d !== void 0 && (this.segment = d)
                }

                clone() {
                    return new Jl(this.x, this.y, this.z, this.angle, this.segment)
                }
            }

            function nA(n, e, i, a, c) {
                if (e.segment === void 0) return !0;
                let d = e, f = e.segment + 1, _ = 0;
                for (; _ > -i / 2;) {
                    if (f--, f < 0) return !1;
                    _ -= n[f].dist(d), d = n[f]
                }
                _ += n[f].dist(n[f + 1]), f++;
                const x = [];
                let w = 0;
                for (; _ < i / 2;) {
                    const E = n[f], I = n[f + 1];
                    if (!I) return !1;
                    let C = n[f - 1].angleTo(E) - E.angleTo(I);
                    for (C = Math.abs((C + 3 * Math.PI) % (2 * Math.PI) - Math.PI), x.push({
                        distance: _,
                        angleDelta: C
                    }), w += C; _ - x[0].distance > a;) w -= x.shift().angleDelta;
                    if (w > c) return !1;
                    f++, _ += E.dist(I)
                }
                return !0
            }

            function rA(n) {
                let e = 0;
                for (let i = 0; i < n.length - 1; i++) e += n[i].dist(n[i + 1]);
                return e
            }

            function oA(n, e, i) {
                return n ? .6 * e * i : 0
            }

            function sA(n, e) {
                return Math.max(n ? n.right - n.left : 0, e ? e.right - e.left : 0)
            }

            function x3(n, e, i, a, c, d) {
                const f = oA(i, c, d), _ = sA(i, a) * d;
                let x = 0;
                const w = rA(n) / 2;
                for (let E = 0; E < n.length - 1; E++) {
                    const I = n[E], C = n[E + 1], z = I.dist(C);
                    if (x + z > w) {
                        const L = (w - x) / z, F = qt(I.x, C.x, L), N = qt(I.y, C.y, L),
                            H = new Jl(F, N, 0, C.angleTo(I), E);
                        return !f || nA(n, H, _, f, e) ? H : void 0
                    }
                    x += z
                }
            }

            function w3(n, e, i, a, c, d, f, _, x) {
                const w = oA(a, d, f), E = sA(a, c), I = E * f,
                    C = n[0].x === 0 || n[0].x === x || n[0].y === 0 || n[0].y === x;
                return e - I < e / 4 && (e = I + e / 4), aA(n, C ? e / 2 * _ % e : (E / 2 + 2 * d) * f * _ % e, e, w, i, I, C, !1, x)
            }

            function aA(n, e, i, a, c, d, f, _, x) {
                const w = d / 2, E = rA(n);
                let I = 0, C = e - i, z = [];
                for (let L = 0; L < n.length - 1; L++) {
                    const F = n[L], N = n[L + 1], H = F.dist(N), Y = N.angleTo(F);
                    for (; C + i < I + H;) {
                        C += i;
                        const X = (C - I) / H, J = qt(F.x, N.x, X), xe = qt(F.y, N.y, X);
                        if (J >= 0 && J < x && xe >= 0 && xe < x && C - w >= 0 && C + w <= E) {
                            const ge = new Jl(J, xe, 0, Y, L);
                            a && !nA(n, ge, d, a, c) || z.push(ge)
                        }
                    }
                    I += H
                }
                return _ || z.length || f || (z = aA(n, I / 2, i, a, c, d, f, !0, x)), z
            }

            function lA(n) {
                let e = 0, i = 0;
                for (const f of n) e += f.w * f.h, i = Math.max(i, f.w);
                n.sort((f, _) => _.h - f.h);
                const a = [{x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / .95)), i), h: 1 / 0}];
                let c = 0, d = 0;
                for (const f of n) for (let _ = a.length - 1; _ >= 0; _--) {
                    const x = a[_];
                    if (!(f.w > x.w || f.h > x.h)) {
                        if (f.x = x.x, f.y = x.y, d = Math.max(d, f.y + f.h), c = Math.max(c, f.x + f.w), f.w === x.w && f.h === x.h) {
                            const w = a.pop();
                            w && _ < a.length && (a[_] = w)
                        } else f.h === x.h ? (x.x += f.w, x.w -= f.w) : f.w === x.w ? (x.y += f.h, x.h -= f.h) : (a.push({
                            x: x.x + f.w,
                            y: x.y,
                            w: x.w - f.w,
                            h: f.h
                        }), x.y += f.h, x.h -= f.h);
                        break
                    }
                }
                return {w: c, h: d, fill: e / (c * d) || 0}
            }

            Pt(Jl, "Anchor");
            const Bh = 1;

            class hg {
                static getImagePositionScale(e, i, a) {
                    if (i && e && e.options && e.options.transform) {
                        const c = e.options.transform;
                        return {x: c.a, y: c.d}
                    }
                    return {x: a, y: a}
                }

                constructor(e, i, a, c) {
                    this.paddedRect = e;
                    const {pixelRatio: d, version: f, stretchX: _, stretchY: x, content: w, sdf: E, usvg: I} = i;
                    this.pixelRatio = d, this.stretchX = _, this.stretchY = x, this.content = w, this.version = f, this.padding = a, this.sdf = E, this.usvg = I, this.scale = hg.getImagePositionScale(c, I, d)
                }

                get tl() {
                    return [this.paddedRect.x + this.padding, this.paddedRect.y + this.padding]
                }

                get br() {
                    return [this.paddedRect.x + this.paddedRect.w - this.padding, this.paddedRect.y + this.paddedRect.h - this.padding]
                }

                get displaySize() {
                    return [(this.paddedRect.w - 2 * this.padding) / this.scale.x, (this.paddedRect.h - 2 * this.padding) / this.scale.y]
                }
            }

            function aw(n, e, i) {
                const a = va.parse(n), c = function (d, f, _ = [1, 1]) {
                    return {
                        x: 0,
                        y: 0,
                        w: (d.data ? d.data.width : d.width * _[0]) + 2 * f,
                        h: (d.data ? d.data.height : d.height * _[1]) + 2 * f
                    }
                }(e, i, [a.options.transform.a, a.options.transform.d]);
                return {bin: c, imagePosition: new hg(c, e, i, a), imageVariant: a}
            }

            class cA {
                constructor(e, i, a) {
                    const c = new Map, d = new Map;
                    this.haveRenderCallbacks = [];
                    const f = [];
                    this.addImages(e, c, Bh, f), this.addImages(i, d, 2, f);
                    const {w: _, h: x} = lA(f), w = new $r({width: _ || 1, height: x || 1});
                    for (const [E, I] of e.entries()) {
                        const C = c.get(E).paddedRect;
                        $r.copy(I.data, w, {x: 0, y: 0}, {x: C.x + Bh, y: C.y + Bh}, I.data, a, I.sdf)
                    }
                    for (const [E, I] of i.entries()) {
                        const C = d.get(E), z = C.paddedRect;
                        let L = C.padding;
                        const F = z.x + L, N = z.y + L, H = I.data.width, Y = I.data.height;
                        L = L > 1 ? L - 1 : L, $r.copy(I.data, w, {x: 0, y: 0}, {
                            x: F,
                            y: N
                        }, I.data, a), $r.copy(I.data, w, {x: 0, y: Y - L}, {x: F, y: N - L}, {
                            width: H,
                            height: L
                        }, a), $r.copy(I.data, w, {x: 0, y: 0}, {x: F, y: N + Y}, {
                            width: H,
                            height: L
                        }, a), $r.copy(I.data, w, {x: H - L, y: 0}, {x: F - L, y: N}, {
                            width: L,
                            height: Y
                        }, a), $r.copy(I.data, w, {x: 0, y: 0}, {x: F + H, y: N}, {
                            width: L,
                            height: Y
                        }, a), $r.copy(I.data, w, {x: H - L, y: Y - L}, {x: F - L, y: N - L}, {
                            width: L,
                            height: L
                        }, a), $r.copy(I.data, w, {x: 0, y: Y - L}, {x: F + H, y: N - L}, {
                            width: L,
                            height: L
                        }, a), $r.copy(I.data, w, {x: 0, y: 0}, {x: F + H, y: N + Y}, {
                            width: L,
                            height: L
                        }, a), $r.copy(I.data, w, {x: H - L, y: 0}, {x: F - L, y: N + Y}, {width: L, height: L}, a)
                    }
                    this.lut = a, this.image = w, this.iconPositions = c, this.patternPositions = d
                }

                addImages(e, i, a, c) {
                    for (const [d, f] of e.entries()) {
                        const {bin: _, imagePosition: x, imageVariant: w} = aw(d, f, a);
                        i.set(d, x), c.push(_), f.hasRenderCallback && this.haveRenderCallbacks.push(w.id)
                    }
                }

                patchUpdatedImages(e, i, a) {
                    this.haveRenderCallbacks = this.haveRenderCallbacks.filter(c => e.hasImage(c, a)), e.dispatchRenderCallbacks(this.haveRenderCallbacks, a);
                    for (const c of e.getUpdatedImages(a)) {
                        for (const d of this.iconPositions.keys()) {
                            const f = va.parse(d);
                            if (Lo.isEqual(f.id, c)) {
                                const _ = e.getImage(c, a);
                                this.patchUpdatedImage(this.iconPositions.get(d), _, i)
                            }
                        }
                        for (const d of this.patternPositions.keys()) {
                            const f = va.parse(d);
                            if (Lo.isEqual(f.id, c)) {
                                const _ = e.getImage(c, a);
                                this.patchUpdatedImage(this.patternPositions.get(d), _, i)
                            }
                        }
                    }
                }

                patchUpdatedImage(e, i, a) {
                    if (!e || !i || e.version === i.version) return;
                    e.version = i.version;
                    const [c, d] = e.tl, f = e.sdf;
                    if (this.lut || f) {
                        const _ = {width: i.data.width, height: i.data.height}, x = new $r(_);
                        $r.copy(i.data, x, {x: 0, y: 0}, {x: 0, y: 0}, _, this.lut, f), a.update(x, {
                            position: {
                                x: c,
                                y: d
                            }
                        })
                    } else a.update(i.data, {position: {x: c, y: d}})
                }
            }

            Pt(hg, "ImagePosition"), Pt(cA, "ImageAtlas");
            const dg = 1e20;

            function uA(n, e, i, a, c, d, f, _, x) {
                for (let w = e; w < e + a; w++) hA(n, i * d + w, d, c, f, _, x);
                for (let w = i; w < i + c; w++) hA(n, w * d + e, 1, a, f, _, x)
            }

            function hA(n, e, i, a, c, d, f) {
                d[0] = 0, f[0] = -dg, f[1] = dg, c[0] = n[e];
                for (let _ = 1, x = 0, w = 0; _ < a; _++) {
                    c[_] = n[e + _ * i];
                    const E = _ * _;
                    do {
                        const I = d[x];
                        w = (c[_] - c[I] + E - I * I) / (_ - I) / 2
                    } while (w <= f[x] && --x > -1);
                    x++, d[x] = _, f[x] = w, f[x + 1] = dg
                }
                for (let _ = 0, x = 0; _ < a; _++) {
                    for (; f[x + 1] < _;) x++;
                    const w = d[x], E = _ - w;
                    n[e + _ * i] = c[w] + E * E
                }
            }

            const Ta = 2, lw = {none: 0, ideographs: 1, all: 2};

            class wf {
                constructor(e, i, a) {
                    this.requestManager = e, this.localGlyphMode = i, this.localFontFamily = a, this.url = "", this.entries = {}, this.localGlyphs = {
                        200: {},
                        400: {},
                        500: {},
                        900: {}
                    }
                }

                setURL(e) {
                    this.url = e
                }

                getGlyphs(e, i) {
                    const a = [], c = this.url || Br.GLYPHS_URL;
                    for (const d in e) for (const f of e[d]) a.push({stack: d, id: f});
                    Pe(a, ({stack: d, id: f}, _) => {
                        let x = this.entries[d];
                        x || (x = this.entries[d] = {
                            glyphs: {},
                            requests: {},
                            ranges: {},
                            ascender: void 0,
                            descender: void 0
                        });
                        let w = x.glyphs[f];
                        if (w !== void 0) return void _(null, {stack: d, id: f, glyph: w});
                        if (w = this._tinySDF(x, d, f), w) return x.glyphs[f] = w, void _(null, {
                            stack: d,
                            id: f,
                            glyph: w
                        });
                        const E = Math.floor(f / 256);
                        if (256 * E > 65535) return Li("glyphs > 65535 not supported"), void _(null, {
                            stack: d,
                            id: f,
                            glyph: w
                        });
                        if (x.ranges[E]) return void _(null, {stack: d, id: f, glyph: w});
                        let I = x.requests[E];
                        I || (I = x.requests[E] = [], wf.loadGlyphRange(d, E, c, this.requestManager, (C, z) => {
                            if (z) {
                                x.ascender = z.ascender, x.descender = z.descender;
                                for (const L in z.glyphs) this._doesCharSupportLocalGlyph(+L) || (x.glyphs[+L] = z.glyphs[+L]);
                                x.ranges[E] = !0
                            }
                            for (const L of I) L(C, z);
                            delete x.requests[E]
                        })), I.push((C, z) => {
                            C ? _(C) : z && _(null, {stack: d, id: f, glyph: z.glyphs[f] || null})
                        })
                    }, (d, f) => {
                        if (d) i(d); else if (f) {
                            const _ = {};
                            for (const {
                                stack: x,
                                id: w,
                                glyph: E
                            } of f) _[x] === void 0 && (_[x] = {}), _[x].glyphs === void 0 && (_[x].glyphs = {}), _[x].glyphs[w] = E && {
                                id: E.id,
                                bitmap: E.bitmap.clone(),
                                metrics: E.metrics
                            }, _[x].ascender = this.entries[x].ascender, _[x].descender = this.entries[x].descender;
                            i(null, _)
                        }
                    })
                }

                _doesCharSupportLocalGlyph(e) {
                    return this.localGlyphMode !== lw.none && (this.localGlyphMode === lw.all ? !!this.localFontFamily : !!this.localFontFamily && (Qt["CJK Unified Ideographs"](e) || Qt["Hangul Syllables"](e) || Qt.Hiragana(e) || Qt.Katakana(e) || Qt["CJK Symbols and Punctuation"](e) || Qt["CJK Unified Ideographs Extension A"](e) || Qt["CJK Unified Ideographs Extension B"](e) || Qt.Osage(e)))
                }

                _tinySDF(e, i, a) {
                    const c = this.localFontFamily;
                    if (!c || !this._doesCharSupportLocalGlyph(a)) return;
                    let d = e.tinySDF;
                    if (!d) {
                        let F = "400";
                        /bold/i.test(i) ? F = "900" : /medium/i.test(i) ? F = "500" : /light/i.test(i) && (F = "200"), d = e.tinySDF = new wf.TinySDF({
                            fontFamily: c,
                            fontWeight: F,
                            fontSize: 24 * Ta,
                            buffer: 3 * Ta,
                            radius: 8 * Ta
                        }), d.fontWeight = F
                    }
                    if (this.localGlyphs[d.fontWeight][a]) return this.localGlyphs[d.fontWeight][a];
                    const f = String.fromCodePoint(a), {
                        data: _,
                        width: x,
                        height: w,
                        glyphWidth: E,
                        glyphHeight: I,
                        glyphLeft: C,
                        glyphTop: z,
                        glyphAdvance: L
                    } = d.draw(f);
                    return this.localGlyphs[d.fontWeight][a] = {
                        id: a,
                        bitmap: new eu({width: x, height: w}, _),
                        metrics: {
                            width: E / Ta,
                            height: I / Ta,
                            left: C / Ta,
                            top: z / Ta - 27,
                            advance: L / Ta,
                            localGlyph: !0
                        }
                    }
                }
            }

            wf.loadGlyphRange = function (n, e, i, a, c) {
                const d = 256 * e, f = d + 255,
                    _ = a.transformRequest(a.normalizeGlyphsURL(i).replace("{fontstack}", n).replace("{range}", `${d}-${f}`), Yu.Glyphs);
                Ku(_, (x, w) => {
                    if (x) c(x); else if (w) {
                        const E = {}, I = function (C) {
                            return new s0(C).readFields(p3, {})
                        }(w);
                        for (const C of I.glyphs) E[C.id] = C;
                        c(null, {glyphs: E, ascender: I.ascender, descender: I.descender})
                    }
                })
            }, wf.TinySDF = class {
                constructor({
                                fontSize: n = 24,
                                buffer: e = 3,
                                radius: i = 8,
                                cutoff: a = .25,
                                fontFamily: c = "sans-serif",
                                fontWeight: d = "normal",
                                fontStyle: f = "normal"
                            } = {}) {
                    this.buffer = e, this.cutoff = a, this.radius = i;
                    const _ = this.size = n + 4 * e, x = this._createCanvas(_),
                        w = this.ctx = x.getContext("2d", {willReadFrequently: !0});
                    w.font = `${f} ${d} ${n}px ${c}`, w.textBaseline = "alphabetic", w.textAlign = "left", w.fillStyle = "black", this.gridOuter = new Float64Array(_ * _), this.gridInner = new Float64Array(_ * _), this.f = new Float64Array(_), this.z = new Float64Array(_ + 1), this.v = new Uint16Array(_)
                }

                _createCanvas(n) {
                    const e = document.createElement("canvas");
                    return e.width = e.height = n, e
                }

                draw(n) {
                    const {
                            width: e,
                            actualBoundingBoxAscent: i,
                            actualBoundingBoxDescent: a,
                            actualBoundingBoxLeft: c,
                            actualBoundingBoxRight: d
                        } = this.ctx.measureText(n), f = Math.ceil(i),
                        _ = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(d - c))),
                        x = Math.min(this.size - this.buffer, f + Math.ceil(a)), w = _ + 2 * this.buffer,
                        E = x + 2 * this.buffer, I = Math.max(w * E, 0), C = new Uint8ClampedArray(I), z = {
                            data: C,
                            width: w,
                            height: E,
                            glyphWidth: _,
                            glyphHeight: x,
                            glyphTop: f,
                            glyphLeft: 0,
                            glyphAdvance: e
                        };
                    if (_ === 0 || x === 0) return z;
                    const {ctx: L, buffer: F, gridInner: N, gridOuter: H} = this;
                    L.clearRect(F, F, _, x), L.fillText(n, F, F + f);
                    const Y = L.getImageData(F, F, _, x);
                    H.fill(dg, 0, I), N.fill(0, 0, I);
                    for (let X = 0; X < x; X++) for (let J = 0; J < _; J++) {
                        const xe = Y.data[4 * (X * _ + J) + 3] / 255;
                        if (xe === 0) continue;
                        const ge = (X + F) * w + J + F;
                        if (xe === 1) H[ge] = 0, N[ge] = dg; else {
                            const ye = .5 - xe;
                            H[ge] = ye > 0 ? ye * ye : 0, N[ge] = ye < 0 ? ye * ye : 0
                        }
                    }
                    uA(H, 0, 0, w, E, w, this.f, this.v, this.z), uA(N, F, F, _, x, w, this.f, this.v, this.z);
                    for (let X = 0; X < I; X++) {
                        const J = Math.sqrt(H[X]) - Math.sqrt(N[X]);
                        C[X] = Math.round(255 - 255 * (J / this.radius + this.cutoff))
                    }
                    return z
                }
            };
            const nu = Bh;

            function dA(n, e) {
                return n + e[1] - e[0]
            }

            function fA(n, e, i, a, c = 1) {
                const d = [], f = n.imagePrimary, _ = f.pixelRatio, x = f.paddedRect.w - 2 * nu,
                    w = f.paddedRect.h - 2 * nu, E = (n.right - n.left) * c, I = (n.bottom - n.top) * c,
                    C = f.stretchX || [[0, x]], z = f.stretchY || [[0, w]], L = C.reduce(dA, 0), F = z.reduce(dA, 0),
                    N = x - L, H = w - F;
                let Y = 0, X = L, J = 0, xe = F, ge = 0, ye = N, Ee = 0, Ie = H;
                if (f.content && a) {
                    const De = f.content;
                    Y = l0(C, 0, De[0]), J = l0(z, 0, De[1]), X = l0(C, De[0], De[2]), xe = l0(z, De[1], De[3]), ge = De[0] - Y, Ee = De[1] - J, ye = De[2] - De[0] - X, Ie = De[3] - De[1] - xe
                }
                const We = (De, Ye, ht, Qe) => {
                    const ot = c0(De.stretch - Y, X, E, n.left * c), ct = u0(De.fixed - ge, ye, De.stretch, L),
                        He = c0(Ye.stretch - J, xe, I, n.top * c), st = u0(Ye.fixed - Ee, Ie, Ye.stretch, F),
                        ke = c0(ht.stretch - Y, X, E, n.left * c), qe = u0(ht.fixed - ge, ye, ht.stretch, L),
                        pt = c0(Qe.stretch - J, xe, I, n.top * c), at = u0(Qe.fixed - Ee, Ie, Qe.stretch, F),
                        Bt = new Ze(ot, He), zt = new Ze(ke, He), nt = new Ze(ke, pt), lt = new Ze(ot, pt),
                        kt = new Ze(ct / _, st / _), Et = new Ze(qe / _, at / _), vt = e * Math.PI / 180;
                    if (vt) {
                        const ki = Math.sin(vt), bi = Math.cos(vt), Tn = [bi, -ki, ki, bi];
                        Bt._matMult(Tn), zt._matMult(Tn), lt._matMult(Tn), nt._matMult(Tn)
                    }
                    const At = De.stretch + De.fixed, Kt = ht.stretch + ht.fixed, oi = Ye.stretch + Ye.fixed,
                        pi = Qe.stretch + Qe.fixed, ui = n.imageSecondary;
                    return {
                        tl: Bt,
                        tr: zt,
                        bl: lt,
                        br: nt,
                        texPrimary: {x: f.paddedRect.x + nu + At, y: f.paddedRect.y + nu + oi, w: Kt - At, h: pi - oi},
                        texSecondary: ui ? {
                            x: ui.paddedRect.x + nu + At,
                            y: ui.paddedRect.y + nu + oi,
                            w: Kt - At,
                            h: pi - oi
                        } : void 0,
                        writingMode: void 0,
                        glyphOffset: [0, 0],
                        sectionIndex: 0,
                        pixelOffsetTL: kt,
                        pixelOffsetBR: Et,
                        minFontScaleX: ye / _ / E,
                        minFontScaleY: Ie / _ / I,
                        isSDF: i
                    }
                };
                if (a && (f.stretchX || f.stretchY)) {
                    const De = pA(C, N, L), Ye = pA(z, H, F);
                    for (let ht = 0; ht < De.length - 1; ht++) {
                        const Qe = De[ht], ot = De[ht + 1];
                        for (let ct = 0; ct < Ye.length - 1; ct++) d.push(We(Qe, Ye[ct], ot, Ye[ct + 1]))
                    }
                } else d.push(We({fixed: 0, stretch: -1}, {fixed: 0, stretch: -1}, {
                    fixed: 0,
                    stretch: x + 1
                }, {fixed: 0, stretch: w + 1}));
                return d
            }

            function l0(n, e, i) {
                let a = 0;
                for (const c of n) a += Math.max(e, Math.min(i, c[1])) - Math.max(e, Math.min(i, c[0]));
                return a
            }

            function pA(n, e, i) {
                const a = [{fixed: -nu, stretch: 0}];
                for (const [c, d] of n) {
                    const f = a[a.length - 1];
                    a.push({fixed: c - f.stretch, stretch: f.stretch}), a.push({
                        fixed: c - f.stretch,
                        stretch: f.stretch + (d - c)
                    })
                }
                return a.push({fixed: e + nu, stretch: i}), a
            }

            function c0(n, e, i, a) {
                return n / e * i + a
            }

            function u0(n, e, i, a) {
                return n - e * i / a
            }

            function b3(n, e, i, a) {
                const c = e + n.positionedLines[a].lineOffset;
                return a === 0 ? i + c / 2 : i + (c + (e + n.positionedLines[a - 1].lineOffset)) / 2
            }

            function T3(n, e = 1, i = !1) {
                let a = 1 / 0, c = 1 / 0, d = -1 / 0, f = -1 / 0;
                const _ = n[0];
                for (let z = 0; z < _.length; z++) {
                    const L = _[z];
                    (!z || L.x < a) && (a = L.x), (!z || L.y < c) && (c = L.y), (!z || L.x > d) && (d = L.x), (!z || L.y > f) && (f = L.y)
                }
                const x = Math.min(d - a, f - c);
                let w = x / 2;
                const E = new bd([], S3);
                if (x === 0) return new Ze(a, c);
                for (let z = a; z < d; z += x) for (let L = c; L < f; L += x) E.push(new bf(z + w, L + w, w, n));
                let I = function (z) {
                    let L = 0, F = 0, N = 0;
                    const H = z[0];
                    for (let Y = 0, X = H.length, J = X - 1; Y < X; J = Y++) {
                        const xe = H[Y], ge = H[J], ye = xe.x * ge.y - ge.x * xe.y;
                        F += (xe.x + ge.x) * ye, N += (xe.y + ge.y) * ye, L += 3 * ye
                    }
                    return new bf(F / L, N / L, 0, z)
                }(n), C = E.length;
                for (; E.length;) {
                    const z = E.pop();
                    (z.d > I.d || !I.d) && (I = z, i && console.log("found best %d after %d probes", Math.round(1e4 * z.d) / 1e4, C)), z.max - I.d <= e || (w = z.h / 2, E.push(new bf(z.p.x - w, z.p.y - w, w, n)), E.push(new bf(z.p.x + w, z.p.y - w, w, n)), E.push(new bf(z.p.x - w, z.p.y + w, w, n)), E.push(new bf(z.p.x + w, z.p.y + w, w, n)), C += 4)
                }
                return i && (console.log(`num probes: ${C}`), console.log(`best distance: ${I.d}`)), I.p
            }

            function S3(n, e) {
                return e.max - n.max
            }

            class bf {
                constructor(e, i, a, c) {
                    this.p = new Ze(e, i), this.h = a, this.d = function (d, f) {
                        let _ = !1, x = 1 / 0;
                        for (let w = 0; w < f.length; w++) {
                            const E = f[w];
                            for (let I = 0, C = E.length, z = C - 1; I < C; z = I++) {
                                const L = E[I], F = E[z];
                                L.y > d.y != F.y > d.y && d.x < (F.x - L.x) * (d.y - L.y) / (F.y - L.y) + L.x && (_ = !_), x = Math.min(x, ts(d, L, F))
                            }
                        }
                        return (_ ? 1 : -1) * Math.sqrt(x)
                    }(this.p, c), this.max = this.d + this.h * Math.SQRT2
                }
            }

            const E3 = Object.keys, cw = Number.POSITIVE_INFINITY, A3 = Math.sqrt(2);

            function mA(n, [e, i]) {
                let a = 0, c = 0;
                if (i === cw) {
                    e < 0 && (e = 0);
                    const d = e / A3;
                    switch (n) {
                        case"top-right":
                        case"top-left":
                            c = d - 7;
                            break;
                        case"bottom-right":
                        case"bottom-left":
                            c = 7 - d;
                            break;
                        case"bottom":
                            c = 7 - e;
                            break;
                        case"top":
                            c = e - 7
                    }
                    switch (n) {
                        case"top-right":
                        case"bottom-right":
                            a = -d;
                            break;
                        case"top-left":
                        case"bottom-left":
                            a = d;
                            break;
                        case"left":
                            a = e;
                            break;
                        case"right":
                            a = -e
                    }
                } else {
                    switch (e = Math.abs(e), i = Math.abs(i), n) {
                        case"top-right":
                        case"top-left":
                        case"top":
                            c = i - 7;
                            break;
                        case"bottom-right":
                        case"bottom-left":
                        case"bottom":
                            c = 7 - i
                    }
                    switch (n) {
                        case"top-right":
                        case"bottom-right":
                        case"right":
                            a = -e;
                            break;
                        case"top-left":
                        case"bottom-left":
                        case"left":
                            a = e
                    }
                }
                return [a, c]
            }

            function h0(n, e, i, a, c, d, f, _, x) {
                if (!e || !e.usvg) return;
                const w = tA(a), E = tA(c), I = d !== "both" && d !== "width" || !JE(a) ? 1 : E.width / w.width,
                    C = d !== "both" && d !== "height" || !eA(a) ? 1 : E.height / w.height;
                i.scaleSelf(I, C);
                const z = i.toString();
                f.set(z, i), _.set(z, e);
                const {imagePosition: L} = aw(z, e, Bh);
                x.set(z, L)
            }

            function gA(n, e, i, a, c, d, f, _, x) {
                if (!n) return;
                const w = function (E, I, C, z, L, F) {
                    if (E.kind === "camera") return E.maxSize;
                    if (E.kind === "composite") {
                        const N = I.possiblyEvaluate(new sn(E.maxZoom, {worldview: F}), C).evaluate(L, {}, C),
                            H = I.possiblyEvaluate(new sn(E.minZoom, {worldview: F}), C).evaluate(L, {}, C);
                        return Math.max(N, H)
                    }
                    return I.possiblyEvaluate(new sn(z, {worldview: F})).evaluate(L, {}, C)
                }(e, i, a, c, d, x);
                return n.scaleSelf(w * _ * f)
            }

            function _A(n, e, i, a, c, d, f, _, x) {
                return {
                    iconPrimary: gA(n.getPrimary(), e, i, a, c, d, f, _, x),
                    iconSecondary: gA(n.getSecondary(), e, i, a, c, d, f, _, x)
                }
            }

            function I3(n, e, i) {
                if (!e) return;
                const a = i.get(n.toString()), c = i.get(e.toString());
                c && (a.paddedRect.w === c.paddedRect.w && a.paddedRect.h === c.paddedRect.h || Li(`Mismatch in icon variant sizes: ${n.toString()} and ${e.toString()}`), a.usvg !== c.usvg && Li(`Mismatch in icon variant image types: ${n.id} and ${e.id}`))
            }

            function yA(n, e, i, a) {
                if (!n) return;
                const c = e.get(i.toString());
                if (n.imagePrimary = c, a) {
                    const d = e.get(a.toString());
                    n.imageSecondary = d
                }
            }

            function C3(n, e) {
                for (const i in n.horizontal) vA(n.horizontal[i], e);
                vA(n.vertical, e)
            }

            function vA(n, e) {
                if (n) {
                    for (const i of n.positionedLines) for (const a of i.positionedGlyphs) if (a.image !== null) {
                        const c = a.image.toString();
                        a.rect = e.get(c).paddedRect
                    }
                }
            }

            function uw(n) {
                switch (n) {
                    case"right":
                    case"top-right":
                    case"bottom-right":
                        return "right";
                    case"left":
                    case"top-left":
                    case"bottom-left":
                        return "left"
                }
                return "center"
            }

            function P3(n, e, i, a, c, d, f, _, x) {
                const w = hw(d.horizontal) || d.vertical, E = i.get("icon-text-fit-padding").evaluate(a, {}, c);
                let I, C = e;
                return e && x !== "none" && (n.allowVerticalPlacement && d.vertical && (I = QE(e, d.vertical, x, E, _, f)), w && (C = QE(e, w, x, E, _, f))), {
                    defaultShapedIcon: C,
                    verticallyShapedIcon: I
                }
            }

            function M3(n, e, i, a, c, d, f, _, x, w, E, I, C, z, L, F, N, H, Y, X) {
                let J = f.textMaxSize.evaluate(e, {}, C);
                J === void 0 ? J = _ * f.textScaleFactor : J *= f.textScaleFactor;
                const xe = n.layers[0].layout, ge = hw(i.horizontal) || i.vertical, ye = z.name === "globe", Ee = Dr,
                    Ie = n.tilePixelRatio * J / Ee,
                    We = (ct = n.overscaling, n.zoom > 18 && ct > 2 && (ct >>= 1), Math.max(yt / (512 * ct), 1) * xe.get("symbol-spacing")),
                    De = xe.get("text-padding") * n.tilePixelRatio, Ye = xe.get("icon-padding") * n.tilePixelRatio,
                    ht = Ai(xe.get("text-max-angle")),
                    Qe = xe.get("icon-rotation-alignment") === "map" && X !== "point", ot = We / 2;
                var ct;
                n.hasAnyIconTextFit === !1 && N !== "none" && (n.hasAnyIconTextFit = !0);
                const He = e.properties ? +e.properties[St] : null,
                    st = He && n.elevationFeatureIdToIndex ? n.elevationFeatureIdToIndex.get(He) : 65535,
                    ke = (qe, pt, at) => {
                        if (pt.x < 0 || pt.x >= yt || pt.y < 0 || pt.y >= yt) return;
                        let Bt = null;
                        if (ye) {
                            const {x: zt, y: nt, z: lt} = z.projectTilePoint(pt.x, pt.y, at);
                            Bt = {anchor: new Jl(zt, nt, lt, 0, void 0), up: z.upVector(at, pt.x, pt.y)}
                        }
                        (function (zt, nt, lt, kt, Et, vt, At, Kt, oi, pi, ui, ki, bi, Tn, ne, re, Ge, mt, bt, wt, Lt, ti, Ci, Pi, yi, an, Vn, mi, Cn) {
                            const _n = zt.addToLineVertexArray(nt, kt);
                            let tn, On, Sn, yn, wn, on, vi, ln = 0, Fn = 0, Jt = 0, Ni = 0, En = -1, Gn = -1;
                            const Pn = {};
                            let dr = xc("");
                            const dn = lt ? lt.anchor : nt, sr = mi !== "none";
                            let Bo = 0, Hr = 0;
                            if (oi._unevaluatedLayout.getValue("text-radial-offset") === void 0) {
                                const fr = oi.layout.get("text-offset").evaluate(Lt, {}, yi);
                                Bo = fr[0] * Dr, Hr = fr[1] * Dr
                            } else Bo = oi.layout.get("text-radial-offset").evaluate(Lt, {}, yi) * Dr, Hr = cw;
                            if (zt.allowVerticalPlacement && Et.vertical) {
                                const fr = Et.vertical;
                                if (ne) on = dw(fr), Kt && (vi = dw(Kt)); else {
                                    const xr = oi.layout.get("text-rotate").evaluate(Lt, {}, yi) + 90;
                                    Sn = d0(pi, dn, nt, ui, ki, bi, fr, Tn, xr, re), Kt && (yn = d0(pi, dn, nt, ui, ki, bi, Kt, mt, xr))
                                }
                            }
                            if (vt) {
                                const fr = zt.iconSizeData, xr = oi.layout.get("icon-rotate").evaluate(Lt, {}, yi),
                                    qr = fA(vt, xr, Ci, sr, ti.iconScaleFactor),
                                    yo = Kt ? fA(Kt, xr, Ci, sr, ti.iconScaleFactor) : void 0;
                                On = d0(pi, dn, nt, ui, ki, bi, vt, mt, xr, null), ln = 4 * qr.length;
                                let no = null;
                                fr.kind === "source" ? (no = [ml * oi.layout.get("icon-size").evaluate(Lt, {}, yi) * ti.iconScaleFactor], no[0] > ru && Li(`${zt.layerIds[0]}: Value for "icon-size" is >= ${fg}. Reduce your "icon-size".`)) : fr.kind === "composite" && (no = [ml * ti.compositeIconSizes[0].evaluate(Lt, {}, yi) * ti.iconScaleFactor, ml * ti.compositeIconSizes[1].evaluate(Lt, {}, yi) * ti.iconScaleFactor], (no[0] > ru || no[1] > ru) && Li(`${zt.layerIds[0]}: Value for "icon-size" is >= ${fg}. Reduce your "icon-size".`)), zt.addSymbols(zt.icon, qr, no, wt, bt, Lt, void 0, lt, nt, _n.lineStartIndex, _n.lineLength, -1, Pi, yi, an, Vn), En = zt.icon.placedSymbolArray.length - 1, yo && (Fn = 4 * yo.length, zt.addSymbols(zt.icon, yo, no, wt, bt, Lt, ss.vertical, lt, nt, _n.lineStartIndex, _n.lineLength, -1, Pi, yi, an, Vn), Gn = zt.icon.placedSymbolArray.length - 1)
                            }
                            for (const fr in Et.horizontal) {
                                const xr = fr, qr = Et.horizontal[xr];
                                tn || (dr = xc(qr.text), ne ? wn = dw(qr) : tn = d0(pi, dn, nt, ui, ki, bi, qr, Tn, oi.layout.get("text-rotate").evaluate(Lt, {}, yi), re));
                                const yo = qr.positionedLines.length === 1;
                                if (Jt += xA(zt, lt, nt, qr, At, oi, ne, Lt, re, _n, Et.vertical ? ss.horizontal : ss.horizontalOnly, yo ? E3(Et.horizontal) : [xr], Pn, En, ti, Pi, yi, an), yo) break
                            }
                            Et.vertical && (Ni += xA(zt, lt, nt, Et.vertical, At, oi, ne, Lt, re, _n, ss.vertical, ["vertical"], Pn, Gn, ti, Pi, yi, an));
                            let Nr = -1;
                            const No = (fr, xr) => fr ? Math.max(fr, xr) : xr;
                            Nr = No(wn, Nr), Nr = No(on, Nr), Nr = No(vi, Nr);
                            const gl = Nr > -1 ? 1 : 0;
                            zt.glyphOffsetArray.length >= 65535 && Li("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Lt.sortKey !== void 0 && zt.addToSortKeyRanges(zt.symbolInstances.length, Lt.sortKey), zt.symbolInstances.emplaceBack(nt.x, nt.y, dn.x, dn.y, dn.z, Pn.right >= 0 ? Pn.right : -1, Pn.center >= 0 ? Pn.center : -1, Pn.left >= 0 ? Pn.left : -1, Pn.vertical >= 0 ? Pn.vertical : -1, En, Gn, dr, tn !== void 0 ? tn : zt.collisionBoxArray.length, tn !== void 0 ? tn + 1 : zt.collisionBoxArray.length, Sn !== void 0 ? Sn : zt.collisionBoxArray.length, Sn !== void 0 ? Sn + 1 : zt.collisionBoxArray.length, On !== void 0 ? On : zt.collisionBoxArray.length, On !== void 0 ? On + 1 : zt.collisionBoxArray.length, yn || zt.collisionBoxArray.length, yn ? yn + 1 : zt.collisionBoxArray.length, ui, Jt, Ni, ln, Fn, gl, 0, Bo, Hr, Nr, 0, sr ? 1 : 0, Cn)
                        })(n, pt, Bt, qe, i, a, d, c, n.layers[0], n.collisionBoxArray, e.index, e.sourceLayerIndex, n.index, De, Y, w, 0, Ye, Qe, H, e, f, E, I, C, L, F, N, st)
                    };
                if (X === "line") for (const qe of Qy(e.geometry, 0, 0, yt, yt)) {
                    const pt = w3(qe, We, ht, i.vertical || ge, a, Ee, Ie, n.overscaling, yt);
                    for (const at of pt) ge && R3(n, ge.text, ot, at) || ke(qe, at, C)
                } else if (X === "line-center") {
                    for (const qe of e.geometry) if (qe.length > 1) {
                        const pt = x3(qe, ht, i.vertical || ge, a, Ee, Ie);
                        pt && ke(qe, pt, C)
                    }
                } else if (e.type === "Polygon") for (const qe of Xm(e.geometry, 0)) {
                    const pt = T3(qe, 16);
                    ke(qe[0], new Jl(pt.x, pt.y, 0, 0, void 0), C)
                } else if (e.type === "LineString") for (const qe of e.geometry) ke(qe, new Jl(qe[0].x, qe[0].y, 0, 0, void 0), C); else if (e.type === "Point") for (const qe of e.geometry) for (const pt of qe) ke([pt], new Jl(pt.x, pt.y, 0, 0, void 0), C)
            }

            const fg = 255, ru = fg * ml;

            function xA(n, e, i, a, c, d, f, _, x, w, E, I, C, z, L, F, N, H) {
                const Y = function (xe, ge, ye, Ee, Ie, We, De, Ye) {
                    const ht = [];
                    if (ge.positionedLines.length === 0) return ht;
                    const Qe = Ee.layout.get("text-rotate").evaluate(We, {}) * Math.PI / 180, ot = function (qe) {
                        const pt = qe[0], at = qe[1], Bt = pt * at;
                        return Bt > 0 ? [pt, -at] : Bt < 0 ? [-pt, at] : pt === 0 ? [at, pt] : [at, -pt]
                    }(ye);
                    let ct = Math.abs(ge.top - ge.bottom);
                    for (const qe of ge.positionedLines) ct -= qe.lineOffset;
                    const He = ge.positionedLines.length, st = ct / He;
                    let ke = ge.top - ye[1];
                    for (let qe = 0; qe < He; ++qe) {
                        const pt = ge.positionedLines[qe];
                        ke = b3(ge, st, ke, qe);
                        for (const at of pt.positionedGlyphs) {
                            if (!at.rect) continue;
                            const Bt = at.rect || {};
                            let zt = HE + 1, nt = !0, lt = 1, kt = 0;
                            if (at.image) {
                                const Lt = De.get(at.image.toString());
                                if (!Lt) continue;
                                if (Lt.sdf) {
                                    Li("SDF images are not supported in formatted text and will be ignored.");
                                    continue
                                }
                                nt = !1, lt = Lt.pixelRatio, zt = Bh / lt
                            }
                            const Et = (Ie || Ye) && at.vertical, vt = at.metrics.advance * at.scale / 2,
                                At = at.metrics, Kt = at.rect;
                            if (Kt === null) continue;
                            Ye && ge.verticalizable && (kt = at.image ? vt - at.metrics.width * at.scale / 2 : 0);
                            const oi = Ie ? [at.x + vt, at.y] : [0, 0];
                            let pi = [0, 0], ui = [0, 0], ki = !1;
                            Ie || (Et ? (ui = [at.x + vt + ot[0], at.y + ot[1] - kt], ki = !0) : pi = [at.x + vt + ye[0], at.y + ye[1] - kt]);
                            const bi = Kt.w * at.scale / (lt * (at.localGlyph ? Ta : 1)),
                                Tn = Kt.h * at.scale / (lt * (at.localGlyph ? Ta : 1));
                            let ne, re, Ge, mt;
                            if (Et) {
                                const Lt = at.y - ke, ti = new Ze(-vt, vt - Lt), Ci = -Math.PI / 2, Pi = new Ze(...ui);
                                ne = new Ze(-vt + pi[0], pi[1]), ne._rotateAround(Ci, ti)._add(Pi), ne.x += -Lt + vt, ne.y -= (At.left - zt) * at.scale;
                                const yi = at.image ? At.advance * at.scale : Dr * at.scale,
                                    an = String.fromCodePoint(at.glyph);
                                n3(an) ? ne.x += (1 - zt) * at.scale : r3(an) ? ne.x += yi - At.height * at.scale + (-zt - 1) * at.scale : ne.x += at.image || At.width + 2 * zt === Kt.w && At.height + 2 * zt === Kt.h ? (yi - Tn) / 2 : (yi - (At.height + 2 * zt) * at.scale) / 2, re = new Ze(ne.x, ne.y - bi), Ge = new Ze(ne.x + Tn, ne.y), mt = new Ze(ne.x + Tn, ne.y - bi)
                            } else {
                                const Lt = (At.left - zt) * at.scale - vt + pi[0],
                                    ti = (-At.top - zt) * at.scale + pi[1], Ci = Lt + bi, Pi = ti + Tn;
                                ne = new Ze(Lt, ti), re = new Ze(Ci, ti), Ge = new Ze(Lt, Pi), mt = new Ze(Ci, Pi)
                            }
                            if (Qe) {
                                let Lt;
                                Lt = Ie ? new Ze(0, 0) : ki ? new Ze(ot[0], ot[1]) : new Ze(ye[0], ye[1]), ne._rotateAround(Qe, Lt), re._rotateAround(Qe, Lt), Ge._rotateAround(Qe, Lt), mt._rotateAround(Qe, Lt)
                            }
                            const bt = new Ze(0, 0), wt = new Ze(0, 0);
                            ht.push({
                                tl: ne,
                                tr: re,
                                bl: Ge,
                                br: mt,
                                texPrimary: Bt,
                                texSecondary: void 0,
                                writingMode: ge.writingMode,
                                glyphOffset: oi,
                                sectionIndex: at.sectionIndex,
                                isSDF: nt,
                                pixelOffsetTL: bt,
                                pixelOffsetBR: wt,
                                minFontScaleX: 0,
                                minFontScaleY: 0
                            })
                        }
                    }
                    return ht
                }(0, a, x, d, f, _, c, n.allowVerticalPlacement), X = n.textSizeData;
                let J = null;
                X.kind === "source" ? (J = [ml * d.layout.get("text-size").evaluate(_, {}, N) * L.textScaleFactor], J[0] > ru && Li(`${n.layerIds[0]}: Value for "text-size" is >= ${fg}. Reduce your "text-size".`)) : X.kind === "composite" && (J = [ml * L.compositeTextSizes[0].evaluate(_, {}, N) * L.textScaleFactor, ml * L.compositeTextSizes[1].evaluate(_, {}, N) * L.textScaleFactor], (J[0] > ru || J[1] > ru) && Li(`${n.layerIds[0]}: Value for "text-size" is >= ${fg}. Reduce your "text-size".`)), n.addSymbols(n.text, Y, J, x, f, _, E, e, i, w.lineStartIndex, w.lineLength, z, F, N, H, !1);
                for (const xe of I) C[xe] = n.text.placedSymbolArray.length - 1;
                return 4 * Y.length
            }

            function hw(n) {
                for (const e in n) return n[e];
                return null
            }

            function d0(n, e, i, a, c, d, f, _, x, w) {
                let E = f.top, I = f.bottom, C = f.left, z = f.right;
                if (KE(f) && f.collisionPadding) {
                    const L = f.collisionPadding;
                    C -= L[0], E -= L[1], z += L[2], I += L[3]
                }
                if (x) {
                    const L = new Ze(C, E), F = new Ze(z, E), N = new Ze(C, I), H = new Ze(z, I), Y = Ai(x);
                    let X = new Ze(0, 0);
                    w && (X = new Ze(w[0], w[1])), L._rotateAround(Y, X), F._rotateAround(Y, X), N._rotateAround(Y, X), H._rotateAround(Y, X), C = Math.min(L.x, F.x, N.x, H.x), z = Math.max(L.x, F.x, N.x, H.x), E = Math.min(L.y, F.y, N.y, H.y), I = Math.max(L.y, F.y, N.y, H.y)
                }
                return n.emplaceBack(e.x, e.y, e.z, i.x, i.y, C, E, z, I, _, a, c, d), n.length - 1
            }

            function dw(n) {
                KE(n) && n.collisionPadding && (n.top -= n.collisionPadding[1], n.bottom += n.collisionPadding[3]);
                const e = n.bottom - n.top;
                return e > 0 ? Math.max(10, e) : null
            }

            function R3(n, e, i, a) {
                const c = n.compareText;
                if (e in c) {
                    const d = c[e];
                    for (let f = d.length - 1; f >= 0; f--) if (a.dist(d[f]) < i) return !0
                } else c[e] = [];
                return c[e].push(a), !1
            }

            function wA(n, e) {
                const i = n.fovAboveCenter, a = n.elevation ? n.elevation.getMinElevationBelowMSL() * e : 0,
                    c = (n._camera.position[2] * n.worldSize - a) / Math.cos(n._pitch),
                    d = Math.sin(i) * c / Math.sin(Math.max(Math.PI / 2 - n._pitch - i, .01));
                let f = Math.sin(n._pitch) * d + c;
                const _ = c * (1 / n._horizonShift);
                if (!n.elevation || n.elevation.exaggeration() === 0) {
                    let x = Math.max(n.zoom - 17, 0);
                    n.isOrthographic && (x /= 10), f *= 1 + x
                }
                return Math.min(1.01 * f, _)
            }

            function pg(n, e) {
                if (!e.isReprojectedInTileSpace) return {
                    scale: 1 << n.z,
                    x: n.x,
                    y: n.y,
                    x2: n.x + 1,
                    y2: n.y + 1,
                    projection: e
                };
                const i = Math.pow(2, -n.z), a = n.x * i, c = (n.x + 1) * i, d = n.y * i, f = (n.y + 1) * i, _ = Z(a),
                    x = Z(c), w = Q(d), E = Q(f), I = e.project(_, w), C = e.project(x, w), z = e.project(x, E),
                    L = e.project(_, E);
                let F = Math.min(I.x, C.x, z.x, L.x), N = Math.min(I.y, C.y, z.y, L.y),
                    H = Math.max(I.x, C.x, z.x, L.x), Y = Math.max(I.y, C.y, z.y, L.y);
                const X = i / 16;

                function J(ge, ye, Ee, Ie, We, De) {
                    const Ye = (Ee + We) / 2, ht = (Ie + De) / 2, Qe = e.project(Z(Ye), Q(ht)),
                        ot = Math.max(0, F - Qe.x, N - Qe.y, Qe.x - H, Qe.y - Y);
                    F = Math.min(F, Qe.x), H = Math.max(H, Qe.x), N = Math.min(N, Qe.y), Y = Math.max(Y, Qe.y), ot > X && (J(ge, Qe, Ee, Ie, Ye, ht), J(Qe, ye, Ye, ht, We, De))
                }

                J(I, C, a, d, c, d), J(C, z, c, d, c, f), J(z, L, c, f, a, f), J(L, I, a, f, a, d), F -= X, N -= X, H += X, Y += X;
                const xe = 1 / Math.max(H - F, Y - N);
                return {scale: xe, x: F * xe, y: N * xe, x2: H * xe, y2: Y * xe, projection: e}
            }

            function bA(n, {x: e, y: i}, a = 0) {
                return new Ze(((e - a) * n.scale - n.x) * yt, (i * n.scale - n.y) * yt)
            }

            const z3 = fe(new Float32Array(16));

            class ou {
                constructor(e) {
                    this.spec = e, this.name = e.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7]
                }

                project(e, i) {
                    return {x: 0, y: 0, z: 0}
                }

                unproject(e, i) {
                    return new M(0, 0)
                }

                projectTilePoint(e, i, a) {
                    return {x: e, y: i, z: 0}
                }

                locationPoint(e, i, a, c = !0) {
                    return e._coordinatePoint(e.locationCoordinate(i, a), c)
                }

                pixelsPerMeter(e, i) {
                    return U(1, e) * i
                }

                pixelSpaceConversion(e, i, a) {
                    return 1
                }

                farthestPixelDistance(e) {
                    return wA(e, e.pixelsPerMeter)
                }

                pointCoordinate(e, i, a, c) {
                    const d = e.horizonLineFromTop(!1), f = new Ze(i, Math.max(d, a));
                    return e.rayIntersectionCoordinate(e.pointRayIntersection(f, c))
                }

                pointCoordinate3D(e, i, a) {
                    const c = new Ze(i, a);
                    if (e.elevation) return e.elevation.pointCoordinate(c);
                    {
                        const d = this.pointCoordinate(e, c.x, c.y, 0);
                        return [d.x, d.y, d.z]
                    }
                }

                isPointAboveHorizon(e, i) {
                    if (e.elevation && e.elevation.visibleDemTiles.length) return !this.pointCoordinate3D(e, i.x, i.y);
                    const a = e.horizonLineFromTop();
                    return i.y < a
                }

                createInversionMatrix(e, i) {
                    return z3
                }

                createTileMatrix(e, i, a) {
                    let c, d, f;
                    const _ = a.canonical, x = fe(new Float64Array(16));
                    if (this.isReprojectedInTileSpace) {
                        const w = pg(_, this);
                        c = 1, d = w.x + a.wrap * w.scale, f = w.y, be(x, x, [c / w.scale, c / w.scale, e.pixelsPerMeter / i])
                    } else c = i / e.zoomScale(_.z), d = (_.x + Math.pow(2, _.z) * a.wrap) * c, f = _.y * c;
                    return le(x, x, [d, f, 0]), be(x, x, [c / yt, c / yt, 1]), x
                }

                upVector(e, i, a) {
                    return [0, 0, 1]
                }

                upVectorScale(e, i, a) {
                    return {metersToTile: 1}
                }
            }

            class D3 extends ou {
                constructor(e) {
                    super(e), this.range = [4, 7], this.center = e.center || [-96, 37.5];
                    const [i, a] = this.parallels = e.parallels || [29.5, 45.5], c = Math.sin(Ai(i));
                    this.n = (c + Math.sin(Ai(a))) / 2, this.c = 1 + c * (2 * this.n - c), this.r0 = Math.sqrt(this.c) / this.n
                }

                project(e, i) {
                    const {n: a, c, r0: d} = this, f = Ai(e - this.center[0]), _ = Ai(i),
                        x = Math.sqrt(c - 2 * a * Math.sin(_)) / a;
                    return {x: x * Math.sin(f * a), y: x * Math.cos(f * a) - d, z: 0}
                }

                unproject(e, i) {
                    const {n: a, c, r0: d} = this, f = d + i;
                    let _ = Math.atan2(e, Math.abs(f)) * Math.sign(f);
                    f * a < 0 && (_ -= Math.PI * Math.sign(e) * Math.sign(f));
                    const x = Ai(this.center[0]) * a;
                    _ = Ve(_, -Math.PI - x, Math.PI - x);
                    const w = se(Le(_ / a) + this.center[0], -180, 180),
                        E = Math.asin(se((c - (e * e + f * f) * a * a) / (2 * a), -1, 1)), I = se(Le(E), -ce, ce);
                    return new M(w, I)
                }
            }

            const mg = 1.340264, gg = -.081106, _g = 893e-6, yg = .003796, f0 = Math.sqrt(3) / 2;

            class L3 extends ou {
                project(e, i) {
                    i = i / 180 * Math.PI, e = e / 180 * Math.PI;
                    const a = Math.asin(f0 * Math.sin(i)), c = a * a, d = c * c * c;
                    return {
                        x: .5 * (e * Math.cos(a) / (f0 * (mg + 3 * gg * c + d * (7 * _g + 9 * yg * c))) / Math.PI + .5),
                        y: 1 - .5 * (a * (mg + gg * c + d * (_g + yg * c)) / Math.PI + 1),
                        z: 0
                    }
                }

                unproject(e, i) {
                    e = (2 * e - .5) * Math.PI;
                    let a = i = (2 * (1 - i) - 1) * Math.PI, c = a * a, d = c * c * c;
                    for (let E, I, C, z = 0; z < 12 && (I = a * (mg + gg * c + d * (_g + yg * c)) - i, C = mg + 3 * gg * c + d * (7 * _g + 9 * yg * c), E = I / C, a = se(a - E, -Math.PI / 3, Math.PI / 3), c = a * a, d = c * c * c, !(Math.abs(E) < 1e-12)); ++z) ;
                    const f = f0 * e * (mg + 3 * gg * c + d * (7 * _g + 9 * yg * c)) / Math.cos(a),
                        _ = Math.asin(Math.sin(a) / f0), x = se(180 * f / Math.PI, -180, 180),
                        w = se(180 * _ / Math.PI, -ce, ce);
                    return new M(x, w)
                }
            }

            class k3 extends ou {
                constructor(e) {
                    super(e), this.wrap = !0, this.supportsWorldCopies = !0
                }

                project(e, i) {
                    return {x: .5 + e / 360, y: .5 - i / 360, z: 0}
                }

                unproject(e, i) {
                    const a = 360 * (e - .5), c = se(360 * (.5 - i), -ce, ce);
                    return new M(a, c)
                }
            }

            const Tf = Math.PI / 2;

            function p0(n) {
                return Math.tan((Tf + n) / 2)
            }

            class O3 extends ou {
                constructor(e) {
                    super(e), this.center = e.center || [0, 30];
                    const [i, a] = this.parallels = e.parallels || [30, 30];
                    let c = Ai(i), d = Ai(a);
                    this.southernCenter = c + d < 0, this.southernCenter && (c = -c, d = -d);
                    const f = Math.cos(c), _ = p0(c);
                    this.n = c === d ? Math.sin(c) : Math.log(f / Math.cos(d)) / Math.log(p0(d) / _), this.f = f * Math.pow(p0(c), this.n) / this.n
                }

                project(e, i) {
                    i = Ai(i), this.southernCenter && (i = -i), e = Ai(e - this.center[0]);
                    const a = 1e-6, {n: c, f: d} = this;
                    d > 0 ? i < -Tf + a && (i = -Tf + a) : i > Tf - a && (i = Tf - a);
                    const f = d / Math.pow(p0(i), c);
                    let _ = f * Math.sin(c * e), x = d - f * Math.cos(c * e);
                    return _ = .5 * (_ / Math.PI + .5), x = .5 * (x / Math.PI + .5), {
                        x: _,
                        y: this.southernCenter ? x : 1 - x,
                        z: 0
                    }
                }

                unproject(e, i) {
                    e = (2 * e - .5) * Math.PI, this.southernCenter && (i = 1 - i), i = (2 * (1 - i) - .5) * Math.PI;
                    const {n: a, f: c} = this, d = c - i, f = Math.sign(d), _ = Math.sign(a) * Math.sqrt(e * e + d * d);
                    let x = Math.atan2(e, Math.abs(d)) * f;
                    d * a < 0 && (x -= Math.PI * Math.sign(e) * f);
                    const w = se(Le(x / a) + this.center[0], -180, 180),
                        E = se(Le(2 * Math.atan(Math.pow(c / _, 1 / a)) - Tf), -ce, ce);
                    return new M(w, this.southernCenter ? -E : E)
                }
            }

            class TA extends ou {
                constructor(e) {
                    super(e), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null
                }

                project(e, i) {
                    return {x: B(e), y: G(i), z: 0}
                }

                unproject(e, i) {
                    const a = Z(e), c = Q(i);
                    return new M(a, c)
                }
            }

            const SA = Ai(ce);

            class F3 extends ou {
                project(e, i) {
                    const a = (i = Ai(i)) * i, c = a * a;
                    return {
                        x: .5 * ((e = Ai(e)) * (.8707 - .131979 * a + c * (c * (.003971 * a - .001529 * c) - .013791)) / Math.PI + .5),
                        y: 1 - .5 * (i * (1.007226 + a * (.015085 + c * (.028874 * a - .044475 - .005916 * c))) / Math.PI + 1),
                        z: 0
                    }
                }

                unproject(e, i) {
                    e = (2 * e - .5) * Math.PI;
                    let a = i = (2 * (1 - i) - 1) * Math.PI, c = 25, d = 0, f = a * a;
                    do {
                        f = a * a;
                        const w = f * f;
                        d = (a * (1.007226 + f * (.015085 + w * (.028874 * f - .044475 - .005916 * w))) - i) / (1.007226 + f * (.045255 + w * (.259866 * f - .311325 - .005916 * 11 * w))), a = se(a - d, -SA, SA)
                    } while (Math.abs(d) > 1e-6 && --c > 0);
                    f = a * a;
                    const _ = se(Le(e / (.8707 + f * (f * (f * f * f * (.003971 - .001529 * f) - .013791) - .131979))), -180, 180),
                        x = Le(a);
                    return new M(_, x)
                }
            }

            const EA = Ai(ce);

            class B3 extends ou {
                project(e, i) {
                    i = Ai(i), e = Ai(e);
                    const a = Math.cos(i), c = 2 / Math.PI, d = Math.acos(a * Math.cos(e / 2)), f = Math.sin(d) / d,
                        _ = .5 * (e * c + 2 * a * Math.sin(e / 2) / f) || 0, x = .5 * (i + Math.sin(i) / f) || 0;
                    return {x: .5 * (_ / Math.PI + .5), y: 1 - .5 * (x / Math.PI + 1), z: 0}
                }

                unproject(e, i) {
                    let a = e = (2 * e - .5) * Math.PI, c = i = (2 * (1 - i) - 1) * Math.PI, d = 25;
                    const f = 1e-6;
                    let _ = 0, x = 0;
                    do {
                        const w = Math.cos(c), E = Math.sin(c), I = 2 * E * w, C = E * E, z = w * w,
                            L = Math.cos(a / 2), F = Math.sin(a / 2), N = 2 * L * F, H = F * F, Y = 1 - z * L * L,
                            X = Y ? 1 / Y : 0, J = Y ? Math.acos(w * L) * Math.sqrt(1 / Y) : 0,
                            xe = .5 * (2 * J * w * F + 2 * a / Math.PI) - e, ge = .5 * (J * E + c) - i,
                            ye = .5 * X * (z * H + J * w * L * C) + 1 / Math.PI, Ee = X * (N * I / 4 - J * E * F),
                            Ie = .125 * X * (I * F - J * E * z * N), We = .5 * X * (C * L + J * H * w) + .5,
                            De = Ee * Ie - We * ye;
                        _ = (ge * Ee - xe * We) / De, x = (xe * Ie - ge * ye) / De, a = se(a - _, -Math.PI, Math.PI), c = se(c - x, -EA, EA)
                    } while ((Math.abs(_) > f || Math.abs(x) > f) && --d > 0);
                    return new M(Le(a), Le(c))
                }
            }

            class AA extends ou {
                constructor(e) {
                    super(e), this.center = e.center || [0, 0], this.parallels = e.parallels || [0, 0], this.cosPhi = Math.max(.01, Math.cos(Ai(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0
                }

                project(e, i) {
                    const {scale: a, cosPhi: c} = this;
                    return {x: Ai(e) * c * a + .5, y: -Math.sin(Ai(i)) / c * a + .5, z: 0}
                }

                unproject(e, i) {
                    const {scale: a, cosPhi: c} = this, d = -(i - .5) / a, f = se(Le((e - .5) / a) / c, -180, 180),
                        _ = Math.asin(se(d * c, -1, 1)), x = se(Le(_), -ce, ce);
                    return new M(f, x)
                }
            }

            class N3 extends TA {
                constructor(e) {
                    super(e), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5]
                }

                projectTilePoint(e, i, a) {
                    const c = Gm(e, i, a);
                    return An(c, c, Gy(fl(a))), {x: c[0], y: c[1], z: c[2]}
                }

                locationPoint(e, i, a) {
                    const c = b(i.lat, i.lng), d = Bi([], c),
                        f = a ? e._centerAltitude + a : e.elevation ? e.elevation.getAtPointOrZero(e.locationCoordinate(i), e._centerAltitude) : e._centerAltitude;
                    fi(c, c, d, U(1, 0) * yt * f);
                    const _ = fe(new Float64Array(16));
                    return pe(_, e.pixelMatrix, e.globeMatrix), An(c, c, _), new Ze(c[0], c[1])
                }

                pixelsPerMeter(e, i) {
                    return U(1, 0) * i
                }

                pixelSpaceConversion(e, i, a) {
                    const c = U(1, e) * i, d = qt(U(1, 45) * i, c, a);
                    return this.pixelsPerMeter(e, i) / d
                }

                createTileMatrix(e, i, a) {
                    const c = w1(fl(a.canonical));
                    return pe(new Float64Array(16), e.globeMatrix, c)
                }

                createInversionMatrix(e, i) {
                    const {center: a} = e, c = Gy(fl(i));
                    return et(c, c, Ai(a.lng)), Ue(c, c, Ai(a.lat)), be(c, c, [e._pixelsPerMercatorPixel, e._pixelsPerMercatorPixel, 1]), Float32Array.from(c)
                }

                pointCoordinate(e, i, a, c) {
                    return K2(e, i, a, !0) || new me(0, 0)
                }

                pointCoordinate3D(e, i, a) {
                    const c = this.pointCoordinate(e, i, a, 0);
                    return [c.x, c.y, c.z]
                }

                isPointAboveHorizon(e, i) {
                    return !K2(e, i.x, i.y, !1)
                }

                farthestPixelDistance(e) {
                    const i = function (c, d) {
                        const f = c.cameraToCenterDistance, _ = c._centerAltitude * d, x = c._camera,
                            w = c._camera.forward(), E = si([], ai([], w, -f), [0, 0, _]),
                            I = c.worldSize / (2 * Math.PI), C = [0, 0, -I], z = c.width / c.height,
                            L = Math.tan(c.fovAboveCenter), F = ai([], x.up(), L), N = ai([], x.right(), L * z),
                            H = Bi([], si([], si([], w, F), N)), Y = [];
                        let X;
                        if (new Gi(E, H).closestPointOnSphere(C, I, Y)) {
                            const J = si([], Y, C), xe = Nn([], J, E);
                            X = Math.cos(c.fovAboveCenter) * Mi(xe)
                        } else {
                            const J = Nn([], E, C), xe = Nn([], C, E);
                            Bi(xe, xe);
                            const ge = Mi(J) - I;
                            X = Math.sqrt(ge * (ge + 2 * I));
                            const ye = Math.acos(X / (I + ge)) - Math.acos(Ii(w, xe));
                            X *= Math.cos(ye)
                        }
                        return 1.01 * X
                    }(e, this.pixelsPerMeter(e.center.lat, e.worldSize)), a = Jc(e.zoom);
                    if (a > 0) {
                        const c = wA(e, U(1, e.center.lat) * e.worldSize), d = e.worldSize / (2 * Math.PI),
                            f = Math.max(e.width, e.height) / e.worldSize * Math.PI;
                        return qt(i, c + d * (1 - Math.cos(f)), Math.pow(a, 10))
                    }
                    return i
                }

                upVector(e, i, a) {
                    return Gm(i, a, e, 1)
                }

                upVectorScale(e) {
                    return {metersToTile: jy(Uy(fl(e)))}
                }
            }

            function IA(n) {
                const e = n.parallels, i = !!e && Math.abs(e[0] + e[1]) < .01;
                switch (n.name) {
                    case"mercator":
                        return new TA(n);
                    case"equirectangular":
                        return new k3(n);
                    case"naturalEarth":
                        return new F3(n);
                    case"equalEarth":
                        return new L3(n);
                    case"winkelTripel":
                        return new B3(n);
                    case"albers":
                        return i ? new AA(n) : new D3(n);
                    case"lambertConformalConic":
                        return i ? new AA(n) : new O3(n);
                    case"globe":
                        return new N3(n)
                }
                throw new Error(`Invalid projection name: ${n.name}`)
            }

            const j3 = Be.types, V3 = [{name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0}];

            function m0(n, e, i, a, c, d, f, _, x, w, E, I, C) {
                const z = _ ? Math.min(ru, Math.round(_[0])) : 0, L = _ ? Math.min(ru, Math.round(_[1])) : 0;
                n.emplaceBack(e, i, Math.round(32 * a), Math.round(32 * c), d, f, (z << 1) + (x ? 1 : 0), L, 16 * w, 16 * E, 256 * I, 256 * C)
            }

            function g0(n, e, i) {
                n.emplaceBack(e, i)
            }

            function _0(n, e, i, a, c, d, f) {
                n.emplaceBack(e, i, a, c, d, f)
            }

            const y0 = (n, e, i, a) => {
                for (let c = 0; c < e; c++) n.emplaceBack(i[0], i[1], i[2], a[0], a[1], a[2])
            };

            function v0(n, e, i, a, c) {
                n.emplaceBack(e, i, a, c), n.emplaceBack(e, i, a, c), n.emplaceBack(e, i, a, c), n.emplaceBack(e, i, a, c)
            }

            function U3(n) {
                for (const e of n.sections) if (s1(e.text)) return !0;
                return !1
            }

            class fw {
                constructor(e) {
                    this.layoutVertexArray = new rf, this.indexArray = new Mn, this.programConfigurations = e, this.segments = new Ln, this.dynamicLayoutVertexArray = new ul, this.opacityVertexArray = new Am, this.placedSymbolArray = new Ah, this.iconTransitioningVertexArray = new ea, this.globeExtVertexArray = new $c, this.zOffsetVertexArray = new Zl, this.orientationVertexArray = new Pm
                }

                isEmpty() {
                    return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0 && this.iconTransitioningVertexArray.length === 0
                }

                upload(e, i, a, c, d) {
                    this.isEmpty() || (a && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Wk.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, i), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, Xk.members, !0), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, V3, !0), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = e.createVertexBuffer(this.iconTransitioningVertexArray, Qk.members, !0)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = e.createVertexBuffer(this.globeExtVertexArray, Zk.members, !0)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || d) && (this.zOffsetVertexBuffer = e.createVertexBuffer(this.zOffsetVertexArray, Yk.members, !0)), !this.orientationVertexBuffer && this.orientationVertexArray && this.orientationVertexArray.length > 0 && (this.orientationVertexBuffer = e.createVertexBuffer(this.orientationVertexArray, Kk.members, !0)), this.opacityVertexBuffer.itemSize = 1), (a || c) && this.programConfigurations.upload(e))
                }

                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.orientationVertexBuffer && this.orientationVertexBuffer.destroy())
                }
            }

            Pt(fw, "SymbolBuffers");

            class pw {
                constructor(e, i, a) {
                    this.layoutVertexArray = new e, this.layoutAttributes = i, this.indexArray = new a, this.segments = new Ln, this.collisionVertexArray = new qc, this.collisionVertexArrayExt = new ul
                }

                upload(e) {
                    this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, Jk.members, !0), this.collisionVertexBufferExt = e.createVertexBuffer(this.collisionVertexArrayExt, e3.members, !0)
                }

                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy())
                }
            }

            Pt(pw, "CollisionBuffers");

            class x0 {
                constructor(e) {
                    this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.lut = e.lut, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(f => f.fqid), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.hasAnyIconTextFit = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = fe([]), this.placementViewportMatrix = fe([]);
                    const i = this.layers[0]._unevaluatedLayout._values;
                    this.worldview = e.worldview, this.textSizeData = iA(this.zoom, i["text-size"], this.worldview), this.iconSizeData = iA(this.zoom, i["icon-size"], this.worldview);
                    const a = this.layers[0].layout, c = a.get("symbol-sort-key"), d = a.get("symbol-z-order");
                    this.canOverlap = a.get("text-allow-overlap") || a.get("icon-allow-overlap") || a.get("text-ignore-placement") || a.get("icon-ignore-placement"), this.sortFeaturesByKey = d !== "viewport-y" && c.constantOr(1) !== void 0, this.sortFeaturesByY = (d === "viewport-y" || d === "auto" && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = a.get("text-writing-mode").map(f => ss[f]), this.stateDependentLayerIds = this.layers.filter(f => f.isStateDependent()).map(f => f.id), this.sourceID = e.sourceID, this.projection = e.projection, this.hasAnyZOffset = !1, this.zOffsetSortDirty = !1, this.zOffsetBuffersNeedUpload = !1, this.elevationType = "none", this.elevationStateComplete = !1, this.activeReplacements = [], this.replacementUpdateTime = 0, this.hasAnySecondaryIcon = !1
                }

                createArrays() {
                    this.text = new fw(new es(this.layers, {
                        zoom: this.zoom,
                        lut: this.lut
                    }, e => e.startsWith("text") || e.startsWith("symbol"))), this.icon = new fw(new es(this.layers, {
                        zoom: this.zoom,
                        lut: this.lut
                    }, e => e.startsWith("icon") || e.startsWith("symbol"))), this.glyphOffsetArray = new Fm, this.lineVertexArray = new Cy, this.symbolInstances = new Iy
                }

                calculateGlyphDependencies(e, i, a, c, d) {
                    for (const f of e) {
                        const _ = f.codePointAt(0);
                        if (_ === void 0) break;
                        if (i[_] = !0, c && d && _ <= 65535) {
                            const x = lg[f];
                            x && (i[x.charCodeAt(0)] = !0)
                        }
                    }
                }

                updateFootprints(e, i) {
                }

                updateReplacement(e, i) {
                    if (i.updateTime === this.replacementUpdateTime) return !1;
                    this.replacementUpdateTime = i.updateTime;
                    const a = i.getReplacementRegionsForTile(e.toUnwrapped(), !0);
                    return !Xy(this.activeReplacements, a) && (this.activeReplacements = a, !0)
                }

                populate(e, i, a, c) {
                    const d = this.layers[0], f = d.layout, _ = this.projection.name === "globe",
                        x = f.get("text-font"), w = f.get("text-field"),
                        E = f.get("icon-image"), [I, C] = f.get("icon-size-scale-range"),
                        z = se(i.scaleFactor || 1, I, C),
                        L = (w.value.kind !== "constant" || w.value.value instanceof fo && !w.value.value.isEmpty() || w.value.value.toString().length > 0) && (x.value.kind !== "constant" || x.value.value.length > 0),
                        F = E.value.kind !== "constant" || !!E.value.value || Object.keys(E.parameters).length > 0,
                        N = f.get("symbol-sort-key");
                    if (this.features = [], !L && !F) return;
                    const H = i.iconDependencies, Y = i.glyphDependencies, X = i.availableImages,
                        J = new sn(this.zoom, {worldview: this.worldview});
                    for (const {feature: xe, id: ge, index: ye, sourceLayerIndex: Ee} of e) {
                        const Ie = d._featureFilter.needGeometry, We = $e(xe, Ie);
                        if (!d._featureFilter.filter(J, We, a)) continue;
                        if (Ie || (We.geometry = Te(xe, a, c)), _ && xe.type !== 1 && a.z <= 5) {
                            const ot = We.geometry, ct = .98078528056,
                                He = (st, ke) => Ii(Gm(st.x, st.y, a, 1), Gm(ke.x, ke.y, a, 1)) < ct;
                            for (let st = 0; st < ot.length; st++) ot[st] = je(ot[st], He)
                        }
                        let De, Ye;
                        if (L) {
                            const ot = d.getValueAndResolveTokens("text-field", We, a, X), ct = fo.factory(ot);
                            U3(ct) && (this.hasRTLText = !0), (!this.hasRTLText || vm() === "unavailable" || this.hasRTLText && Qs.isParsed()) && (De = i3(ct, d, We))
                        }
                        if (F) {
                            const ot = d.getValueAndResolveTokens("icon-image", We, a, X);
                            Ye = typeof ot == "string" ? Ao.build(ot) : ot
                        }
                        if (!De && !Ye) continue;
                        const ht = this.sortFeaturesByKey ? N.evaluate(We, {}, a) : void 0, Qe = {
                            id: ge,
                            text: De,
                            icon: Ye,
                            index: ye,
                            sourceLayerIndex: Ee,
                            geometry: We.geometry,
                            properties: xe.properties,
                            type: j3[xe.type],
                            sortKey: ht
                        };
                        if (this.features.push(Qe), Ye) {
                            const ot = this.layers[0]._unevaluatedLayout._values, {
                                    iconPrimary: ct,
                                    iconSecondary: He
                                } = _A(Ye, this.iconSizeData, ot["icon-size"], a, this.zoom, Qe, this.pixelRatio, z, this.worldview),
                                st = ct.id.toString();
                            if (H.has(st) ? H.get(st).push(ct) : H.set(st, [ct]), He) {
                                this.hasAnySecondaryIcon = !0;
                                const ke = He.id.toString();
                                H.has(ke) ? H.get(ke).push(He) : H.set(ke, [He])
                            }
                        }
                        if (De) {
                            const ot = x.evaluate(We, {}, a).join(","),
                                ct = f.get("text-rotation-alignment") === "map" && f.get("symbol-placement") !== "point";
                            this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(ss.vertical) >= 0;
                            for (const He of De.sections) if (He.image) {
                                const st = He.image.getPrimary().scaleSelf(this.pixelRatio), ke = st.id.toString(),
                                    qe = H.get(ke) || [];
                                qe.push(st), H.set(ke, qe)
                            } else {
                                const st = mm(De.toString()), ke = He.fontStack || ot, qe = Y[ke] = Y[ke] || {};
                                this.calculateGlyphDependencies(He.text, qe, ct, this.allowVerticalPlacement, st)
                            }
                        }
                    }
                    if (f.get("symbol-placement") === "line" && (this.features = function (xe) {
                        const ge = {}, ye = {}, Ee = [];
                        let Ie = 0;

                        function We(Qe) {
                            Ee.push(xe[Qe]), Ie++
                        }

                        function De(Qe, ot, ct) {
                            const He = ye[Qe];
                            return delete ye[Qe], ye[ot] = He, Ee[He].geometry[0].pop(), Ee[He].geometry[0] = Ee[He].geometry[0].concat(ct[0]), He
                        }

                        function Ye(Qe, ot, ct) {
                            const He = ge[ot];
                            return delete ge[ot], ge[Qe] = He, Ee[He].geometry[0].shift(), Ee[He].geometry[0] = ct[0].concat(Ee[He].geometry[0]), He
                        }

                        function ht(Qe, ot, ct) {
                            const He = ct ? ot[0][ot[0].length - 1] : ot[0][0];
                            return `${Qe}:${He.x}:${He.y}`
                        }

                        for (let Qe = 0; Qe < xe.length; Qe++) {
                            const ot = xe[Qe], ct = ot.geometry, He = ot.text ? ot.text.toString() : null;
                            if (!He) {
                                We(Qe);
                                continue
                            }
                            const st = ht(He, ct), ke = ht(He, ct, !0);
                            if (st in ye && ke in ge && ye[st] !== ge[ke]) {
                                const qe = Ye(st, ke, ct), pt = De(st, ke, Ee[qe].geometry);
                                delete ge[st], delete ye[ke], ye[ht(He, Ee[pt].geometry, !0)] = pt, Ee[qe].geometry = null
                            } else st in ye ? De(st, ke, ct) : ke in ge ? Ye(st, ke, ct) : (We(Qe), ge[st] = Ie - 1, ye[ke] = Ie - 1)
                        }
                        return Ee.filter(Qe => Qe.geometry)
                    }(this.features)), f.get("symbol-elevation-reference") === "hd-road-markup") {
                        if (this.elevationType = "road", i.elevationFeatures) {
                            !this.elevationFeatures && i.elevationFeatures.length > 0 && (this.elevationFeatures = [], this.elevationFeatureIdToIndex = new Map);
                            for (const xe of i.elevationFeatures) this.elevationFeatureIdToIndex.set(xe.id, this.elevationFeatures.length), this.elevationFeatures.push(xe)
                        }
                    } else f.get("symbol-z-elevate") && (this.elevationType = "offset");
                    this.elevationType !== "none" && (this.zOffsetBuffersNeedUpload = !0), this.sortFeaturesByKey && this.features.sort((xe, ge) => xe.sortKey - ge.sortKey)
                }

                update(e, i, a, c, d, f, _) {
                    this.text.programConfigurations.updatePaintArrays(e, i, d, a, c, f, _, this.worldview), this.icon.programConfigurations.updatePaintArrays(e, i, d, a, c, f, _, this.worldview)
                }

                updateRoadElevation(e) {
                    if (this.elevationType !== "road" || !this.elevationFeatures || this.elevationStateComplete) return;
                    this.elevationStateComplete = !0, this.hasAnyZOffset = !1;
                    let i = !1;
                    const a = he(e), c = 1 / a;
                    let d = !1, f = !1;
                    for (let _ = 0; _ < this.symbolInstances.length; _++) {
                        const x = this.symbolInstances.get(_), w = $t(1, 0, 0), E = $t(0, 1, 0), {
                            numHorizontalGlyphVertices: I,
                            numVerticalGlyphVertices: C,
                            numIconVertices: z,
                            numVerticalIconVertices: L
                        } = x, F = I > 0 || C > 0, N = z > 0, H = this.elevationFeatures[x.elevationFeatureIndex];
                        if (H) {
                            const Y = new Ze(x.tileAnchorX, x.tileAnchorY), X = .075 + H.pointElevation(Y);
                            x.zOffset !== X && (i = !0, x.zOffset = X);
                            const J = H.computeSlopeNormal(Y, c), xe = Ds(ps(), $t(0, 0, 1), J);
                            wo(w, w, xe), wo(E, E, xe), w[2] *= a, E[2] *= a, w[0] === 1 && w[1] === 0 && w[2] === 0 && E[0] === 0 && E[1] === 1 && E[2] === 0 || (d = d || F, f = f || N)
                        }
                        if (F && (y0(this.text.orientationVertexArray, I, w, E), y0(this.text.orientationVertexArray, C, w, E)), N) {
                            const {placedIconSymbolIndex: Y, verticalPlacedIconSymbolIndex: X} = x;
                            Y >= 0 && y0(this.icon.orientationVertexArray, z, w, E), X >= 0 && y0(this.icon.orientationVertexArray, L, w, E)
                        }
                    }
                    d || (this.text.orientationVertexArray = void 0), f || (this.icon.orientationVertexArray = void 0), i && (this.zOffsetBuffersNeedUpload = !0, this.zOffsetSortDirty = !0)
                }

                updateZOffset() {
                    const e = (d, f, _) => {
                        a += f, a > d.length && d.resize(a);
                        for (let x = -f; x < 0; x++) d.emplace(x + a, _)
                    }, i = (d, f, _) => {
                        c += f, c > d.length && d.resize(c);
                        for (let x = -f; x < 0; x++) d.emplace(x + c, _)
                    };
                    if (!this.zOffsetBuffersNeedUpload) return;
                    this.zOffsetBuffersNeedUpload = !1;
                    let a = 0, c = 0;
                    for (let d = 0; d < this.symbolInstances.length; d++) {
                        const f = this.symbolInstances.get(d), {
                            numHorizontalGlyphVertices: _,
                            numVerticalGlyphVertices: x,
                            numIconVertices: w
                        } = f, E = f.zOffset, I = w > 0;
                        if ((_ > 0 || x > 0) && (e(this.text.zOffsetVertexArray, _, E), e(this.text.zOffsetVertexArray, x, E)), I) {
                            const {placedIconSymbolIndex: C, verticalPlacedIconSymbolIndex: z} = f;
                            C >= 0 && i(this.icon.zOffsetVertexArray, w, E), z >= 0 && i(this.icon.zOffsetVertexArray, f.numVerticalIconVertices, E)
                        }
                    }
                    this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray)
                }

                isEmpty() {
                    return this.symbolInstances.length === 0 && !this.hasRTLText
                }

                uploadPending() {
                    return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
                }

                upload(e) {
                    !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.uploaded = !0
                }

                destroyDebugData() {
                    this.textCollisionBox.destroy(), this.iconCollisionBox.destroy()
                }

                getProjection() {
                    return this.projectionInstance || (this.projectionInstance = IA(this.projection)), this.projectionInstance
                }

                destroy() {
                    this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData()
                }

                addToLineVertexArray(e, i) {
                    const a = this.lineVertexArray.length;
                    if (e.segment !== void 0) for (const {x: c, y: d} of i) this.lineVertexArray.emplaceBack(c, d);
                    return {lineStartIndex: a, lineLength: this.lineVertexArray.length - a}
                }

                addSymbols(e, i, a, c, d, f, _, x, w, E, I, C, z, L, F, N) {
                    const H = e.indexArray, Y = e.layoutVertexArray, X = e.globeExtVertexArray,
                        J = e.segments.prepareSegment(4 * i.length, Y, H, this.canOverlap ? f.sortKey : void 0),
                        xe = this.glyphOffsetArray.length, ge = J.vertexLength,
                        ye = this.allowVerticalPlacement && _ === ss.vertical ? Math.PI / 2 : 0,
                        Ee = f.text && f.text.sections;
                    for (let We = 0; We < i.length; We++) {
                        const {
                            tl: De,
                            tr: Ye,
                            bl: ht,
                            br: Qe,
                            texPrimary: ot,
                            texSecondary: ct,
                            pixelOffsetTL: He,
                            pixelOffsetBR: st,
                            minFontScaleX: ke,
                            minFontScaleY: qe,
                            glyphOffset: pt,
                            isSDF: at,
                            sectionIndex: Bt
                        } = i[We], zt = J.vertexLength, nt = pt[1];
                        if (m0(Y, w.x, w.y, De.x, nt + De.y, ot.x, ot.y, a, at, He.x, He.y, ke, qe), m0(Y, w.x, w.y, Ye.x, nt + Ye.y, ot.x + ot.w, ot.y, a, at, st.x, He.y, ke, qe), m0(Y, w.x, w.y, ht.x, nt + ht.y, ot.x, ot.y + ot.h, a, at, He.x, st.y, ke, qe), m0(Y, w.x, w.y, Qe.x, nt + Qe.y, ot.x + ot.w, ot.y + ot.h, a, at, st.x, st.y, ke, qe), x) {
                            const {x: lt, y: kt, z: Et} = x.anchor, [vt, At, Kt] = x.up;
                            _0(X, lt, kt, Et, vt, At, Kt), _0(X, lt, kt, Et, vt, At, Kt), _0(X, lt, kt, Et, vt, At, Kt), _0(X, lt, kt, Et, vt, At, Kt), v0(e.dynamicLayoutVertexArray, lt, kt, Et, ye)
                        } else v0(e.dynamicLayoutVertexArray, w.x, w.y, w.z, ye);
                        if (N) {
                            const lt = ct || ot;
                            g0(e.iconTransitioningVertexArray, lt.x, lt.y), g0(e.iconTransitioningVertexArray, lt.x + lt.w, lt.y), g0(e.iconTransitioningVertexArray, lt.x, lt.y + lt.h), g0(e.iconTransitioningVertexArray, lt.x + lt.w, lt.y + lt.h)
                        }
                        H.emplaceBack(zt, zt + 1, zt + 2), H.emplaceBack(zt + 1, zt + 2, zt + 3), J.vertexLength += 4, J.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(pt[0]), We !== i.length - 1 && Bt === i[We + 1].sectionIndex || e.programConfigurations.populatePaintArrays(Y.length, f, f.index, {}, z, L, F, Ee && Ee[Bt], this.worldview)
                    }
                    const Ie = x ? x.anchor : w;
                    e.placedSymbolArray.emplaceBack(Ie.x, Ie.y, Ie.z, w.x, w.y, xe, this.glyphOffsetArray.length - xe, ge, E, I, w.segment, a ? a[0] : 0, a ? a[1] : 0, c[0], c[1], _, 0, 0, 0, C, 0)
                }

                _commitLayoutVertex(e, i, a, c, d, f, _) {
                    e.emplaceBack(i, a, c, d, f, Math.round(_.x), Math.round(_.y))
                }

                _addCollisionDebugVertices(e, i, a, c, d, f, _) {
                    const x = a.segments.prepareSegment(4, a.layoutVertexArray, a.indexArray), w = x.vertexLength,
                        E = _.tileAnchorX, I = _.tileAnchorY;
                    for (let z = 0; z < 4; z++) a.collisionVertexArray.emplaceBack(0, 0, 0, 0, 0, 0);
                    this._commitDebugCollisionVertexUpdate(a.collisionVertexArrayExt, i, e.padding, _.zOffset), this._commitLayoutVertex(a.layoutVertexArray, c, d, f, E, I, new Ze(e.x1, e.y1)), this._commitLayoutVertex(a.layoutVertexArray, c, d, f, E, I, new Ze(e.x2, e.y1)), this._commitLayoutVertex(a.layoutVertexArray, c, d, f, E, I, new Ze(e.x2, e.y2)), this._commitLayoutVertex(a.layoutVertexArray, c, d, f, E, I, new Ze(e.x1, e.y2)), x.vertexLength += 4;
                    const C = a.indexArray;
                    C.emplaceBack(w, w + 1), C.emplaceBack(w + 1, w + 2), C.emplaceBack(w + 2, w + 3), C.emplaceBack(w + 3, w), x.primitiveLength += 4
                }

                _addTextDebugCollisionBoxes(e, i, a, c, d, f) {
                    for (let _ = c; _ < d; _++) {
                        const x = a.get(_), w = this.getSymbolInstanceTextSize(e, f, i, _);
                        this._addCollisionDebugVertices(x, w, this.textCollisionBox, x.projectedAnchorX, x.projectedAnchorY, x.projectedAnchorZ, f)
                    }
                }

                _addIconDebugCollisionBoxes(e, i, a, c, d, f) {
                    for (let _ = c; _ < d; _++) {
                        const x = a.get(_), w = this.getSymbolInstanceIconSize(e, i, f.placedIconSymbolIndex);
                        this._addCollisionDebugVertices(x, w, this.iconCollisionBox, x.projectedAnchorX, x.projectedAnchorY, x.projectedAnchorZ, f)
                    }
                }

                generateCollisionDebugBuffers(e, i, a) {
                    this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new pw(of, VE.members, ea), this.iconCollisionBox = new pw(of, VE.members, ea);
                    const c = ug(this.iconSizeData, e), d = ug(this.textSizeData, e, a);
                    for (let f = 0; f < this.symbolInstances.length; f++) {
                        const _ = this.symbolInstances.get(f);
                        this._addTextDebugCollisionBoxes(d, e, i, _.textBoxStartIndex, _.textBoxEndIndex, _), this._addTextDebugCollisionBoxes(d, e, i, _.verticalTextBoxStartIndex, _.verticalTextBoxEndIndex, _), this._addIconDebugCollisionBoxes(c, e, i, _.iconBoxStartIndex, _.iconBoxEndIndex, _), this._addIconDebugCollisionBoxes(c, e, i, _.verticalIconBoxStartIndex, _.verticalIconBoxEndIndex, _)
                    }
                }

                getSymbolInstanceTextSize(e, i, a, c) {
                    const d = this.text.placedSymbolArray.get(i.rightJustifiedTextSymbolIndex >= 0 ? i.rightJustifiedTextSymbolIndex : i.centerJustifiedTextSymbolIndex >= 0 ? i.centerJustifiedTextSymbolIndex : i.leftJustifiedTextSymbolIndex >= 0 ? i.leftJustifiedTextSymbolIndex : i.verticalPlacedTextSymbolIndex >= 0 ? i.verticalPlacedTextSymbolIndex : c),
                        f = sw(this.textSizeData, e, d) / Dr;
                    return this.tilePixelRatio * f
                }

                getSymbolInstanceIconSize(e, i, a) {
                    const c = this.icon.placedSymbolArray.get(a), d = sw(this.iconSizeData, e, c);
                    return this.tilePixelRatio * d
                }

                _commitDebugCollisionVertexUpdate(e, i, a, c) {
                    e.emplaceBack(i, -a, -a, c), e.emplaceBack(i, a, -a, c), e.emplaceBack(i, a, a, c), e.emplaceBack(i, -a, a, c)
                }

                _updateTextDebugCollisionBoxes(e, i, a, c, d, f, _) {
                    for (let x = c; x < d; x++) {
                        const w = a.get(x), E = this.getSymbolInstanceTextSize(e, f, i, x);
                        this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, E, w.padding, f.zOffset)
                    }
                }

                _updateIconDebugCollisionBoxes(e, i, a, c, d, f, _) {
                    for (let x = c; x < d; x++) {
                        const w = a.get(x), E = this.getSymbolInstanceIconSize(e, i, f.placedIconSymbolIndex);
                        this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, E, w.padding, f.zOffset)
                    }
                }

                updateCollisionDebugBuffers(e, i, a, c) {
                    if (!this.hasDebugData()) return;
                    this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
                    const d = ug(this.iconSizeData, e, c), f = ug(this.textSizeData, e, a);
                    for (let _ = 0; _ < this.symbolInstances.length; _++) {
                        const x = this.symbolInstances.get(_);
                        this._updateTextDebugCollisionBoxes(f, e, i, x.textBoxStartIndex, x.textBoxEndIndex, x, a), this._updateTextDebugCollisionBoxes(f, e, i, x.verticalTextBoxStartIndex, x.verticalTextBoxEndIndex, x, a), this._updateIconDebugCollisionBoxes(d, e, i, x.iconBoxStartIndex, x.iconBoxEndIndex, x, c), this._updateIconDebugCollisionBoxes(d, e, i, x.verticalIconBoxStartIndex, x.verticalIconBoxEndIndex, x, c)
                    }
                    this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt)
                }

                _deserializeCollisionBoxesForSymbol(e, i, a, c, d, f, _, x, w) {
                    const E = {};
                    if (i < a) {
                        const {
                            x1: I,
                            y1: C,
                            x2: z,
                            y2: L,
                            padding: F,
                            projectedAnchorX: N,
                            projectedAnchorY: H,
                            projectedAnchorZ: Y,
                            tileAnchorX: X,
                            tileAnchorY: J,
                            featureIndex: xe
                        } = e.get(i);
                        E.textBox = {
                            x1: I,
                            y1: C,
                            x2: z,
                            y2: L,
                            padding: F,
                            projectedAnchorX: N,
                            projectedAnchorY: H,
                            projectedAnchorZ: Y,
                            tileAnchorX: X,
                            tileAnchorY: J
                        }, E.textFeatureIndex = xe
                    }
                    if (c < d) {
                        const {
                            x1: I,
                            y1: C,
                            x2: z,
                            y2: L,
                            padding: F,
                            projectedAnchorX: N,
                            projectedAnchorY: H,
                            projectedAnchorZ: Y,
                            tileAnchorX: X,
                            tileAnchorY: J,
                            featureIndex: xe
                        } = e.get(c);
                        E.verticalTextBox = {
                            x1: I,
                            y1: C,
                            x2: z,
                            y2: L,
                            padding: F,
                            projectedAnchorX: N,
                            projectedAnchorY: H,
                            projectedAnchorZ: Y,
                            tileAnchorX: X,
                            tileAnchorY: J
                        }, E.verticalTextFeatureIndex = xe
                    }
                    if (f < _) {
                        const {
                            x1: I,
                            y1: C,
                            x2: z,
                            y2: L,
                            padding: F,
                            projectedAnchorX: N,
                            projectedAnchorY: H,
                            projectedAnchorZ: Y,
                            tileAnchorX: X,
                            tileAnchorY: J,
                            featureIndex: xe
                        } = e.get(f);
                        E.iconBox = {
                            x1: I,
                            y1: C,
                            x2: z,
                            y2: L,
                            padding: F,
                            projectedAnchorX: N,
                            projectedAnchorY: H,
                            projectedAnchorZ: Y,
                            tileAnchorX: X,
                            tileAnchorY: J
                        }, E.iconFeatureIndex = xe
                    }
                    if (x < w) {
                        const {
                            x1: I,
                            y1: C,
                            x2: z,
                            y2: L,
                            padding: F,
                            projectedAnchorX: N,
                            projectedAnchorY: H,
                            projectedAnchorZ: Y,
                            tileAnchorX: X,
                            tileAnchorY: J,
                            featureIndex: xe
                        } = e.get(x);
                        E.verticalIconBox = {
                            x1: I,
                            y1: C,
                            x2: z,
                            y2: L,
                            padding: F,
                            projectedAnchorX: N,
                            projectedAnchorY: H,
                            projectedAnchorZ: Y,
                            tileAnchorX: X,
                            tileAnchorY: J
                        }, E.verticalIconFeatureIndex = xe
                    }
                    return E
                }

                deserializeCollisionBoxes(e) {
                    this.collisionArrays = [];
                    for (let i = 0; i < this.symbolInstances.length; i++) {
                        const a = this.symbolInstances.get(i);
                        this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, a.textBoxStartIndex, a.textBoxEndIndex, a.verticalTextBoxStartIndex, a.verticalTextBoxEndIndex, a.iconBoxStartIndex, a.iconBoxEndIndex, a.verticalIconBoxStartIndex, a.verticalIconBoxEndIndex))
                    }
                }

                hasTextData() {
                    return this.text.segments.get().length > 0
                }

                hasIconData() {
                    return this.icon.segments.get().length > 0
                }

                hasDebugData() {
                    return this.textCollisionBox && this.iconCollisionBox
                }

                hasTextCollisionBoxData() {
                    return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
                }

                hasIconCollisionBoxData() {
                    return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
                }

                hasIconTextFit() {
                    return this.hasAnyIconTextFit
                }

                addIndicesForPlacedSymbol(e, i) {
                    const a = e.placedSymbolArray.get(i), c = a.vertexStartIndex + 4 * a.numGlyphs;
                    for (let d = a.vertexStartIndex; d < c; d += 4) e.indexArray.emplaceBack(d, d + 1, d + 2), e.indexArray.emplaceBack(d + 1, d + 2, d + 3)
                }

                getSortedSymbolIndexes(e) {
                    if (this.sortedAngle === e && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
                    const i = Math.sin(e), a = Math.cos(e), c = [], d = [], f = [];
                    for (let _ = 0; _ < this.symbolInstances.length; ++_) {
                        f.push(_);
                        const x = this.symbolInstances.get(_);
                        c.push(0 | Math.round(i * x.tileAnchorX + a * x.tileAnchorY)), d.push(x.featureIndex)
                    }
                    return f.sort((_, x) => c[_] - c[x] || d[x] - d[_]), f
                }

                getSortedIndexesByZOffset() {
                    if (!this.zOffsetSortDirty) return this.symbolInstanceIndexesSortedZOffset;
                    if (!this.symbolInstanceIndexesSortedZOffset) {
                        this.symbolInstanceIndexesSortedZOffset = [];
                        for (let e = 0; e < this.symbolInstances.length; ++e) this.symbolInstanceIndexesSortedZOffset.push(e)
                    }
                    return this.zOffsetSortDirty = !1, this.symbolInstanceIndexesSortedZOffset.sort((e, i) => this.symbolInstances.get(i).zOffset - this.symbolInstances.get(e).zOffset)
                }

                addToSortKeyRanges(e, i) {
                    const a = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                    a && a.sortKey === i ? a.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({
                        sortKey: i,
                        symbolInstanceStart: e,
                        symbolInstanceEnd: e + 1
                    })
                }

                sortFeatures(e) {
                    if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                        this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                        for (const i of this.symbolInstanceIndexes) {
                            const a = this.symbolInstances.get(i);
                            this.featureSortOrder.push(a.featureIndex);
                            const {
                                rightJustifiedTextSymbolIndex: c,
                                centerJustifiedTextSymbolIndex: d,
                                leftJustifiedTextSymbolIndex: f,
                                verticalPlacedTextSymbolIndex: _,
                                placedIconSymbolIndex: x,
                                verticalPlacedIconSymbolIndex: w
                            } = a;
                            c >= 0 && this.addIndicesForPlacedSymbol(this.text, c), d >= 0 && d !== c && this.addIndicesForPlacedSymbol(this.text, d), f >= 0 && f !== d && f !== c && this.addIndicesForPlacedSymbol(this.text, f), _ >= 0 && this.addIndicesForPlacedSymbol(this.text, _), x >= 0 && this.addIndicesForPlacedSymbol(this.icon, x), w >= 0 && this.addIndicesForPlacedSymbol(this.icon, w)
                        }
                        this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
                    }
                }
            }

            let CA, PA, mw;
            Pt(x0, "SymbolBucket", {omit: ["layers", "collisionBoxArray", "features", "compareText"]}), x0.addDynamicAttributes = v0;

            class MA {
                constructor(e) {
                    this.type = e.property.overrides ? e.property.overrides.runtimeType : bc, this.defaultValue = e
                }

                evaluate(e) {
                    if (e.formattedSection) {
                        const i = this.defaultValue.property.overrides;
                        if (i && i.hasOverride(e.formattedSection)) return i.getOverride(e.formattedSection)
                    }
                    return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default
                }

                eachChild(e) {
                    this.defaultValue.isConstant() || e(this.defaultValue.value._styleExpression.expression)
                }

                outputDefined() {
                    return !1
                }

                serialize() {
                    return null
                }
            }

            Pt(MA, "FormatSectionOverride", {omit: ["defaultValue"]});
            const gw = () => mw || (mw = {
                layout: CA || (CA = new qn({
                    "symbol-placement": new dt(ze.layout_symbol["symbol-placement"]),
                    "symbol-spacing": new dt(ze.layout_symbol["symbol-spacing"]),
                    "symbol-avoid-edges": new dt(ze.layout_symbol["symbol-avoid-edges"]),
                    "symbol-sort-key": new Tt(ze.layout_symbol["symbol-sort-key"]),
                    "symbol-z-order": new dt(ze.layout_symbol["symbol-z-order"]),
                    "symbol-z-elevate": new dt(ze.layout_symbol["symbol-z-elevate"]),
                    "symbol-elevation-reference": new dt(ze.layout_symbol["symbol-elevation-reference"]),
                    "icon-allow-overlap": new dt(ze.layout_symbol["icon-allow-overlap"]),
                    "icon-ignore-placement": new dt(ze.layout_symbol["icon-ignore-placement"]),
                    "icon-optional": new dt(ze.layout_symbol["icon-optional"]),
                    "icon-rotation-alignment": new dt(ze.layout_symbol["icon-rotation-alignment"]),
                    "icon-size": new Tt(ze.layout_symbol["icon-size"]),
                    "icon-size-scale-range": new dt(ze.layout_symbol["icon-size-scale-range"]),
                    "icon-text-fit": new Tt(ze.layout_symbol["icon-text-fit"]),
                    "icon-text-fit-padding": new Tt(ze.layout_symbol["icon-text-fit-padding"]),
                    "icon-image": new Tt(ze.layout_symbol["icon-image"]),
                    "icon-rotate": new Tt(ze.layout_symbol["icon-rotate"]),
                    "icon-padding": new dt(ze.layout_symbol["icon-padding"]),
                    "icon-keep-upright": new dt(ze.layout_symbol["icon-keep-upright"]),
                    "icon-offset": new Tt(ze.layout_symbol["icon-offset"]),
                    "icon-anchor": new Tt(ze.layout_symbol["icon-anchor"]),
                    "icon-pitch-alignment": new dt(ze.layout_symbol["icon-pitch-alignment"]),
                    "text-pitch-alignment": new dt(ze.layout_symbol["text-pitch-alignment"]),
                    "text-rotation-alignment": new dt(ze.layout_symbol["text-rotation-alignment"]),
                    "text-field": new Tt(ze.layout_symbol["text-field"]),
                    "text-font": new Tt(ze.layout_symbol["text-font"]),
                    "text-size": new Tt(ze.layout_symbol["text-size"]),
                    "text-size-scale-range": new dt(ze.layout_symbol["text-size-scale-range"]),
                    "text-max-width": new Tt(ze.layout_symbol["text-max-width"]),
                    "text-line-height": new Tt(ze.layout_symbol["text-line-height"]),
                    "text-letter-spacing": new Tt(ze.layout_symbol["text-letter-spacing"]),
                    "text-justify": new Tt(ze.layout_symbol["text-justify"]),
                    "text-radial-offset": new Tt(ze.layout_symbol["text-radial-offset"]),
                    "text-variable-anchor": new dt(ze.layout_symbol["text-variable-anchor"]),
                    "text-anchor": new Tt(ze.layout_symbol["text-anchor"]),
                    "text-max-angle": new dt(ze.layout_symbol["text-max-angle"]),
                    "text-writing-mode": new dt(ze.layout_symbol["text-writing-mode"]),
                    "text-rotate": new Tt(ze.layout_symbol["text-rotate"]),
                    "text-padding": new dt(ze.layout_symbol["text-padding"]),
                    "text-keep-upright": new dt(ze.layout_symbol["text-keep-upright"]),
                    "text-transform": new Tt(ze.layout_symbol["text-transform"]),
                    "text-offset": new Tt(ze.layout_symbol["text-offset"]),
                    "text-allow-overlap": new dt(ze.layout_symbol["text-allow-overlap"]),
                    "text-ignore-placement": new dt(ze.layout_symbol["text-ignore-placement"]),
                    "text-optional": new dt(ze.layout_symbol["text-optional"]),
                    visibility: new dt(ze.layout_symbol.visibility)
                })), paint: PA || (PA = new qn({
                    "icon-opacity": new Tt(ze.paint_symbol["icon-opacity"]),
                    "icon-occlusion-opacity": new Tt(ze.paint_symbol["icon-occlusion-opacity"]),
                    "icon-emissive-strength": new Tt(ze.paint_symbol["icon-emissive-strength"]),
                    "text-emissive-strength": new Tt(ze.paint_symbol["text-emissive-strength"]),
                    "icon-color": new Tt(ze.paint_symbol["icon-color"]),
                    "icon-halo-color": new Tt(ze.paint_symbol["icon-halo-color"]),
                    "icon-halo-width": new Tt(ze.paint_symbol["icon-halo-width"]),
                    "icon-halo-blur": new Tt(ze.paint_symbol["icon-halo-blur"]),
                    "icon-translate": new dt(ze.paint_symbol["icon-translate"]),
                    "icon-translate-anchor": new dt(ze.paint_symbol["icon-translate-anchor"]),
                    "icon-image-cross-fade": new dt(ze.paint_symbol["icon-image-cross-fade"]),
                    "text-opacity": new Tt(ze.paint_symbol["text-opacity"]),
                    "text-occlusion-opacity": new Tt(ze.paint_symbol["text-occlusion-opacity"]),
                    "text-color": new Tt(ze.paint_symbol["text-color"], {
                        runtimeType: ko,
                        getOverride: n => n.textColor,
                        hasOverride: n => !!n.textColor
                    }),
                    "text-halo-color": new Tt(ze.paint_symbol["text-halo-color"]),
                    "text-halo-width": new Tt(ze.paint_symbol["text-halo-width"]),
                    "text-halo-blur": new Tt(ze.paint_symbol["text-halo-blur"]),
                    "text-translate": new dt(ze.paint_symbol["text-translate"]),
                    "text-translate-anchor": new dt(ze.paint_symbol["text-translate-anchor"]),
                    "icon-color-saturation": new dt(ze.paint_symbol["icon-color-saturation"]),
                    "icon-color-contrast": new dt(ze.paint_symbol["icon-color-contrast"]),
                    "icon-color-brightness-min": new dt(ze.paint_symbol["icon-color-brightness-min"]),
                    "icon-color-brightness-max": new dt(ze.paint_symbol["icon-color-brightness-max"]),
                    "symbol-z-offset": new Tt(ze.paint_symbol["symbol-z-offset"]),
                    "icon-color-use-theme": new Tt({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "icon-halo-color-use-theme": new Tt({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "text-color-use-theme": new Tt({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "text-halo-color-use-theme": new Tt({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    })
                }))
            }, mw);

            class w0 extends to {
                constructor(e, i, a, c) {
                    super(e, gw(), i, a, c), this._colorAdjustmentMatrix = fe([]), this.hasInitialOcclusionOpacityProperties = e.paint !== void 0 && ("icon-occlusion-opacity" in e.paint || "text-occlusion-opacity" in e.paint)
                }

                recalculate(e, i) {
                    super.recalculate(e, i), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
                    const a = this.layout.get("text-writing-mode");
                    if (a) {
                        const c = [];
                        for (const d of a) c.indexOf(d) < 0 && c.push(d);
                        this.layout._values["text-writing-mode"] = c
                    } else this.layout._values["text-writing-mode"] = this.layout.get("symbol-placement") === "point" ? ["horizontal"] : ["horizontal", "vertical"];
                    this._setPaintOverrides()
                }

                getColorAdjustmentMatrix(e, i, a, c) {
                    return this._saturation === e && this._contrast === i && this._brightnessMin === a && this._brightnessMax === c || (this._colorAdjustmentMatrix = function (d, f, _, x) {
                        d = Qr(d), f = So(f);
                        const w = Re(), E = d / 3, I = 1 - 2 * E, C = [I, E, E, 0, E, I, E, 0, E, E, I, 0, 0, 0, 0, 1],
                            z = .5 - .5 * f, L = x - _;
                        return pe(w, [L, 0, 0, 0, 0, L, 0, 0, 0, 0, L, 0, _, _, _, 1], [f, 0, 0, 0, 0, f, 0, 0, 0, 0, f, 0, z, z, z, 1]), pe(w, w, C), w
                    }(e, i, a, c), this._saturation = e, this._contrast = i, this._brightnessMin = a, this._brightnessMax = c), this._colorAdjustmentMatrix
                }

                getValueAndResolveTokens(e, i, a, c) {
                    const d = this.layout.get(e).evaluate(i, {}, a, c), f = this._unevaluatedLayout._values[e];
                    return f.isDataDriven() || hm(f.value) || !d ? d : function (_, x) {
                        return x.replace(/{([^{}]+)}/g, (w, E) => E in _ ? String(_[E]) : "")
                    }(i.properties, d)
                }

                createBucket(e) {
                    return new x0(e)
                }

                queryRadius() {
                    return 0
                }

                queryIntersectsFeature() {
                    return !1
                }

                _setPaintOverrides() {
                    for (const e of gw().paint.overridableProperties) {
                        if (!w0.hasPaintOverride(this.layout, e)) continue;
                        const i = this.paint.get(e), a = new MA(i),
                            c = new um(a, i.property.specification, this.scope, this.options);
                        let d = null;
                        d = i.value.kind === "constant" || i.value.kind === "source" ? new Hd("source", c) : new ol("composite", c, i.value.zoomStops, i.value.interpolationType), this.paint._values[e] = new Wl(i.property, d, i.parameters)
                    }
                }

                _handleOverridablePaintPropertyUpdate(e, i, a) {
                    return !(!this.layout || i.isDataDriven() || a.isDataDriven()) && w0.hasPaintOverride(this.layout, e)
                }

                static hasPaintOverride(e, i) {
                    const a = e.get("text-field"), c = gw().paint.properties[i];
                    let d = !1;
                    const f = _ => {
                        for (const x of _) if (c.overrides && c.overrides.hasOverride(x)) return void (d = !0)
                    };
                    if (a.value.kind === "constant" && a.value.value instanceof fo) f(a.value.value.sections); else if (a.value.kind === "source") {
                        const _ = w => {
                            d || (w instanceof ei && It(w.value) === nh ? f(w.value.sections) : w instanceof Sc ? f(w.sections) : w.eachChild(_))
                        }, x = a.value;
                        x._styleExpression && _(x._styleExpression.expression)
                    }
                    return d
                }

                getProgramIds() {
                    return ["symbol"]
                }

                getDefaultProgramParams(e, i, a) {
                    return {config: new go(this, {zoom: i, lut: a}), overrideFog: !1}
                }

                hasElevation() {
                    return this.layout && this.layout.get("symbol-elevation-reference") === "hd-road-markup"
                }
            }

            let RA, zA, DA, LA;
            var _w = Fi([{name: "a_pos", type: "Int16", components: 2}, {
                name: "a_texture_pos",
                type: "Int16",
                components: 2
            }]);

            function b0(n, e, i, a, c, d, f, _) {
                const x = [n, e, 1, i, a, 1, c, d, 1], w = [f, _, 1], E = de([], x), [I, C, z] = Zr(w, w, E);
                return ae(x, x, [I, 0, 0, 0, C, 0, 0, 0, z])
            }

            function kA(n, e, i, a, c, d, f, _) {
                const x = function (w, E, I, C, z, L, F, N) {
                    const H = b0(0, 0, 1, 0, 1, 1, 0, 1), Y = b0(w, E, I, C, z, L, F, N);
                    return ae(Y, Y, de([], H))
                }(n, e, i, a, c, d, f, _);
                return [x[2] / x[8] / yt, x[5] / x[8] / yt]
            }

            function T0(n) {
                return [n[0], Math.min(Math.max(n[1], -ce), ce)]
            }

            class OA extends Ol {
                constructor(e, i, a, c) {
                    super(), this.id = e, this.dispatcher = a, this.coordinates = i.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.onNorthPole = !1, this.onSouthPole = !1, this.setEventedParent(c), this.options = i, this._dirty = !1
                }

                load(e, i) {
                    if (this._loaded = i || !1, this.fire(new _a("dataloading", {dataType: "source"})), this.url = this.options.url, !this.url) return e && (this.coordinates = e), this._loaded = !0, void this._finishLoading();
                    this._imageRequest = Ju(this.map._requestManager.transformRequest(this.url, Yu.Image), (a, c) => {
                        this._imageRequest = null, this._loaded = !0, a ? this.fire(new Xo(a)) : c && (this.image = c instanceof HTMLImageElement ? ks.getImageData(c) : c, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, e && (this.coordinates = e), this._finishLoading())
                    })
                }

                loaded() {
                    return this._loaded
                }

                updateImage(e) {
                    return e.url ? (this._imageRequest && e.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = e.url, this.load(e.coordinates, this._loaded), this) : this
                }

                setTexture(e) {
                    if (!(e.handle instanceof WebGLTexture)) throw new Error("The provided handle is not a WebGLTexture instance");
                    return this.texture = new og(this.map.painter.context, e.handle), this.width = e.dimensions[0], this.height = e.dimensions[1], this._dirty = !1, this._loaded = !0, this._finishLoading(), this
                }

                _finishLoading() {
                    this.map && (this.setCoordinates(this.coordinates), this.fire(new _a("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })))
                }

                onAdd(e) {
                    this.map = e, this.load()
                }

                onRemove(e) {
                    this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof og || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy())
                }

                setCoordinates(e) {
                    if (this.coordinates = e, this._boundsArray = void 0, this._unsupportedCoords = !1, !e.length) return this;
                    this.onNorthPole = !1, this.onSouthPole = !1;
                    let i = e[0][1], a = e[0][1];
                    for (const d of e) d[1] > a && (a = d[1]), d[1] < i && (i = d[1]);
                    const c = (a + i) / 2;
                    if (c > ce ? this.onNorthPole = !0 : c < -ce && (this.onSouthPole = !0), !this.onNorthPole && !this.onSouthPole) {
                        const d = e.map(me.fromLngLat);
                        this.tileID = function (f) {
                            let _ = 1 / 0, x = 1 / 0, w = -1 / 0, E = -1 / 0;
                            for (const F of f) _ = Math.min(_, F.x), x = Math.min(x, F.y), w = Math.max(w, F.x), E = Math.max(E, F.y);
                            const I = Math.max(w - _, E - x), C = Math.max(0, Math.floor(-Math.log(I) / Math.LN2)),
                                z = Math.pow(2, C);
                            let L = Math.floor((_ + w) / 2 * z);
                            return L > 1 && (L -= 1), new ns(C, L, Math.floor((x + E) / 2 * z))
                        }(d), this.minzoom = this.maxzoom = this.tileID.z
                    }
                    return this.fire(new _a("data", {dataType: "source", sourceDataType: "content"})), this
                }

                _clear() {
                    !this.texture || this.texture instanceof og || (this.texture.destroy(), this._dirty = !0), this.texture = null, this._boundsArray = void 0, this._unsupportedCoords = !1
                }

                _prepareData(e) {
                    for (const H in this.tiles) {
                        const Y = this.tiles[H];
                        Y.state !== "loaded" && (Y.state = "loaded", Y.texture = this.texture)
                    }
                    if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords) return;
                    const i = pg(new ns(0, 0, 0), this.map.transform.projection),
                        a = [i.projection.project(this.coordinates[0][0], this.coordinates[0][1]), i.projection.project(this.coordinates[1][0], this.coordinates[1][1]), i.projection.project(this.coordinates[2][0], this.coordinates[2][1]), i.projection.project(this.coordinates[3][0], this.coordinates[3][1])];
                    if (!function (H) {
                        const Y = H[1].x - H[0].x, X = H[1].y - H[0].y, J = H[2].x - H[1].x, xe = H[2].y - H[1].y,
                            ge = H[3].x - H[2].x, ye = H[3].y - H[2].y, Ee = H[0].x - H[3].x, Ie = H[0].y - H[3].y,
                            We = Y * xe - J * X, De = J * ye - ge * xe, Ye = ge * Ie - Ee * ye, ht = Ee * X - Y * Ie;
                        return We > 0 && De > 0 && Ye > 0 && ht > 0 || We < 0 && De < 0 && Ye < 0 && ht < 0
                    }(a)) return console.warn("Image source coordinates are defining non-convex area in the Mercator projection"), void (this._unsupportedCoords = !0);
                    const c = pg(this.tileID, this.map.transform.projection), [d, f, _, x] = this.coordinates.map(H => {
                        const Y = c.projection.project(H[0], H[1]);
                        return bA(c, Y)._round()
                    });
                    this.perspectiveTransform = kA(d.x, d.y, f.x, f.y, _.x, _.y, x.x, x.y);
                    const w = this._boundsArray = new Uc;
                    w.emplaceBack(d.x, d.y, 0, 0), w.emplaceBack(f.x, f.y, yt, 0), w.emplaceBack(x.x, x.y, 0, yt), w.emplaceBack(_.x, _.y, yt, yt), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = e.createVertexBuffer(w, _w.members), this.boundsSegments = Ln.simpleSegment(0, 0, 4, 2);
                    const E = [], I = [T0((C = this.coordinates)[0]), T0(C[1]), T0(C[2]), T0(C[3])];
                    var C;
                    const [z, L, F, N] = function (H) {
                        let Y = H[0][0], X = Y, J = H[0][1], xe = J;
                        for (let ge = 1; ge < H.length; ge++) H[ge][0] < Y ? Y = H[ge][0] : H[ge][0] > X && (X = H[ge][0]), H[ge][1] < J ? J = H[ge][1] : H[ge][1] > xe && (xe = H[ge][1]);
                        return [Y, J, X - Y, xe - J]
                    }(I);
                    {
                        const H = new Uc, [Y, X, J, xe] = function (He) {
                                let st = He[0].x, ke = st, qe = He[0].y, pt = qe;
                                for (let at = 1; at < He.length; at++) He[at].x < st ? st = He[at].x : He[at].x > ke && (ke = He[at].x), He[at].y < qe ? qe = He[at].y : He[at].y > pt && (pt = He[at].y);
                                return [st, qe, ke - st, pt - qe]
                            }(a), ge = He => [(He.x - Y) / J, (He.y - X) / xe], [ye, Ee, Ie, We] = a.map(ge),
                            De = function (He, st, ke, qe, pt, at, Bt, zt) {
                                const nt = b0(0, 0, 1, 0, 1, 1, 0, 1);
                                return ae(nt, nt, de([], b0(He, st, ke, qe, pt, at, Bt, zt)))
                            }(ye[0], ye[1], Ee[0], Ee[1], Ie[0], Ie[1], We[0], We[1]);
                        this.elevatedGlobePerspectiveTransform = kA(ye[0], ye[1], Ee[0], Ee[1], Ie[0], Ie[1], We[0], We[1]);
                        const Ye = (He, st) => {
                            E.push(He.lng);
                            const ke = Math.round((He.lng - z) / F * yt), qe = Math.round((He.lat - L) / N * yt),
                                pt = ge(st), at = Zr([], [pt[0], pt[1], 1], De), Bt = Math.round(at[0] / at[2] * yt),
                                zt = Math.round(at[1] / at[2] * yt);
                            H.emplaceBack(ke, qe, Bt, zt)
                        }, ht = a[3].x - a[0].x, Qe = a[3].y - a[0].y, ot = a[2].x - a[1].x, ct = a[2].y - a[1].y;
                        for (let He = 0; He < 65; He++) {
                            const st = He / 64, ke = [a[0].x + st * ht, a[0].y + st * Qe],
                                qe = [a[1].x + st * ot, a[1].y + st * ct], pt = qe[0] - ke[0], at = qe[1] - ke[1];
                            for (let Bt = 0; Bt < 65; Bt++) {
                                const zt = Bt / 64, nt = {x: ke[0] + pt * zt, y: ke[1] + at * zt};
                                Ye(i.projection.unproject(nt.x, nt.y), nt)
                            }
                        }
                        this.elevatedGlobeVertexBuffer = e.createVertexBuffer(H, _w.members)
                    }
                    {
                        this.maxLongitudeTriangleSize = 0;
                        let H = [], Y = new Mn;
                        const X = (J, xe, ge) => {
                            Y.emplaceBack(J, xe, ge);
                            const ye = E[J], Ee = E[xe], Ie = E[ge], We = Math.min(Math.min(ye, Ee), Ie),
                                De = Math.max(Math.max(ye, Ee), Ie) - We;
                            De > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = De), H.push(We + De / 2)
                        };
                        for (let J = 0; J < 64; J++) for (let xe = 0; xe < 64; xe++) {
                            const ge = 65 * J + xe, ye = ge + 1, Ee = ge + 65, Ie = Ee + 1;
                            X(ge, Ee, ye), X(ye, Ee, Ie)
                        }
                        [H, Y] = function (J, xe) {
                            const ge = Array.from({length: J.length}, (Ie, We) => We);
                            ge.sort((Ie, We) => J[Ie] - J[We]);
                            const ye = [], Ee = new Mn;
                            for (let Ie = 0; Ie < ge.length; Ie++) {
                                const We = ge[Ie];
                                ye.push(J[We]);
                                const De = 3 * We, Ye = De + 1;
                                Ee.emplaceBack(xe.uint16[De], xe.uint16[Ye], xe.uint16[Ye + 1])
                            }
                            return [ye, Ee]
                        }(H, Y), this.elevatedGlobeTrianglesCenterLongitudes = H, this.elevatedGlobeIndexBuffer = e.createIndexBuffer(Y)
                    }
                    this.elevatedGlobeSegments = Ln.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([0, F / yt, 0, N / yt, 0, 0, L, z, 0])
                }

                prepare() {
                    const e = Object.keys(this.tiles).length !== 0;
                    if (this.tileID && !e) return;
                    const i = this.map.painter.context, a = i.gl;
                    !this._dirty || this.texture instanceof og || (this.texture ? this.texture.update(this.image) : (this.texture = new q1(i, this.image, a.RGBA8), this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE)), this._dirty = !1), e && this._prepareData(i)
                }

                loadTile(e, i) {
                    this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}, i(null)) : (e.state = "errored", i(null))
                }

                serialize() {
                    return {type: "image", url: this.options.url, coordinates: this.coordinates}
                }

                hasTransition() {
                    return !1
                }

                getSegmentsForLongitude(e) {
                    const i = this.elevatedGlobeSegments;
                    if (!this.elevatedGlobeTrianglesCenterLongitudes || !i) return null;
                    const a = this.elevatedGlobeTrianglesCenterLongitudes;
                    let c = (d = e + 180) + 360 * Math.round((a[0] - d) / 360);
                    var d;
                    const f = new Ln, _ = (I, C) => {
                        f.segments.push({
                            vertexOffset: 0,
                            primitiveOffset: I,
                            vertexLength: i.segments[0].vertexLength,
                            primitiveLength: C,
                            sortKey: void 0,
                            vaos: {}
                        })
                    }, x = .51 * this.maxLongitudeTriangleSize;
                    if (Math.abs(a[0] - c) <= x) {
                        const I = Pr(a, 0, a.length, c + x);
                        return I === a.length || _(I, Dn(a, I + 1, a.length, c + 360 - x) - I), f
                    }
                    c < a[0] && (c += 360);
                    const w = Dn(a, 0, a.length, c - x);
                    if (w === a.length) return _(0, a.length), f;
                    _(0, w - 0);
                    const E = Pr(a, w + 1, a.length, c + x);
                    return E !== a.length && _(E, a.length - E), f
                }
            }

            const G3 = (Math.pow(256, 2) - 1) / 16907520;

            class FA extends to {
                constructor(e, i, a, c) {
                    super(e, {
                        layout: DA || (DA = new qn({visibility: new dt(ze.layout_raster.visibility)})),
                        paint: LA || (LA = new qn({
                            "raster-opacity": new dt(ze.paint_raster["raster-opacity"]),
                            "raster-color": new Fc(ze.paint_raster["raster-color"]),
                            "raster-color-mix": new dt(ze.paint_raster["raster-color-mix"]),
                            "raster-color-range": new dt(ze.paint_raster["raster-color-range"]),
                            "raster-hue-rotate": new dt(ze.paint_raster["raster-hue-rotate"]),
                            "raster-brightness-min": new dt(ze.paint_raster["raster-brightness-min"]),
                            "raster-brightness-max": new dt(ze.paint_raster["raster-brightness-max"]),
                            "raster-saturation": new dt(ze.paint_raster["raster-saturation"]),
                            "raster-contrast": new dt(ze.paint_raster["raster-contrast"]),
                            "raster-resampling": new dt(ze.paint_raster["raster-resampling"]),
                            "raster-fade-duration": new dt(ze.paint_raster["raster-fade-duration"]),
                            "raster-emissive-strength": new dt(ze.paint_raster["raster-emissive-strength"]),
                            "raster-array-band": new dt(ze.paint_raster["raster-array-band"]),
                            "raster-elevation": new dt(ze.paint_raster["raster-elevation"]),
                            "raster-color-use-theme": new Tt({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, i, a, c), this.updateColorRamp(), this._curRampRange = [NaN, NaN]
                }

                getProgramIds() {
                    return ["raster"]
                }

                hasColorMap() {
                    return !!this._transitionablePaint._values["raster-color"].value.value
                }

                tileCoverLift() {
                    return this.paint.get("raster-elevation")
                }

                isDraped(e) {
                    return !(e && e._source instanceof OA && (e._source.onNorthPole || e._source.onSouthPole)) && this.paint.get("raster-elevation") === 0
                }

                _handleSpecialPaintPropertyUpdate(e) {
                    e !== "raster-color" && e !== "raster-color-range" || (this._curRampRange = [NaN, NaN], this.updateColorRamp())
                }

                _clear() {
                    this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null)
                }

                updateColorRamp(e) {
                    if (!this.hasColorMap() || !this._curRampRange) return;
                    const i = this._transitionablePaint._values["raster-color"].value.expression, [a, c] = e || this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({zoom: 0}) || [NaN, NaN];
                    isNaN(a) && isNaN(c) || a === this._curRampRange[0] && c === this._curRampRange[1] || (this.colorRamp = $m({
                        expression: i,
                        evaluationKey: "rasterValue",
                        image: this.colorRamp,
                        clips: [{start: a, end: c}],
                        resolution: 256
                    }), this.colorRampTexture = null, this._curRampRange = [a, c])
                }
            }

            let BA, NA, jA, VA, UA;

            class GA extends to {
                constructor(e, i, a, c) {
                    super(e, {
                        layout: BA || (BA = new qn({visibility: new dt(ze["layout_raster-particle"].visibility)})),
                        paint: NA || (NA = new qn({
                            "raster-particle-array-band": new dt(ze["paint_raster-particle"]["raster-particle-array-band"]),
                            "raster-particle-count": new dt(ze["paint_raster-particle"]["raster-particle-count"]),
                            "raster-particle-color": new Fc(ze["paint_raster-particle"]["raster-particle-color"]),
                            "raster-particle-max-speed": new dt(ze["paint_raster-particle"]["raster-particle-max-speed"]),
                            "raster-particle-speed-factor": new dt(ze["paint_raster-particle"]["raster-particle-speed-factor"]),
                            "raster-particle-fade-opacity-factor": new dt(ze["paint_raster-particle"]["raster-particle-fade-opacity-factor"]),
                            "raster-particle-reset-rate-factor": new dt(ze["paint_raster-particle"]["raster-particle-reset-rate-factor"]),
                            "raster-particle-elevation": new dt(ze["paint_raster-particle"]["raster-particle-elevation"]),
                            "raster-particle-color-use-theme": new Tt({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, i, a, c), this._updateColorRamp(), this.lastInvalidatedAt = ks.now()
                }

                _clear() {
                    this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null), this.tileFramebuffer && (this.tileFramebuffer.destroy(), this.tileFramebuffer = null), this.particleFramebuffer && (this.particleFramebuffer.destroy(), this.particleFramebuffer = null)
                }

                onRemove(e) {
                    this.colorRampTexture && this.colorRampTexture.destroy(), this.tileFramebuffer && this.tileFramebuffer.destroy(), this.particleFramebuffer && this.particleFramebuffer.destroy()
                }

                hasColorMap() {
                    return !!this._transitionablePaint._values["raster-particle-color"].value.value
                }

                getProgramIds() {
                    return ["rasterParticle"]
                }

                hasOffscreenPass() {
                    return this.visibility !== "none"
                }

                isDraped(e) {
                    return !1
                }

                _handleSpecialPaintPropertyUpdate(e) {
                    e !== "raster-particle-color" && e !== "raster-particle-max-speed" || (this._updateColorRamp(), this._invalidateAnimationState()), e === "raster-particle-count" && this._invalidateAnimationState()
                }

                _updateColorRamp() {
                    if (!this.hasColorMap()) return;
                    const e = this._transitionablePaint._values["raster-particle-color"].value.expression,
                        i = this._transitionablePaint._values["raster-particle-max-speed"].value.expression.evaluate({zoom: 0});
                    this.colorRamp = $m({
                        expression: e,
                        evaluationKey: "rasterParticleSpeed",
                        image: this.colorRamp,
                        clips: [{start: 0, end: i}],
                        resolution: 256
                    }), this.colorRampTexture = null
                }

                _invalidateAnimationState() {
                    this.lastInvalidatedAt = ks.now()
                }

                tileCoverLift() {
                    return this.paint.get("raster-particle-elevation")
                }
            }

            class $3 extends to {
                constructor(e, i) {
                    super(e, {}, i, null), this.implementation = e, e.slot && (this.slot = e.slot)
                }

                is3D(e) {
                    return this.implementation.renderingMode === "3d"
                }

                hasOffscreenPass() {
                    return this.implementation.prerender !== void 0
                }

                isDraped(e) {
                    return this.implementation.renderToTile !== void 0
                }

                shouldRedrape() {
                    return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles()
                }

                recalculate() {
                }

                updateTransitions() {
                }

                hasTransition() {
                    return !1
                }

                serialize() {
                }

                onAdd(e) {
                    this.implementation.onAdd && this.implementation.onAdd(e, e.painter.context.gl)
                }

                onRemove(e) {
                    this.implementation.onRemove && this.implementation.onRemove(e, e.painter.context.gl)
                }
            }

            function yw(n, e, i) {
                const a = [0, 0, 1], c = Yr([]);
                return Va(c, c, i ? -Ai(n) + Math.PI : Ai(n)), fa(c, c, -Ai(e)), wo(a, a, c), Bi(a, a)
            }

            const $A = {None: 0, Model: 1, Symbol: 2, FillExtrusion: 4};

            class S0 {
                constructor(e, i, a, c) {
                    this.message = (e ? `${e}: ` : "") + a, c && (this.identifier = c), i != null && i.__line__ && (this.line = i.__line__)
                }
            }

            function vw(n, e) {
                const i = n.indexOf("://") === -1;
                try {
                    return new URL(n, i && e ? "http://example.com" : void 0), !0
                } catch {
                    return !1
                }
            }

            class HA {
                constructor(e, i) {
                    this.feature = e, this.instancedDataOffset = i, this.instancedDataCount = 0, this.rotation = [0, 0, 0], this.scale = [1, 1, 1], this.translation = [0, 0, 0]
                }
            }

            class qA {
                constructor() {
                    this.instancedDataArray = new sf, this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {}
                }
            }

            class xw {
                constructor(e) {
                    this.zoom = e.zoom, this.canonical = e.canonical, this.layers = e.layers, this.layerIds = this.layers.map(i => i.fqid), this.projection = e.projection, this.index = e.index, this.worldview = e.worldview, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter(i => i.isStateDependent()).map(i => i.id), this.hasPattern = !1, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = {
                        id: null,
                        timestamp: 0
                    }, this.modelUris = [], this.modelsRequested = !1, this.activeReplacements = [], this.replacementUpdateTime = 0, this.styleDefinedModelURLs = e.styleDefinedModelURLs
                }

                updateFootprints(e, i) {
                }

                populate(e, i, a, c) {
                    this.tileToMeter = he(a);
                    const d = this.layers[0]._featureFilter.needGeometry;
                    this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
                    for (const {feature: f, id: _, index: x, sourceLayerIndex: w} of e) {
                        const E = _ ?? (f.properties && f.properties.hasOwnProperty("id") ? f.properties.id : void 0),
                            I = $e(f, d);
                        if (!this.layers[0]._featureFilter.filter(new sn(this.zoom, {worldview: this.worldview}), I, a)) continue;
                        const C = {
                            id: E,
                            sourceLayerIndex: w,
                            index: x,
                            geometry: d ? I.geometry : Te(f, a, c),
                            properties: f.properties,
                            type: f.type,
                            patterns: {}
                        }, z = this.addFeature(C, C.geometry, I);
                        z && i.featureIndex.insert(f, C.geometry, x, w, this.index, this.instancesPerModel[z].instancedDataArray.length, yt / 32)
                    }
                    this.lookup = null
                }

                update(e, i, a, c) {
                    for (const d in this.instancesPerModel) {
                        const f = this.instancesPerModel[d];
                        for (const _ in e) f.idToFeaturesIndex.hasOwnProperty(_) && (this.evaluate(f.features[f.idToFeaturesIndex[_]], e[_], f, !0), this.uploaded = !1)
                    }
                    this.maxHeight = 0
                }

                updateZoomBasedPaintProperties() {
                    if (!this.hasZoomDependentProperties) return !1;
                    let e = !1;
                    for (const i in this.instancesPerModel) {
                        const a = this.instancesPerModel[i];
                        for (const c of a.features) {
                            const d = this.layers[0], f = c.feature, _ = this.canonical,
                                x = d.paint.get("model-rotation").evaluate(f, {}, _),
                                w = d.paint.get("model-scale").evaluate(f, {}, _),
                                E = d.paint.get("model-translation").evaluate(f, {}, _);
                            Xr(c.rotation, x) && Xr(c.scale, w) && Xr(c.translation, E) || (this.evaluate(c, c.featureStates, a, !0), e = !0)
                        }
                    }
                    return e
                }

                updateReplacement(e, i, a, c) {
                    if (i.updateTime === this.replacementUpdateTime) return !1;
                    this.replacementUpdateTime = i.updateTime;
                    const d = i.getReplacementRegionsForTile(e.toUnwrapped(), !0);
                    if (Xy(this.activeReplacements, d)) return !1;
                    this.activeReplacements = d;
                    let f = !1;
                    for (const _ in this.instancesPerModel) {
                        const x = this.instancesPerModel[_], w = x.instancedDataArray;
                        for (const E of x.features) {
                            const I = E.instancedDataOffset, C = E.instancedDataCount;
                            for (let z = 0; z < C; z++) {
                                const L = 16 * (z + I);
                                let F = w.float32[L + 0];
                                const N = F > yt;
                                F = N ? F - yt : F;
                                const H = Math.floor(F), Y = w.float32[L + 1];
                                let X = !1;
                                for (const J of this.activeReplacements) if (!DS(J, a, $A.Model, c) && !(J.min.x > H || H > J.max.x || J.min.y > Y || Y > J.max.y) && (X = L1(FS(H, Y, e.canonical, J.footprintTileId.canonical), J.footprint), X)) break;
                                w.float32[L] = X ? F + yt : F, f = f || X !== N
                            }
                        }
                    }
                    return f
                }

                isEmpty() {
                    for (const e in this.instancesPerModel) if (this.instancesPerModel[e].instancedDataArray.length !== 0) return !1;
                    return !0
                }

                uploadPending() {
                    return !this.uploaded
                }

                upload(e) {
                    if (!this.uploaded) for (const i in this.instancesPerModel) {
                        const a = this.instancesPerModel[i];
                        a.instancedDataArray.length < 0 || a.instancedDataArray.length === 0 || (a.instancedDataBuffer ? a.instancedDataBuffer.updateData(a.instancedDataArray) : a.instancedDataBuffer = e.createVertexBuffer(a.instancedDataArray, Tk.members, !0, void 0, this.instanceCount))
                    }
                    this.uploaded = !0
                }

                destroy() {
                    for (const i in this.instancesPerModel) {
                        const a = this.instancesPerModel[i];
                        a.instancedDataArray.length !== 0 && a.instancedDataBuffer && a.instancedDataBuffer.destroy()
                    }
                    const e = this.layers[0].modelManager;
                    if (e && this.modelUris && this.modelsRequested) for (const i of this.modelUris) e.removeModel(i, "", !0)
                }

                addFeature(e, i, a) {
                    const c = this.layers[0], d = c.layout.get("model-id").evaluate(a, {}, this.canonical);
                    if (!d) return Li(`modelId is not evaluated for layer ${c.id} and it is not going to get rendered.`), d;
                    (vw(d, !1) || this.styleDefinedModelURLs[d] !== void 0) && (this.modelUris.includes(d) || this.modelUris.push(d)), this.instancesPerModel[d] || (this.instancesPerModel[d] = new qA);
                    const f = this.instancesPerModel[d], _ = f.instancedDataArray, x = new HA(a, _.length);
                    for (const w of i) for (const E of w) {
                        if (E.x < 0 || E.x >= yt || E.y < 0 || E.y >= yt) continue;
                        const I = (this.lookupDim - 1) / yt, C = this.lookupDim * (E.y * I | 0) + E.x * I | 0;
                        if (this.lookup) {
                            if (this.lookup[C] !== 0) continue;
                            this.lookup[C] = 1
                        }
                        this.instanceCount++;
                        const z = _.length;
                        _.resize(z + 1), f.instancesEvaluatedElevation.push(0), _.float32[16 * z] = E.x, _.float32[16 * z + 1] = E.y
                    }
                    return x.instancedDataCount = f.instancedDataArray.length - x.instancedDataOffset, x.instancedDataCount > 0 && (e.id && (f.idToFeaturesIndex[e.id] = f.features.length), f.features.push(x), this.evaluate(x, {}, f, !1)), d
                }

                getModelUris() {
                    return this.modelUris
                }

                evaluate(e, i, a, c) {
                    const d = this.layers[0], f = e.feature, _ = this.canonical,
                        x = e.rotation = d.paint.get("model-rotation").evaluate(f, i, _),
                        w = e.scale = d.paint.get("model-scale").evaluate(f, i, _),
                        E = e.translation = d.paint.get("model-translation").evaluate(f, i, _),
                        I = d.paint.get("model-color").evaluate(f, i, _);
                    I.a = d.paint.get("model-color-mix-intensity").evaluate(f, i, _);
                    const C = [];
                    this.maxVerticalOffset < E[2] && (this.maxVerticalOffset = E[2]), this.maxScale = Math.max(Math.max(this.maxScale, w[0]), Math.max(w[1], w[2])), yE(C, x, w);
                    const z = Math.round(100 * I.a) + I.b / 1.05;
                    for (let L = 0; L < e.instancedDataCount; ++L) {
                        const F = e.instancedDataOffset + L, N = 16 * F, H = a.instancedDataArray.float32;
                        let Y = 0;
                        c && (Y = H[N + 6] - a.instancesEvaluatedElevation[F]);
                        const X = 0 | H[N + 1];
                        H[N] = (0 | H[N]) + I.r / 1.05, H[N + 1] = X + I.g / 1.05, H[N + 2] = z, H[N + 3] = 1 / (_.z > 10 ? this.tileToMeter : he(_, X)), H[N + 4] = E[0], H[N + 5] = E[1], H[N + 6] = E[2] + Y, H[N + 7] = C[0], H[N + 8] = C[1], H[N + 9] = C[2], H[N + 10] = C[4], H[N + 11] = C[5], H[N + 12] = C[6], H[N + 13] = C[8], H[N + 14] = C[9], H[N + 15] = C[10], a.instancesEvaluatedElevation[F] = E[2]
                    }
                }
            }

            let WA, ZA;
            Pt(xw, "ModelBucket", {omit: ["layers"]}), Pt(qA, "PerModelAttributes"), Pt(HA, "ModelFeature");

            class Sf {
                constructor(e, i, a) {
                    this._demTile = e, this._dem = this._demTile.dem, this._scale = i, this._offset = a
                }

                static create(e, i, a) {
                    const c = a || e.findDEMTileFor(i);
                    if (!c || !c.dem) return;
                    const d = c.dem, f = c.tileID, _ = 1 << i.canonical.z - f.canonical.z;
                    return new Sf(c, d.dim / yt / _, [(i.canonical.x / _ - f.canonical.x) * d.dim, (i.canonical.y / _ - f.canonical.y) * d.dim])
                }

                tileCoordToPixel(e, i) {
                    const a = i * this._scale + this._offset[1];
                    return new Ze(Math.floor(e * this._scale + this._offset[0]), Math.floor(a))
                }

                getElevationAt(e, i, a, c) {
                    const d = e * this._scale + this._offset[0], f = i * this._scale + this._offset[1],
                        _ = Math.floor(d), x = Math.floor(f), w = this._dem;
                    return c = !!c, a ? qt(qt(w.get(_, x, c), w.get(_, x + 1, c), f - x), qt(w.get(_ + 1, x, c), w.get(_ + 1, x + 1, c), f - x), d - _) : w.get(_, x, c)
                }

                getElevationAtPixel(e, i, a) {
                    return this._dem.get(e, i, !!a)
                }

                getMeterToDEM(e) {
                    return (1 << this._demTile.tileID.canonical.z) * U(1, e) * this._dem.stride
                }
            }

            const ww = new Float32Array(262144), Nh = new Uint8Array(262144);

            function XA(n) {
                let e = 0;
                if (n.meshes) for (const i of n.meshes) e = Math.max(e, i.aabb.max[2]);
                if (n.children) for (const i of n.children) e = Math.max(e, XA(i));
                return e
            }

            function YA(n, e, i) {
                if (n.meshes) for (const a of n.meshes) {
                    if (a.aabb.min[0] === 1 / 0) continue;
                    const c = Ei.applyTransform(a.aabb, n.matrix);
                    i.insert(e, c.min[0], c.min[1], c.max[0], c.max[1])
                }
                if (n.children) for (const a of n.children) YA(a, e, i)
            }

            const KA = ["", "wall", "door", "roof", "window", "lamp", "logo"];

            class QA {
                constructor(e) {
                    this.node = e, this.evaluatedRMEA = [[1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [.4, 1, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1]], this.hiddenByReplacement = !1, this.evaluatedTranslation = [0, 0, 0], this.evaluatedScale = [1, 1, 1], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.cameraCollisionOpacity = 1, this.feature = {
                        type: "Point",
                        id: e.id,
                        geometry: [],
                        properties: {height: XA(e)}
                    }, this.aabb = this._getLocalBounds(), this.state = null
                }

                _getLocalBounds() {
                    if (!this.node.meshes) return new Ei([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
                    if (!this.aabb) {
                        let e = 0;
                        const i = new Ei([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
                        for (const a of this.node.meshes) this.node.lightMeshIndex !== e && (a.transformedAabb = Ei.applyTransformFast(a.aabb, this.node.matrix), i.encapsulate(a.transformedAabb)), e++;
                        this.aabb = i
                    }
                    return this.aabb
                }
            }

            class E0 {
                constructor(e, i, a, c, d, f, _, x) {
                    this.id = a, this.layers = e, this.layerIds = this.layers.map(w => w.fqid), this.stateDependentLayerIds = this.layers.filter(w => w.isStateDependent()).map(w => w.id), this.modelTraits |= yf.CoordinateSpaceTile, this.uploaded = !1, this.hasPattern = !1, c && (this.modelTraits |= yf.HasMapboxMeshFeatures), d && (this.modelTraits |= yf.HasMeshoptCompression), this.zoom = -1, this.terrainExaggeration = 1, this.projection = {name: "mercator"}, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = f, this.worldview = x, this.dirty = !0, this.needsUpload = !1, this.filter = null, this.nodesInfo = [];
                    for (const w of i) this.nodesInfo.push(new QA(w)), YA(w, _.featureIndexArray.length, _.grid), _.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, _.bucketLayerIDs.length - 1, 0);
                    this.states = {}
                }

                updateFootprints(e, i) {
                    for (const a of this.getNodesInfo()) {
                        const c = a.node;
                        c.footprint && i.push({footprint: c.footprint, id: e})
                    }
                }

                update(e) {
                    const i = Object.keys(e).length !== 0;
                    if (i && !this.stateDependentLayers.length) return;
                    const a = i ? this.stateDependentLayers : this.layers;
                    if (!xn(e, this.states)) for (const c of a) this.evaluate(c, e);
                    this.states = structuredClone(e)
                }

                populate() {
                    console.log("populate 3D model bucket")
                }

                uploadPending() {
                    return !this.uploaded || this.needsUpload
                }

                upload(e) {
                    if (!this.needsUpload) return;
                    const i = this.getNodesInfo();
                    for (const a of i) {
                        const c = a.node;
                        this.uploaded ? this.updatePbrBuffer(c) : X1(c, e, !0)
                    }
                    for (const a of i) o0(a.node);
                    this.uploaded = !0, this.needsUpload = !1
                }

                updatePbrBuffer(e) {
                    let i = !1;
                    if (!e.meshes) return i;
                    for (const a of e.meshes) a.pbrBuffer && (a.pbrBuffer.updateData(a.featureArray), i = !0);
                    return i
                }

                needsReEvaluation(e, i, a) {
                    const c = e.transform.projectionOptions, d = e.style.getBrightness(), f = this.brightness !== d;
                    if (!this.uploaded || this.dirty || c.name !== this.projection.name || vg(a.paint.get("model-color").value, f) || vg(a.paint.get("model-color-mix-intensity").value, f) || vg(a.paint.get("model-roughness").value, f) || vg(a.paint.get("model-emissive-strength").value, f) || vg(a.paint.get("model-height-based-emissive-strength-multiplier").value, f)) {
                        this.projection = c, this.brightness = d;
                        const _ = this.getNodesInfo();
                        for (const x of _) x.state = null;
                        return !0
                    }
                    return !1
                }

                evaluateTransform(e, i) {
                    if (e.transform.zoom === this.zoom) return;
                    this.zoom = e.transform.zoom;
                    const a = this.getNodesInfo(), c = this.id.canonical;
                    for (const d of a) {
                        const f = d.feature;
                        d.evaluatedTranslation = i.paint.get("model-translation").evaluate(f, {}, c), d.evaluatedScale = i.paint.get("model-scale").evaluate(f, {}, c)
                    }
                }

                evaluate(e, i) {
                    const a = this.getNodesInfo();
                    for (const c of a) {
                        if (!c.node.meshes) continue;
                        const d = c.feature, f = i && i[d.id];
                        if (xn(f, c.state)) continue;
                        c.state = structuredClone(f);
                        const _ = c.node.meshes && c.node.meshes[0].featureData, x = c.evaluatedColor[2],
                            w = c.evaluatedRMEA[2], E = this.id.canonical;
                        if (c.hasTranslucentParts = !1, _) {
                            for (let I = 0; I < KA.length; I++) {
                                const C = KA[I];
                                C.length && (d.properties.part = C);
                                const z = e.paint.get("model-color").evaluate(d, f, E).toPremultipliedRenderColor(null),
                                    L = e.paint.get("model-color-mix-intensity").evaluate(d, f, E);
                                c.evaluatedColor[I] = [z.r, z.g, z.b, L], c.evaluatedRMEA[I][0] = e.paint.get("model-roughness").evaluate(d, f, E), c.evaluatedRMEA[I][2] = e.paint.get("model-emissive-strength").evaluate(d, f, E), c.evaluatedRMEA[I][3] = z.a, c.emissionHeightBasedParams[I] = e.paint.get("model-height-based-emissive-strength-multiplier").evaluate(d, f, E), !c.hasTranslucentParts && z.a < 1 && (c.hasTranslucentParts = !0)
                            }
                            delete d.properties.part, q3(c, x !== c.evaluatedColor[2] || w !== c.evaluatedRMEA[2], this.modelTraits)
                        } else c.evaluatedRMEA[0][2] = e.paint.get("model-emissive-strength").evaluate(d, f, E);
                        c.evaluatedTranslation = e.paint.get("model-translation").evaluate(d, f, E), c.evaluatedScale = e.paint.get("model-scale").evaluate(d, f, E), this.updatePbrBuffer(c.node) || (this.needsUpload = !0)
                    }
                    this.dirty = !1
                }

                elevationUpdate(e, i, a, c) {
                    const d = e.findDEMTileFor(a);
                    if (d && (d.tileID.canonical !== this.terrainTile || i !== this.terrainExaggeration)) {
                        if (d.dem && d.tileID.overscaledZ !== this.elevationReadFromZ) {
                            this.elevationReadFromZ = d.tileID.overscaledZ;
                            const f = Sf.create(e, a, d);
                            if (!f) return;
                            this.modelTraits & yf.HasMapboxMeshFeatures && this.updateDEM(e, f, a, c);
                            for (const _ of this.getNodesInfo()) {
                                const x = _.node;
                                if (!x.footprint || !x.footprint.vertices || !x.footprint.vertices.length) continue;
                                const w = x.footprint.vertices;
                                let E = f.getElevationAt(w[0].x, w[0].y, !0, !0);
                                for (let I = 1; I < w.length; I++) E = Math.min(E, f.getElevationAt(w[I].x, w[I].y, !0, !0));
                                x.elevation = E
                            }
                        }
                        this.terrainTile = d.tileID.canonical, this.terrainExaggeration = i
                    }
                }

                updateDEM(e, i, a, c) {
                    let d = i._dem._modifiedForSources[c];
                    if (d === void 0 && (i._dem._modifiedForSources[c] = [], d = i._dem._modifiedForSources[c]), d.includes(a.canonical)) return;
                    const f = i._dem.dim;
                    d.push(a.canonical);
                    let _ = !1;
                    for (const x of this.getNodesInfo()) {
                        const w = x.node;
                        if (!w.footprint || !w.footprint.grid) continue;
                        const E = w.footprint.grid, I = i.tileCoordToPixel(E.min.x, E.min.y),
                            C = i.tileCoordToPixel(E.max.x, E.max.y),
                            z = Math.min(Math.min(f - C.y, I.x), Math.min(I.y, f - C.x));
                        if (z < 0) continue;
                        const L = se(z, 2, 5);
                        let F = Math.max(0, I.x - L), N = Math.max(0, I.y - L), H = Math.min(C.x + L, f - 1),
                            Y = Math.min(C.y + L, f - 1);
                        for (let ge = N; ge <= Y; ++ge) for (let ye = F; ye <= H; ++ye) Nh[ge * f + ye] = 255;
                        let X = 0, J = 0;
                        for (let ge = 0; ge < E.cellsY; ++ge) for (let ye = 0; ye < E.cellsX; ++ye) {
                            if (!E.cells[ge * E.cellsX + ye]) continue;
                            const Ee = i.tileCoordToPixel(E.min.x + ye / E.xScale, E.min.y + ge / E.yScale),
                                Ie = i.tileCoordToPixel(E.min.x + (ye + 1) / E.xScale, E.min.y + (ge + 1) / E.yScale);
                            for (let We = Ee.y; We <= Math.min(Ie.y + 1, f - 1); ++We) for (let De = Ee.x; De <= Math.min(Ie.x + 1, f - 1); ++De) Nh[We * f + De] === 255 && (Nh[We * f + De] = 0, X += i.getElevationAtPixel(De, We), J++)
                        }
                        const xe = X / J;
                        F = Math.max(1, I.x - L), N = Math.max(1, I.y - L), H = Math.min(C.x + L, f - 2), Y = Math.min(C.y + L, f - 2), _ = !0;
                        for (let ge = N; ge <= Y; ++ge) for (let ye = F; ye <= H; ++ye) Nh[ge * f + ye] === 0 && (ww[ge * f + ye] = i._dem.set(ye, ge, xe));
                        for (let ge = 1; ge < L; ++ge) {
                            F = Math.max(1, I.x - ge), N = Math.max(1, I.y - ge), H = Math.min(C.x + ge, f - 2), Y = Math.min(C.y + ge, f - 2);
                            for (let ye = N; ye <= Y; ++ye) for (let Ee = F; Ee <= H; ++Ee) {
                                const Ie = ye * f + Ee;
                                if (Nh[Ie] === 255) {
                                    let We = 0, De = 0, Ye = -1, ht = -1;
                                    for (let Qe = -1; Qe <= 1; ++Qe) for (let ot = -1; ot <= 1; ++ot) {
                                        const ct = (ye + Qe) * f + Ee + ot;
                                        if (Nh[ct] >= ge) continue;
                                        const He = ww[ct], st = Math.abs(He);
                                        st > De && (We = He, De = st, Ye = ot, ht = Qe)
                                    }
                                    if (De > .1) {
                                        const Qe = 1 - (ge + .5 * Math.abs(Ye * ht)) / L;
                                        let ot = i._dem.get(Ee, ye) + We * Qe;
                                        const ct = i._dem.get(Ee + Ye, ye + ht), He = i._dem.get(Ee - Ye, ye - ht, !0);
                                        (ot - ct) * (ot - He) > 0 && (ot = (ct + He) / 2), ww[Ie] = i._dem.set(Ee, ye, ot), Nh[Ie] = ge
                                    }
                                }
                            }
                        }
                    }
                    _ && (i._demTile.needsDEMTextureUpload = !0, i._dem._timestamp = ks.now())
                }

                setFilter(e) {
                    this.filter = e ? Bc(e) : null
                }

                getNodesInfo() {
                    return this.filter ? this.nodesInfo.filter(e => this.filter.filter(new sn(this.id.overscaledZ, {worldview: this.worldview}), e.feature, this.id.canonical)) : this.nodesInfo
                }

                destroy() {
                    const e = this.getNodesInfo();
                    for (const i of e) o0(i.node), Y1(i.node)
                }

                isEmpty() {
                    return !this.nodesInfo.length
                }

                updateReplacement(e, i) {
                    if (i.updateTime === this.replacementUpdateTime) return;
                    this.replacementUpdateTime = i.updateTime;
                    const a = i.getReplacementRegionsForTile(e.toUnwrapped());
                    for (const c of this.getNodesInfo()) {
                        const d = c.node.footprint;
                        c.hiddenByReplacement = !!d && !a.find(f => f.footprint === d)
                    }
                }

                getHeightAtTileCoord(e, i) {
                    const a = [], c = [0, 0, 0], d = fe([]);
                    for (const f of this.getNodesInfo()) {
                        const _ = f.node.meshes[0], x = _.transformedAabb;
                        if (e < x.min[0] || i < x.min[1] || e > x.max[0] || i > x.max[1]) continue;
                        if (f.node.hidden === !0) return {
                            height: 1 / 0,
                            maxHeight: f.feature.properties.height,
                            hidden: !1,
                            verticalScale: f.evaluatedScale[2]
                        };
                        Me(d, f.node.matrix), c[0] = e, c[1] = i, An(c, c, d);
                        const w = (c[0] - _.aabb.min[0]) / (_.aabb.max[0] - _.aabb.min[0]) * Oh | 0,
                            E = Math.min(63, (c[1] - _.aabb.min[1]) / (_.aabb.max[1] - _.aabb.min[1]) * Oh | 0) * Oh + Math.min(63, w),
                            I = _.heightmap[E];
                        if (!(I < 0 && f.node.footprint)) return f.hiddenByReplacement ? void 0 : {
                            height: I,
                            maxHeight: f.feature.properties.height,
                            hidden: !1,
                            verticalScale: f.evaluatedScale[2]
                        };
                        if (f.node.footprint.grid.query(new Ze(e, i), new Ze(e, i), a), a.length > 0) return {
                            height: void 0,
                            maxHeight: f.feature.properties.height,
                            hidden: f.hiddenByReplacement,
                            verticalScale: f.evaluatedScale[2]
                        }
                    }
                }
            }

            function vg(n, e) {
                return n instanceof Hd && !n.isLightConstant && e
            }

            function H3(n, e, i, a, c, d, f, _) {
                let x = (61440 & e | (61440 & e) >> 4) >> 8, w = (3840 & e | (3840 & e) >> 4) >> 4,
                    E = 240 & e | (240 & e) >> 4;
                i[3] > 0 && (x = qt(x, 255 * i[0], i[3]), w = qt(w, 255 * i[1], i[3]), E = qt(E, 255 * i[2], i[3]));
                const I = x << 8 | w, C = E << 8 | Math.floor(255 * a[3]), z = function (ge) {
                        const ye = se(ge, 0, 2);
                        return Math.min(Math.round(.5 * ye * 255), 255)
                    }(a[2]) << 8 | 15 * a[0] << 4 | 15 * a[1], L = se(c[0], 0, 1), F = se(c[1], 0, 1), N = se(c[2], 0, 1),
                    H = se(c[3], 0, 1);
                let Y, X, J, xe;
                if (L !== F && f !== d && F !== L) {
                    const ge = f - d;
                    X = 1 / (ge * (F - L)), J = -(d + ge * L) / (ge * (F - L));
                    const ye = se(c[4], -1, 1);
                    xe = Math.pow(10, ye), Y = 255 * N << 8 | 255 * H
                } else Y = 65535, X = 0, J = 1, xe = 1;
                if (n.emplaceBack(I, C, z, Y, X, J, xe), _) {
                    const ge = _.length;
                    _.clear();
                    for (let ye = 0; ye < ge; ye++) _.emplaceBack(I, C, z, Y, X, J, xe)
                }
            }

            function q3(n, e, i) {
                const a = n.node;
                let c = 0;
                const d = i & yf.HasMeshoptCompression;
                for (const f of a.meshes) {
                    if (a.lights && a.lightMeshIndex === c || !f.featureData) continue;
                    f.featureArray = new Zc, f.featureArray.reserve(f.featureData.length);
                    let _ = e;
                    for (const x of f.featureData) {
                        const w = d ? 65535 & x : x >> 16 & 65535, E = d ? x >> 16 & 65535 : 65535 & x,
                            I = (15 & E) < 8 ? 15 & E : 0, C = n.evaluatedRMEA[I], z = n.evaluatedColor[I],
                            L = n.emissionHeightBasedParams[I];
                        let F;
                        if (_ && I === 2 && a.lights && (F = new Zc, F.resize(10 * a.lights.length)), H3(f.featureArray, w, z, C, L, f.aabb.min[2], f.aabb.max[2], F), F && _) {
                            _ = !1;
                            const N = a.meshes[a.lightMeshIndex];
                            N.featureArray = F, N.featureArray._trim()
                        }
                    }
                    f.featureArray._trim(), c++
                }
            }

            function JA(n, e, i, a) {
                const c = 1 << n.z;
                e.lat = Q((a / yt + n.y) / c), e.lng = Z((i / yt + n.x) / c)
            }

            function W3(n, e, i, a) {
                const c = n.getNodesInfo()[e];
                if (!c || c.hiddenByReplacement || !c.node.meshes) return;
                let d = Number.MAX_VALUE;
                const f = c.node, _ = i.tile, x = a.calculatePosMatrix(_.tileID.toUnwrapped(), a.worldSize),
                    w = c.evaluatedScale;
                let E = 0;
                a.elevation && f.elevation && (E = f.elevation * a.elevation.exaggeration()), le(x, x, [(f.anchor ? f.anchor[0] : 0) * (w[0] - 1), (f.anchor ? f.anchor[1] : 0) * (w[1] - 1), E]), be(x, x, w);
                const I = i.queryGeometry, C = I.isPointQuery() ? I.screenBounds : I.screenGeometry, z = function (F) {
                    const N = pe([], x, F.matrix);
                    pe(N, a.expandedFarZProjMatrix, N);
                    for (let H = 0; H < F.meshes.length; ++H) {
                        const Y = F.meshes[H];
                        if (H === F.lightMeshIndex) continue;
                        const X = vE(C, a, N, Y.aabb);
                        X != null && (d = Math.min(X, d))
                    }
                    if (F.children) for (const H of F.children) z(H)
                };
                if (z(f), d === Number.MAX_VALUE) return;
                const L = new M(0, 0);
                return JA(_.tileID.canonical, L, c.node.anchor[0], c.node.anchor[1]), {
                    intersectionZ: d,
                    position: L,
                    feature: c.feature
                }
            }

            Pt(E0, "Tiled3dModelBucket", {omit: ["layers"]}), Pt(QA, "Tiled3dModelFeature");
            const Z3 = {
                    circle: class extends to {
                        constructor(n, e, i, a) {
                            super(n, {
                                layout: dl || (dl = new qn({
                                    "circle-sort-key": new Tt(ze.layout_circle["circle-sort-key"]),
                                    "circle-elevation-reference": new dt(ze.layout_circle["circle-elevation-reference"]),
                                    visibility: new dt(ze.layout_circle.visibility)
                                })),
                                paint: Kc || (Kc = new qn({
                                    "circle-radius": new Tt(ze.paint_circle["circle-radius"]),
                                    "circle-color": new Tt(ze.paint_circle["circle-color"]),
                                    "circle-blur": new Tt(ze.paint_circle["circle-blur"]),
                                    "circle-opacity": new Tt(ze.paint_circle["circle-opacity"]),
                                    "circle-translate": new dt(ze.paint_circle["circle-translate"]),
                                    "circle-translate-anchor": new dt(ze.paint_circle["circle-translate-anchor"]),
                                    "circle-pitch-scale": new dt(ze.paint_circle["circle-pitch-scale"]),
                                    "circle-pitch-alignment": new dt(ze.paint_circle["circle-pitch-alignment"]),
                                    "circle-stroke-width": new Tt(ze.paint_circle["circle-stroke-width"]),
                                    "circle-stroke-color": new Tt(ze.paint_circle["circle-stroke-color"]),
                                    "circle-stroke-opacity": new Tt(ze.paint_circle["circle-stroke-opacity"]),
                                    "circle-emissive-strength": new dt(ze.paint_circle["circle-emissive-strength"]),
                                    "circle-color-use-theme": new Tt({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    }),
                                    "circle-stroke-color-use-theme": new Tt({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    })
                                }))
                            }, e, i, a)
                        }

                        createBucket(n) {
                            return new Yi(n)
                        }

                        queryRadius(n) {
                            const e = n;
                            return zr("circle-radius", this, e) + zr("circle-stroke-width", this, e) + Kn(this.paint.get("circle-translate"))
                        }

                        queryIntersectsFeature(n, e, i, a, c, d, f, _) {
                            const x = Yl(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), d.angle, n.pixelToTileUnitsFactor),
                                w = this.paint.get("circle-radius").evaluate(e, i) + this.paint.get("circle-stroke-width").evaluate(e, i);
                            return sS(n, a, d, f, _, this.paint.get("circle-pitch-alignment") === "map", this.paint.get("circle-pitch-scale") === "map", x, w)
                        }

                        getProgramIds() {
                            return ["circle"]
                        }

                        getDefaultProgramParams(n, e, i) {
                            const a = oS(this);
                            return {config: new go(this, {zoom: e, lut: i}), defines: a, overrideFog: !1}
                        }

                        is3D(n) {
                            return !n && !!this.layout && this.layout.get("circle-elevation-reference") !== "none"
                        }

                        hasElevation() {
                            return this.layout && this.layout.get("circle-elevation-reference") !== "none"
                        }
                    }, heatmap: class extends to {
                        createBucket(n) {
                            return new lS(n)
                        }

                        constructor(n, e, i, a) {
                            super(n, {
                                layout: cS || (cS = new qn({visibility: new dt(ze.layout_heatmap.visibility)})),
                                paint: uS || (uS = new qn({
                                    "heatmap-radius": new Tt(ze.paint_heatmap["heatmap-radius"]),
                                    "heatmap-weight": new Tt(ze.paint_heatmap["heatmap-weight"]),
                                    "heatmap-intensity": new dt(ze.paint_heatmap["heatmap-intensity"]),
                                    "heatmap-color": new Fc(ze.paint_heatmap["heatmap-color"]),
                                    "heatmap-opacity": new dt(ze.paint_heatmap["heatmap-opacity"]),
                                    "heatmap-color-use-theme": new Tt({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    })
                                }))
                            }, e, i, a), this._updateColorRamp()
                        }

                        _handleSpecialPaintPropertyUpdate(n) {
                            n === "heatmap-color" && this._updateColorRamp()
                        }

                        _updateColorRamp() {
                            this.colorRamp = $m({
                                expression: this._transitionablePaint._values["heatmap-color"].value.expression,
                                evaluationKey: "heatmapDensity",
                                image: this.colorRamp
                            }), this.colorRampTexture = null
                        }

                        resize() {
                            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null)
                        }

                        _clear() {
                            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null)
                        }

                        queryRadius(n) {
                            return zr("heatmap-radius", this, n)
                        }

                        queryIntersectsFeature(n, e, i, a, c, d, f, _) {
                            const x = this.paint.get("heatmap-radius").evaluate(e, i);
                            return sS(n, a, d, f, _, !0, !0, new Ze(0, 0), x)
                        }

                        hasOffscreenPass() {
                            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none"
                        }

                        getProgramIds() {
                            return ["heatmap", "heatmapTexture"]
                        }

                        getDefaultProgramParams(n, e, i) {
                            return n === "heatmap" ? {config: new go(this, {zoom: e, lut: i}), overrideFog: !1} : {}
                        }
                    }, hillshade: class extends to {
                        constructor(n, e, i, a) {
                            super(n, {
                                layout: hS || (hS = new qn({visibility: new dt(ze.layout_hillshade.visibility)})),
                                paint: dS || (dS = new qn({
                                    "hillshade-illumination-direction": new dt(ze.paint_hillshade["hillshade-illumination-direction"]),
                                    "hillshade-illumination-anchor": new dt(ze.paint_hillshade["hillshade-illumination-anchor"]),
                                    "hillshade-exaggeration": new dt(ze.paint_hillshade["hillshade-exaggeration"]),
                                    "hillshade-shadow-color": new dt(ze.paint_hillshade["hillshade-shadow-color"]),
                                    "hillshade-highlight-color": new dt(ze.paint_hillshade["hillshade-highlight-color"]),
                                    "hillshade-accent-color": new dt(ze.paint_hillshade["hillshade-accent-color"]),
                                    "hillshade-emissive-strength": new dt(ze.paint_hillshade["hillshade-emissive-strength"]),
                                    "hillshade-shadow-color-use-theme": new Tt({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    }),
                                    "hillshade-highlight-color-use-theme": new Tt({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    }),
                                    "hillshade-accent-color-use-theme": new Tt({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    })
                                }))
                            }, e, i, a)
                        }

                        shouldRedrape() {
                            return this.hasOffscreenPass() && this.paint.get("hillshade-illumination-anchor") === "viewport"
                        }

                        hasOffscreenPass() {
                            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none"
                        }

                        getProgramIds() {
                            return ["hillshade", "hillshadePrepare"]
                        }

                        getDefaultProgramParams(n, e, i) {
                            return {overrideFog: !1}
                        }
                    }, fill: class extends to {
                        constructor(n, e, i, a) {
                            super(n, {
                                layout: IS || (IS = new qn({
                                    "fill-sort-key": new Tt(ze.layout_fill["fill-sort-key"]),
                                    visibility: new dt(ze.layout_fill.visibility),
                                    "fill-elevation-reference": new dt(ze.layout_fill["fill-elevation-reference"]),
                                    "fill-construct-bridge-guard-rail": new Tt(ze.layout_fill["fill-construct-bridge-guard-rail"])
                                })), paint: CS || (CS = new qn({
                                    "fill-antialias": new dt(ze.paint_fill["fill-antialias"]),
                                    "fill-opacity": new Tt(ze.paint_fill["fill-opacity"]),
                                    "fill-color": new Tt(ze.paint_fill["fill-color"]),
                                    "fill-outline-color": new Tt(ze.paint_fill["fill-outline-color"]),
                                    "fill-translate": new dt(ze.paint_fill["fill-translate"]),
                                    "fill-translate-anchor": new dt(ze.paint_fill["fill-translate-anchor"]),
                                    "fill-pattern": new Tt(ze.paint_fill["fill-pattern"]),
                                    "fill-pattern-cross-fade": new dt(ze.paint_fill["fill-pattern-cross-fade"]),
                                    "fill-emissive-strength": new dt(ze.paint_fill["fill-emissive-strength"]),
                                    "fill-z-offset": new Tt(ze.paint_fill["fill-z-offset"]),
                                    "fill-bridge-guard-rail-color": new Tt(ze.paint_fill["fill-bridge-guard-rail-color"]),
                                    "fill-tunnel-structure-color": new Tt(ze.paint_fill["fill-tunnel-structure-color"]),
                                    "fill-color-use-theme": new Tt({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    }),
                                    "fill-outline-color-use-theme": new Tt({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    }),
                                    "fill-bridge-guard-rail-color-use-theme": new Tt({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    }),
                                    "fill-tunnel-structure-color-use-theme": new Tt({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    })
                                }))
                            }, e, i, a)
                        }

                        getProgramIds() {
                            const n = this.paint.get("fill-pattern"), e = n && n.constantOr(1),
                                i = [e ? "fillPattern" : "fill"];
                            return this.paint.get("fill-antialias") && i.push(e && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), i
                        }

                        getDefaultProgramParams(n, e, i) {
                            return {config: new go(this, {zoom: e, lut: i}), overrideFog: !1}
                        }

                        recalculate(n, e) {
                            super.recalculate(n, e);
                            const i = this.paint._values["fill-outline-color"];
                            i.value.kind === "constant" && i.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
                        }

                        createBucket(n) {
                            return new R1(n)
                        }

                        queryRadius() {
                            return Kn(this.paint.get("fill-translate"))
                        }

                        queryIntersectsFeature(n, e, i, a, c, d) {
                            return !n.queryGeometry.isAboveHorizon && er(is(n.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), d.angle, n.pixelToTileUnitsFactor), a)
                        }

                        isTileClipped() {
                            return this.paint.get("fill-z-offset").constantOr(1) === 0
                        }

                        is3D(n) {
                            if (this.paint.get("fill-z-offset").constantOr(1) !== 0) return !0;
                            const e = this.layout && this.layout.get("fill-elevation-reference") !== "none";
                            return n != null ? e && !n : e
                        }

                        hasElevation() {
                            return this.layout && this.layout.get("fill-elevation-reference") !== "none"
                        }

                        hasShadowPass() {
                            return this.layout && this.layout.get("fill-elevation-reference") !== "none"
                        }
                    }, "fill-extrusion": class extends to {
                        constructor(n, e, i, a) {
                            super(n, {
                                layout: KS || (KS = new qn({
                                    visibility: new dt(ze["layout_fill-extrusion"].visibility),
                                    "fill-extrusion-edge-radius": new dt(ze["layout_fill-extrusion"]["fill-extrusion-edge-radius"])
                                })), paint: QS || (QS = new qn({
                                    "fill-extrusion-opacity": new dt(ze["paint_fill-extrusion"]["fill-extrusion-opacity"]),
                                    "fill-extrusion-color": new Tt(ze["paint_fill-extrusion"]["fill-extrusion-color"]),
                                    "fill-extrusion-translate": new dt(ze["paint_fill-extrusion"]["fill-extrusion-translate"]),
                                    "fill-extrusion-translate-anchor": new dt(ze["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
                                    "fill-extrusion-pattern": new Tt(ze["paint_fill-extrusion"]["fill-extrusion-pattern"]),
                                    "fill-extrusion-pattern-cross-fade": new dt(ze["paint_fill-extrusion"]["fill-extrusion-pattern-cross-fade"]),
                                    "fill-extrusion-height": new Tt(ze["paint_fill-extrusion"]["fill-extrusion-height"]),
                                    "fill-extrusion-base": new Tt(ze["paint_fill-extrusion"]["fill-extrusion-base"]),
                                    "fill-extrusion-height-alignment": new dt(ze["paint_fill-extrusion"]["fill-extrusion-height-alignment"]),
                                    "fill-extrusion-base-alignment": new dt(ze["paint_fill-extrusion"]["fill-extrusion-base-alignment"]),
                                    "fill-extrusion-vertical-gradient": new dt(ze["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]),
                                    "fill-extrusion-ambient-occlusion-intensity": new dt(ze["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]),
                                    "fill-extrusion-ambient-occlusion-radius": new dt(ze["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]),
                                    "fill-extrusion-ambient-occlusion-wall-radius": new dt(ze["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]),
                                    "fill-extrusion-ambient-occlusion-ground-radius": new dt(ze["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]),
                                    "fill-extrusion-ambient-occlusion-ground-attenuation": new dt(ze["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]),
                                    "fill-extrusion-flood-light-color": new dt(ze["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]),
                                    "fill-extrusion-flood-light-intensity": new dt(ze["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]),
                                    "fill-extrusion-flood-light-wall-radius": new Tt(ze["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]),
                                    "fill-extrusion-flood-light-ground-radius": new Tt(ze["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]),
                                    "fill-extrusion-flood-light-ground-attenuation": new dt(ze["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]),
                                    "fill-extrusion-vertical-scale": new dt(ze["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]),
                                    "fill-extrusion-rounded-roof": new dt(ze["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]),
                                    "fill-extrusion-cutoff-fade-range": new dt(ze["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]),
                                    "fill-extrusion-emissive-strength": new Tt(ze["paint_fill-extrusion"]["fill-extrusion-emissive-strength"]),
                                    "fill-extrusion-line-width": new Tt(ze["paint_fill-extrusion"]["fill-extrusion-line-width"]),
                                    "fill-extrusion-cast-shadows": new dt(ze["paint_fill-extrusion"]["fill-extrusion-cast-shadows"]),
                                    "fill-extrusion-color-use-theme": new Tt({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    }),
                                    "fill-extrusion-flood-light-color-use-theme": new Tt({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    })
                                }))
                            }, e, i, a), this._stats = {
                                numRenderedVerticesInShadowPass: 0,
                                numRenderedVerticesInTransparentPass: 0
                            }
                        }

                        createBucket(n) {
                            return new Ky(n)
                        }

                        queryRadius() {
                            return Kn(this.paint.get("fill-extrusion-translate"))
                        }

                        is3D(n) {
                            return !0
                        }

                        hasShadowPass() {
                            return this.paint.get("fill-extrusion-cast-shadows")
                        }

                        cutoffRange() {
                            return this.paint.get("fill-extrusion-cutoff-fade-range")
                        }

                        canCastShadows() {
                            return !0
                        }

                        getProgramIds() {
                            return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"]
                        }

                        queryIntersectsFeature(n, e, i, a, c, d, f, _, x) {
                            const w = Yl(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), d.angle, n.pixelToTileUnitsFactor),
                                E = this.paint.get("fill-extrusion-height").evaluate(e, i),
                                I = this.paint.get("fill-extrusion-base").evaluate(e, i), C = [0, 0], z = _ && d.elevation,
                                L = d.elevation ? d.elevation.exaggeration() : 1, F = n.tile.getBucket(this);
                            if (z && F instanceof Ky) {
                                const J = F.centroidVertexArray, xe = x + 1;
                                xe < J.length && (C[0] = J.geta_centroid_pos0(xe), C[1] = J.geta_centroid_pos1(xe))
                            }
                            if (C[0] === 0 && C[1] === 1) return !1;
                            d.projection.name === "globe" && (a = YS([a], [new Ze(0, 0), new Ze(yt, yt)], n.tileID.canonical).map(J => J.polygon).flat());
                            const N = z ? _ : null, [H, Y] = function (J, xe, ge, ye, Ee, Ie, We, De, Ye, ht, Qe) {
                                return J.projection.name === "globe" ? function (ot, ct, He, st, ke, qe, pt, at, Bt, zt, nt) {
                                    const lt = [], kt = [],
                                        Et = ot.projection.upVectorScale(nt, ot.center.lat, ot.worldSize).metersToTile,
                                        vt = [0, 0, 0, 1], At = [0, 0, 0, 1], Kt = (pi, ui, ki, bi) => {
                                            pi[0] = ui, pi[1] = ki, pi[2] = bi, pi[3] = 1
                                        }, oi = XS();
                                    He > 0 && (He += oi), st += oi;
                                    for (const pi of ct) {
                                        const ui = [], ki = [];
                                        for (const bi of pi) {
                                            const Tn = bi.x + ke.x, ne = bi.y + ke.y,
                                                re = ot.projection.projectTilePoint(Tn, ne, nt),
                                                Ge = ot.projection.upVector(nt, bi.x, bi.y);
                                            let mt = He, bt = st;
                                            if (pt) {
                                                const wt = rE(Tn, ne, He, st, pt, at, Bt, zt);
                                                mt += wt.base, bt += wt.top
                                            }
                                            He !== 0 ? Kt(vt, re.x + Ge[0] * Et * mt, re.y + Ge[1] * Et * mt, re.z + Ge[2] * Et * mt) : Kt(vt, re.x, re.y, re.z), Kt(At, re.x + Ge[0] * Et * bt, re.y + Ge[1] * Et * bt, re.z + Ge[2] * Et * bt), An(vt, vt, qe), An(At, At, qe), ui.push(new Lh(vt[0], vt[1], vt[2])), ki.push(new Lh(At[0], At[1], At[2]))
                                        }
                                        lt.push(ui), kt.push(ki)
                                    }
                                    return [lt, kt]
                                }(J, xe, ge, ye, Ee, Ie, We, De, Ye, ht, Qe) : We ? function (ot, ct, He, st, ke, qe, pt, at, Bt) {
                                    const zt = [], nt = [], lt = [0, 0, 0, 1];
                                    for (const kt of ot) {
                                        const Et = [], vt = [];
                                        for (const At of kt) {
                                            const Kt = At.x + st.x, oi = At.y + st.y,
                                                pi = rE(Kt, oi, ct, He, qe, pt, at, Bt);
                                            lt[0] = Kt, lt[1] = oi, lt[2] = pi.base, lt[3] = 1, Ir(lt, lt, ke), lt[3] = Math.max(lt[3], 1e-5);
                                            const ui = new Lh(lt[0] / lt[3], lt[1] / lt[3], lt[2] / lt[3]);
                                            lt[0] = Kt, lt[1] = oi, lt[2] = pi.top, lt[3] = 1, Ir(lt, lt, ke), lt[3] = Math.max(lt[3], 1e-5);
                                            const ki = new Lh(lt[0] / lt[3], lt[1] / lt[3], lt[2] / lt[3]);
                                            Et.push(ui), vt.push(ki)
                                        }
                                        zt.push(Et), nt.push(vt)
                                    }
                                    return [zt, nt]
                                }(xe, ge, ye, Ee, Ie, We, De, Ye, ht) : function (ot, ct, He, st, ke) {
                                    const qe = [], pt = [], at = ke[8] * ct, Bt = ke[9] * ct, zt = ke[10] * ct,
                                        nt = ke[11] * ct, lt = ke[8] * He, kt = ke[9] * He, Et = ke[10] * He,
                                        vt = ke[11] * He;
                                    for (const At of ot) {
                                        const Kt = [], oi = [];
                                        for (const pi of At) {
                                            const ui = pi.x + st.x, ki = pi.y + st.y, bi = ke[0] * ui + ke[4] * ki + ke[12],
                                                Tn = ke[1] * ui + ke[5] * ki + ke[13],
                                                ne = ke[2] * ui + ke[6] * ki + ke[14],
                                                re = ke[3] * ui + ke[7] * ki + ke[15], Ge = bi + at, mt = Tn + Bt,
                                                bt = ne + zt, wt = Math.max(re + nt, 1e-5), Lt = bi + lt, ti = Tn + kt,
                                                Ci = ne + Et, Pi = Math.max(re + vt, 1e-5);
                                            Kt.push(new Lh(Ge / wt, mt / wt, bt / wt)), oi.push(new Lh(Lt / Pi, ti / Pi, Ci / Pi))
                                        }
                                        qe.push(Kt), pt.push(oi)
                                    }
                                    return [qe, pt]
                                }(xe, ge, ye, Ee, Ie)
                            }(d, a, I, E, w, f, N, C, L, d.center.lat, n.tileID.canonical), X = n.queryGeometry;
                            return function (J, xe, ge) {
                                let ye = 1 / 0;
                                er(ge, xe) && (ye = nE(ge, xe[0]));
                                for (let Ee = 0; Ee < xe.length; Ee++) {
                                    const Ie = xe[Ee], We = J[Ee];
                                    for (let De = 0; De < Ie.length - 1; De++) {
                                        const Ye = Ie[De], ht = [Ye, Ie[De + 1], We[De + 1], We[De], Ye];
                                        hn(ge, ht) && (ye = Math.min(ye, nE(ge, ht)))
                                    }
                                }
                                return ye !== 1 / 0 && ye
                            }(H, Y, X.isPointQuery() ? X.screenBounds : X.screenGeometry)
                        }
                    }, building: class extends to {
                        constructor(n, e, i, a) {
                            super(n, {
                                layout: CE || (CE = new qn({
                                    visibility: new dt(ze.layout_building.visibility),
                                    "building-facade": new Tt(ze.layout_building["building-facade"]),
                                    "building-facade-floors": new Tt(ze.layout_building["building-facade-floors"]),
                                    "building-facade-window": new Tt(ze.layout_building["building-facade-window"]),
                                    "building-roof-shape": new Tt(ze.layout_building["building-roof-shape"]),
                                    "building-height": new Tt(ze.layout_building["building-height"]),
                                    "building-base": new Tt(ze.layout_building["building-base"])
                                })), paint: PE || (PE = new qn({
                                    "building-opacity": new dt(ze.paint_building["building-opacity"]),
                                    "building-ambient-occlusion-intensity": new dt(ze.paint_building["building-ambient-occlusion-intensity"]),
                                    "building-ambient-occlusion-ground-intensity": new dt(ze.paint_building["building-ambient-occlusion-ground-intensity"]),
                                    "building-ambient-occlusion-ground-radius": new dt(ze.paint_building["building-ambient-occlusion-ground-radius"]),
                                    "building-ambient-occlusion-ground-attenuation": new dt(ze.paint_building["building-ambient-occlusion-ground-attenuation"]),
                                    "building-vertical-scale": new dt(ze.paint_building["building-vertical-scale"]),
                                    "building-cast-shadows": new dt(ze.paint_building["building-cast-shadows"]),
                                    "building-color": new Tt(ze.paint_building["building-color"]),
                                    "building-emissive-strength": new Tt(ze.paint_building["building-emissive-strength"]),
                                    "building-facade-emissive-chance": new dt(ze.paint_building["building-facade-emissive-chance"]),
                                    "building-cutoff-fade-range": new dt(ze.paint_building["building-cutoff-fade-range"]),
                                    "building-color-use-theme": new Tt({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    })
                                }))
                            }, e, i, a), this._stats = {
                                numRenderedVerticesInShadowPass: 0,
                                numRenderedVerticesInTransparentPass: 0
                            }
                        }

                        createBucket(n) {
                            return new IE(n)
                        }

                        hasShadowPass() {
                            return this.paint.get("building-cast-shadows")
                        }

                        hasLightBeamPass() {
                            return !0
                        }

                        canCastShadows() {
                            return !0
                        }

                        is3D(n) {
                            return !0
                        }
                    }, line: class extends to {
                        constructor(n, e, i, a) {
                            const c = NE();
                            super(n, c, e, i, a), c.layout && (this.layout = new Bs(c.layout)), this.gradientVersion = 0, this.hasElevatedBuckets = !1, this.hasNonElevatedBuckets = !1
                        }

                        _handleSpecialPaintPropertyUpdate(n) {
                            if (n === "line-gradient") {
                                const e = this._transitionablePaint._values["line-gradient"].value.expression;
                                this.stepInterpolant = e._styleExpression && e._styleExpression.expression instanceof fh, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
                            }
                        }

                        gradientExpression() {
                            return this._transitionablePaint._values["line-gradient"].value.expression
                        }

                        widthExpression() {
                            return this._transitionablePaint._values["line-width"].value.expression
                        }

                        recalculate(n, e) {
                            super.recalculate(n, e), this.paint._values["line-floorwidth"] = (() => {
                                if (ag) return ag;
                                const i = NE();
                                return ag = new qk(i.paint.properties["line-width"].specification), ag.useIntegerZoom = !0, ag
                            })().possiblyEvaluate(this._transitioningPaint._values["line-width"].value, n)
                        }

                        createBucket(n) {
                            return new J1(n)
                        }

                        getProgramIds() {
                            return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"]
                        }

                        getDefaultProgramParams(n, e, i) {
                            const a = FE(this);
                            return {config: new go(this, {zoom: e, lut: i}), defines: a, overrideFog: !1}
                        }

                        queryRadius(n) {
                            const e = n, i = jE(zr("line-width", this, e), zr("line-gap-width", this, e)),
                                a = zr("line-offset", this, e);
                            return i / 2 + Math.abs(a) + Kn(this.paint.get("line-translate"))
                        }

                        queryIntersectsFeature(n, e, i, a, c, d) {
                            if (n.queryGeometry.isAboveHorizon) return !1;
                            const f = is(n.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), d.angle, n.pixelToTileUnitsFactor),
                                _ = n.pixelToTileUnitsFactor / 2 * jE(this.paint.get("line-width").evaluate(e, i), this.paint.get("line-gap-width").evaluate(e, i)),
                                x = this.paint.get("line-offset").evaluate(e, i);
                            return x && (a = function (w, E) {
                                const I = [], C = new Ze(0, 0);
                                for (let z = 0; z < w.length; z++) {
                                    const L = w[z], F = [];
                                    for (let N = 0; N < L.length; N++) {
                                        const H = L[N], Y = L[N + 1], X = N === 0 ? C : H.sub(L[N - 1])._unit()._perp(),
                                            J = N === L.length - 1 ? C : Y.sub(H)._unit()._perp(), xe = X._add(J)._unit();
                                        xe._mult(1 / (xe.x * J.x + xe.y * J.y)), F.push(xe._mult(E)._add(H))
                                    }
                                    I.push(F)
                                }
                                return I
                            }(a, x * n.pixelToTileUnitsFactor)), function (w, E, I) {
                                for (let C = 0; C < E.length; C++) {
                                    const z = E[C];
                                    if (w.length >= 3) {
                                        for (let L = 0; L < z.length; L++) if (Gr(w, z[L])) return !0
                                    }
                                    if (rr(w, z, I)) return !0
                                }
                                return !1
                            }(f, a, _)
                        }

                        isTileClipped() {
                            return this.hasNonElevatedBuckets
                        }

                        isDraped(n) {
                            return !this.hasElevatedBuckets || this.layout && this.layout.get("line-elevation-reference") === "hd-road-markup"
                        }

                        hasElevation() {
                            return this.layout && this.layout.get("line-elevation-reference") !== "none"
                        }
                    }, symbol: w0, background: class extends to {
                        constructor(n, e, i, a) {
                            super(n, {
                                layout: RA || (RA = new qn({visibility: new dt(ze.layout_background.visibility)})),
                                paint: zA || (zA = new qn({
                                    "background-pitch-alignment": new dt(ze.paint_background["background-pitch-alignment"]),
                                    "background-color": new dt(ze.paint_background["background-color"]),
                                    "background-pattern": new dt(ze.paint_background["background-pattern"]),
                                    "background-opacity": new dt(ze.paint_background["background-opacity"]),
                                    "background-emissive-strength": new dt(ze.paint_background["background-emissive-strength"]),
                                    "background-color-use-theme": new Tt({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    })
                                }))
                            }, e, i, a)
                        }

                        getProgramIds() {
                            return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"]
                        }

                        getDefaultProgramParams(n, e, i) {
                            return {overrideFog: !1}
                        }

                        is3D(n) {
                            return this.paint.get("background-pitch-alignment") === "viewport"
                        }
                    }, raster: FA, "raster-particle": GA, sky: class extends to {
                        constructor(n, e, i, a) {
                            super(n, {
                                layout: jA || (jA = new qn({visibility: new dt(ze.layout_sky.visibility)})),
                                paint: VA || (VA = new qn({
                                    "sky-type": new dt(ze.paint_sky["sky-type"]),
                                    "sky-atmosphere-sun": new dt(ze.paint_sky["sky-atmosphere-sun"]),
                                    "sky-atmosphere-sun-intensity": new dt(ze.paint_sky["sky-atmosphere-sun-intensity"]),
                                    "sky-gradient-center": new dt(ze.paint_sky["sky-gradient-center"]),
                                    "sky-gradient-radius": new dt(ze.paint_sky["sky-gradient-radius"]),
                                    "sky-gradient": new Fc(ze.paint_sky["sky-gradient"]),
                                    "sky-atmosphere-halo-color": new dt(ze.paint_sky["sky-atmosphere-halo-color"]),
                                    "sky-atmosphere-color": new dt(ze.paint_sky["sky-atmosphere-color"]),
                                    "sky-opacity": new dt(ze.paint_sky["sky-opacity"]),
                                    "sky-gradient-use-theme": new Tt({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    }),
                                    "sky-atmosphere-halo-color-use-theme": new Tt({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    }),
                                    "sky-atmosphere-color-use-theme": new Tt({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    })
                                }))
                            }, e, i, a), this._updateColorRamp()
                        }

                        _clear() {
                            this.skyboxFbo && (this.skyboxFbo.destroy(), this.skyboxFbo = null), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null), this._skyboxInvalidated = !0
                        }

                        _handleSpecialPaintPropertyUpdate(n) {
                            n === "sky-gradient" ? this._updateColorRamp() : n !== "sky-atmosphere-sun" && n !== "sky-atmosphere-halo-color" && n !== "sky-atmosphere-color" && n !== "sky-atmosphere-sun-intensity" || (this._skyboxInvalidated = !0)
                        }

                        _updateColorRamp() {
                            this.colorRamp = $m({
                                expression: this._transitionablePaint._values["sky-gradient"].value.expression,
                                evaluationKey: "skyRadialProgress"
                            }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null)
                        }

                        needsSkyboxCapture(n) {
                            if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;
                            if (!this.paint.get("sky-atmosphere-sun")) {
                                const e = n.style.light.properties.get("position");
                                return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar
                            }
                            return !1
                        }

                        getCenter(n, e) {
                            if (this.paint.get("sky-type") === "atmosphere") {
                                const a = this.paint.get("sky-atmosphere-sun"), c = !a, d = n.style.light,
                                    f = d.properties.get("position");
                                return c && d.properties.get("anchor") === "viewport" && Li("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), c ? yw(f.azimuthal, 90 - f.polar, e) : yw(a[0], 90 - a[1], e)
                            }
                            const i = this.paint.get("sky-gradient-center");
                            return yw(i[0], 90 - i[1], e)
                        }

                        isSky() {
                            return !0
                        }

                        markSkyboxValid(n) {
                            this._skyboxInvalidated = !1, this._lightPosition = n.style.light.properties.get("position")
                        }

                        hasOffscreenPass() {
                            return !0
                        }

                        getProgramIds() {
                            const n = this.paint.get("sky-type");
                            return n === "atmosphere" ? ["skyboxCapture", "skybox"] : n === "gradient" ? ["skyboxGradient"] : null
                        }
                    }, slot: class extends to {
                        constructor(n, e, i, a) {
                            super(n, {paint: UA || (UA = new qn({}))}, e, null)
                        }
                    }, model: class extends to {
                        constructor(n, e, i, a) {
                            super(n, {
                                layout: WA || (WA = new qn({
                                    visibility: new dt(ze.layout_model.visibility),
                                    "model-id": new Tt(ze.layout_model["model-id"])
                                })), paint: ZA || (ZA = new qn({
                                    "model-opacity": new Tt(ze.paint_model["model-opacity"]),
                                    "model-rotation": new Tt(ze.paint_model["model-rotation"]),
                                    "model-scale": new Tt(ze.paint_model["model-scale"]),
                                    "model-translation": new Tt(ze.paint_model["model-translation"]),
                                    "model-color": new Tt(ze.paint_model["model-color"]),
                                    "model-color-mix-intensity": new Tt(ze.paint_model["model-color-mix-intensity"]),
                                    "model-type": new dt(ze.paint_model["model-type"]),
                                    "model-cast-shadows": new dt(ze.paint_model["model-cast-shadows"]),
                                    "model-receive-shadows": new dt(ze.paint_model["model-receive-shadows"]),
                                    "model-ambient-occlusion-intensity": new dt(ze.paint_model["model-ambient-occlusion-intensity"]),
                                    "model-emissive-strength": new Tt(ze.paint_model["model-emissive-strength"]),
                                    "model-roughness": new Tt(ze.paint_model["model-roughness"]),
                                    "model-height-based-emissive-strength-multiplier": new Tt(ze.paint_model["model-height-based-emissive-strength-multiplier"]),
                                    "model-cutoff-fade-range": new dt(ze.paint_model["model-cutoff-fade-range"]),
                                    "model-front-cutoff": new dt(ze.paint_model["model-front-cutoff"]),
                                    "model-color-use-theme": new Tt({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-driven"
                                    })
                                }))
                            }, e, i, a), this._stats = {
                                numRenderedVerticesInShadowPass: 0,
                                numRenderedVerticesInTransparentPass: 0
                            }
                        }

                        createBucket(n) {
                            return new xw(n)
                        }

                        getProgramIds() {
                            return ["model"]
                        }

                        is3D(n) {
                            return !0
                        }

                        hasShadowPass() {
                            return !0
                        }

                        canCastShadows() {
                            return !0
                        }

                        hasLightBeamPass() {
                            return !0
                        }

                        cutoffRange() {
                            return this.paint.get("model-cutoff-fade-range")
                        }

                        queryRadius(n) {
                            return n instanceof E0 ? yt - 1 : 0
                        }

                        queryIntersectsFeature(n, e, i, a, c, d) {
                            if (!this.modelManager) return !1;
                            const f = this.modelManager, _ = n.tile.getBucket(this);
                            if (!(_ && _ instanceof xw)) return !1;
                            for (const x in _.instancesPerModel) {
                                const w = _.instancesPerModel[x],
                                    E = e.id !== void 0 ? e.id : e.properties && e.properties.hasOwnProperty("id") ? e.properties.id : void 0;
                                if (w.idToFeaturesIndex.hasOwnProperty(E)) {
                                    const I = w.features[w.idToFeaturesIndex[E]], C = f.getModel(x, this.scope);
                                    if (!C) return !1;
                                    let z = Re();
                                    const L = new M(0, 0), F = _.canonical;
                                    let N = Number.MAX_VALUE;
                                    for (let H = 0; H < I.instancedDataCount; ++H) {
                                        const Y = 16 * (I.instancedDataOffset + H), X = w.instancedDataArray.float32,
                                            J = [X[Y + 4], X[Y + 5], X[Y + 6]];
                                        JA(F, L, X[Y], 0 | X[Y + 1]), xE(z, C, d, L, I.rotation, I.scale, J, !1, !1, !1), d.projection.name === "globe" && (z = Z1(z, d));
                                        const xe = pe([], d.projMatrix, z), ge = n.queryGeometry,
                                            ye = vE(ge.isPointQuery() ? ge.screenBounds : ge.screenGeometry, d, xe, C.aabb);
                                        ye != null && (N = Math.min(ye, N))
                                    }
                                    return N !== Number.MAX_VALUE && N
                                }
                            }
                            return !1
                        }

                        _handleOverridablePaintPropertyUpdate(n, e, i) {
                            return !(!this.layout || e.isDataDriven() || i.isDataDriven() || n !== "model-color" && n !== "model-color-mix-intensity" && n !== "model-rotation" && n !== "model-scale" && n !== "model-translation" && n !== "model-emissive-strength")
                        }

                        _isPropertyZoomDependent(n) {
                            const e = this._transitionablePaint._values[n];
                            return e != null && e.value != null && e.value.expression != null && e.value.expression instanceof ol
                        }

                        isZoomDependent() {
                            return this._isPropertyZoomDependent("model-scale") || this._isPropertyZoomDependent("model-rotation") || this._isPropertyZoomDependent("model-translation")
                        }
                    }, clip: class extends to {
                        constructor(n, e, i, a) {
                            super(n, {
                                layout: PS || (PS = new qn({
                                    "clip-layer-types": new dt(ze.layout_clip["clip-layer-types"]),
                                    "clip-layer-scope": new dt(ze.layout_clip["clip-layer-scope"])
                                })), paint: MS || (MS = new qn({}))
                            }, e, i, a)
                        }

                        recalculate(n, e) {
                            super.recalculate(n, e)
                        }

                        createBucket(n) {
                            return new RS(n)
                        }

                        is3D(n) {
                            return !0
                        }
                    }
                }, bw = new Ji(0, 0, 0), Tw = {PATH_RULE_NON_ZERO: 1, PATH_RULE_EVEN_ODD: 2},
                Sw = {LINE_CAP_BUTT: 1, LINE_CAP_ROUND: 2, LINE_CAP_SQUARE: 3},
                A0 = {LINE_JOIN_MITER: 1, LINE_JOIN_MITER_CLIP: 2, LINE_JOIN_ROUND: 3, LINE_JOIN_BEVEL: 4},
                X3 = {PAINT_ORDER_FILL_AND_STROKE: 1}, xg = {
                    PATH_COMMAND_MOVE: 1,
                    PATH_COMMAND_LINE: 2,
                    PATH_COMMAND_QUAD: 3,
                    PATH_COMMAND_CUBIC: 4,
                    PATH_COMMAND_CLOSE: 5
                }, eI = {MASK_TYPE_LUMINANCE: 1};

            function Y3(n, e, i) {
                n === 1 && e.icons.push(function (a, c) {
                    return function (d) {
                        if (d.usvg_tree.height || (d.usvg_tree.height = d.usvg_tree.width), !d.metadata) return d;
                        const {metadata: f} = d;
                        if (f.content_area) {
                            const {content_area: _} = f;
                            _.top == null && (_.top = _.left), _.width == null && (_.width = d.usvg_tree.width), _.height == null && (_.height = _.width)
                        }
                        return f.stretch_x && f.stretch_x.length && tI(f, "x"), f.stretch_y && f.stretch_y.length && tI(f, "y"), d
                    }(a.readFields(K3, {name: void 0}, c))
                }(i, i.readVarint() + i.pos))
            }

            function tI(n, e) {
                const i = [], a = n[`stretch_${e}`];
                let c = null;
                for (let d = 0; d < a.length; d++) c === null ? c = i.length === 0 ? a[0] : i[i.length - 1][1] + a[d] : (i.push([c, c + a[d]]), c = null);
                n[`stretch_${e}_areas`] = i
            }

            function K3(n, e, i) {
                n === 1 ? e.name = i.readString() : n === 2 ? e.metadata = function (a, c) {
                    return a.readFields(Q3, {
                        stretch_x: null,
                        stretch_y: null,
                        stretch_x_areas: null,
                        stretch_y_areas: null,
                        variables: []
                    }, c)
                }(i, i.readVarint() + i.pos) : n === 3 && (e.usvg_tree = function (a, c) {
                    return a.readFields(tO, {
                        width: 20,
                        children: [],
                        linear_gradients: [],
                        radial_gradients: [],
                        clip_paths: [],
                        masks: []
                    }, c)
                }(i, i.readVarint() + i.pos), e.data = "usvg_tree")
            }

            function Q3(n, e, i) {
                n === 1 ? e.stretch_x = i.readPackedVarint() : n === 2 ? e.stretch_y = i.readPackedVarint() : n === 3 ? e.content_area = function (a, c) {
                    return a.readFields(J3, {left: 0}, c)
                }(i, i.readVarint() + i.pos) : n === 4 && e.variables.push(function (a, c) {
                    return a.readFields(eO, {name: void 0}, c)
                }(i, i.readVarint() + i.pos))
            }

            function J3(n, e, i) {
                n === 1 ? e.left = i.readVarint() : n === 2 ? e.width = i.readVarint() : n === 3 ? e.top = i.readVarint() : n === 4 && (e.height = i.readVarint())
            }

            function eO(n, e, i) {
                n === 1 ? e.name = i.readString() : n === 2 && (e.rgb_color = P0(i.readVarint()), e.value = "rgb_color")
            }

            function tO(n, e, i) {
                n === 1 ? e.width = e.height = i.readVarint() : n === 2 ? e.height = i.readVarint() : n === 3 ? e.children.push(I0(i, i.readVarint() + i.pos)) : n === 4 ? e.linear_gradients.push(function (a, c) {
                    return a.readFields(lO, {spread_method: 1, stops: [], x1: 0, y1: 0, x2: 1, y2: 0}, c)
                }(i, i.readVarint() + i.pos)) : n === 5 ? e.radial_gradients.push(function (a, c) {
                    return a.readFields(uO, {
                        spread_method: 1,
                        stops: [],
                        cx: .5,
                        cy: .5,
                        r: .5,
                        fx: .5,
                        fy: .5,
                        fr: 0
                    }, c)
                }(i, i.readVarint() + i.pos)) : n === 7 ? e.clip_paths.push(function (a, c) {
                    return a.readFields(hO, {children: []}, c)
                }(i, i.readVarint() + i.pos)) : n === 8 && e.masks.push(function (a, c) {
                    const d = a.readFields(dO, {
                        left: 0,
                        width: 20,
                        mask_type: eI.MASK_TYPE_LUMINANCE,
                        children: []
                    }, c);
                    return d.height == null && (d.height = d.width), d.top == null && (d.top = d.left), d
                }(i, i.readVarint() + i.pos))
            }

            function I0(n, e) {
                return n.readFields(iO, {}, e)
            }

            function iO(n, e, i) {
                n === 1 ? (e.group = function (a, c) {
                    return a.readFields(nO, {opacity: 255, children: []}, c)
                }(i, i.readVarint() + i.pos), e.node = "group") : n === 2 && (e.path = function (a, c) {
                    return a.readFields(oO, {
                        paint_order: 1,
                        commands: [],
                        step: 1,
                        diffs: [],
                        rule: Tw.PATH_RULE_NON_ZERO
                    }, c)
                }(i, i.readVarint() + i.pos), e.node = "path")
            }

            function nO(n, e, i) {
                n === 1 ? e.transform = C0(i, i.readVarint() + i.pos) : n === 2 ? e.opacity = i.readVarint() : n === 5 ? e.clip_path_idx = i.readVarint() : n === 6 ? e.mask_idx = i.readVarint() : n === 7 && e.children.push(I0(i, i.readVarint() + i.pos))
            }

            function C0(n, e) {
                return n.readFields(rO, {sx: 1, ky: 0, kx: 0, sy: 1, tx: 0, ty: 0}, e)
            }

            function rO(n, e, i) {
                n === 1 ? e.sx = i.readFloat() : n === 2 ? e.ky = i.readFloat() : n === 3 ? e.kx = i.readFloat() : n === 4 ? e.sy = i.readFloat() : n === 5 ? e.tx = i.readFloat() : n === 6 && (e.ty = i.readFloat())
            }

            function oO(n, e, i) {
                n === 1 ? e.fill = function (a, c) {
                    return a.readFields(sO, {rgb_color: bw, paint: "rgb_color", opacity: 255}, c)
                }(i, i.readVarint() + i.pos) : n === 2 ? e.stroke = function (a, c) {
                    return a.readFields(aO, {
                        rgb_color: bw,
                        paint: "rgb_color",
                        dasharray: [],
                        dashoffset: 0,
                        miterlimit: 4,
                        opacity: 255,
                        width: 1,
                        linecap: 1,
                        linejoin: 1
                    }, c)
                }(i, i.readVarint() + i.pos) : n === 3 ? e.paint_order = i.readVarint() : n === 5 ? i.readPackedVarint(e.commands) : n === 6 ? e.step = i.readFloat() : n === 7 ? i.readPackedSVarint(e.diffs) : n === 8 && (e.rule = i.readVarint())
            }

            function sO(n, e, i) {
                n === 1 ? (e.rgb_color = P0(i.readVarint()), e.paint = "rgb_color") : n === 2 ? (e.linear_gradient_idx = i.readVarint(), e.paint = "linear_gradient_idx") : n === 3 ? (e.radial_gradient_idx = i.readVarint(), e.paint = "radial_gradient_idx") : n === 5 && (e.opacity = i.readVarint())
            }

            function P0(n) {
                return new Ji((n >> 16 & 255) / 255, (n >> 8 & 255) / 255, (255 & n) / 255, 1)
            }

            function aO(n, e, i) {
                n === 1 ? (e.rgb_color = P0(i.readVarint()), e.paint = "rgb_color") : n === 2 ? (e.linear_gradient_idx = i.readVarint(), e.paint = "linear_gradient_idx") : n === 3 ? (e.radial_gradient_idx = i.readVarint(), e.paint = "radial_gradient_idx") : n === 5 ? i.readPackedFloat(e.dasharray) : n === 6 ? e.dashoffset = i.readFloat() : n === 7 ? e.miterlimit = i.readFloat() : n === 8 ? e.opacity = i.readVarint() : n === 9 ? e.width = i.readFloat() : n === 10 ? e.linecap = i.readVarint() : n === 11 && (e.linejoin = i.readVarint())
            }

            function lO(n, e, i) {
                n === 1 ? e.transform = C0(i, i.readVarint() + i.pos) : n === 2 ? e.spread_method = i.readVarint() : n === 3 ? e.stops.push(iI(i, i.readVarint() + i.pos)) : n === 4 ? e.x1 = i.readFloat() : n === 5 ? e.y1 = i.readFloat() : n === 6 ? e.x2 = i.readFloat() : n === 7 && (e.y2 = i.readFloat())
            }

            function iI(n, e) {
                return n.readFields(cO, {offset: 0, opacity: 255, rgb_color: bw}, e)
            }

            function cO(n, e, i) {
                n === 1 ? e.offset = i.readFloat() : n === 2 ? e.opacity = i.readVarint() : n === 3 && (e.rgb_color = P0(i.readVarint()))
            }

            function uO(n, e, i) {
                n === 1 ? e.transform = C0(i, i.readVarint() + i.pos) : n === 2 ? e.spread_method = i.readVarint() : n === 3 ? e.stops.push(iI(i, i.readVarint() + i.pos)) : n === 4 ? e.cx = i.readFloat() : n === 5 ? e.cy = i.readFloat() : n === 6 ? e.r = i.readFloat() : n === 7 ? e.fx = i.readFloat() : n === 8 ? e.fy = i.readFloat() : n === 9 && (e.fr = i.readFloat())
            }

            function hO(n, e, i) {
                n === 1 ? e.transform = C0(i, i.readVarint() + i.pos) : n === 2 ? e.clip_path_idx = i.readVarint() : n === 3 && e.children.push(I0(i, i.readVarint() + i.pos))
            }

            function dO(n, e, i) {
                n === 1 ? e.left = e.top = i.readFloat() : n === 2 ? e.width = e.height = i.readFloat() : n === 3 ? e.top = i.readFloat() : n === 4 ? e.height = i.readFloat() : n === 5 ? e.mask_type = i.readVarint() : n === 6 ? e.mask_idx = i.readVarint() : n === 7 && e.children.push(I0(i, i.readVarint() + i.pos))
            }

            class fO {
                static calculate(e = {}, i = []) {
                    const a = new Map, c = new Map;
                    if (Object.keys(e).length === 0) return a;
                    i.forEach(d => {
                        c.set(d.name, d.rgb_color || new Ji(0, 0, 0))
                    });
                    for (const [d, f] of Object.entries(e)) c.has(d) ? a.set(c.get(d).toString(), f) : console.warn(`Ignoring unknown image variable "${d}"`);
                    return a
                }
            }

            function Ef(n, e = 255, i) {
                const a = e / 255, c = n.toString(), d = i.has(c) ? i.get(c).clone() : n.clone();
                return d.a *= a, d.toString()
            }

            function wg(n, e) {
                if (!dd()) {
                    const i = document.createElement("canvas");
                    return i.width = n, i.height = e, i
                }
                return new OffscreenCanvas(n, e)
            }

            function pO(n, e) {
                const i = fO.calculate(e.params, n.metadata ? n.metadata.variables : []), a = n.usvg_tree, c = a.width,
                    d = a.height, f = e.transform ? e.transform : new DOMMatrix, _ = Math.max(1, Math.round(c * f.a)),
                    x = Math.max(1, Math.round(d * f.d)), w = new DOMMatrix([_ / c, 0, 0, x / d, 0, 0]),
                    E = wg(_, x).getContext("2d");
                return Ew(E, w, a, a, i), E.getImageData(0, 0, _, x)
            }

            function Ew(n, e, i, a, c) {
                for (const d of a.children) nI(n, e, i, d, c)
            }

            function nI(n, e, i, a, c) {
                a.group ? (n.save(), function (d, f, _, x, w) {
                    const E = x.mask_idx != null ? _.masks[x.mask_idx] : null,
                        I = x.clip_path_idx != null ? _.clip_paths[x.clip_path_idx] : null;
                    if (x.transform && (f = Af(x.transform).preMultiplySelf(f)), !function (L, F, N) {
                        return L.opacity !== 255 || F || N
                    }(x, I != null, E != null)) return void Ew(d, f, _, x, w);
                    const C = wg(d.canvas.width, d.canvas.height), z = C.getContext("2d");
                    Ew(z, f, _, x, w), I && uI(z, f, _, I), E && hI(z, f, _, E, w), d.globalAlpha = x.opacity / 255, d.drawImage(C, 0, 0)
                }(n, e, i, a.group, c), n.restore()) : a.path && (n.save(), function (d, f, _, x, w) {
                    d.setTransform(f), x.paint_order === X3.PAINT_ORDER_FILL_AND_STROKE ? (rI(d, _, x, w), sI(d, _, x, w)) : (sI(d, _, x, w), rI(d, _, x, w))
                }(n, e, i, a.path, c), n.restore())
            }

            function rI(n, e, i, a) {
                const c = i.fill;
                if (!c) return;
                const d = c.opacity / 255;
                switch (n.save(), n.beginPath(), dI(i, n), c.paint) {
                    case"rgb_color":
                        n.fillStyle = Ef(c.rgb_color, c.opacity, a);
                        break;
                    case"linear_gradient_idx": {
                        const f = e.linear_gradients[c.linear_gradient_idx];
                        f.transform && n.setTransform(Af(f.transform).preMultiplySelf(n.getTransform())), n.fillStyle = aI(n, f, d, a);
                        break
                    }
                    case"radial_gradient_idx": {
                        const f = e.radial_gradients[c.radial_gradient_idx];
                        f.transform && n.setTransform(Af(f.transform).preMultiplySelf(n.getTransform())), n.fillStyle = lI(n, f, d, a)
                    }
                }
                n.fill(oI(i)), n.restore()
            }

            function oI(n) {
                return n.rule === Tw.PATH_RULE_NON_ZERO ? "nonzero" : n.rule === Tw.PATH_RULE_EVEN_ODD ? "evenodd" : void 0
            }

            function sI(n, e, i, a) {
                const c = i.stroke;
                if (!c) return;
                const d = fI(i);
                n.lineWidth = c.width, n.miterLimit = c.miterlimit, n.setLineDash(c.dasharray), n.lineDashOffset = c.dashoffset;
                const f = c.opacity / 255;
                switch (c.paint) {
                    case"rgb_color":
                        n.strokeStyle = Ef(c.rgb_color, c.opacity, a);
                        break;
                    case"linear_gradient_idx":
                        n.strokeStyle = aI(n, e.linear_gradients[c.linear_gradient_idx], f, a, !0);
                        break;
                    case"radial_gradient_idx":
                        n.strokeStyle = lI(n, e.radial_gradients[c.radial_gradient_idx], f, a, !0)
                }
                switch (c.linejoin) {
                    case A0.LINE_JOIN_MITER_CLIP:
                    case A0.LINE_JOIN_MITER:
                        n.lineJoin = "miter";
                        break;
                    case A0.LINE_JOIN_ROUND:
                        n.lineJoin = "round";
                        break;
                    case A0.LINE_JOIN_BEVEL:
                        n.lineJoin = "bevel"
                }
                switch (c.linecap) {
                    case Sw.LINE_CAP_BUTT:
                        n.lineCap = "butt";
                        break;
                    case Sw.LINE_CAP_ROUND:
                        n.lineCap = "round";
                        break;
                    case Sw.LINE_CAP_SQUARE:
                        n.lineCap = "square"
                }
                n.stroke(d)
            }

            function aI(n, e, i, a, c = !1) {
                if (e.stops.length === 1) {
                    const C = e.stops[0];
                    return Ef(C.rgb_color, C.opacity * i, a)
                }
                const {x1: d, y1: f, x2: _, y2: x} = e;
                let w = new DOMPoint(d, f), E = new DOMPoint(_, x);
                if (c) {
                    const C = Af(e.transform);
                    w = C.transformPoint(w), E = C.transformPoint(E)
                }
                const I = n.createLinearGradient(w.x, w.y, E.x, E.y);
                for (const C of e.stops) I.addColorStop(C.offset, Ef(C.rgb_color, C.opacity * i, a));
                return I
            }

            function lI(n, e, i, a, c = !1) {
                if (e.stops.length === 1) {
                    const H = e.stops[0];
                    return Ef(H.rgb_color, H.opacity * i, a)
                }
                const d = Af(e.transform), {fx: f, fy: _, fr: x, cx: w, cy: E, r: I} = e;
                let C = new DOMPoint(f, _), z = new DOMPoint(w, E), L = x, F = I;
                if (c) {
                    C = d.transformPoint(C), z = d.transformPoint(z);
                    const H = (d.a + d.d) / 2;
                    L = x * H, F = e.r * H
                }
                const N = n.createRadialGradient(C.x, C.y, L, z.x, z.y, F);
                for (const H of e.stops) N.addColorStop(H.offset, Ef(H.rgb_color, H.opacity * i, a));
                return N
            }

            function cI(n, e, i, a) {
                const c = a.transform ? Af(a.transform).preMultiplySelf(e) : e, d = wg(n.canvas.width, n.canvas.height),
                    f = d.getContext("2d");
                for (const x of a.children) if (x.group) cI(f, c, i, x.group); else if (x.path) {
                    const w = x.path, E = new Path2D;
                    E.addPath(fI(w), c), f.fill(E, oI(w))
                }
                const _ = a.clip_path_idx != null ? i.clip_paths[a.clip_path_idx] : null;
                _ && uI(f, c, i, _), n.globalCompositeOperation = "source-over", n.drawImage(d, 0, 0)
            }

            function uI(n, e, i, a) {
                const c = wg(n.canvas.width, n.canvas.height);
                cI(c.getContext("2d"), e, i, a), n.globalCompositeOperation = "destination-in", n.drawImage(c, 0, 0)
            }

            function hI(n, e, i, a, c) {
                if (a.children.length === 0) return;
                const d = a.mask_idx != null ? i.masks[a.mask_idx] : null;
                d && hI(n, e, i, d, c);
                const f = n.canvas.width, _ = n.canvas.height, x = wg(f, _), w = x.getContext("2d"), E = a.width,
                    I = a.height, C = a.left, z = a.top, L = new Path2D, F = new Path2D;
                F.rect(C, z, E, I), L.addPath(F, e), w.clip(L);
                for (const Y of a.children) nI(w, e, i, Y, c);
                const N = w.getImageData(0, 0, f, _), H = N.data;
                if (a.mask_type === eI.MASK_TYPE_LUMINANCE) for (let Y = 0; Y < H.length; Y += 4) H[Y + 3] = H[Y + 3] / 255 * (.2126 * H[Y] + .7152 * H[Y + 1] + .0722 * H[Y + 2]);
                w.putImageData(N, 0, 0), n.globalCompositeOperation = "destination-in", n.drawImage(x, 0, 0)
            }

            function Af(n) {
                return n ? new DOMMatrix([n.sx, n.ky, n.kx, n.sy, n.tx, n.ty]) : new DOMMatrix
            }

            function dI(n, e) {
                const i = n.step;
                let a = n.diffs[0] * i, c = n.diffs[1] * i;
                e.moveTo(a, c);
                for (let d = 0, f = 2; d < n.commands.length; d++) switch (n.commands[d]) {
                    case xg.PATH_COMMAND_MOVE:
                        a += n.diffs[f++] * i, c += n.diffs[f++] * i, e.moveTo(a, c);
                        break;
                    case xg.PATH_COMMAND_LINE:
                        a += n.diffs[f++] * i, c += n.diffs[f++] * i, e.lineTo(a, c);
                        break;
                    case xg.PATH_COMMAND_QUAD: {
                        const _ = a + n.diffs[f++] * i, x = c + n.diffs[f++] * i;
                        a = _ + n.diffs[f++] * i, c = x + n.diffs[f++] * i, e.quadraticCurveTo(_, x, a, c);
                        break
                    }
                    case xg.PATH_COMMAND_CUBIC: {
                        const _ = a + n.diffs[f++] * i, x = c + n.diffs[f++] * i, w = _ + n.diffs[f++] * i,
                            E = x + n.diffs[f++] * i;
                        a = w + n.diffs[f++] * i, c = E + n.diffs[f++] * i, e.bezierCurveTo(_, x, w, E, a, c);
                        break
                    }
                    case xg.PATH_COMMAND_CLOSE:
                        e.closePath()
                }
                return e
            }

            function fI(n) {
                return dI(n, new Path2D)
            }

            class M0 {
                constructor(e) {
                    this.capacity = e, this.cache = new Map
                }

                get(e) {
                    if (!this.cache.has(e)) return;
                    const i = this.cache.get(e);
                    return this.cache.delete(e), this.cache.set(e, i), i
                }

                put(e, i) {
                    this.cache.has(e) ? this.cache.delete(e) : this.cache.size === this.capacity && this.cache.delete(this.cache.keys().next().value), this.cache.set(e, i)
                }

                delete(e) {
                    this.cache.delete(e)
                }
            }

            Pt(M0, "LRUCache");

            class Aw {
                constructor() {
                    this.cacheMap = new Map, this.cacheDependenciesMap = new Map
                }

                static _getImage(e) {
                    return new $r(e, e.data)
                }

                getFromCache(e, i, a) {
                    return this.cacheMap.has(a) || this.cacheMap.set(a, new M0(150)), this.cacheMap.get(a).get(jc(e.toString(), i))
                }

                setInCache(e, i, a, c) {
                    this.cacheDependenciesMap.has(c) || this.cacheDependenciesMap.set(c, new Map), this.cacheMap.has(c) || this.cacheMap.set(c, new M0(150));
                    const d = this.cacheDependenciesMap.get(c), f = jc(e.id.toString(), a);
                    d.get(f) || d.set(f, new Set);
                    const _ = this.cacheMap.get(c), x = e.toString();
                    d.get(f).add(x), _.put(jc(e.toString(), a), i)
                }

                removeImagesFromCacheByIds(e, i, a = 0) {
                    if (!this.cacheMap.has(a) || !this.cacheDependenciesMap.has(a)) return;
                    const c = this.cacheMap.get(a), d = this.cacheDependenciesMap.get(a);
                    for (const f of e) {
                        const _ = jc(f.toString(), i);
                        if (d.has(_)) {
                            for (const x of d.get(_)) c.delete(x);
                            d.delete(_)
                        }
                    }
                }

                rasterize(e, i, a, c, d = pO) {
                    const f = this.getFromCache(e, a, c);
                    if (f) return f.clone();
                    const _ = d(i.icon, e.options), x = Aw._getImage(_);
                    return this.setInCache(e, x, a, c), x.clone()
                }
            }

            class pI {
                constructor(e) {
                    this.size = e, this.minimums = [], this.maximums = [], this.leaves = []
                }

                getElevation(e, i) {
                    const a = this.toIdx(e, i);
                    return {min: this.minimums[a], max: this.maximums[a]}
                }

                isLeaf(e, i) {
                    return this.leaves[this.toIdx(e, i)]
                }

                toIdx(e, i) {
                    return i * this.size + e
                }
            }

            function mI(n, e, i, a) {
                let c = 0, d = Number.MAX_VALUE;
                for (let f = 0; f < 3; f++) if (Math.abs(a[f]) < 1e-15) {
                    if (i[f] < n[f] || i[f] > e[f]) return null
                } else {
                    const _ = 1 / a[f];
                    let x = (n[f] - i[f]) * _, w = (e[f] - i[f]) * _;
                    if (x > w) {
                        const E = x;
                        x = w, w = E
                    }
                    if (x > c && (c = x), w < d && (d = w), c > d) return null
                }
                return c
            }

            function gI(n, e, i, a, c, d, f, _, x, w, E) {
                const I = a - n, C = c - e, z = d - i, L = f - n, F = _ - e, N = x - i, H = E[1] * N - E[2] * F,
                    Y = E[2] * L - E[0] * N, X = E[0] * F - E[1] * L, J = I * H + C * Y + z * X;
                if (Math.abs(J) < 1e-15) return null;
                const xe = 1 / J, ge = w[0] - n, ye = w[1] - e, Ee = w[2] - i, Ie = (ge * H + ye * Y + Ee * X) * xe;
                if (Ie < 0 || Ie > 1) return null;
                const We = ye * z - Ee * C, De = Ee * I - ge * z, Ye = ge * C - ye * I,
                    ht = (E[0] * We + E[1] * De + E[2] * Ye) * xe;
                return ht < 0 || Ie + ht > 1 ? null : (L * We + F * De + N * Ye) * xe
            }

            function _I(n, e, i) {
                return (n - e) / (i - e)
            }

            function yI(n, e, i, a, c, d, f, _, x) {
                const w = 1 << i, E = d - a, I = f - c, C = (n + 1) / w * E + a, z = (e + 0) / w * I + c,
                    L = (e + 1) / w * I + c;
                _[0] = (n + 0) / w * E + a, _[1] = z, x[0] = C, x[1] = L
            }

            class vI {
                constructor(e) {
                    if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = e, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem) return;
                    const i = function (d) {
                        const f = Math.ceil(Math.log2(d.dim / 8)), _ = [];
                        let x = Math.ceil(Math.pow(2, f));
                        const w = 1 / x, E = (z, L, F, N, H) => {
                            const Y = N ? 1 : 0, X = (z + 1) * F - Y, J = L * F, xe = (L + 1) * F - Y;
                            H[0] = z * F, H[1] = J, H[2] = X, H[3] = xe
                        };
                        let I = new pI(x);
                        const C = [];
                        for (let z = 0; z < x * x; z++) {
                            E(z % x, Math.floor(z / x), w, !1, C);
                            const L = su(C[0], C[1], d), F = su(C[2], C[1], d), N = su(C[2], C[3], d),
                                H = su(C[0], C[3], d);
                            I.minimums.push(Math.min(L, F, N, H)), I.maximums.push(Math.max(L, F, N, H)), I.leaves.push(1)
                        }
                        for (_.push(I), x /= 2; x >= 1; x /= 2) {
                            const z = _[_.length - 1];
                            I = new pI(x);
                            for (let L = 0; L < x * x; L++) {
                                E(L % x, Math.floor(L / x), 2, !0, C);
                                const F = z.getElevation(C[0], C[1]), N = z.getElevation(C[2], C[1]),
                                    H = z.getElevation(C[2], C[3]), Y = z.getElevation(C[0], C[3]),
                                    X = z.isLeaf(C[0], C[1]), J = z.isLeaf(C[2], C[1]), xe = z.isLeaf(C[2], C[3]),
                                    ge = z.isLeaf(C[0], C[3]), ye = Math.min(F.min, N.min, H.min, Y.min),
                                    Ee = Math.max(F.max, N.max, H.max, Y.max), Ie = X && J && xe && ge;
                                I.maximums.push(Ee), I.minimums.push(ye), I.leaves.push(Ee - ye <= 5 && Ie ? 1 : 0)
                            }
                            _.push(I)
                        }
                        return _
                    }(this.dem), a = i.length - 1, c = i[a];
                    this._addNode(c.minimums[0], c.maximums[0], c.leaves[0]), this._construct(i, 0, 0, a, 0)
                }

                raycastRoot(e, i, a, c, d, f, _ = 1) {
                    return mI([e, i, -100], [a, c, this.maximums[0] * _], d, f)
                }

                raycast(e, i, a, c, d, f, _ = 1) {
                    if (!this.nodeCount) return null;
                    const x = this.raycastRoot(e, i, a, c, d, f, _);
                    if (x == null) return null;
                    const w = [], E = [], I = [], C = [], z = [{idx: 0, t: x, nodex: 0, nodey: 0, depth: 0}];
                    for (; z.length > 0;) {
                        const {idx: L, t: F, nodex: N, nodey: H, depth: Y} = z.pop();
                        if (this.leaves[L]) {
                            yI(N, H, Y, e, i, a, c, I, C);
                            const J = 1 << Y, xe = (N + 0) / J, ge = (N + 1) / J, ye = (H + 0) / J, Ee = (H + 1) / J,
                                Ie = su(xe, ye, this.dem) * _, We = su(ge, ye, this.dem) * _,
                                De = su(ge, Ee, this.dem) * _, Ye = su(xe, Ee, this.dem) * _,
                                ht = gI(I[0], I[1], Ie, C[0], I[1], We, C[0], C[1], De, d, f),
                                Qe = gI(C[0], C[1], De, I[0], C[1], Ye, I[0], I[1], Ie, d, f),
                                ot = Math.min(ht !== null ? ht : Number.MAX_VALUE, Qe !== null ? Qe : Number.MAX_VALUE);
                            if (ot !== Number.MAX_VALUE) return ot;
                            {
                                const ct = fi([], d, f, F);
                                if (xI(Ie, We, Ye, De, _I(ct[0], I[0], C[0]), _I(ct[1], I[1], C[1])) >= ct[2]) return F
                            }
                            continue
                        }
                        let X = 0;
                        for (let J = 0; J < this._siblingOffset.length; J++) {
                            yI((N << 1) + this._siblingOffset[J][0], (H << 1) + this._siblingOffset[J][1], Y + 1, e, i, a, c, I, C), I[2] = -100, C[2] = this.maximums[this.childOffsets[L] + J] * _;
                            const xe = mI(I, C, d, f);
                            if (xe != null) {
                                const ge = xe;
                                w[J] = ge;
                                let ye = !1;
                                for (let Ee = 0; Ee < X && !ye; Ee++) ge >= w[E[Ee]] && (E.splice(Ee, 0, J), ye = !0);
                                ye || (E[X] = J), X++
                            }
                        }
                        for (let J = 0; J < X; J++) {
                            const xe = E[J];
                            z.push({
                                idx: this.childOffsets[L] + xe,
                                t: w[xe],
                                nodex: (N << 1) + this._siblingOffset[xe][0],
                                nodey: (H << 1) + this._siblingOffset[xe][1],
                                depth: Y + 1
                            })
                        }
                    }
                    return null
                }

                _addNode(e, i, a) {
                    return this.minimums.push(e), this.maximums.push(i), this.leaves.push(a), this.childOffsets.push(0), this.nodeCount++
                }

                _construct(e, i, a, c, d) {
                    if (e[c].isLeaf(i, a) === 1) return;
                    this.childOffsets[d] || (this.childOffsets[d] = this.nodeCount);
                    const f = c - 1, _ = e[f];
                    let x = 0, w = 0;
                    for (let E = 0; E < this._siblingOffset.length; E++) {
                        const I = 2 * i + this._siblingOffset[E][0], C = 2 * a + this._siblingOffset[E][1],
                            z = _.getElevation(I, C), L = _.isLeaf(I, C), F = this._addNode(z.min, z.max, L);
                        L && (x |= 1 << E), w || (w = F)
                    }
                    for (let E = 0; E < this._siblingOffset.length; E++) x & 1 << E || this._construct(e, 2 * i + this._siblingOffset[E][0], 2 * a + this._siblingOffset[E][1], f, w + E)
                }
            }

            function xI(n, e, i, a, c, d) {
                return qt(qt(n, i, d), qt(e, a, d), c)
            }

            function su(n, e, i) {
                const a = i.dim, c = se(n * a - .5, 0, a - 1), d = se(e * a - .5, 0, a - 1), f = Math.floor(c),
                    _ = Math.floor(d), x = Math.min(f + 1, a - 1), w = Math.min(_ + 1, a - 1);
                return xI(i.get(f, _), i.get(x, _), i.get(f, w), i.get(x, w), c - f, d - _)
            }

            const mO = {mapbox: [6553.6, 25.6, .1, 1e4], terrarium: [256, 1, 1 / 256, 32768]};

            function gO(n, e, i) {
                return (256 * n * 256 + 256 * e + i) / 10 - 1e4
            }

            function _O(n, e, i) {
                return 256 * n + e + i / 256 - 32768
            }

            class R0 {
                get tree() {
                    return this._tree || this._buildQuadTree(), this._tree
                }

                constructor(e, i, a, c = !1) {
                    if (this.uid = e, i.height !== i.width) throw new RangeError("DEM tiles must be square");
                    if (a && a !== "mapbox" && a !== "terrarium") return void Li(`"${a}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
                    this.stride = i.height;
                    const d = this.dim = i.height - 2, f = new Uint32Array(i.data.buffer);
                    if (this.pixels = new Uint8Array(i.data.buffer), this.floatView = new Float32Array(i.data.buffer), this.borderReady = c, this._modifiedForSources = {}, !c) {
                        for (let x = 0; x < d; x++) f[this._idx(-1, x)] = f[this._idx(0, x)], f[this._idx(d, x)] = f[this._idx(d - 1, x)], f[this._idx(x, -1)] = f[this._idx(x, 0)], f[this._idx(x, d)] = f[this._idx(x, d - 1)];
                        f[this._idx(-1, -1)] = f[this._idx(0, 0)], f[this._idx(d, -1)] = f[this._idx(d - 1, 0)], f[this._idx(-1, d)] = f[this._idx(0, d - 1)], f[this._idx(d, d)] = f[this._idx(d - 1, d - 1)]
                    }
                    const _ = a === "terrarium" ? _O : gO;
                    for (let x = 0; x < f.length; ++x) {
                        const w = 4 * x;
                        this.floatView[x] = _(this.pixels[w], this.pixels[w + 1], this.pixels[w + 2])
                    }
                    this._timestamp = ks.now()
                }

                _buildQuadTree() {
                    this._tree = new vI(this)
                }

                get(e, i, a = !1) {
                    a && (e = se(e, -1, this.dim), i = se(i, -1, this.dim));
                    const c = this._idx(e, i);
                    return this.floatView[c]
                }

                set(e, i, a) {
                    const c = this._idx(e, i), d = this.floatView[c];
                    return this.floatView[c] = a, a - d
                }

                static getUnpackVector(e) {
                    return mO[e]
                }

                _idx(e, i) {
                    if (e < -1 || e >= this.dim + 1 || i < -1 || i >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
                    return (i + 1) * this.stride + (e + 1)
                }

                static pack(e, i) {
                    const a = [0, 0, 0, 0], c = R0.getUnpackVector(i);
                    let d = Math.floor((e + c[3]) / c[2]);
                    return a[2] = d % 256, d = Math.floor(d / 256), a[1] = d % 256, d = Math.floor(d / 256), a[0] = d, a
                }

                getPixels() {
                    return new mS({width: this.stride, height: this.stride}, this.pixels)
                }

                backfillBorder(e, i, a) {
                    if (this.dim !== e.dim) throw new Error("dem dimension mismatch");
                    let c = i * this.dim, d = i * this.dim + this.dim, f = a * this.dim, _ = a * this.dim + this.dim;
                    switch (i) {
                        case-1:
                            c = d - 1;
                            break;
                        case 1:
                            d = c + 1
                    }
                    switch (a) {
                        case-1:
                            f = _ - 1;
                            break;
                        case 1:
                            _ = f + 1
                    }
                    const x = -i * this.dim, w = -a * this.dim;
                    for (let E = f; E < _; E++) for (let I = c; I < d; I++) {
                        const C = 4 * this._idx(I, E), z = 4 * this._idx(I + x, E + w);
                        this.pixels[C + 0] = e.pixels[z + 0], this.pixels[C + 1] = e.pixels[z + 1], this.pixels[C + 2] = e.pixels[z + 2], this.pixels[C + 3] = e.pixels[z + 3]
                    }
                }

                onDeserialize() {
                    this._tree && (this._tree.dem = this)
                }
            }

            function yO(n, e, i) {
                n === 1 ? e.headerLength = i.readFixed32() : n === 2 ? e.x = i.readVarint() : n === 3 ? e.y = i.readVarint() : n === 4 ? e.z = i.readVarint() : n === 5 && e.layers.push(function (a, c) {
                    return a.readFields(TO, {
                        version: 0,
                        name: "",
                        units: "",
                        tileSize: 0,
                        buffer: 0,
                        pixelFormat: 0,
                        dataIndex: []
                    }, c)
                }(i, i.readVarint() + i.pos))
            }

            function vO(n, e, i) {
                n === 1 ? (e.delta_filter = function (a, c) {
                    return a.readFields(xO, {blockSize: 0}, c)
                }(i, i.readVarint() + i.pos), e.filter = "delta_filter") : n === 2 ? (i.readVarint(), e.filter = "zigzag_filter") : n === 3 ? (i.readVarint(), e.filter = "bitshuffle_filter") : n === 4 && (i.readVarint(), e.filter = "byteshuffle_filter")
            }

            function xO(n, e, i) {
                n === 1 && (e.blockSize = i.readVarint())
            }

            function wO(n, e, i) {
                n === 1 ? (i.readVarint(), e.codec = "gzip_data") : n === 2 ? (i.readVarint(), e.codec = "jpeg_image") : n === 3 ? (i.readVarint(), e.codec = "webp_image") : n === 4 && (i.readVarint(), e.codec = "png_image")
            }

            function bO(n, e, i) {
                let a = 0, c = 0;
                n === 1 ? e.firstByte = i.readFixed64() : n === 2 ? e.lastByte = i.readFixed64() : n === 3 ? e.filters.push(function (d, f) {
                    return d.readFields(vO, {}, f)
                }(i, i.readVarint() + i.pos)) : n === 4 ? e.codec = function (d, f) {
                    return d.readFields(wO, {}, f)
                }(i, i.readVarint() + i.pos) : n === 5 ? c = i.readFloat() : n === 6 ? a = i.readFloat() : n === 7 ? e.bands.push(i.readString()) : n === 8 ? e.offset = i.readDouble() : n === 9 && (e.scale = i.readDouble()), e.offset === 0 && (e.offset = c), e.scale === 0 && (e.scale = a)
            }

            function TO(n, e, i) {
                n === 1 ? e.version = i.readVarint() : n === 2 ? e.name = i.readString() : n === 3 ? e.units = i.readString() : n === 4 ? e.tileSize = i.readVarint() : n === 5 ? e.buffer = i.readVarint() : n === 6 ? e.pixelFormat = i.readVarint() : n === 7 && e.dataIndex.push(function (a, c) {
                    return a.readFields(bO, {
                        firstByte: 0,
                        lastByte: 0,
                        filters: [],
                        codec: null,
                        offset: 0,
                        scale: 0,
                        bands: []
                    }, c)
                }(i, i.readVarint() + i.pos))
            }

            function SO(n, e, i) {
                if (n === 2) (function (a, c, d) {
                    a.readFields(EO, d, c)
                })(i, i.readVarint() + i.pos, e); else if (n === 3) throw new Error("Not implemented")
            }

            function EO(n, e, i) {
                if (n === 1) {
                    let a = 0;
                    const c = i.readVarint() + i.pos;
                    for (; i.pos < c;) e[a++] = i.readVarint()
                }
            }

            function AO(n, e) {
                if (e.length !== 4) throw new Error(`Expected data of dimension 4 but got ${e.length}.`);
                let i = e[3];
                for (let a = 2; a >= 1; a--) {
                    const c = a === 1 ? 1 : 0, d = a === 2 ? 1 : 0;
                    for (let f = 0; f < e[0]; f++) {
                        const _ = e[1] * f;
                        for (let x = c; x < e[1]; x++) {
                            const w = e[2] * (x + _);
                            for (let E = d; E < e[2]; E++) {
                                const I = e[3] * (E + w);
                                for (let C = 0; C < e[3]; C++) {
                                    const z = I + C;
                                    n[z] += n[z - i]
                                }
                            }
                        }
                    }
                    i *= e[a]
                }
                return n
            }

            function IO(n) {
                for (let e = 0, i = n.length; e < i; e++) n[e] = n[e] >>> 1 ^ -(1 & n[e]);
                return n
            }

            function CO(n, e) {
                switch (e) {
                    case"uint32":
                        return n;
                    case"uint16":
                        for (let i = 0; i < n.length; i += 2) {
                            const a = n[i], c = n[i + 1];
                            n[i] = (240 & a) >> 4 | (61440 & a) >> 8 | (240 & c) << 4 | 61440 & c, n[i + 1] = 15 & a | (3840 & a) >> 4 | (15 & c) << 8 | (3840 & c) << 4
                        }
                        return n;
                    case"uint8":
                        for (let i = 0; i < n.length; i += 4) {
                            const a = n[i], c = n[i + 1], d = n[i + 2], f = n[i + 3];
                            n[i + 0] = (192 & a) >> 6 | (192 & c) >> 4 | (192 & d) >> 2 | 192 & f, n[i + 1] = (48 & a) >> 4 | (48 & c) >> 2 | 48 & d | (48 & f) << 2, n[i + 2] = (12 & a) >> 2 | 12 & c | (12 & d) << 2 | (12 & f) << 4, n[i + 3] = 3 & a | (3 & c) << 2 | (3 & d) << 4 | (3 & f) << 6
                        }
                        return n;
                    default:
                        throw new Error(`Invalid pixel format, "${e}"`)
                }
            }

            Pt(R0, "DEMData"), Pt(vI, "DemMinMaxQuadTree", {omit: ["dem"]});
            var js = Uint8Array, bg = Uint16Array, PO = Int32Array,
                wI = new js([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
                bI = new js([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
                MO = new js([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), TI = function (n, e) {
                    for (var i = new bg(31), a = 0; a < 31; ++a) i[a] = e += 1 << n[a - 1];
                    var c = new PO(i[30]);
                    for (a = 1; a < 30; ++a) for (var d = i[a]; d < i[a + 1]; ++d) c[d] = d - i[a] << 5 | a;
                    return {b: i, r: c}
                }, SI = TI(wI, 2), EI = SI.b, RO = SI.r;
            EI[28] = 258, RO[258] = 28;
            for (var zO = TI(bI, 0).b, AI = new bg(32768), gr = 0; gr < 32768; ++gr) {
                var If = (43690 & gr) >> 1 | (21845 & gr) << 1;
                AI[gr] = ((65280 & (If = (61680 & (If = (52428 & If) >> 2 | (13107 & If) << 2)) >> 4 | (3855 & If) << 4)) >> 8 | (255 & If) << 8) >> 1
            }
            var Tg = function (n, e, i) {
                for (var a = n.length, c = 0, d = new bg(e); c < a; ++c) n[c] && ++d[n[c] - 1];
                var f, _ = new bg(e);
                for (c = 1; c < e; ++c) _[c] = _[c - 1] + d[c - 1] << 1;
                f = new bg(1 << e);
                var x = 15 - e;
                for (c = 0; c < a; ++c) if (n[c]) for (var w = c << 4 | n[c], E = e - n[c], I = _[n[c] - 1]++ << E, C = I | (1 << E) - 1; I <= C; ++I) f[AI[I] >> x] = w;
                return f
            }, Sg = new js(288);
            for (gr = 0; gr < 144; ++gr) Sg[gr] = 8;
            for (gr = 144; gr < 256; ++gr) Sg[gr] = 9;
            for (gr = 256; gr < 280; ++gr) Sg[gr] = 7;
            for (gr = 280; gr < 288; ++gr) Sg[gr] = 8;
            var II = new js(32);
            for (gr = 0; gr < 32; ++gr) II[gr] = 5;
            var DO = Tg(Sg, 9), LO = Tg(II, 5), Iw = function (n) {
                    for (var e = n[0], i = 1; i < n.length; ++i) n[i] > e && (e = n[i]);
                    return e
                }, Sa = function (n, e, i) {
                    var a = e / 8 | 0;
                    return (n[a] | n[a + 1] << 8) >> (7 & e) & i
                }, Cw = function (n, e) {
                    var i = e / 8 | 0;
                    return (n[i] | n[i + 1] << 8 | n[i + 2] << 16) >> (7 & e)
                },
                kO = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"],
                Ea = function (n, e, i) {
                    var a = new Error(e || kO[n]);
                    if (a.code = n, Error.captureStackTrace && Error.captureStackTrace(a, Ea), !i) throw a;
                    return a
                }, OO = new js(0), FO = typeof TextDecoder < "u" && new TextDecoder;
            try {
                FO.decode(OO, {stream: !0})
            } catch {
            }
            const BO = {gzip_data: "gzip"};

            class na extends Error {
                constructor(e) {
                    super(e), this.name = "MRTError"
                }
            }

            const NO = {0: "uint32", 1: "uint32", 2: "uint16", 3: "uint8"}, CI = {uint32: 1, uint16: 2, uint8: 4},
                jO = {uint32: Uint32Array, uint16: Uint16Array, uint8: Uint8Array};
            let Pw;

            class z0 {
                constructor(e = 5) {
                    this.x = NaN, this.y = NaN, this.z = NaN, this.layers = {}, this._cacheSize = e
                }

                getLayer(e) {
                    const i = this.layers[e];
                    if (!i) throw new na(`Layer '${e}' not found`);
                    return i
                }

                getHeaderLength(e) {
                    const i = new Uint8Array(e), a = new DataView(e);
                    if (i[0] !== 13) throw new na("File is not a valid MRT.");
                    return a.getUint32(1, !0)
                }

                parseHeader(e) {
                    const i = new Uint8Array(e), a = this.getHeaderLength(e);
                    if (i.length < a) throw new na(`Expected header with length >= ${a} but got buffer of length ${i.length}`);
                    const c = new Pw(i.subarray(0, a)).readFields(yO, {
                        headerLength: 0,
                        x: 0,
                        y: 0,
                        z: 0,
                        layers: []
                    }, void 0);
                    if (!isNaN(this.x) && (this.x !== c.x || this.y !== c.y || this.z !== c.z)) throw new na(`Invalid attempt to parse header ${c.z}/${c.x}/${c.y} for tile ${this.z}/${this.x}/${this.y}`);
                    this.x = c.x, this.y = c.y, this.z = c.z;
                    for (const d of c.layers) this.layers[d.name] = new PI(d, {cacheSize: this._cacheSize});
                    return this
                }

                createDecodingTask(e) {
                    const i = [], a = this.getLayer(e.layerName);
                    for (let c of e.blockIndices) {
                        const d = a.dataIndex[c], f = d.firstByte - e.firstByte, _ = d.lastByte - e.firstByte;
                        if (a._blocksInProgress.has(c)) continue;
                        const x = {
                            layerName: a.name,
                            firstByte: f,
                            lastByte: _,
                            pixelFormat: a.pixelFormat,
                            blockIndex: c,
                            blockShape: [d.bands.length].concat(a.bandShape),
                            buffer: a.buffer,
                            codec: d.codec.codec,
                            filters: d.filters.map(w => w.filter)
                        };
                        a._blocksInProgress.add(c), i.push(x)
                    }
                    return new MI(i, () => {
                        i.forEach(c => a._blocksInProgress.delete(c.blockIndex))
                    }, (c, d) => {
                        if (i.forEach(f => a._blocksInProgress.delete(f.blockIndex)), c) throw c;
                        d.forEach(f => {
                            this.getLayer(f.layerName).processDecodedData(f)
                        })
                    })
                }
            }

            class PI {
                constructor({version: e, name: i, units: a, tileSize: c, pixelFormat: d, buffer: f, dataIndex: _}, x) {
                    if (this.version = e, this.version !== 1) throw new na(`Cannot parse raster layer encoded with MRT version ${e}`);
                    this.name = i, this.units = a, this.tileSize = c, this.buffer = f, this.pixelFormat = NO[d], this.dataIndex = _, this.bandShape = [c + 2 * f, c + 2 * f, CI[this.pixelFormat]], this._decodedBlocks = new M0(x ? x.cacheSize : 5), this._blocksInProgress = new Set
                }

                get dimension() {
                    return CI[this.pixelFormat]
                }

                get cacheSize() {
                    return this._decodedBlocks.capacity
                }

                getBandList() {
                    return this.dataIndex.map(({bands: e}) => e).flat()
                }

                processDecodedData(e) {
                    const i = e.blockIndex.toString();
                    this._decodedBlocks.get(i) || this._decodedBlocks.put(i, e.data)
                }

                getBlockForBand(e) {
                    let i = 0;
                    switch (typeof e) {
                        case"string":
                            for (const [a, c] of this.dataIndex.entries()) {
                                for (const [d, f] of c.bands.entries()) if (f === e) return {
                                    bandIndex: i + d,
                                    blockIndex: a,
                                    blockBandIndex: d
                                };
                                i += c.bands.length
                            }
                            break;
                        case"number":
                            for (const [a, c] of this.dataIndex.entries()) {
                                if (e >= i && e < i + c.bands.length) return {
                                    bandIndex: e,
                                    blockIndex: a,
                                    blockBandIndex: e - i
                                };
                                i += c.bands.length
                            }
                            break;
                        default:
                            throw new na(`Invalid band \`${JSON.stringify(e)}\`. Expected string or integer.`)
                    }
                    return {blockIndex: -1, blockBandIndex: -1}
                }

                getDataRange(e) {
                    let i = 1 / 0, a = -1 / 0;
                    const c = [], d = new Set;
                    for (const f of e) {
                        const {blockIndex: _} = this.getBlockForBand(f);
                        if (_ < 0) throw new na(`Invalid band: ${JSON.stringify(f)}`);
                        const x = this.dataIndex[_];
                        c.includes(_) || c.push(_), d.add(_), i = Math.min(i, x.firstByte), a = Math.max(a, x.lastByte)
                    }
                    if (d.size > this.cacheSize) throw new na(`Number of blocks to decode (${d.size}) exceeds cache size (${this.cacheSize}).`);
                    return {layerName: this.name, firstByte: i, lastByte: a, blockIndices: c}
                }

                hasBand(e) {
                    const {blockIndex: i} = this.getBlockForBand(e);
                    return i >= 0
                }

                hasDataForBand(e) {
                    const {blockIndex: i} = this.getBlockForBand(e);
                    return i >= 0 && !!this._decodedBlocks.get(i.toString())
                }

                getBandView(e) {
                    const {blockIndex: i, blockBandIndex: a} = this.getBlockForBand(e);
                    if (i < 0) throw new na(`Band not found: ${JSON.stringify(e)}`);
                    const c = this._decodedBlocks.get(i.toString());
                    if (!c) throw new na(`Data for band ${JSON.stringify(e)} of layer "${this.name}" not decoded.`);
                    const d = this.dataIndex[i], f = this.bandShape.reduce((w, E) => w * E, 1), _ = a * f,
                        x = c.subarray(_, _ + f);
                    return {
                        data: x,
                        bytes: new Uint8Array(x.buffer).subarray(x.byteOffset, x.byteOffset + x.byteLength),
                        tileSize: this.tileSize,
                        buffer: this.buffer,
                        pixelFormat: this.pixelFormat,
                        dimension: this.dimension,
                        offset: d.offset,
                        scale: d.scale
                    }
                }
            }

            z0.setPbf = function (n) {
                Pw = n
            };

            class MI {
                constructor(e, i, a) {
                    this.tasks = e, this._onCancel = i, this._onComplete = a, this._finalized = !1
                }

                cancel() {
                    this._finalized || (this._onCancel(), this._finalized = !0)
                }

                complete(e, i) {
                    this._finalized || (this._onComplete(e, i), this._finalized = !0)
                }
            }

            z0.performDecoding = function (n, e) {
                const i = new Uint8Array(n);
                return Promise.all(e.tasks.map(a => {
                    const {
                        layerName: c,
                        firstByte: d,
                        lastByte: f,
                        pixelFormat: _,
                        blockShape: x,
                        blockIndex: w,
                        filters: E,
                        codec: I
                    } = a, C = i.subarray(d, f + 1), z = new Uint32Array(x[0] * x[1] * x[2]);
                    let L;
                    if (I !== "gzip_data") throw new na(`Unhandled codec: ${I}`);
                    return L = function (F, N) {
                        if (!globalThis.DecompressionStream && N === "gzip_data") return Promise.resolve(((J = function (ye) {
                            ye[0] == 31 && ye[1] == 139 && ye[2] == 8 || Ea(6, "invalid gzip data");
                            var Ee = ye[3], Ie = 10;
                            4 & Ee && (Ie += 2 + (ye[10] | ye[11] << 8));
                            for (var We = (Ee >> 3 & 1) + (Ee >> 4 & 1); We > 0; We -= !ye[Ie++]) ;
                            return Ie + (2 & Ee)
                        }(X = F)) + 8 > X.length && Ea(6, "invalid gzip data"), function (ye, Ee, Ie, We) {
                            var De = ye.length;
                            if (!De || Ee.f && !Ee.l) return Ie || new js(0);
                            var Ye = !Ie, ht = Ye || Ee.i != 2, Qe = Ee.i;
                            Ye && (Ie = new js(3 * De));
                            var ot, ct, He = function (On) {
                                    var Sn = Ie.length;
                                    if (On > Sn) {
                                        var yn = new js(Math.max(2 * Sn, On));
                                        yn.set(Ie), Ie = yn
                                    }
                                }, st = Ee.f || 0, ke = Ee.p || 0, qe = Ee.b || 0, pt = Ee.l, at = Ee.d, Bt = Ee.m,
                                zt = Ee.n, nt = 8 * De;
                            do {
                                if (!pt) {
                                    st = Sa(ye, ke, 1);
                                    var lt = Sa(ye, ke + 1, 3);
                                    if (ke += 3, !lt) {
                                        var kt = ye[(ne = 4 + ((ke + 7) / 8 | 0)) - 4] | ye[ne - 3] << 8, Et = ne + kt;
                                        if (Et > De) {
                                            Qe && Ea(0);
                                            break
                                        }
                                        ht && He(qe + kt), Ie.set(ye.subarray(ne, Et), qe), Ee.b = qe += kt, Ee.p = ke = 8 * Et, Ee.f = st;
                                        continue
                                    }
                                    if (lt == 1) pt = DO, at = LO, Bt = 9, zt = 5; else if (lt == 2) {
                                        var vt = Sa(ye, ke, 31) + 257, At = Sa(ye, ke + 10, 15) + 4,
                                            Kt = vt + Sa(ye, ke + 5, 31) + 1;
                                        ke += 14;
                                        for (var oi = new js(Kt), pi = new js(19), ui = 0; ui < At; ++ui) pi[MO[ui]] = Sa(ye, ke + 3 * ui, 7);
                                        ke += 3 * At;
                                        var ki = Iw(pi), bi = (1 << ki) - 1, Tn = Tg(pi, ki);
                                        for (ui = 0; ui < Kt;) {
                                            var ne, re = Tn[Sa(ye, ke, bi)];
                                            if (ke += 15 & re, (ne = re >> 4) < 16) oi[ui++] = ne; else {
                                                var Ge = 0, mt = 0;
                                                for (ne == 16 ? (mt = 3 + Sa(ye, ke, 3), ke += 2, Ge = oi[ui - 1]) : ne == 17 ? (mt = 3 + Sa(ye, ke, 7), ke += 3) : ne == 18 && (mt = 11 + Sa(ye, ke, 127), ke += 7); mt--;) oi[ui++] = Ge
                                            }
                                        }
                                        var bt = oi.subarray(0, vt), wt = oi.subarray(vt);
                                        Bt = Iw(bt), zt = Iw(wt), pt = Tg(bt, Bt), at = Tg(wt, zt)
                                    } else Ea(1);
                                    if (ke > nt) {
                                        Qe && Ea(0);
                                        break
                                    }
                                }
                                ht && He(qe + 131072);
                                for (var Lt = (1 << Bt) - 1, ti = (1 << zt) - 1, Ci = ke; ; Ci = ke) {
                                    var Pi = (Ge = pt[Cw(ye, ke) & Lt]) >> 4;
                                    if ((ke += 15 & Ge) > nt) {
                                        Qe && Ea(0);
                                        break
                                    }
                                    if (Ge || Ea(2), Pi < 256) Ie[qe++] = Pi; else {
                                        if (Pi == 256) {
                                            Ci = ke, pt = null;
                                            break
                                        }
                                        var yi = Pi - 254;
                                        Pi > 264 && (yi = Sa(ye, ke, (1 << (mi = wI[ui = Pi - 257])) - 1) + EI[ui], ke += mi);
                                        var an = at[Cw(ye, ke) & ti], Vn = an >> 4;
                                        if (an || Ea(3), ke += 15 & an, wt = zO[Vn], Vn > 3) {
                                            var mi = bI[Vn];
                                            wt += Cw(ye, ke) & (1 << mi) - 1, ke += mi
                                        }
                                        if (ke > nt) {
                                            Qe && Ea(0);
                                            break
                                        }
                                        ht && He(qe + 131072);
                                        var Cn = qe + yi;
                                        if (qe < wt) {
                                            var _n = 0 - wt, tn = Math.min(wt, Cn);
                                            for (_n + qe < 0 && Ea(3); qe < tn; ++qe) Ie[qe] = (void 0)[_n + qe]
                                        }
                                        for (; qe < Cn; ++qe) Ie[qe] = Ie[qe - wt]
                                    }
                                }
                                Ee.l = pt, Ee.p = Ci, Ee.b = qe, Ee.f = st, pt && (st = 1, Ee.m = Bt, Ee.d = at, Ee.n = zt)
                            } while (!st);
                            return qe != Ie.length && Ye ? (ot = Ie, ((ct = qe) == null || ct > ot.length) && (ct = ot.length), new js(ot.subarray(0, ct))) : Ie.subarray(0, qe)
                        }(X.subarray(J, -8), {i: 2}, new js(((H = X)[(Y = H.length) - 4] | H[Y - 3] << 8 | H[Y - 2] << 16 | H[Y - 1] << 24) >>> 0))));
                        var H, Y, X, J;
                        const xe = BO[N];
                        if (!xe) throw new Error(`Unhandled codec: ${N}`);
                        const ge = new globalThis.DecompressionStream(xe);
                        return new Response(new Blob([F]).stream().pipeThrough(ge)).arrayBuffer().then(ye => new Uint8Array(ye))
                    }(C, I).then(F => (function (N, H) {
                        N.readFields(SO, H)
                    }(new Pw(F), z), new jO[_](z.buffer))), L.then(F => {
                        for (let N = E.length - 1; N >= 0; N--) switch (E[N]) {
                            case"delta_filter":
                                AO(F, x);
                                break;
                            case"zigzag_filter":
                                IO(F);
                                break;
                            case"bitshuffle_filter":
                                CO(F, _);
                                break;
                            default:
                                throw new na(`Unhandled filter "${E[N]}"`)
                        }
                        return {layerName: c, blockIndex: w, data: F}
                    }).catch(F => {
                        throw F
                    })
                }))
            }, Pt(MI, "MRTDecodingBatch", {omit: ["_onCancel", "_onComplete"]}), Pt(z0, "MapboxRasterTile"), Pt(PI, "MapboxRasterLayer", {omit: ["_blocksInProgress"]});

            class RI {
                constructor(e) {
                    this._stringToNumber = {}, this._numberToString = [];
                    for (let i = 0; i < e.length; i++) {
                        const a = e[i];
                        this._stringToNumber[a] = i, this._numberToString[i] = a
                    }
                }

                encode(e) {
                    return this._stringToNumber[e]
                }

                decode(e) {
                    return this._numberToString[e]
                }
            }

            const VO = ["id", "tile", "layer", "source", "sourceLayer", "state"];

            class Cf {
                constructor(e, i, a, c, d) {
                    this.type = "Feature", this._vectorTileFeature = e, this._z = i, this._x = a, this._y = c, this.properties = e.properties, this.id = d
                }

                clone() {
                    const e = new Cf(this._vectorTileFeature, this._z, this._x, this._y, this.id);
                    return this.state && (e.state = Object.assign({}, this.state)), this.layer && (e.layer = Object.assign({}, this.layer)), this.source && (e.source = this.source), this.sourceLayer && (e.sourceLayer = this.sourceLayer), e
                }

                get geometry() {
                    return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry
                }

                set geometry(e) {
                    this._geometry = e
                }

                toJSON() {
                    const e = {type: "Feature", state: void 0, geometry: this.geometry, properties: this.properties};
                    for (const i of VO) this[i] !== void 0 && (e[i] = this[i]);
                    return e
                }
            }

            class zI {
                constructor(e, i) {
                    this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new sl(yt, 16, 0), this.featureIndexArray = new Py, this.promoteId = i, this.is3DTile = !1, this.serializedLayersCache = new Map
                }

                insert(e, i, a, c, d, f = 0, _ = 0) {
                    const x = this.featureIndexArray.length;
                    this.featureIndexArray.emplaceBack(a, c, d, f);
                    const w = this.grid;
                    for (let E = 0; E < i.length; E++) {
                        const I = i[E], C = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                        for (let z = 0; z < I.length; z++) {
                            const L = I[z];
                            C[0] = Math.min(C[0], L.x), C[1] = Math.min(C[1], L.y), C[2] = Math.max(C[2], L.x), C[3] = Math.max(C[3], L.y)
                        }
                        _ !== 0 && (C[0] -= _, C[1] -= _, C[2] += _, C[3] += _), C[0] < yt && C[1] < yt && C[2] >= 0 && C[3] >= 0 && w.insert(x, C[0], C[1], C[2], C[3])
                    }
                }

                loadVTLayers() {
                    if (!this.vtLayers) {
                        this.vtLayers = new Ot(new s0(this.rawTileData)).layers, this.sourceLayerCoder = new RI(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
                        for (const e in this.vtLayers) this.vtFeatures[e] = []
                    }
                    return this.vtLayers
                }

                query(e, i) {
                    const {
                        tilespaceGeometry: a,
                        transform: c,
                        tileTransform: d,
                        pixelPosMatrix: f,
                        availableImages: _,
                        worldview: x
                    } = i;
                    this.loadVTLayers(), this.serializedLayersCache.clear();
                    const w = a.bufferedTilespaceBounds,
                        E = this.grid.query(w.min.x, w.min.y, w.max.x, w.max.y, (L, F, N, H) => Yn(a.bufferedTilespaceGeometry, L, F, N, H));
                    E.sort(UO);
                    let I = null;
                    c.elevation && E.length > 0 && (I = Sf.create(c.elevation, this.tileID));
                    const C = {};
                    let z;
                    for (let L = 0; L < E.length; L++) {
                        const F = E[L];
                        if (F === z) continue;
                        z = F;
                        const N = this.featureIndexArray.get(F);
                        let H = null;
                        this.is3DTile ? this.loadMatchingModelFeature(C, N, e, a, c, x) : this.loadMatchingFeature(C, N, e, _, x, (Y, X, J, xe = 0) => (H || (H = Te(Y, this.tileID.canonical, d)), X.queryIntersectsFeature(a, Y, J, H, this.z, c, f, I, xe)))
                    }
                    return C
                }

                loadMatchingFeature(e, i, a, c, d, f) {
                    const {featureIndex: _, bucketIndex: x, sourceLayerIndex: w, layoutVertexArrayOffset: E} = i,
                        I = this.bucketLayerIDs[x], C = a.layers, z = Object.keys(C);
                    if (z.length && !Di(z, I)) return;
                    const L = a.sourceCache, F = this.sourceLayerCoder.decode(w), N = this.vtLayers[F].feature(_),
                        H = this.getId(N, F);
                    for (let Y = 0; Y < I.length; Y++) {
                        const X = I[Y];
                        if (!C[X]) continue;
                        const {styleLayer: J, targets: xe} = C[X];
                        let ge = {};
                        H !== void 0 && (ge = L.getFeatureState(J.sourceLayer, H));
                        const ye = !f || f(N, J, ge, E);
                        if (!ye) continue;
                        const Ee = new Cf(N, this.z, this.x, this.y, H);
                        Ee.tile = this.tileID.canonical, Ee.state = ge;
                        let Ie = this.serializedLayersCache.get(X);
                        Ie || (Ie = J.serialize(), Ie.id = X, this.serializedLayersCache.set(X, Ie)), Ee.source = Ie.source, Ee.sourceLayer = Ie["source-layer"], Ee.layer = Ne({}, Ie), Ee.layer.paint = DI(Ie.paint, J.paint, N, ge, c), Ee.layer.layout = DI(Ie.layout, J.layout, N, ge, c);
                        let We = !1;
                        for (const De of xe) {
                            this.updateFeatureProperties(Ee, De);
                            const {filter: Ye} = De;
                            if (Ye) {
                                if (N.properties = Ee.properties, Ye.needGeometry) {
                                    const ht = $e(N, !0);
                                    if (!Ye.filter(new sn(this.tileID.overscaledZ, {worldview: d}), ht, this.tileID.canonical)) continue
                                } else if (!Ye.filter(new sn(this.tileID.overscaledZ, {worldview: d}), N)) continue
                            }
                            We = !0, De.targetId && this.addFeatureVariant(Ee, De)
                        }
                        We && this.appendToResult(e, X, _, Ee, ye)
                    }
                }

                loadMatchingModelFeature(e, i, a, c, d, f) {
                    const {featureIndex: _, bucketIndex: x} = i, w = this.bucketLayerIDs[x], E = a.layers,
                        I = Object.keys(E);
                    if (!I.length || Di(I, w)) for (let C = 0; C < w.length; C++) {
                        const z = w[C], {styleLayer: L, targets: F} = E[z];
                        if (L.type !== "model") continue;
                        const N = c.tile, H = N.getBucket(L);
                        if (!(H && H instanceof E0)) continue;
                        const Y = W3(H, _, c, d);
                        if (!Y) continue;
                        const {z: X, x: J, y: xe} = N.tileID.canonical, {
                            feature: ge,
                            intersectionZ: ye,
                            position: Ee
                        } = Y;
                        let Ie = {};
                        ge.id !== void 0 && (Ie = a.sourceCache.getFeatureState(L.sourceLayer, ge.id));
                        const We = new Cf({}, X, J, xe, ge.id);
                        We.tile = this.tileID.canonical, We.state = Ie, We.properties = ge.properties, We.geometry = {
                            type: "Point",
                            coordinates: [Ee.lng, Ee.lat]
                        };
                        let De = this.serializedLayersCache.get(z);
                        De || (De = L.serialize(), De.id = z, this.serializedLayersCache.set(z, De)), We.source = De.source, We.sourceLayer = De["source-layer"], We.layer = Ne({}, De);
                        let Ye = !1;
                        for (const ht of F) {
                            this.updateFeatureProperties(We, ht);
                            const {filter: Qe} = ht;
                            if (Qe) {
                                if (ge.properties = We.properties, Qe.needGeometry) {
                                    if (!Qe.filter(new sn(this.tileID.overscaledZ, {worldview: f}), ge, this.tileID.canonical)) continue
                                } else if (!Qe.filter(new sn(this.tileID.overscaledZ, {worldview: f}), ge)) continue
                            }
                            Ye = !0, ht.targetId && this.addFeatureVariant(We, ht)
                        }
                        Ye && this.appendToResult(e, z, _, We, ye)
                    }
                }

                updateFeatureProperties(e, i, a) {
                    if (i.properties) {
                        const c = {};
                        for (const d in i.properties) {
                            const f = i.properties[d].evaluate({zoom: this.z}, e._vectorTileFeature, e.state, e.tile, a);
                            f != null && (c[d] = f)
                        }
                        e.properties = c
                    }
                }

                addFeatureVariant(e, i, a) {
                    const c = {target: i.target, namespace: i.namespace, uniqueFeatureID: i.uniqueFeatureID};
                    i.properties && (c.properties = e.properties), e.variants = e.variants || {}, e.variants[i.targetId] = e.variants[i.targetId] || [], e.variants[i.targetId].push(c)
                }

                appendToResult(e, i, a, c, d) {
                    let f = e[i];
                    f === void 0 && (f = e[i] = []), f.push({featureIndex: a, feature: c, intersectionZ: d})
                }

                lookupSymbolFeatures(e, i, a, c, d, f) {
                    const _ = {};
                    this.loadVTLayers();
                    for (const x of e) this.loadMatchingFeature(_, {
                        bucketIndex: i,
                        sourceLayerIndex: a,
                        featureIndex: x,
                        layoutVertexArrayOffset: 0
                    }, c, d, f);
                    return _
                }

                loadFeature(e) {
                    const {featureIndex: i, sourceLayerIndex: a} = e;
                    this.loadVTLayers();
                    const c = this.sourceLayerCoder.decode(a), d = this.vtFeatures[c];
                    if (d[i]) return d[i];
                    const f = this.vtLayers[c].feature(i);
                    return d[i] = f, f
                }

                hasLayer(e) {
                    for (const i of this.bucketLayerIDs) for (const a of i) if (e === a) return !0;
                    return !1
                }

                getId(e, i) {
                    let a = e.id;
                    if (this.promoteId) {
                        const c = Array.isArray(this.promoteId) || typeof this.promoteId != "object" ? this.promoteId : this.promoteId[i];
                        if (c != null) if (Array.isArray(c)) {
                            if (!this.promoteIdExpression) {
                                const d = Hl(c);
                                if (d.result !== "success") {
                                    const f = d.value.map(_ => `${_.key}: ${_.message}`).join(", ");
                                    return void Li(`Failed to create expression for promoteId: ${f}`)
                                }
                                this.promoteIdExpression = d.value
                            }
                            this.promoteIdExpression._evaluator || (this.promoteIdExpression._evaluator = new lh), a = this.promoteIdExpression.evaluate({zoom: 0}, e)
                        } else a = e.properties[c];
                        typeof a == "boolean" && (a = Number(a))
                    }
                    return a
                }
            }

            function DI(n, e, i, a, c) {
                return li(n, (d, f) => {
                    const _ = e instanceof Bs ? e.get(f) : null;
                    return _ && _.evaluate ? _.evaluate(i, a, void 0, c) : _
                })
            }

            function UO(n, e) {
                return e - n
            }

            Pt(zI, "FeatureIndex", {omit: ["rawTileData", "sourceLayerCoder"]});
            const LI = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];

            class Mw {
                static from(e) {
                    if (!(e instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
                    const [i, a] = new Uint8Array(e, 0, 2);
                    if (i !== 219) throw new Error("Data does not appear to be in a KDBush format.");
                    const c = a >> 4;
                    if (c !== 1) throw new Error(`Got v${c} data when expected v1.`);
                    const d = LI[15 & a];
                    if (!d) throw new Error("Unrecognized array type.");
                    const [f] = new Uint16Array(e, 2, 1), [_] = new Uint32Array(e, 4, 1);
                    return new Mw(_, f, d, e)
                }

                constructor(e, i = 64, a = Float64Array, c) {
                    if (isNaN(e) || e < 0) throw new Error(`Unpexpected numItems value: ${e}.`);
                    this.numItems = +e, this.nodeSize = Math.min(Math.max(+i, 2), 65535), this.ArrayType = a, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
                    const d = LI.indexOf(this.ArrayType), f = 2 * e * this.ArrayType.BYTES_PER_ELEMENT,
                        _ = e * this.IndexArrayType.BYTES_PER_ELEMENT, x = (8 - _ % 8) % 8;
                    if (d < 0) throw new Error(`Unexpected typed array class: ${a}.`);
                    c && c instanceof ArrayBuffer ? (this.data = c, this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + _ + x, 2 * e), this._pos = 2 * e, this._finished = !0) : (this.data = new ArrayBuffer(8 + f + _ + x), this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + _ + x, 2 * e), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + d]), new Uint16Array(this.data, 2, 1)[0] = i, new Uint32Array(this.data, 4, 1)[0] = e)
                }

                add(e, i) {
                    const a = this._pos >> 1;
                    return this.ids[a] = a, this.coords[this._pos++] = e, this.coords[this._pos++] = i, a
                }

                finish() {
                    const e = this._pos >> 1;
                    if (e !== this.numItems) throw new Error(`Added ${e} items when expected ${this.numItems}.`);
                    return Rw(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this
                }

                range(e, i, a, c) {
                    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
                    const {ids: d, coords: f, nodeSize: _} = this, x = [0, d.length - 1, 0], w = [];
                    for (; x.length;) {
                        const E = x.pop() || 0, I = x.pop() || 0, C = x.pop() || 0;
                        if (I - C <= _) {
                            for (let N = C; N <= I; N++) {
                                const H = f[2 * N], Y = f[2 * N + 1];
                                H >= e && H <= a && Y >= i && Y <= c && w.push(d[N])
                            }
                            continue
                        }
                        const z = C + I >> 1, L = f[2 * z], F = f[2 * z + 1];
                        L >= e && L <= a && F >= i && F <= c && w.push(d[z]), (E === 0 ? e <= L : i <= F) && (x.push(C), x.push(z - 1), x.push(1 - E)), (E === 0 ? a >= L : c >= F) && (x.push(z + 1), x.push(I), x.push(1 - E))
                    }
                    return w
                }

                within(e, i, a) {
                    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
                    const {ids: c, coords: d, nodeSize: f} = this, _ = [0, c.length - 1, 0], x = [], w = a * a;
                    for (; _.length;) {
                        const E = _.pop() || 0, I = _.pop() || 0, C = _.pop() || 0;
                        if (I - C <= f) {
                            for (let N = C; N <= I; N++) OI(d[2 * N], d[2 * N + 1], e, i) <= w && x.push(c[N]);
                            continue
                        }
                        const z = C + I >> 1, L = d[2 * z], F = d[2 * z + 1];
                        OI(L, F, e, i) <= w && x.push(c[z]), (E === 0 ? e - a <= L : i - a <= F) && (_.push(C), _.push(z - 1), _.push(1 - E)), (E === 0 ? e + a >= L : i + a >= F) && (_.push(z + 1), _.push(I), _.push(1 - E))
                    }
                    return x
                }
            }

            function Rw(n, e, i, a, c, d) {
                if (c - a <= i) return;
                const f = a + c >> 1;
                kI(n, e, f, a, c, d), Rw(n, e, i, a, f - 1, 1 - d), Rw(n, e, i, f + 1, c, 1 - d)
            }

            function kI(n, e, i, a, c, d) {
                for (; c > a;) {
                    if (c - a > 600) {
                        const w = c - a + 1, E = i - a + 1, I = Math.log(w), C = .5 * Math.exp(2 * I / 3),
                            z = .5 * Math.sqrt(I * C * (w - C) / w) * (E - w / 2 < 0 ? -1 : 1);
                        kI(n, e, i, Math.max(a, Math.floor(i - E * C / w + z)), Math.min(c, Math.floor(i + (w - E) * C / w + z)), d)
                    }
                    const f = e[2 * i + d];
                    let _ = a, x = c;
                    for (Eg(n, e, a, i), e[2 * c + d] > f && Eg(n, e, a, c); _ < x;) {
                        for (Eg(n, e, _, x), _++, x--; e[2 * _ + d] < f;) _++;
                        for (; e[2 * x + d] > f;) x--
                    }
                    e[2 * a + d] === f ? Eg(n, e, a, x) : (x++, Eg(n, e, x, c)), x <= i && (a = x + 1), i <= x && (c = x - 1)
                }
            }

            function Eg(n, e, i, a) {
                zw(n, i, a), zw(e, 2 * i, 2 * a), zw(e, 2 * i + 1, 2 * a + 1)
            }

            function zw(n, e, i) {
                const a = n[e];
                n[e] = n[i], n[i] = a
            }

            function OI(n, e, i, a) {
                const c = n - i, d = e - a;
                return c * c + d * d
            }

            o.$ = Mr, o.A = _a, o.B = va, o.C = jc, o.D = pf, o.E = Ol, o.F = 2, o.G = hg, o.H = lA, o.I = Lo, o.J = Xa, o.K = class extends S0 {
            }, o.L = Fl, o.M = by, o.N = Gd, o.O = Ud, o.P = Ze, o.Q = dy, o.R = Yu, o.S = hm, o.T = q1, o.U = wh, o.V = S0, o.W = dm, o.X = Hl, o.Y = Cd, o.Z = Rc, o._ = Mc, o.a = function (n) {
                return Br.API_CDN_URL_REGEX.test(n)
            }, o.a$ = Je, o.a0 = Lp, o.a1 = bh, o.a2 = $d, o.a3 = hy, o.a4 = function (n) {
                const e = n.value;
                let i = [];
                if (!e) return i;
                const a = Xa(e);
                return a !== "string" ? (i = i.concat([new S0(n.key, e, `string expected, "${a}" found`)]), i) : (vw(e, !0) || (i = i.concat([new S0(n.key, e, `invalid url "${e}"`)])), i)
            }, o.a5 = ze, o.a6 = xh, o.a7 = qn, o.a8 = dt, o.a9 = class {
                constructor(n) {
                    this.specification = n
                }

                possiblyEvaluate(n, e) {
                    return lr(n.expression.evaluate(e))
                }

                interpolate(n, e, i) {
                    return {
                        x: qt(n.x, e.x, i),
                        y: qt(n.y, e.y, i),
                        z: qt(n.z, e.z, i),
                        azimuthal: qt(n.azimuthal, e.azimuthal, i),
                        polar: qt(n.polar, e.polar, i)
                    }
                }
            }, o.aA = Ir, o.aB = io, o.aC = Gr, o.aD = B, o.aE = Se, o.aF = function (n, e) {
                const i = {};
                for (let a = 0; a < e.length; a++) {
                    const c = e[a];
                    c in n && (i[c] = n[c])
                }
                return i
            }, o.aG = k, o.aH = G, o.aI = class {
                constructor(n) {
                    this.entries = {}, this.scheduler = n
                }

                request(n, e, i, a) {
                    const c = this.entries[n] = this.entries[n] || {callbacks: []};
                    if (c.result) {
                        const [d, f] = c.result;
                        return this.scheduler ? this.scheduler.add(() => {
                            a(d, f)
                        }, e) : a(d, f), () => {
                        }
                    }
                    return c.callbacks.push(a), c.cancel || (c.cancel = i((d, f) => {
                        c.result = [d, f];
                        for (const _ of c.callbacks) this.scheduler ? this.scheduler.add(() => {
                            _(d, f)
                        }, e) : _(d, f);
                        setTimeout(() => delete this.entries[n], 3e3)
                    })), () => {
                        c.result || (c.callbacks = c.callbacks.filter(d => d !== a), c.callbacks.length || (c.cancel(), delete this.entries[n]))
                    }
                }
            }, o.aJ = function (n, e, i) {
                const a = JSON.stringify(n.request);
                return n.data && (this.deduped.entries[a] = {result: [null, n.data]}), this.deduped.request(a, {
                    type: "parseTile",
                    isSymbolTile: n.isSymbolTile,
                    zoom: n.tileZoom
                }, c => {
                    const d = Ku(n.request, (f, _, x, w) => {
                        f ? c(f) : _ && c(null, {
                            vectorTile: i ? void 0 : new Ot(new s0(_)),
                            rawData: _,
                            cacheControl: x,
                            expires: w
                        })
                    });
                    return () => {
                        d.cancel(), c()
                    }
                }, e)
            }, o.aK = function (n) {
                Pp++, Pp > ga && (n.getActor().send("enforceCacheSizeLimit", Os), Pp = 0)
            }, o.aL = function (n) {
                return n <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(n) / Math.LN2))
            }, o.aM = hr, o.aN = FA, o.aO = GA, o.aP = OA, o.aQ = function (n, e) {
                const i = document.createElement("video");
                i.muted = !0, i.onloadstart = function () {
                    e(null, i)
                };
                for (let a = 0; a < n.length; a++) {
                    const c = document.createElement("source");
                    Nx(n[a]) || (i.crossOrigin = "Anonymous"), c.src = n[a], i.appendChild(c)
                }
                return {
                    cancel: () => {
                    }
                }
            }, o.aR = og, o.aS = function (n) {
                return fetch(n).then(e => e.arrayBuffer()).then(e => pE(e, 0, n))
            }, o.aT = bE, o.aU = class {
                constructor(n, e, i, a) {
                    this.id = n, this.position = e != null ? new M(e[0], e[1]) : new M(0, 0), this.orientation = i ?? [0, 0, 0], this.nodes = a, this.uploaded = !1, this.aabb = new Ei([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), this.matrix = []
                }

                _applyTransformations(n, e) {
                    if (pe(n.matrix, e, n.matrix), n.meshes) for (const i of n.meshes) {
                        const a = Ei.applyTransformFast(i.aabb, n.matrix);
                        this.aabb.encapsulate(a)
                    }
                    if (n.children) for (const i of n.children) this._applyTransformations(i, n.matrix)
                }

                computeBoundsAndApplyParent() {
                    const n = fe([]);
                    for (const e of this.nodes) this._applyTransformations(e, n)
                }

                computeModelMatrix(n, e, i, a, c, d, f = !1) {
                    xE(this.matrix, this, n.transform, this.position, e, i, a, c, d, f)
                }

                upload(n) {
                    if (!this.uploaded) {
                        for (const e of this.nodes) X1(e, n);
                        for (const e of this.nodes) o0(e);
                        this.uploaded = !0
                    }
                }

                destroy() {
                    for (const n of this.nodes) Y1(n)
                }
            }, o.aV = ii, o.aW = pg, o.aX = Z, o.aY = Q, o.aZ = Uc, o.a_ = Mn, o.aa = sn, o.ab = ol, o.ac = me, o.ad = An, o.ae = Mi, o.af = Ae, o.ag = Bs, o.ah = Jc, o.ai = qt, o.aj = yt, o.ak = j_, o.al = Ai, o.am = Ji, o.an = class {
                constructor(n) {
                    this.specification = n
                }

                possiblyEvaluate(n, e) {
                    return function ([i, a]) {
                        const c = lr([1, i, a]);
                        return {x: c.x, y: c.y, z: c.z}
                    }(n.expression.evaluate(e))
                }

                interpolate(n, e, i) {
                    return {x: qt(n.x, e.x, i), y: qt(n.y, e.y, i), z: qt(n.z, e.z, i)}
                }
            }, o.ao = function (n, e, i = 0, a = !0) {
                const c = new Ze(i, i), d = n.sub(c), f = e.add(c), _ = [d, new Ze(f.x, d.y), f, new Ze(d.x, f.y)];
                return a && _.push(d.clone()), _
            }, o.ap = function (n, e) {
                const i = [];
                for (let a = 0; a < n.length; a++) {
                    const c = Ve(a - 1, -1, n.length - 1), d = Ve(a + 1, -1, n.length - 1), f = n[a], _ = n[d],
                        x = n[c].sub(f).unit(), w = _.sub(f).unit(), E = w.angleWithSep(x.x, x.y),
                        I = x.add(w).unit().mult(-1 * e / Math.sin(E / 2));
                    i.push(f.add(I))
                }
                return i
            }, o.aq = bA, o.ar = Yn, o.as = function (n, e, i = 0) {
                return $t(((e.x - i) * n.scale - n.x) * yt, (e.y * n.scale - n.y) * yt, te(e.z, e.y))
            }, o.at = Nn, o.au = Bi, o.av = Gi, o.aw = DE, o.ax = function (n) {
                let e = 1 / 0, i = 1 / 0, a = -1 / 0, c = -1 / 0;
                for (const d of n) e = Math.min(e, d.x), i = Math.min(i, d.y), a = Math.max(a, d.x), c = Math.max(c, d.y);
                return {min: new Ze(e, i), max: new Ze(a, c)}
            }, o.ay = se, o.az = pe, o.b = function (n) {
                return Br.API_FONTS_REGEX.test(n)
            }, o.b$ = uw, o.b0 = Ay, o.b1 = x0, o.b2 = function () {
                Qs.isLoading() || Qs.isLoaded() || vm() !== "deferred" || vy()
            }, o.b3 = Bc, o.b4 = $e, o.b5 = Cf,o.b6 = Zi,o.b7 = J1,o.b8 = R1,o.b9 = Te,o.bA = function (n, e) {
                const {x: i, y: a} = n.point, c = iS(i, a, n.worldSize / n._pixelsPerMercatorPixel, 0, 0);
                return pe(c, c, w1(fl(e)))
            },o.bB = ee,o.bC = Do,o.bD = function (n, e) {
                return Math.hypot(e[0] - n[0], e[1] - n[1], e[2] - n[2])
            },o.bE = fi,o.bF = Bn,o.bG = Ii,o.bH = ug,o.bI = ss,o.bJ = sw,o.bK = function (n, e, i, a, c) {
                const d = 5 * e + 2;
                n.float32[d + 0] = i, n.float32[d + 1] = a, n.float32[d + 2] = c
            },o.bL = v0,o.bM = uo,o.bN = Ls,o.bO = ms,o.bP = To,o.bQ = Ve,o.bR = function (n, e, i, a) {
                var c = new q(4);
                return c[0] = n, c[1] = e, c[2] = i, c[3] = a, c
            },o.bS = Qy,o.bT = hn,o.bU = Dr,o.bV = DS,o.bW = $A,o.bX = FS,o.bY = L1,o.bZ = ow,o.b_ = mA,o.ba = Po,o.bb = Dm,o.bc = Y2,o.bd = Ln,o.be = df,o.bf = _w,o.bg = function (n, e) {
                const i = Jc(e.zoom);
                if (i === 0) return fl(n);
                const a = Vy(n), c = x1(a), d = B(a.getWest()) * e.worldSize, f = B(a.getEast()) * e.worldSize,
                    _ = G(a.getNorth()) * e.worldSize, x = G(a.getSouth()) * e.worldSize, w = [d, _, 0], E = [f, _, 0],
                    I = [d, x, 0], C = [f, x, 0], z = Me([], e.globeMatrix);
                return An(w, w, z), An(E, E, z), An(I, I, z), An(C, C, z), c[0] = Ql(c[0], I, i), c[1] = Ql(c[1], C, i), c[2] = Ql(c[2], E, i), c[3] = Ql(c[3], w, i), Ei.fromPoints(c)
            },o.bh = Gy,o.bi = Me,o.bj = Gm,o.bk = Ql,o.bl = Vc,o.bm = xL,o.bn = xt,o.bo = le,o.bp = z0,o.bq = s0,o.br = Ku,o.bs = function (n, e) {
                const i = [];
                for (const a in n) a in e || i.push(a);
                return i
            },o.bt = Pe,o.bu = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"],o.bv = xn,o.bw = function (n) {
                var e = new q(16);
                return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], e
            },o.bx = fe,o.by = _t,o.bz = Re,o.c = cd,o.c$ = 45,o.c0 = Mw,o.c1 = ai,o.c2 = fs,o.c3 = Yr,o.c4 = function (n, e, i) {
                i *= .5;
                var a = e[0], c = e[1], d = e[2], f = e[3], _ = Math.sin(i), x = Math.cos(i);
                return n[0] = a * x + c * _, n[1] = c * x - a * _, n[2] = d * x + f * _, n[3] = f * x - d * _, n
            },o.c5 = fa,o.c6 = jn,o.c7 = function (n, e) {
                return n[0] = -e[0], n[1] = -e[1], n[2] = -e[2], n[3] = e[3], n
            },o.c8 = Xt,o.c9 = function (n, e, i, a, c) {
                var d, f = 1 / Math.tan(e / 2);
                return n[0] = f / i, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = f, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = -1, n[12] = 0, n[13] = 0, n[15] = 0, c != null && c !== 1 / 0 ? (n[10] = (c + a) * (d = 1 / (a - c)), n[14] = 2 * c * a * d) : (n[10] = -1, n[14] = -2 * a), n
            },o.cA = ns,o.cB = J2,o.cC = function (n, e, i, a, c, d, f, _, x) {
                if (x.name === "globe") return J2(n, e, new ns(i, a, c), !1);
                const w = pg({z: i, x: a, y: c}, x);
                return new Ei([(d + w.x / w.scale) * e, e * (w.y / w.scale), f], [(d + w.x2 / w.scale) * e, e * (w.y2 / w.scale), _])
            },o.cD = function (n, e, i) {
                return n[0] = Math.min(e[0], i[0]), n[1] = Math.min(e[1], i[1]), n[2] = Math.min(e[2], i[2]), n[3] = Math.min(e[3], i[3]), n
            },o.cE = function (n, e, i) {
                return n[0] = Math.max(e[0], i[0]), n[1] = Math.max(e[1], i[1]), n[2] = Math.max(e[2], i[2]), n[3] = Math.max(e[3], i[3]), n
            },o.cF = function (n) {
                const e = Math.round((n + 45 + 360) % 360 / 90) % 4;
                return $[e]
            },o.cG = ce,o.cH = lo,o.cI = u,o.cJ = function (n) {
                const e = fe(new Float64Array(16));
                pe(e, n.pixelMatrix, n.globeMatrix);
                const i = [0, m, 0], a = [0, g, 0];
                return An(i, i, e), An(a, a, e), [i[0] > 0 && i[0] <= n.width && i[1] > 0 && i[1] <= n.height && !T1(n, new M(n.center.lat, 90)), a[0] > 0 && a[0] <= n.width && a[1] > 0 && a[1] <= n.height && !T1(n, new M(n.center.lat, -90))]
            },o.cK = function (n, e) {
                const {scale: i} = n.tileTransform,
                    a = i * yt / (n.tileSize * Math.pow(2, e.zoom - n.tileID.overscaledZ + n.tileID.canonical.z));
                return function (c, d, f) {
                    var _ = d[1], x = d[2], w = d[3], E = f[0], I = f[1];
                    return c[0] = d[0] * E, c[1] = _ * E, c[2] = x * I, c[3] = w * I, c
                }(new Float32Array(4), e.inverseAdjustmentMatrix, [a, a])
            },o.cL = n0,o.cM = Zt,o.cN = mE,o.cO = function (n) {
                const e = mE(n, !0);
                return ee([], [e[0], e[1], e[4], e[5]])
            },o.cP = be,o.cQ = qi,o.cR = Ue,o.cS = function (n) {
                const {x: e, y: i} = n.point, {lng: a, lat: c} = n._center;
                return iS(e, i, n.worldSize, a, c)
            },o.cT = Ct,o.cU = Le,o.cV = rs,o.cW = Un,o.cX = By,o.cY = function (n, e, i) {
                let a = 0;
                for (let c = 0; c < 2; ++c) n[c] > 0 && (a += (n[c] - 0) * (n[c] - 0)), e[c] < 0 && (a += (0 - e[c]) * (0 - e[c]));
                return a
            },o.cZ = function (n) {
                return n * n * n * n * n
            },o.c_ = V,o.ca = function (n, e, i, a, c, d, f) {
                var _ = 1 / (e - i), x = 1 / (a - c), w = 1 / (d - f);
                return n[0] = -2 * _, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = -2 * x, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 2 * w, n[11] = 0, n[12] = (e + i) * _, n[13] = (c + a) * x, n[14] = (f + d) * w, n[15] = 1, n
            },o.cb = U,o.cc = function (n, e, i) {
                n[4 * e + 0] = i[0], n[4 * e + 1] = i[1], n[4 * e + 2] = i[2], n[4 * e + 3] = i[3]
            },o.cd = hf,o.ce = Xc,o.cf = tr,o.cg = ta,o.ch = Mh,o.ci = M,o.cj = IA,o.ck = function () {
                var n = new q(4);
                return q != Float32Array && (n[1] = 0, n[2] = 0), n[0] = 1, n[3] = 1, n
            },o.cl = function (n, e, i) {
                var a = e[0], c = e[1], d = e[2], f = e[3], _ = Math.sin(i), x = Math.cos(i);
                return n[0] = a * x + d * _, n[1] = c * x + f * _, n[2] = a * -_ + d * x, n[3] = c * -_ + f * x, n
            },o.cm = function (n, e) {
                return n[0] === e[0] && n[1] === e[1] && n[2] === e[2] && n[3] === e[3]
            },o.cn = Xr,o.co = function (n) {
                return Math.hypot(n[0], n[1], n[2], n[3])
            },o.cp = zs,o.cq = wo,o.cr = ia,o.cs = 3,o.ct = 2,o.cu = 7,o.cv = 6,o.cw = ar,o.cx = Ht,o.cy = Xi,o.cz = gE,o.d = function (n) {
                return Br.API_TILEJSON_REGEX.test(n)
            },o.d$ = (n, e, i, a, c, d, f, _, x, w) => {
                const E = n.transform, I = E.calculatePixelsToTileUnitsMatrix(e),
                    C = i.paint.get("line-trim-color-use-theme").constantOr("default") === "none",
                    z = E.pitch < 15 ? LE(.07, .7, se((14 - E.zoom) / 5, 0, 1)) : .07;
                return {
                    u_matrix: OE(n, e, i, a),
                    u_pixels_to_tile_units: I,
                    u_device_pixel_ratio: d,
                    u_width_scale: f,
                    u_floor_width_scale: _,
                    u_units_to_pixels: [1 / E.pixelsToGLUnits[0], 1 / E.pixelsToGLUnits[1]],
                    u_dash_image: 0,
                    u_gradient_image: 1,
                    u_image_height: c,
                    u_texsize: BE(i) && e.lineAtlasTexture ? e.lineAtlasTexture.size : [0, 0],
                    u_tile_units_to_pixels: kE(e, n.transform),
                    u_alpha_discard_threshold: 0,
                    u_trim_offset: x,
                    u_trim_fade_range: i.paint.get("line-trim-fade-range"),
                    u_trim_color: i.paint.get("line-trim-color").toPremultipliedRenderColor(C ? null : i.lut).toArray01(),
                    u_emissive_strength: i.paint.get("line-emissive-strength"),
                    u_zbias_factor: z,
                    u_tile_to_meter: he(e.tileID.canonical, 0),
                    u_ground_shadow_factor: w
                }
            },o.d0 = Ph,o.d1 = function (n, e, i) {
                const a = Math.sqrt(n * n + e * e + i * i), c = a > 0 ? Math.acos(i / a) * Kr : 0;
                let d = n !== 0 || e !== 0 ? Math.atan2(-e, -n) * Kr + 90 : 0;
                return d < 0 && (d += 360), [a, d, c]
            },o.d2 = $t,o.d3 = lr,o.d4 = he,o.d5 = si,o.d6 = Ei,o.d7 = Ri,o.d8 = function (n) {
                return [Math.pow(n[0], 1 / 2.2), Math.pow(n[1], 1 / 2.2), Math.pow(n[2], 1 / 2.2)]
            },o.d9 = vw,o.dA = Vy,o.dB = function (n) {
                const e = ce - 5;
                n = se(n, -e, e) / e * 90;
                const i = Math.pow(Math.abs(Math.sin(Ai(n))), 3);
                return Math.round(i * (h.length - 1))
            },o.dC = function (n, e, i, a) {
                const c = e.getNorth(), d = e.getSouth(), f = e.getWest(), _ = e.getEast(), x = 1 << n.z, w = _ - f,
                    E = c - d, I = w / s, C = -E / h[i], z = [0, I, 0, C, 0, 0, c, f, 0];
                if (n.z > 0) {
                    const L = 180 / a;
                    ae(z, z, [L / w + 1, 0, 0, 0, L / E + 1, 0, -.5 * L / I, .5 * L / C, 1])
                }
                return z[2] = x, z[5] = n.x, z[8] = n.y, z
            },o.dD = fl,o.dE = function (n, e, i) {
                const a = fe(new Float64Array(16)), c = (e / (1 << n) - .5) * Math.PI * 2;
                return et(a, i.globeMatrix, c), Float32Array.from(a)
            },o.dF = class {
                isDataAvailableAtPoint(n) {
                    const e = this._source();
                    if (this.isUsingMockSource() || !e || n.y < 0 || n.y > 1) return !1;
                    const i = e.getSource().maxzoom, a = 1 << i, c = Math.floor(n.x), d = Math.floor((n.x - c) * a),
                        f = Math.floor(n.y * a), _ = this.findDEMTileFor(new hr(i, c, i, d, f));
                    return !(!_ || !_.dem)
                }

                getAtPointOrZero(n, e = 0) {
                    return this.getAtPoint(n, e) || 0
                }

                getAtPoint(n, e, i = !0) {
                    if (this.isUsingMockSource()) return null;
                    e == null && (e = null);
                    const a = this._source();
                    if (!a || n.y < 0 || n.y > 1) return e;
                    const c = a.getSource().maxzoom, d = 1 << c, f = Math.floor(n.x), _ = n.x - f,
                        x = new hr(c, f, c, Math.floor(_ * d), Math.floor(n.y * d)), w = this.findDEMTileFor(x);
                    if (!w || !w.dem) return e;
                    const E = w.dem, I = 1 << w.tileID.canonical.z, C = (_ * I - w.tileID.canonical.x) * E.dim,
                        z = (n.y * I - w.tileID.canonical.y) * E.dim, L = Math.floor(C), F = Math.floor(z);
                    return (i ? this.exaggeration() : 1) * qt(qt(E.get(L, F), E.get(L, F + 1), z - F), qt(E.get(L + 1, F), E.get(L + 1, F + 1), z - F), C - L)
                }

                getAtTileOffset(n, e, i) {
                    const a = 1 << n.canonical.z;
                    return this.getAtPointOrZero(new me(n.wrap + (n.canonical.x + e / yt) / a, (n.canonical.y + i / yt) / a))
                }

                getAtTileOffsetFunc(n, e, i, a) {
                    return c => {
                        const d = this.getAtTileOffset(n, c.x, c.y), f = a.upVector(n.canonical, c.x, c.y);
                        return ai(f, f, d * a.upVectorScale(n.canonical, e, i).metersToTile), f
                    }
                }

                getForTilePoints(n, e, i, a) {
                    if (this.isUsingMockSource()) return !1;
                    const c = Sf.create(this, n, a);
                    return !!c && (e.forEach(d => {
                        d[2] = this.exaggeration() * c.getElevationAt(d[0], d[1], i)
                    }), !0)
                }

                getMinMaxForTile(n) {
                    if (this.isUsingMockSource()) return null;
                    const e = this.findDEMTileFor(n);
                    if (!e || !e.dem) return null;
                    const i = e.dem.tree, a = e.tileID, c = 1 << n.canonical.z - a.canonical.z;
                    let d = n.canonical.x / c - a.canonical.x, f = n.canonical.y / c - a.canonical.y, _ = 0;
                    for (let x = 0; x < n.canonical.z - a.canonical.z && !i.leaves[_]; x++) {
                        d *= 2, f *= 2;
                        const w = 2 * Math.floor(f) + Math.floor(d);
                        _ = i.childOffsets[_] + w, d %= 1, f %= 1
                    }
                    return {min: this.exaggeration() * i.minimums[_], max: this.exaggeration() * i.maximums[_]}
                }

                getMinElevationBelowMSL() {
                    throw new Error("Pure virtual method called.")
                }

                raycast(n, e, i) {
                    throw new Error("Pure virtual method called.")
                }

                pointCoordinate(n) {
                    throw new Error("Pure virtual method called.")
                }

                _source() {
                    throw new Error("Pure virtual method called.")
                }

                isUsingMockSource() {
                    throw new Error("Pure virtual method called.")
                }

                exaggeration() {
                    throw new Error("Pure virtual method called.")
                }

                findDEMTileFor(n) {
                    throw new Error("Pure virtual method called.")
                }

                get visibleDemTiles() {
                    throw new Error("Getter must be implemented in subclass.")
                }

                getMinMaxForVisibleTiles() {
                    const n = this.visibleDemTiles;
                    if (n.length === 0) return null;
                    let e = !1, i = Number.MAX_VALUE, a = Number.MIN_VALUE;
                    for (const c of n) {
                        const d = this.getMinMaxForTile(c.tileID);
                        d && (i = Math.min(i, d.min), a = Math.max(a, d.max), e = !0)
                    }
                    return e ? {min: i, max: a} : null
                }
            },o.dG = mS,o.dH = jy,o.dI = function (n, e) {
                return [Math.pow(n[0], 2.2) * e, Math.pow(n[1], 2.2) * e, Math.pow(n[2], 2.2) * e]
            },o.dJ = oe,o.dK = function (n, e) {
                var i = Math.sin(e), a = Math.cos(e);
                return n[0] = a, n[1] = i, n[2] = 0, n[3] = -i, n[4] = a, n[5] = 0, n[6] = 0, n[7] = 0, n[8] = 1, n
            },o.dL = Zr,o.dM = tS,o.dN = So,o.dO = Qr,o.dP = 256,o.dQ = function (n, e) {
                const i = [0, 0, 0];
                return An(i, i, Gy(fl(e.canonical))), An(i, i, n), i
            },o.dR = n => ({
                u_matrix: new Mh(n),
                u_texsize: new ta(n),
                u_pixels_to_tile_units: new Vm(n),
                u_device_pixel_ratio: new tr(n),
                u_width_scale: new tr(n),
                u_floor_width_scale: new tr(n),
                u_image: new hf(n),
                u_units_to_pixels: new ta(n),
                u_tile_units_to_pixels: new tr(n),
                u_alpha_discard_threshold: new tr(n),
                u_trim_offset: new ta(n),
                u_trim_fade_range: new ta(n),
                u_trim_color: new Ph(n),
                u_emissive_strength: new tr(n),
                u_zbias_factor: new tr(n),
                u_tile_to_meter: new tr(n),
                u_ground_shadow_factor: new Xc(n),
                u_pattern_transition: new tr(n)
            }),o.dS = n => ({
                u_matrix: new Mh(n),
                u_pixels_to_tile_units: new Vm(n),
                u_device_pixel_ratio: new tr(n),
                u_width_scale: new tr(n),
                u_floor_width_scale: new tr(n),
                u_units_to_pixels: new ta(n),
                u_dash_image: new hf(n),
                u_gradient_image: new hf(n),
                u_image_height: new tr(n),
                u_texsize: new ta(n),
                u_tile_units_to_pixels: new tr(n),
                u_alpha_discard_threshold: new tr(n),
                u_trim_offset: new ta(n),
                u_trim_fade_range: new ta(n),
                u_trim_color: new Ph(n),
                u_emissive_strength: new tr(n),
                u_zbias_factor: new tr(n),
                u_tile_to_meter: new tr(n),
                u_ground_shadow_factor: new Xc(n)
            }),o.dT = n => ({
                u_camera_to_center_distance: new tr(n),
                u_extrude_scale: new Vm(n),
                u_device_pixel_ratio: new tr(n),
                u_matrix: new Mh(n),
                u_inv_rot_matrix: new Mh(n),
                u_merc_center: new ta(n),
                u_tile_id: new Xc(n),
                u_zoom_transition: new tr(n),
                u_up_dir: new Xc(n),
                u_emissive_strength: new tr(n)
            }),o.dU = Hc,o.dV = t3,o.dW = oS,o.dX = (n, e, i, a, c, d) => {
                const f = n.transform, _ = f.projection.name === "globe";
                let x;
                if (d.paint.get("circle-pitch-alignment") === "map") if (_) {
                    const E = tS(f.zoom, e.canonical) * f._pixelsPerMercatorPixel;
                    x = Float32Array.from([E, 0, 0, E])
                } else x = f.calculatePixelsToTileUnitsMatrix(i); else x = new Float32Array([f.pixelsToGLUnits[0], 0, 0, f.pixelsToGLUnits[1]]);
                const w = {
                    u_camera_to_center_distance: n.transform.getCameraToCenterDistance(f.projection),
                    u_matrix: n.translatePosMatrix(e.projMatrix, i, d.paint.get("circle-translate"), d.paint.get("circle-translate-anchor")),
                    u_device_pixel_ratio: ks.devicePixelRatio,
                    u_extrude_scale: x,
                    u_inv_rot_matrix: EL,
                    u_merc_center: [0, 0],
                    u_tile_id: [0, 0, 0],
                    u_zoom_transition: 0,
                    u_up_dir: [0, 0, 0],
                    u_emissive_strength: d.paint.get("circle-emissive-strength")
                };
                if (_) {
                    w.u_inv_rot_matrix = a, w.u_merc_center = c, w.u_tile_id = [e.canonical.x, e.canonical.y, 1 << e.canonical.z], w.u_zoom_transition = Jc(f.zoom);
                    const E = c[0] * yt, I = c[1] * yt;
                    w.u_up_dir = f.projection.upVector(new ns(0, 0, 0), E, I)
                }
                return w
            },o.dY = FE,o.dZ = Ao,o.d_ = (n, e, i, a, c, d, f, _, x, w) => {
                const E = n.transform, I = E.pitch < 15 ? LE(.07, .7, se((14 - E.zoom) / 5, 0, 1)) : .07,
                    C = i.paint.get("line-trim-color-use-theme").constantOr("default") === "none";
                return {
                    u_matrix: OE(n, e, i, a),
                    u_texsize: e.imageAtlasTexture ? e.imageAtlasTexture.size : [0, 0],
                    u_pixels_to_tile_units: E.calculatePixelsToTileUnitsMatrix(e),
                    u_device_pixel_ratio: c,
                    u_width_scale: d,
                    u_floor_width_scale: f,
                    u_image: 0,
                    u_tile_units_to_pixels: kE(e, E),
                    u_units_to_pixels: [1 / E.pixelsToGLUnits[0], 1 / E.pixelsToGLUnits[1]],
                    u_alpha_discard_threshold: 0,
                    u_trim_offset: _,
                    u_trim_fade_range: i.paint.get("line-trim-fade-range"),
                    u_trim_color: i.paint.get("line-trim-color").toPremultipliedRenderColor(C ? null : i.lut).toArray01(),
                    u_emissive_strength: i.paint.get("line-emissive-strength"),
                    u_zbias_factor: I,
                    u_tile_to_meter: he(e.tileID.canonical, 0),
                    u_ground_shadow_factor: x,
                    u_pattern_transition: w
                }
            },o.da = function (n, e) {
                return n.readFields(Y3, {icons: []}, e)
            },o.db = Jy,o.dc = wf,o.dd = lw,o.de = fd,o.df = yy,o.dg = _s,o.dh = xc,o.di = Ti,o.dj = function (n) {
                const e = n.indexOf(Th);
                return e >= 0 ? n.slice(0, e) : n
            },o.dk = function (n) {
                return n.indexOf(Th) >= 0
            },o.dl = function (n) {
                const e = n.lastIndexOf(Th);
                return e >= 0 ? n.slice(e + 1) : ""
            },o.dm = function (n) {
                const e = [], i = n.id;
                return i === void 0 && e.push({message: `layers.${i}: missing required property "id"`}), n.render === void 0 && e.push({message: `layers.${i}: missing required method "render"`}), n.renderingMode && n.renderingMode !== "2d" && n.renderingMode !== "3d" && e.push({message: `layers.${i}: property "renderingMode" must be either "2d" or "3d"`}), e
            },o.dn = function (n, e, i, a) {
                return n.type === "custom" ? new $3(n, e) : new Z3[n.type](n, e, i, a)
            },o.dp = zi,o.dq = function (n) {
                const e = n.indexOf(Th);
                return e >= 0 ? n.slice(e + 1) : ""
            },o.dr = class extends Cf {
                constructor(n, e) {
                    super(n._vectorTileFeature, n._z, n._x, n._y, n.id), n.state && (this.state = Object.assign({}, n.state)), this.target = e.target, this.namespace = e.namespace, e.properties && (this.properties = e.properties), this.target && ("featuresetId" in this.target && !this.target.importId || "layerId" in this.target) && (this.source = n.source, this.sourceLayer = n.sourceLayer, this.layer = n.layer)
                }

                toJSON() {
                    const n = super.toJSON();
                    return n.target = this.target, n.namespace = this.namespace, n
                }
            },o.ds = ym,o.dt = yc,o.du = function (n) {
                return n({pluginStatus: mo, pluginURL: al}), ym.on("pluginStateChange", n), n
            },o.dv = jm,o.dw = class extends bs {
                constructor(n) {
                    super(n), this.current = p1
                }

                set(n, e, i) {
                    if (this.fetchUniformLocation(n, e)) {
                        for (let a = 0; a < 9; a++) if (i[a] !== this.current[a]) {
                            this.current = i, this.gl.uniformMatrix3fv(this.location, !1, i);
                            break
                        }
                    }
                }
            },o.dx = W,o.dy = function (n, e, i) {
                const a = Jc(i.zoom), c = n.style.map._antialias, d = n.terrain && n.terrain.exaggeration() > 0;
                return a === 0 && !c && !d
            },o.dz = function (n) {
                const e = n.pixelsPerMeter, i = e / U(1, n.center.lat), a = fe(new Float64Array(16));
                return le(a, a, [n.point.x, n.point.y, 0]), be(a, a, [i, i, e]), Float32Array.from(a)
            },o.e = Br,o.e$ = vm,o.e0 = Gt,o.e1 = $m,o.e2 = te,o.e3 = Kl,o.e4 = Ky,o.e5 = XS,o.e6 = tu,o.e7 = 450,o.e8 = 7,o.e9 = ve,o.eA = function (n, e, i, a, c, d, f, _, x, w, E, I, C, z, L, F) {
                var N = new q(16);
                return N[0] = n, N[1] = e, N[2] = i, N[3] = a, N[4] = c, N[5] = d, N[6] = f, N[7] = _, N[8] = x, N[9] = w, N[10] = E, N[11] = I, N[12] = C, N[13] = z, N[14] = L, N[15] = F, N
            },o.eB = S,o.eC = Rm,o.eD = Eh,o.eE = class {
                constructor() {
                    this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [], this._globalClipBounds = {
                        min: new Ze(1 / 0, 1 / 0),
                        max: new Ze(-1 / 0, -1 / 0)
                    }
                }

                clear() {
                    this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = []
                }

                get updateTime() {
                    return this._updateTime
                }

                getReplacementRegionsForTile(n, e = !1) {
                    const i = kS(new Ze(0, 0), new Ze(yt, yt), n), a = [];
                    if (e && !z1(i, this._globalClipBounds)) return a;
                    for (const c of this._activeRegions) {
                        if (c.hiddenByOverlap || !z1(i, c)) continue;
                        const d = JL(c.min, c.max, n);
                        a.push({
                            min: d.min,
                            max: d.max,
                            sourceId: this._sourceIds[c.priority],
                            footprint: c.footprint,
                            footprintTileId: c.tileId,
                            order: c.order,
                            clipMask: c.clipMask,
                            clipScope: c.clipScope
                        })
                    }
                    return a
                }

                setSources(n) {
                    this._setSources(n.map(e => ({
                        getSourceId: () => e.cache.id, getFootprints: () => {
                            const i = [];
                            for (const a of e.cache.getVisibleCoordinates()) {
                                const c = e.cache.getTile(a).buckets[e.layer];
                                c && c.updateFootprints(a.toUnwrapped(), i)
                            }
                            return i
                        }, getOrder: () => e.order, getClipMask: () => e.clipMask, getClipScope: () => e.clipScope
                    })))
                }

                _addSource(n) {
                    const e = n.getFootprints();
                    if (e.length === 0) return;
                    const i = n.getOrder(), a = n.getClipMask(), c = n.getClipScope();
                    for (const d of e) {
                        if (!d.footprint) continue;
                        const f = kS(d.footprint.min, d.footprint.max, d.id);
                        this._activeRegions.push({
                            min: f.min,
                            max: f.max,
                            hiddenByOverlap: !1,
                            priority: this._sourceIds.length,
                            tileId: d.id,
                            footprint: d.footprint,
                            order: i,
                            clipMask: a,
                            clipScope: c
                        })
                    }
                    this._sourceIds.push(n.getSourceId())
                }

                _computeReplacement() {
                    this._activeRegions.sort((e, i) => e.priority - i.priority || Zy(e.min, i.min) || Zy(e.max, i.max) || e.order - i.order || e.clipMask - i.clipMask || function (a, c) {
                        const d = (f, _) => f + _;
                        return a.length - c.length || a.reduce(d, "").localeCompare(c.reduce(d, ""))
                    }(e.clipScope, i.clipScope));
                    let n = this._activeRegions.length !== this._prevRegions.length;
                    if (!n) {
                        let e = 0;
                        for (; !n && e !== this._activeRegions.length;) {
                            const i = this._activeRegions[e], a = this._prevRegions[e];
                            n = i.priority !== a.priority || !LS(i, a) || i.order !== a.order || i.clipMask !== a.clipMask || !xn(i.clipScope, a.clipScope), ++e
                        }
                    }
                    if (n) {
                        ++this._updateTime;
                        for (const i of this._activeRegions) i.order !== Ym && (this._globalClipBounds.min.x = Math.min(this._globalClipBounds.min.x, i.min.x), this._globalClipBounds.min.y = Math.min(this._globalClipBounds.min.y, i.min.y), this._globalClipBounds.max.x = Math.max(this._globalClipBounds.max.x, i.max.x), this._globalClipBounds.max.y = Math.max(this._globalClipBounds.max.y, i.max.y));
                        const e = i => {
                            const a = this._activeRegions;
                            if (i >= a.length) return i;
                            const c = a[i].priority;
                            for (; i < a.length && a[i].priority === c;) ++i;
                            return i
                        };
                        if (this._sourceIds.length > 1) {
                            let i = 0, a = e(i);
                            for (; i !== a;) {
                                let c = i;
                                const d = i;
                                for (; c !== a;) {
                                    const f = this._activeRegions[c];
                                    f.hiddenByOverlap = !1;
                                    for (let _ = 0; _ < d; _++) {
                                        const x = this._activeRegions[_];
                                        if (!x.hiddenByOverlap && f.order === Ym && z1(f, x) && (f.hiddenByOverlap = OS(f.footprint, f.tileId, x.footprint, x.tileId), f.hiddenByOverlap)) break
                                    }
                                    ++c
                                }
                                i = a, a = e(i)
                            }
                        }
                    }
                }

                _setSources(n) {
                    [this._prevRegions, this._activeRegions] = [this._activeRegions, []], this._sourceIds = [];
                    for (let e = n.length - 1; e >= 0; e--) this._addSource(n[e]);
                    this._computeReplacement()
                }
            },o.eF = Ym,o.eG = class {
                constructor(n) {
                    this._createGrid(n), this._createPoles(n)
                }

                destroy() {
                    this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
                    for (const n of this._poleSegments) n.destroy();
                    for (const n of this._gridSegments) n.withSkirts.destroy(), n.withoutSkirts.destroy()
                }

                _fillGridMeshWithLods(n, e) {
                    const i = new Po, a = new Mn, c = [], d = n + 1 + 2, f = e[0] + 1, _ = e[0] + 1 + (1 + e.length),
                        x = (w, E, I) => {
                            let C = w === d - 1 ? w - 2 : w === 0 ? w : w - 1;
                            return C += I ? 24575 : 0, [C, E]
                        };
                    for (let w = 0; w < d; ++w) i.emplaceBack(...x(w, 0, !0));
                    for (let w = 0; w < f; ++w) for (let E = 0; E < d; ++E) i.emplaceBack(...x(E, w, (E === 0 || E === d - 1) && !0));
                    for (let w = 0; w < e.length; ++w) {
                        const E = e[w];
                        for (let I = 0; I < d; ++I) i.emplaceBack(...x(I, E, !0))
                    }
                    for (let w = 0; w < e.length; ++w) {
                        const E = a.length, I = e[w] + 1 + 2, C = new Mn;
                        for (let F = 0; F < I - 1; F++) {
                            const N = F === I - 2, H = N ? d * (_ - e.length + w - F) : d;
                            for (let Y = 0; Y < d - 1; Y++) {
                                const X = F * d + Y;
                                F === 0 || N || Y === 0 || Y === d - 2 ? (C.emplaceBack(X + 1, X, X + H), C.emplaceBack(X + H, X + H + 1, X + 1)) : (a.emplaceBack(X + 1, X, X + H), a.emplaceBack(X + H, X + H + 1, X + 1))
                            }
                        }
                        const z = Ln.simpleSegment(0, E, i.length, a.length - E);
                        for (let F = 0; F < C.uint16.length; F += 3) a.emplaceBack(C.uint16[F], C.uint16[F + 1], C.uint16[F + 2]);
                        const L = Ln.simpleSegment(0, E, i.length, a.length - E);
                        c.push({withoutSkirts: z, withSkirts: L})
                    }
                    return {vertices: i, indices: a, segments: c}
                }

                _createGrid(n) {
                    const e = this._fillGridMeshWithLods(s, h);
                    this._gridSegments = e.segments, this._gridBuffer = n.createVertexBuffer(e.vertices, Y2.members), this._gridIndexBuffer = n.createIndexBuffer(e.indices, !0)
                }

                _createPoles(n) {
                    const e = new Mn;
                    for (let f = 0; f <= s; f++) e.emplaceBack(0, f + 1, f + 2);
                    this._poleIndexBuffer = n.createIndexBuffer(e, !0);
                    const i = new Xl, a = new Xl, c = new Xl, d = new Xl;
                    this._poleSegments = [];
                    for (let f = 0, _ = 0; f < By; f++) {
                        const x = 360 / (1 << f);
                        i.emplaceBack(0, -io, 0, .5, 0), a.emplaceBack(0, -io, 0, .5, 1), c.emplaceBack(0, -io, 0, .5, .5), d.emplaceBack(0, -io, 0, .5, .5);
                        for (let w = 0; w <= s; w++) {
                            let E = w / s, I = 0;
                            const C = qt(0, x, E), [z, L, F] = v(TL, SL, C, io);
                            i.emplaceBack(z, L, F, E, I), a.emplaceBack(z, L, F, E, 1 - I);
                            const N = Ai(C);
                            E = .5 + .5 * Math.sin(N), I = .5 + .5 * Math.cos(N), c.emplaceBack(z, L, F, E, I), d.emplaceBack(z, L, F, E, 1 - I)
                        }
                        this._poleSegments.push(Ln.simpleSegment(_, 0, 66, 64)), _ += 66
                    }
                    this._poleNorthVertexBuffer = n.createVertexBuffer(i, Ny, !1), this._poleSouthVertexBuffer = n.createVertexBuffer(a, Ny, !1), this._texturedPoleNorthVertexBuffer = n.createVertexBuffer(c, Ny, !1), this._texturedPoleSouthVertexBuffer = n.createVertexBuffer(d, Ny, !1)
                }

                getGridBuffers(n, e) {
                    return [this._gridBuffer, this._gridIndexBuffer, e ? this._gridSegments[n].withSkirts : this._gridSegments[n].withoutSkirts]
                }

                getPoleBuffers(n, e) {
                    return [e ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer, e ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[n]]
                }
            },o.eH = zS,o.eI = ie,o.eJ = function () {
                return !!document.fullscreenElement || !!document.webkitFullscreenElement
            },o.eK = we,o.eL = ue,o.eM = function (n, e, i) {
                return n[0] = e[0] / i[0], n[1] = e[1] / i[1], n[2] = e[2] / i[2], n
            },o.eN = Ar,o.eO = b,o.eP = cn,o.eQ = _i,o.eR = function ([n, e, i]) {
                const a = Math.hypot(n, e, i), c = Math.atan2(n, i), d = .5 * Math.PI - Math.acos(-e / a);
                return new M(Le(c), Le(d))
            },o.eS = co,o.eT = W1,o.eU = function (n) {
                const e = n.navigator ? n.navigator.userAgent : null;
                return !!function (i) {
                    if (Hn == null) {
                        const a = i.navigator ? i.navigator.userAgent : null;
                        Hn = !!i.safari || !(!a || !(/\b(iPad|iPhone|iPod)\b/.test(a) || a.match("Safari") && !a.match("Chrome")))
                    }
                    return Hn
                }(n) && !(!e || !(e.match("Version/15.4") || e.match("Version/15.5") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/)))
            },o.eV = function (n, e) {
                Os = n, ga = e
            },o.eW = T1,o.eX = nS,o.eY = function (n) {
                const e = [0, 0, 0], i = fe(new Float64Array(16));
                return pe(i, n.pixelMatrix, n.globeMatrix), An(e, e, i), new Ze(e[0], e[1])
            },o.eZ = function () {
                const n = ig;
                n && (n.isPreloaded() && n.numActive() === 1 ? (n.release(N1), ig = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
            },o.e_ = function () {
                Jy().acquire(N1)
            },o.ea = function (n, e) {
                if (n === e) {
                    var i = e[1], a = e[2], c = e[3], d = e[6], f = e[7], _ = e[11];
                    n[1] = e[4], n[2] = e[8], n[3] = e[12], n[4] = i, n[6] = e[9], n[7] = e[13], n[8] = a, n[9] = d, n[11] = e[14], n[12] = c, n[13] = f, n[14] = _
                } else n[0] = e[0], n[1] = e[4], n[2] = e[8], n[3] = e[12], n[4] = e[1], n[5] = e[5], n[6] = e[9], n[7] = e[13], n[8] = e[2], n[9] = e[6], n[10] = e[10], n[11] = e[14], n[12] = e[3], n[13] = e[7], n[14] = e[11], n[15] = e[15];
                return n
            },o.eb = G3,o.ec = Fi,o.ed = Lm,o.ee = 256,o.ef = w1,o.eg = Qo,o.eh = et,o.ei = function (n, e) {
                return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[4], n[4] = e[5], n[5] = e[6], n[6] = e[8], n[7] = e[9], n[8] = e[10], n
            },o.ej = Xl,o.ek = Mm,o.el = ly,o.em = function (n, e, i, a, c) {
                return se((n - e) / (i - e) * (c - a) + a, a, c)
            },o.en = Va,o.eo = function (n, e) {
                var i = e[0], a = e[1], c = e[2], d = e[3], f = e[4], _ = e[5], x = e[6], w = e[7], E = e[8],
                    I = E * f - _ * w, C = -E * d + _ * x, z = w * d - f * x, L = i * I + a * C + c * z;
                return L ? (n[0] = I * (L = 1 / L), n[1] = (-E * a + c * w) * L, n[2] = (_ * a - c * f) * L, n[3] = C * L, n[4] = (E * i - c * x) * L, n[5] = (-_ * i + c * d) * L, n[6] = z * L, n[7] = (-w * i + a * x) * L, n[8] = (f * i - a * d) * L, n) : null
            },o.ep = 2,o.eq = Zn,o.er = Z1,o.es = [1, 1, 1],o.et = class {
                constructor(n, e, i, a) {
                    this.context = n, this.format = a, this.size = i, this.texture = n.gl.createTexture();
                    const [c, d, f] = this.size, {gl: _} = n;
                    _.bindTexture(_.TEXTURE_3D, this.texture), n.pixelStoreUnpackFlipY.set(!1), n.pixelStoreUnpack.set(1), n.pixelStoreUnpackPremultiplyAlpha.set(!1), _.texImage3D(_.TEXTURE_3D, 0, this.format, c, d, f, 0, $1(this.format), H1(this.format), e.data)
                }

                bind(n, e) {
                    const {context: i} = this, {gl: a} = i;
                    a.bindTexture(a.TEXTURE_3D, this.texture), n !== this.minFilter && (a.texParameteri(a.TEXTURE_3D, a.TEXTURE_MAG_FILTER, n), a.texParameteri(a.TEXTURE_3D, a.TEXTURE_MIN_FILTER, n), this.minFilter = n), e !== this.wrapS && (a.texParameteri(a.TEXTURE_3D, a.TEXTURE_WRAP_S, e), a.texParameteri(a.TEXTURE_3D, a.TEXTURE_WRAP_T, e), this.wrapS = e)
                }

                destroy() {
                    const {gl: n} = this.context;
                    n.deleteTexture(this.texture), this.texture = null
                }
            },o.eu = Sf,o.ev = Rs,o.ew = function (n, e, i, a) {
                var c = e[0], d = e[1], f = e[2], _ = e[3];
                return n[0] = c + a * (i[0] - c), n[1] = d + a * (i[1] - d), n[2] = f + a * (i[2] - f), n[3] = _ + a * (i[3] - _), n
            },o.ex = yf,o.ey = ea,o.ez = hl,o.f = function (n) {
                return btoa(encodeURIComponent(n).replace(/%([0-9A-F]{2})/g, (e, i) => String.fromCharCode(+("0x" + i))))
            },o.f0 = function (n, e, i = !1) {
                if (mo === Oo.deferred || mo === Oo.loading || mo === Oo.loaded) throw new Error("setRTLTextPlugin cannot be called multiple times.");
                al = ks.resolveURL(n), mo = Oo.deferred, gm = e, _m(), i || vy()
            },o.f1 = function (n) {
                mf = ks.resolveURL(n), gf || (gf = new pf(Jy(), new Ol)), gf.broadcast("setMeshoptUrl", mf)
            },o.f2 = lE,o.f3 = function (n) {
                V1 = ks.resolveURL(n), gf || (gf = new pf(Jy(), new Ol)), gf.broadcast("setDracoUrl", V1)
            },o.f4 = aE,o.f5 = tg,o.f6 = function (n) {
                const e = zl();
                if (!e) return;
                const i = e.delete(ma);
                n && i.then(() => n()).catch(n)
            },o.f7 = kh,o.f8 = Pt,o.f9 = eu,o.fa = Ta,o.fb = RI,o.fc = zI,o.fd = ME,o.fe = St,o.ff = "hd_road_elevation",o.fg = kn,o.fh = li,o.fi = Dh,o.fj = aw,o.fk = Bh,o.fl = function (n, e, i, a, c, d, f, _ = 1, x, w, E) {
                n.createArrays(), n.tilePixelRatio = yt / (512 * n.overscaling), n.compareText = {}, n.iconsNeedLinear = !1;
                const I = n.layers[0].layout, C = n.layers[0]._unevaluatedLayout._values, z = {};
                z.scaleFactor = _, z.textSizeScaleRange = I.get("text-size-scale-range"), z.iconSizeScaleRange = I.get("icon-size-scale-range");
                const [L, F] = z.textSizeScaleRange, [N, H] = z.iconSizeScaleRange;
                z.textScaleFactor = se(z.scaleFactor, L, F), z.iconScaleFactor = se(z.scaleFactor, N, H);
                const Y = C["text-size"], X = C["icon-size"];
                if (n.textSizeData.kind === "composite") {
                    const {minZoom: Ie, maxZoom: We} = n.textSizeData;
                    z.compositeTextSizes = [Y.possiblyEvaluate(new sn(Ie, {worldview: E}), d), Y.possiblyEvaluate(new sn(We, {worldview: E}), d)]
                }
                if (n.iconSizeData.kind === "composite") {
                    const {minZoom: Ie, maxZoom: We} = n.iconSizeData;
                    z.compositeIconSizes = [X.possiblyEvaluate(new sn(Ie, {worldview: E}), d), X.possiblyEvaluate(new sn(We, {worldview: E}), d)]
                }
                z.layoutTextSize = Y.possiblyEvaluate(new sn(f + 1, {worldview: E}), d), z.layoutIconSize = X.possiblyEvaluate(new sn(f + 1, {worldview: E}), d), z.textMaxSize = Y.possiblyEvaluate(new sn(18, {worldview: E}), d);
                const J = I.get("symbol-placement"), xe = I.get("text-rotation-alignment") === "map" && J !== "point",
                    ge = I.get("text-size");
                let ye = !1;
                const Ee = [];
                for (const Ie of n.features) {
                    const We = I.get("text-font").evaluate(Ie, {}, d).join(","),
                        De = ge.evaluate(Ie, {}, d) * z.textScaleFactor,
                        Ye = z.layoutTextSize.evaluate(Ie, {}, d) * z.textScaleFactor,
                        ht = z.layoutIconSize.evaluate(Ie, {}, d) * z.iconScaleFactor,
                        Qe = {horizontal: {}, vertical: void 0}, ot = Ie.text;
                    let ct, He = [0, 0];
                    if (ot) {
                        const At = ot.toString(), Kt = I.get("text-letter-spacing").evaluate(Ie, {}, d) * Dr,
                            oi = I.get("text-line-height").evaluate(Ie, {}, d) * Dr, pi = n1(At) ? Kt : 0,
                            ui = I.get("text-anchor").evaluate(Ie, {}, d), ki = I.get("text-variable-anchor");
                        if (!ki) {
                            const Ge = I.get("text-radial-offset").evaluate(Ie, {}, d);
                            if (Ge) He = mA(ui, [Ge * Dr, cw]); else {
                                const mt = I.get("text-offset").evaluate(Ie, {}, d);
                                He = [mt[0] * Dr, mt[1] * Dr]
                            }
                        }
                        let bi = xe ? "center" : I.get("text-justify").evaluate(Ie, {}, d);
                        const Tn = J === "point", ne = Tn ? I.get("text-max-width").evaluate(Ie, {}, d) * Dr : 1 / 0,
                            re = Ge => {
                                n.allowVerticalPlacement && mm(At) && (Qe.vertical = rw(ot, e, i, c, We, ne, oi, ui, Ge, pi, He, ss.vertical, !0, Ye, De, x))
                            };
                        if (!xe && ki) {
                            const Ge = bi === "auto" ? ki.map(bt => uw(bt)) : [bi];
                            let mt = !1;
                            for (let bt = 0; bt < Ge.length; bt++) {
                                const wt = Ge[bt];
                                if (!Qe.horizontal[wt]) if (mt) Qe.horizontal[wt] = Qe.horizontal[0]; else {
                                    const Lt = rw(ot, e, i, c, We, ne, oi, "center", wt, pi, He, ss.horizontal, !1, Ye, De, x);
                                    Lt && (Qe.horizontal[wt] = Lt, mt = Lt.positionedLines.length === 1)
                                }
                            }
                            re("left")
                        } else {
                            if (bi === "auto" && (bi = uw(ui)), Tn || I.get("text-writing-mode").indexOf("horizontal") >= 0 || !mm(At)) {
                                const Ge = rw(ot, e, i, c, We, ne, oi, ui, bi, pi, He, ss.horizontal, !1, Ye, De, x);
                                Ge && (Qe.horizontal[bi] = Ge)
                            }
                            re(Tn ? "left" : bi)
                        }
                    }
                    let st, ke, qe, pt, at, Bt, zt = !1;
                    const nt = I.get("icon-text-fit").evaluate(Ie, {}, d);
                    if (Ie.icon && Ie.icon.hasPrimary()) {
                        const At = _A(Ie.icon, n.iconSizeData, C["icon-size"], d, n.zoom, Ie, x, z.iconScaleFactor, E);
                        st = At.iconPrimary, qe = At.iconSecondary;
                        const Kt = st.toString();
                        if (ke = a.get(Kt), ke && (at = I.get("icon-offset").evaluate(Ie, {}, d), Bt = I.get("icon-anchor").evaluate(Ie, {}, d), ct = v3(c.get(Kt), qe ? c.get(qe.toString()) : void 0, at, Bt), zt = ke.sdf, n.sdfIcons === void 0 ? n.sdfIcons = ke.sdf : n.sdfIcons !== ke.sdf && Li("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (ke.pixelRatio !== n.pixelRatio || I.get("icon-rotate").constantOr(1) !== 0) && (n.iconsNeedLinear = !0)), qe) {
                            const oi = qe.toString();
                            pt = a.get(oi)
                        }
                    }
                    ye = ye || !(!Ie.icon || !Ie.icon.hasSecondary());
                    const lt = hw(Qe.horizontal) || Qe.vertical;
                    n.iconsInText || (n.iconsInText = !!lt && lt.iconsInText);
                    const kt = Ye * z.textScaleFactor / Dr, {
                        defaultShapedIcon: Et,
                        verticallyShapedIcon: vt
                    } = P3(n, ct, I, Ie, d, Qe, kt, at, nt);
                    nt !== "none" && ct && (JE(ct) || eA(ct)) && (h0(0, ke, st, ct, Et, nt, w, a, c), h0(0, pt, qe, ct, Et, nt, w, a, c), vt && (h0(0, ke, st, ct, vt, nt, w, a, c), h0(0, pt, qe, ct, vt, nt, w, a, c))), ct = Et, Ee.push({
                        feature: Ie,
                        shapedTextOrientations: Qe,
                        shapedText: lt,
                        shapedIcon: ct,
                        iconPrimary: st,
                        iconSecondary: qe,
                        iconOffset: at,
                        iconAnchor: Bt,
                        verticallyShapedIcon: vt,
                        layoutTextSize: Ye,
                        layoutIconSize: ht,
                        textOffset: He,
                        isSDFIcon: zt,
                        iconTextFit: nt
                    })
                }
                return {featureData: Ee, sizes: z, hasAnySecondaryIcon: ye, textAlongLine: xe, symbolPlacement: J}
            },o.fm = cA,o.fn = function (n, e, i, a, c, d, f, _, x, w) {
                const {featureData: E, hasAnySecondaryIcon: I, sizes: C, textAlongLine: z, symbolPlacement: L} = e;
                for (const F of E) {
                    const {
                        shapedIcon: N,
                        verticallyShapedIcon: H,
                        feature: Y,
                        shapedTextOrientations: X,
                        shapedText: J,
                        layoutTextSize: xe,
                        textOffset: ge,
                        isSDFIcon: ye,
                        iconPrimary: Ee,
                        iconSecondary: Ie,
                        iconTextFit: We,
                        iconOffset: De
                    } = F;
                    yA(N, w.iconPositions, Ee, Ie), yA(H, w.iconPositions, Ee, Ie), C3(X, w.iconPositions), I3(Ee, Ie, w.iconPositions), (J || N) && M3(n, Y, X, N, H, x, C, xe, 0, ge, ye, a, c, f, _, I, We, De, z, L)
                }
                i && n.generateCollisionDebugBuffers(d, n.collisionBoxArray, C.textScaleFactor)
            },o.fo = Ot,o.fp = R0,o.fq = Be,o.fr = function (n) {
                let e = 0;
                if (new Uint32Array(n, 0, 1)[0] !== uE) {
                    const i = new Uint32Array(n, 0, 7), [, , a, c, d, f] = i;
                    e = i.byteLength + c + d + f + d, (a !== n.byteLength || e >= n.byteLength) && Li("Invalid b3dm header information.")
                }
                return pE(n, e)
            },o.fs = function (n, e) {
                const i = bE(n);
                for (const a of i) {
                    for (const c of a.meshes) Mk(c);
                    a.lights && (a.lightMeshIndex = a.meshes.length, a.meshes.push(Rk(a.lights, e)))
                }
                return i
            },o.ft = E0,o.fu = un,o.fv = oE,o.fw = Qs,o.fx = Oo,o.fy = function (n) {
                gc(), Ys != null && Ys.then(e => {
                    e.keys().then(i => {
                        for (let a = 0; a < i.length - n; a++) e.delete(i[a]).catch(c => Li(c.message))
                    }).catch(i => Li(i.message))
                }).catch(e => Li(e.message))
            },o.g = function (n, e) {
                return yc(Ne(n, {method: "GET"}), e)
            },o.h = Ne,o.i = function (n) {
                return Br.API_STYLE_REGEX.test(n) && !cd(n)
            },o.j = function (n) {
                return n.indexOf("mapbox:") === 0
            },o.k = qa,o.l = Mp,o.m = function (n) {
                return decodeURIComponent(atob(n).split("").map(e => "%" + ("00" + e.charCodeAt(0).toString(16)).slice(-2)).join(""))
            },o.n = function (n, e) {
                return yc(Ne(n, {type: "json"}), e)
            },o.o = Ju,o.p = function (n, e) {
                return yc(Ne(n, {method: "POST"}), e)
            },o.q = ks,o.r = $r,o.s = function (n) {
                try {
                    const e = self[n];
                    return e.setItem("_mapbox_test_", 1), e.removeItem("_mapbox_test_"), !0
                } catch {
                    return !1
                }
            },o.t = dd,o.u = function () {
                return function n(e) {
                    return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, n)
                }()
            },o.v = function (n) {
                return !!n && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(n)
            },o.w = Li,o.x = function () {
                return j1 || (j1 = new kh), j1
            },o.y = Aw,o.z = Xo
        }), A(["./shared"], function (o) {
            function j(Le) {
                const $ = Le ? Le.url.toString() : void 0;
                return $ ? performance.getEntriesByName($) : []
            }

            function q(Le) {
                if (typeof Le == "number" || typeof Le == "boolean" || typeof Le == "string" || Le == null) return JSON.stringify(Le);
                if (Array.isArray(Le)) {
                    let W = "[";
                    for (const ie of Le) W += `${q(ie)},`;
                    return `${W}]`
                }
                let $ = "{";
                for (const W of Object.keys(Le).sort()) $ += `${W}:${q(Le[W])},`;
                return `${$}}`
            }

            function ee(Le) {
                let $ = "";
                for (const W of o.bu) $ += `/${q(Le[W])}`;
                return $
            }

            class oe {
                constructor($) {
                    this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, $ && this.replace($)
                }

                replace($, W) {
                    this._layerConfigs = {}, this._layers = {}, this.update($, [], W)
                }

                update($, W, ie) {
                    this._options = ie;
                    for (const se of $) this._layerConfigs[se.id] = se, (this._layers[se.id] = o.dn(se, this.scope, null, this._options)).compileFilter(ie), this.keyCache[se.id] && delete this.keyCache[se.id];
                    for (const se of W) delete this.keyCache[se], delete this._layerConfigs[se], delete this._layers[se];
                    this.familiesBySource = {};
                    const we = function (se, Ae) {
                        const Ve = {};
                        for (let Ne = 0; Ne < se.length; Ne++) {
                            const ft = se[Ne];
                            let Je = Ae && Ae[ft.id];
                            Je || (ft.type === "symbol" ? Je = ft.id : (Je = ee(ft), ft.type === "line" && ft.paint && function ii(li) {
                                return typeof li == "string" && li === "line-progress" || (Array.isArray(li) ? li.some(ii) : !(!li || typeof li != "object") && Object.values(li).some(ii))
                            }(ft.paint["line-width"]) && (Je += `/${q(ft.paint["line-width"])}`))), Ae && (Ae[ft.id] = Je);
                            let Gt = Ve[Je];
                            Gt || (Gt = Ve[Je] = []), Gt.push(ft)
                        }
                        const Pe = [];
                        for (const Ne in Ve) Pe.push(Ve[Ne]);
                        return Pe
                    }(Object.values(this._layerConfigs), this.keyCache);
                    for (const se of we) {
                        const Ae = se.map(Gt => this._layers[Gt.id]), Ve = Ae[0];
                        if (Ve.visibility === "none") continue;
                        const Pe = Ve.source || "";
                        let Ne = this.familiesBySource[Pe];
                        Ne || (Ne = this.familiesBySource[Pe] = {});
                        const ft = Ve.sourceLayer || "_geojsonTileLayer";
                        let Je = Ne[ft];
                        Je || (Je = Ne[ft] = []), Je.push(Ae)
                    }
                }
            }

            const de = 1 * o.fa;

            class ae {
                constructor($) {
                    const W = {}, ie = [];
                    for (const Ve in $) {
                        const Pe = $[Ve], Ne = W[Ve] = {};
                        for (const ft in Pe.glyphs) {
                            const Je = Pe.glyphs[+ft];
                            if (!Je || Je.bitmap.width === 0 || Je.bitmap.height === 0) continue;
                            const Gt = Je.metrics.localGlyph ? de : 1,
                                ii = {x: 0, y: 0, w: Je.bitmap.width + 2 * Gt, h: Je.bitmap.height + 2 * Gt};
                            ie.push(ii), Ne[ft] = ii
                        }
                    }
                    const {w: we, h: se} = o.H(ie), Ae = new o.f9({width: we || 1, height: se || 1});
                    for (const Ve in $) {
                        const Pe = $[Ve];
                        for (const Ne in Pe.glyphs) {
                            const ft = Pe.glyphs[+Ne];
                            if (!ft || ft.bitmap.width === 0 || ft.bitmap.height === 0) continue;
                            const Je = W[Ve][Ne], Gt = ft.metrics.localGlyph ? de : 1;
                            o.f9.copy(ft.bitmap, Ae, {x: 0, y: 0}, {x: Je.x + Gt, y: Je.y + Gt}, ft.bitmap)
                        }
                    }
                    this.image = Ae, this.positions = W
                }
            }

            o.f8(ae, "GlyphAtlas");

            class Re {
                constructor($) {
                    this.tileID = new o.aM($.tileID.overscaledZ, $.tileID.wrap, $.tileID.canonical.z, $.tileID.canonical.x, $.tileID.canonical.y), this.tileZoom = $.tileZoom, this.uid = $.uid, this.zoom = $.zoom, this.lut = $.lut, this.canonical = $.tileID.canonical, this.pixelRatio = $.pixelRatio, this.tileSize = $.tileSize, this.source = $.source, this.scope = $.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = $.showCollisionBoxes, this.collectResourceTiming = !!$.request && $.request.collectResourceTiming, this.promoteId = $.promoteId, this.isSymbolTile = $.isSymbolTile, this.tileTransform = o.aW($.tileID.canonical, $.projection), this.projection = $.projection, this.worldview = $.worldview, this.localizableLayerIds = $.localizableLayerIds, this.brightness = $.brightness, this.extraShadowCaster = !!$.extraShadowCaster, this.tessellationStep = $.tessellationStep, this.scaleFactor = $.scaleFactor, this.worldview = $.worldview
                }

                parse($, W, ie, we, se, Ae) {
                    this.status = "parsing", this.data = $, this.collisionBoxArray = new o.b0;
                    const Ve = new o.fb(Object.keys($.layers).sort()), Pe = new o.fc(this.tileID, this.promoteId);
                    Pe.bucketLayerIDs = [];
                    const Ne = {}, ft = new o.fd(256, 256), Je = {
                        featureIndex: Pe,
                        iconDependencies: new Map,
                        patternDependencies: new Map,
                        glyphDependencies: {},
                        lineAtlas: ft,
                        availableImages: ie,
                        brightness: this.brightness,
                        scaleFactor: this.scaleFactor,
                        elevationFeatures: void 0
                    }, Gt = [], ii = W.familiesBySource[this.source];
                    for (const zi in ii) {
                        const Ti = $.layers[zi];
                        if (!Ti) continue;
                        let Di = !1, mn = !1, Li = !1;
                        for (const un of ii[zi]) un[0].type === "symbol" ? Di = !0 : mn = !0, un[0].is3D() && un[0].type !== "model" && (Li = !0);
                        if (this.extraShadowCaster && !Li || this.isSymbolTile === !0 && !Di || this.isSymbolTile === !1 && !mn) continue;
                        Ti.version === 1 && o.w(`Vector tile source "${this.source}" layer "${zi}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                        const Xn = Ve.encode(zi), mr = [];
                        let lr = !1;
                        for (let un = 0, Zi = 0; un < Ti.length; un++) {
                            const Hn = Ti.feature(un), jn = Pe.getId(Hn, zi);
                            if (this.localizableLayerIds && this.localizableLayerIds.has(zi)) {
                                const Dn = Hn.properties ? Hn.properties.worldview : null;
                                if (this.worldview && typeof Dn == "string") if (Dn === "all") Hn.properties.$localized = !0; else {
                                    if (!Dn.split(",").includes(this.worldview)) continue;
                                    Hn.properties.$localized = !0, Hn.properties.worldview = this.worldview
                                }
                            }
                            !lr && Hn.properties && Hn.properties.hasOwnProperty(o.fe) && (lr = !0), mr.push({
                                feature: Hn,
                                id: jn,
                                index: Zi,
                                sourceLayerIndex: Xn
                            }), Zi++
                        }
                        lr && !Je.elevationFeatures && $.layers.hasOwnProperty(o.ff) && (Je.elevationFeatures = o.fg.parseFrom($.layers[o.ff], this.canonical));
                        for (const un of ii[zi]) {
                            const Zi = un[0];
                            if (this.extraShadowCaster && (!Zi.is3D() || Zi.type === "model") || this.isSymbolTile !== void 0 && Zi.type === "symbol" !== this.isSymbolTile || Zi.minzoom && this.zoom < Math.floor(Zi.minzoom) || Zi.maxzoom && this.zoom >= Zi.maxzoom || Zi.visibility === "none") continue;
                            fe(un, this.zoom, Je.brightness, ie, this.worldview);
                            const Hn = Ne[Zi.id] = Zi.createBucket({
                                index: Pe.bucketLayerIDs.length,
                                layers: un,
                                zoom: this.zoom,
                                lut: this.lut,
                                canonical: this.canonical,
                                pixelRatio: this.pixelRatio,
                                overscaling: this.overscaling,
                                collisionBoxArray: this.collisionBoxArray,
                                sourceLayerIndex: Xn,
                                sourceID: this.source,
                                projection: this.projection.spec,
                                tessellationStep: this.tessellationStep,
                                styleDefinedModelURLs: we,
                                worldview: this.worldview
                            });
                            Pe.bucketLayerIDs.push(un.map(Dn => o.C(Dn.id, Dn.scope)));
                            let jn = Hn.prepare ? Hn.prepare() : null;
                            jn != null ? (jn = jn.then(() => Hn.populate(mr, Je, this.tileID.canonical, this.tileTransform)), Gt.push(jn)) : Hn.populate(mr, Je, this.tileID.canonical, this.tileTransform)
                        }
                    }
                    const li = () => {
                        let zi, Ti, Di, mn, Li, Xn;
                        ft.trim();
                        const mr = {type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom},
                            lr = () => {
                                if (zi) return this.status = "done", Ae(zi);
                                if (this.extraShadowCaster) this.status = "done", Ae(null, {
                                    buckets: Object.values(Ne).filter(Zi => !Zi.isEmpty()),
                                    featureIndex: Pe,
                                    collisionBoxArray: null,
                                    glyphAtlasImage: null,
                                    lineAtlas: null,
                                    imageAtlas: null,
                                    brightness: Je.brightness,
                                    glyphMap: null,
                                    iconMap: null,
                                    glyphPositions: null
                                }); else if (Ti && Di && mn) {
                                    const Zi = new ae(Ti), Hn = new Map;
                                    for (const [Pr, So] of Di.entries()) {
                                        const {imagePosition: Qr} = o.fj(Pr, So, o.fk);
                                        Hn.set(Pr, Qr)
                                    }
                                    const jn = {};
                                    for (const Pr in Ne) {
                                        const So = Ne[Pr];
                                        So instanceof o.b1 && (fe(So.layers, this.zoom, Je.brightness, ie, this.worldview), jn[Pr] = o.fl(So, Ti, Zi.positions, Di, Hn, this.tileID.canonical, this.tileZoom, this.scaleFactor, this.pixelRatio, Li, this.worldview))
                                    }
                                    const Dn = {iconsPending: !0, patternsPending: !0};
                                    this.rasterizeIfNeeded(se, Di, Li, () => {
                                        Dn.iconsPending = !1, un(jn, Zi, Dn)
                                    }), this.rasterizeIfNeeded(se, mn, Xn, () => {
                                        Dn.patternsPending = !1, un(jn, Zi, Dn)
                                    })
                                }
                            }, un = (Zi, Hn, jn, Dn) => {
                                if (jn.iconsPending || jn.patternsPending) return;
                                const Pr = new o.fm(Di, mn, this.lut);
                                for (const So in Ne) {
                                    const Qr = Ne[So];
                                    if (So in Zi) o.fn(Qr, Zi[So], this.showCollisionBoxes, ie, this.tileID.canonical, this.tileZoom, this.projection, this.brightness, Di, Pr); else if (Qr.hasPattern && (Qr instanceof o.b7 || Qr instanceof o.b8 || Qr instanceof o.e4)) {
                                        fe(Qr.layers, this.zoom, Je.brightness, ie, this.worldview);
                                        const Gu = Object.fromEntries(Pr.patternPositions);
                                        Qr.addFeatures(Je, this.tileID.canonical, Gu, ie, this.tileTransform, this.brightness)
                                    }
                                }
                                this.status = "done", Ae(null, {
                                    buckets: Object.values(Ne).filter(So => !So.isEmpty()),
                                    featureIndex: Pe,
                                    collisionBoxArray: this.collisionBoxArray,
                                    glyphAtlasImage: Hn.image,
                                    lineAtlas: ft,
                                    imageAtlas: Pr,
                                    brightness: Je.brightness
                                })
                            };
                        if (!this.extraShadowCaster) {
                            const Zi = o.fh(Je.glyphDependencies, Dn => Object.keys(Dn).map(Number));
                            Object.keys(Zi).length ? se.send("getGlyphs", {uid: this.uid, stacks: Zi}, (Dn, Pr) => {
                                zi || (zi = Dn, Ti = Pr, lr())
                            }, void 0, !1, mr) : Ti = {};
                            const Hn = Array.from(Je.iconDependencies.keys()).map(Dn => o.I.parse(Dn));
                            Hn.length ? se.send("getImages", {
                                images: Hn,
                                source: this.source,
                                scope: this.scope,
                                tileID: this.tileID,
                                type: "icons"
                            }, (Dn, Pr) => {
                                zi || (zi = Dn, Di = new Map, Li = this.updateImageMapAndGetImageTaskQueue(Di, Pr, Je.iconDependencies), lr())
                            }, void 0, !1, mr) : (Di = new Map, Li = new Map);
                            const jn = Array.from(Je.patternDependencies.keys()).map(Dn => o.I.parse(Dn));
                            jn.length ? se.send("getImages", {
                                images: jn,
                                source: this.source,
                                scope: this.scope,
                                tileID: this.tileID,
                                type: "patterns"
                            }, (Dn, Pr) => {
                                zi || (zi = Dn, mn = new Map, Xn = this.updateImageMapAndGetImageTaskQueue(mn, Pr, Je.patternDependencies), lr())
                            }, void 0, !1, mr) : (mn = new Map, Xn = new Map)
                        }
                        if (Je.elevationFeatures && Je.elevationFeatures.length > 0) {
                            const Zi = [];
                            for (const jn of Object.values(Ne)) if (jn instanceof o.b8) {
                                const Dn = jn.getUnevaluatedPortalGraph();
                                Dn && Zi.push(Dn)
                            }
                            const Hn = o.fi.evaluate(Zi);
                            for (const jn of Object.values(Ne)) if (jn instanceof o.b8) {
                                const Dn = $.layers[Ve.decode(jn.sourceLayerIndex)];
                                jn.setEvaluatedPortalGraph(Hn, Dn, this.tileID.canonical, Je.availableImages, Je.brightness)
                            }
                        }
                        lr()
                    };
                    Gt.length > 0 ? Promise.allSettled(Gt).then(li).catch(Ae) : li()
                }

                rasterizeIfNeeded($, W, ie, we) {
                    Array.from(W.values()).some(se => se.usvg) ? this.rasterize($, W, ie, we) : we()
                }

                updateImageMapAndGetImageTaskQueue($, W, ie) {
                    const we = new Map;
                    for (const se of W.keys()) {
                        const Ae = ie.get(se) || [];
                        for (const Ve of Ae) {
                            const Pe = Ve.toString(), Ne = W.get(Ve.id.toString());
                            Ne.usvg ? we.has(Pe) || (we.set(Pe, Ve), $.set(Pe, Object.assign({}, Ne))) : $.set(Pe, Ne)
                        }
                    }
                    return we
                }

                rasterize($, W, ie, we) {
                    this.rasterizeTask = $.send("rasterizeImages", {scope: this.scope, tasks: ie}, (se, Ae) => {
                        if (!se) for (const [Ve, Pe] of Ae.entries()) {
                            const Ne = Object.assign(W.get(Ve), {data: Pe});
                            W.set(Ve, Ne)
                        }
                        we()
                    })
                }

                cancelRasterize() {
                    this.rasterizeTask && this.rasterizeTask.cancel()
                }
            }

            function fe(Le, $, W, ie, we) {
                const se = new o.aa($, {brightness: W, worldview: we});
                for (const Ae of Le) Ae.recalculate(se, ie)
            }

            class Me extends o.E {
                constructor($, W, ie, we, se, Ae, Ve) {
                    super(), this.actor = $, this.layerIndex = W, this.availableImages = ie, this.availableModels = we, this.loadVectorData = Ae || o.aJ, this.loading = {}, this.loaded = {}, this.deduped = new o.aI($.scheduler), this.isSpriteLoaded = se, this.scheduler = $.scheduler, this.brightness = Ve
                }

                loadTile($, W) {
                    const ie = $.uid, we = $ && $.request, se = we && we.collectResourceTiming,
                        Ae = this.loading[ie] = new Re($);
                    Ae.abort = this.loadVectorData($, (Ve, Pe) => {
                        const Ne = !this.loading[ie];
                        if (delete this.loading[ie], Ae.cancelRasterize(), Ne || Ve || !Pe) return Ae.status = "done", Ne || (this.loaded[ie] = Ae), W(Ve);
                        const ft = Pe.rawData, Je = {};
                        Pe.expires && (Je.expires = Pe.expires), Pe.cacheControl && (Je.cacheControl = Pe.cacheControl), Ae.vectorTile = Pe.vectorTile || new o.fo(new o.bq(ft));
                        const Gt = () => {
                            Ae.parse(Ae.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, (ii, li) => {
                                if (ii || !li) return W(ii);
                                const zi = {};
                                if (se) {
                                    const Ti = j(we);
                                    Ti.length > 0 && (zi.resourceTiming = JSON.parse(JSON.stringify(Ti)))
                                }
                                W(null, o.h({rawTileData: ft.slice(0)}, li, Je, zi))
                            })
                        };
                        this.isSpriteLoaded ? Gt() : this.once("isSpriteLoaded", () => {
                            this.scheduler ? this.scheduler.add(Gt, {
                                type: "parseTile",
                                isSymbolTile: $.isSymbolTile,
                                zoom: $.tileZoom
                            }) : Gt()
                        }), this.loaded = this.loaded || {}, this.loaded[ie] = Ae
                    })
                }

                reloadTile($, W) {
                    const ie = this.loaded, we = $.uid;
                    if (ie && ie[we]) {
                        const se = ie[we];
                        se.scaleFactor = $.scaleFactor, se.showCollisionBoxes = $.showCollisionBoxes, se.projection = $.projection, se.brightness = $.brightness, se.tileTransform = o.aW($.tileID.canonical, $.projection), se.extraShadowCaster = $.extraShadowCaster, se.lut = $.lut, se.worldview = $.worldview;
                        const Ae = (Ve, Pe) => {
                            const Ne = se.reloadCallback;
                            Ne && (delete se.reloadCallback, se.parse(se.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, Ne)), W(Ve, Pe)
                        };
                        se.status === "parsing" ? se.reloadCallback = Ae : se.status === "done" && (se.vectorTile ? se.parse(se.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, Ae) : Ae())
                    } else W(null, void 0)
                }

                abortTile($, W) {
                    const ie = $.uid, we = this.loading[ie];
                    we && (we.abort && we.abort(), delete this.loading[ie]), W()
                }

                removeTile($, W) {
                    const ie = this.loaded, we = $.uid;
                    ie && ie[we] && delete ie[we], W()
                }
            }

            class pe {
                loadTile($, W) {
                    const {uid: ie, encoding: we, rawImageData: se, padding: Ae} = $,
                        Ve = ImageBitmap && se instanceof ImageBitmap ? this.getImageData(se, Ae) : se;
                    W(null, new o.fp(ie, Ve, we, Ae < 1))
                }

                reloadTile($, W) {
                    W(null, null)
                }

                abortTile($, W) {
                    W()
                }

                removeTile($, W) {
                    W()
                }

                getImageData($, W) {
                    this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas($.width, $.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", {willReadFrequently: !0})), this.offscreenCanvas.width = $.width, this.offscreenCanvas.height = $.height, this.offscreenCanvasContext.drawImage($, 0, 0, $.width, $.height);
                    const ie = this.offscreenCanvasContext.getImageData(-W, -W, $.width + 2 * W, $.height + 2 * W);
                    return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), ie
                }
            }

            o.bp.setPbf(o.bq);

            class le {
                constructor($) {
                    this._mrt = new o.bp($.partial ? 30 : 1 / 0), this._isHeaderLoaded = !1, this.uid = $.uid, this.tileID = $.tileID, this.source = $.source
                }

                parse($, W) {
                    const ie = this._mrt;
                    this.status = "parsing", this._entireBuffer = $;
                    try {
                        ie.parseHeader($), this._isHeaderLoaded = !0;
                        const we = [];
                        for (const se in ie.layers) {
                            const Ae = ie.getLayer(se), Ve = Ae.getDataRange(Ae.getBandList()),
                                Pe = ie.createDecodingTask(Ve), Ne = $.slice(Ve.firstByte, Ve.lastByte + 1),
                                ft = o.bp.performDecoding(Ne, Pe).then(Je => Pe.complete(null, Je)).catch(Je => Pe.complete(Je, null));
                            we.push(ft)
                        }
                        Promise.allSettled(we).then(() => W(null, ie)).catch(se => W(se))
                    } catch (we) {
                        W(we)
                    }
                }
            }

            class be {
                constructor($) {
                    this.actor = $, this.loading = {}, this.loaded = {}
                }

                loadTile($, W) {
                    const ie = $.uid, we = $.request,
                        se = this.loading[ie] = new le($), {cancel: Ae} = o.br(we, (Ve, Pe, Ne, ft) => {
                            const Je = !this.loading[ie];
                            if (delete this.loading[ie], Je || Ve || !Pe) return se.status = "done", Je || (this.loaded[ie] = se), W(Ve);
                            se.parse(Pe, (Gt, ii) => {
                                if (Gt || !ii) return W(Gt);
                                W(null, ii, Ne, ft)
                            }), this.loaded[ie] = se
                        });
                    se.abort = Ae
                }

                reloadTile($, W) {
                    W(null, void 0)
                }

                abortTile($, W) {
                    const ie = $.uid, we = this.loading[ie];
                    we && (we.abort && we.abort(), delete this.loading[ie]), W()
                }

                removeTile($, W) {
                    const ie = $.uid;
                    this.loaded[ie] && delete this.loaded[ie], W()
                }

                decodeRasterArray($, W) {
                    o.bp.performDecoding($.buffer, $.task).then(ie => W(null, ie)).catch(ie => W(ie))
                }
            }

            const Ue = o.fq.prototype.toGeoJSON;

            class et {
                constructor($) {
                    this._feature = $, this.extent = o.aj, this.type = $.type, this.properties = $.tags, "id" in $ && !isNaN($.id) && (this.id = parseInt($.id, 10))
                }

                loadGeometry() {
                    if (this._feature.type === 1) {
                        const $ = [];
                        for (const W of this._feature.geometry) $.push([new o.P(W[0], W[1])]);
                        return $
                    }
                    {
                        const $ = [];
                        for (const W of this._feature.geometry) {
                            const ie = [];
                            for (const we of W) ie.push(new o.P(we[0], we[1]));
                            $.push(ie)
                        }
                        return $
                    }
                }

                toGeoJSON($, W, ie) {
                    return Ue.call(this, $, W, ie)
                }
            }

            class _t {
                constructor($, W) {
                    this.name = $, this.extent = o.aj, this.length = W.length, this._jsonFeatures = W
                }

                feature($) {
                    return new et(this._jsonFeatures[$])
                }
            }

            class xt {
                constructor($) {
                    this.layers = {}, this.extent = o.aj;
                    for (const W of Object.keys($)) this.layers[W] = new _t(W, $[W])
                }
            }

            const Mt = 64 / 4096, Xt = 128;

            class Zt {
                constructor() {
                    this.features = new Map
                }

                clear() {
                    this.features.clear()
                }

                load($ = [], W) {
                    for (const ie of $) {
                        const we = ie.id;
                        if (we == null) continue;
                        let se = this.features.get(we);
                        se && this.updateCache(se, W), ie.geometry ? (se = hi(ie), this.updateCache(se, W), this.features.set(we, se)) : this.features.delete(we), this.updateCache(se, W)
                    }
                }

                updateCache($, W) {
                    for (const {canonical: ie, uid: we} of Object.values(W)) {
                        const {z: se, x: Ae, y: Ve} = ie;
                        Ht($, Math.pow(2, se), Ae, Ve) && delete W[we]
                    }
                }

                getTile($, W, ie) {
                    const we = Math.pow(2, $), se = [];
                    for (const Ae of this.features.values()) Ht(Ae, we, W, ie) && se.push(si(Ae, we, W, ie));
                    return {features: se}
                }

                getFeatures() {
                    return [...this.features.values()]
                }
            }

            function Ht({minX: Le, minY: $, maxX: W, maxY: ie}, we, se, Ae) {
                return Le < (se + 1 + Mt) / we && $ < (Ae + 1 + Mt) / we && W > (se - Mt) / we && ie > (Ae - Mt) / we
            }

            function hi(Le) {
                const {id: $, geometry: W, properties: ie} = Le;
                if (!W) return;
                if (W.type === "GeometryCollection") throw new Error("GeometryCollection not supported in dynamic mode.");
                const {type: we, coordinates: se} = W,
                    Ae = {id: $, type: 1, geometry: [], tags: ie, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0},
                    Ve = Ae.geometry;
                if (we === "Point") Mi(se, Ve, Ae); else if (we === "MultiPoint") for (const Pe of se) Mi(Pe, Ve, Ae); else if (we === "LineString") Ae.type = 2, $t(se, Ve, Ae); else if (we === "MultiLineString") Ae.type = 2, _i(se, Ve, Ae); else if (we === "Polygon") Ae.type = 3, _i(se, Ve, Ae, !0); else {
                    if (we !== "MultiPolygon") throw new Error("Input data is not a valid GeoJSON object.");
                    Ae.type = 3;
                    for (const Pe of se) _i(Pe, Ve, Ae, !0)
                }
                return Ae
            }

            function Mi([Le, $], W, ie) {
                const we = o.aD(Le);
                let se = o.aH($);
                se = se < 0 ? 0 : se > 1 ? 1 : se, W.push(we, se), ie.minX = Math.min(ie.minX, we), ie.minY = Math.min(ie.minY, se), ie.maxX = Math.max(ie.maxX, we), ie.maxY = Math.max(ie.maxY, se)
            }

            function $t(Le, $, W, ie = !1, we = !1) {
                const se = [];
                for (const Ae of Le) Mi(Ae, se, W);
                $.push(se), ie && function (Ae, Ve) {
                    let Pe = 0;
                    for (let Ne = 0, ft = Ae.length, Je = ft - 2; Ne < ft; Je = Ne, Ne += 2) Pe += (Ae[Ne] - Ae[Je]) * (Ae[Ne + 1] + Ae[Je + 1]);
                    if (Pe > 0 === Ve) for (let Ne = 0, ft = Ae.length; Ne < ft / 2; Ne += 2) {
                        const Je = Ae[Ne], Gt = Ae[Ne + 1];
                        Ae[Ne] = Ae[ft - 2 - Ne], Ae[Ne + 1] = Ae[ft - 1 - Ne], Ae[ft - 2 - Ne] = Je, Ae[ft - 1 - Ne] = Gt
                    }
                }(se, we)
            }

            function _i(Le, $, W, ie = !1) {
                for (let we = 0; we < Le.length; we++) $t(Le[we], $, W, ie, we === 0)
            }

            function si(Le, $, W, ie) {
                const {id: we, type: se, geometry: Ae, tags: Ve} = Le, Pe = [];
                if (se === 1) (function (Ne, ft, Je, Gt, ii) {
                    for (let li = 0; li < Ne.length; li += 2) {
                        const zi = Math.round(o.aj * (Ne[li + 0] * ft - Je)),
                            Ti = Math.round(o.aj * (Ne[li + 1] * ft - Gt));
                        ii.push([zi, Ti])
                    }
                })(Ae, $, W, ie, Pe); else for (const Ne of Ae) Ri(Ne, $, W, ie, Pe);
                return {id: we, type: se, geometry: Pe, tags: Ve}
            }

            function Ri(Le, $, W, ie, we) {
                const se = -Xt, Ae = o.aj + Xt;
                let Ve;
                for (let Pe = 0; Pe < Le.length - 2; Pe += 2) {
                    let Ne = Math.round(o.aj * (Le[Pe + 0] * $ - W)), ft = Math.round(o.aj * (Le[Pe + 1] * $ - ie)),
                        Je = Math.round(o.aj * (Le[Pe + 2] * $ - W)), Gt = Math.round(o.aj * (Le[Pe + 3] * $ - ie));
                    const ii = Je - Ne, li = Gt - ft;
                    Ne < se && Je < se || (Ne < se ? (ft += Math.round(li * ((se - Ne) / ii)), Ne = se) : Je < se && (Gt = ft + Math.round(li * ((se - Ne) / ii)), Je = se), ft < se && Gt < se || (ft < se ? (Ne += Math.round(ii * ((se - ft) / li)), ft = se) : Gt < se && (Je = Ne + Math.round(ii * ((se - ft) / li)), Gt = se), Ne >= Ae && Je >= Ae || (Ne >= Ae ? (ft += Math.round(li * ((Ae - Ne) / ii)), Ne = Ae) : Je >= Ae && (Gt = ft + Math.round(li * ((Ae - Ne) / ii)), Je = Ae), ft >= Ae && Gt >= Ae || (ft >= Ae ? (Ne += Math.round(ii * ((Ae - ft) / li)), ft = Ae) : Gt >= Ae && (Je = Ne + Math.round(ii * ((Ae - ft) / li)), Gt = Ae), Ve && Ne === Ve[Ve.length - 1][0] && ft === Ve[Ve.length - 1][1] || (Ve = [[Ne, ft]], we.push(Ve)), Ve.push([Je, Gt])))))
                }
            }

            function Ct({name: Le, features: $}, W) {
                W.writeStringField(1, Le), W.writeVarintField(5, o.aj);
                const ie = new Map, we = new Map, se = {keys: ie, values: we, feature: null};
                for (const Ae of $) se.feature = Ae, W.writeMessage(2, Rt, se);
                for (const Ae of ie.keys()) W.writeStringField(3, Ae);
                for (const Ae of we.keys()) W.writeMessage(4, cn, Ae)
            }

            function Rt(Le, $) {
                const W = Le.feature;
                W.id === void 0 || isNaN(+W.id) || $.writeVarintField(1, +W.id), W.tags && $.writeMessage(2, ni, Le), $.writeVarintField(3, W.type), $.writeMessage(4, nn, W)
            }

            function ni({keys: Le, values: $, feature: W}, ie) {
                for (const we of Object.keys(W.tags)) {
                    let se = W.tags[we];
                    if (se === null) continue;
                    let Ae = Le.get(we);
                    Ae === void 0 && (Ae = Le.size, Le.set(we, Ae)), ie.writeVarint(Ae);
                    const Ve = typeof se;
                    Ve !== "string" && Ve !== "boolean" && Ve !== "number" && (se = JSON.stringify(se));
                    let Pe = $.get(se);
                    Pe === void 0 && (Pe = $.size, $.set(se, Pe)), ie.writeVarint(Pe)
                }
            }

            function ai(Le, $) {
                return ($ << 3) + (7 & Le)
            }

            function fi(Le) {
                return Le << 1 ^ Le >> 31
            }

            function nn(Le, $) {
                const {geometry: W, type: ie} = Le;
                let we = 0, se = 0;
                if (ie === 1) {
                    $.writeVarint(ai(1, W.length));
                    for (const Ae of W) {
                        const Ve = Ae[0] - we, Pe = Ae[1] - se;
                        $.writeVarint(fi(Ve)), $.writeVarint(fi(Pe)), we += Ve, se += Pe
                    }
                } else for (const Ae of W) {
                    $.writeVarint(ai(1, 1));
                    const Ve = Ae.length - (ie === 3 ? 1 : 0);
                    for (let Pe = 0; Pe < Ve; Pe++) {
                        Pe === 1 && $.writeVarint(ai(2, Ve - 1));
                        const Ne = Ae[Pe][0] - we, ft = Ae[Pe][1] - se;
                        $.writeVarint(fi(Ne)), $.writeVarint(fi(ft)), we += Ne, se += ft
                    }
                    ie === 3 && $.writeVarint(ai(7, 1))
                }
            }

            function cn(Le, $) {
                const W = typeof Le;
                W === "string" ? $.writeStringField(1, Le) : W === "boolean" ? $.writeBooleanField(7, Le) : W === "number" && (Le % 1 != 0 ? $.writeDoubleField(3, Le) : Le < 0 ? $.writeSVarintField(6, Le) : $.writeVarintField(5, Le))
            }

            const Zn = {
                minZoom: 0,
                maxZoom: 16,
                minPoints: 2,
                radius: 40,
                extent: 512,
                nodeSize: 64,
                log: !1,
                generateId: !1,
                reduce: null,
                map: Le => Le
            }, Bi = Math.fround || (Ii = new Float32Array(1), Le => (Ii[0] = +Le, Ii[0]));
            var Ii;
            const Bn = 3, ar = 5, An = 6;

            class Zr {
                constructor($) {
                    this.options = Object.assign(Object.create(Zn), $), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = []
                }

                load($) {
                    const {log: W, minZoom: ie, maxZoom: we} = this.options;
                    W && console.time("total time");
                    const se = `prepare ${$.length} points`;
                    W && console.time(se), this.points = $;
                    const Ae = [];
                    for (let Pe = 0; Pe < $.length; Pe++) {
                        const Ne = $[Pe];
                        if (!Ne.geometry) continue;
                        const [ft, Je] = Ne.geometry.coordinates, Gt = Bi(Xr(ft)), ii = Bi(Nn(Je));
                        Ae.push(Gt, ii, 1 / 0, Pe, -1, 1), this.options.reduce && Ae.push(0)
                    }
                    let Ve = this.trees[we + 1] = this._createTree(Ae);
                    W && console.timeEnd(se);
                    for (let Pe = we; Pe >= ie; Pe--) {
                        const Ne = +Date.now();
                        Ve = this.trees[Pe] = this._createTree(this._cluster(Ve, Pe)), W && console.log("z%d: %d clusters in %dms", Pe, Ve.numItems, +Date.now() - Ne)
                    }
                    return W && console.timeEnd("total time"), this
                }

                getClusters($, W) {
                    let ie = (($[0] + 180) % 360 + 360) % 360 - 180;
                    const we = Math.max(-90, Math.min(90, $[1]));
                    let se = $[2] === 180 ? 180 : (($[2] + 180) % 360 + 360) % 360 - 180;
                    const Ae = Math.max(-90, Math.min(90, $[3]));
                    if ($[2] - $[0] >= 360) ie = -180, se = 180; else if (ie > se) {
                        const Je = this.getClusters([ie, we, 180, Ae], W), Gt = this.getClusters([-180, we, se, Ae], W);
                        return Je.concat(Gt)
                    }
                    const Ve = this.trees[this._limitZoom(W)], Pe = Ve.range(Xr(ie), Nn(Ae), Xr(se), Nn(we)),
                        Ne = Ve.data, ft = [];
                    for (const Je of Pe) {
                        const Gt = this.stride * Je;
                        ft.push(Ne[Gt + ar] > 1 ? wo(Ne, Gt, this.clusterProps) : this.points[Ne[Gt + Bn]])
                    }
                    return ft
                }

                getChildren($) {
                    const W = this._getOriginId($), ie = this._getOriginZoom($),
                        we = "No cluster with the specified id.", se = this.trees[ie];
                    if (!se) throw new Error(we);
                    const Ae = se.data;
                    if (W * this.stride >= Ae.length) throw new Error(we);
                    const Ve = this.options.radius / (this.options.extent * Math.pow(2, ie - 1)),
                        Pe = se.within(Ae[W * this.stride], Ae[W * this.stride + 1], Ve), Ne = [];
                    for (const ft of Pe) {
                        const Je = ft * this.stride;
                        Ae[Je + 4] === $ && Ne.push(Ae[Je + ar] > 1 ? wo(Ae, Je, this.clusterProps) : this.points[Ae[Je + Bn]])
                    }
                    if (Ne.length === 0) throw new Error(we);
                    return Ne
                }

                getLeaves($, W, ie) {
                    const we = [];
                    return this._appendLeaves(we, $, W = W || 10, ie = ie || 0, 0), we
                }

                getTile($, W, ie) {
                    const we = this.trees[this._limitZoom($)], se = Math.pow(2, $), {
                        extent: Ae,
                        radius: Ve
                    } = this.options, Pe = Ve / Ae, Ne = (ie - Pe) / se, ft = (ie + 1 + Pe) / se, Je = {features: []};
                    return this._addTileFeatures(we.range((W - Pe) / se, Ne, (W + 1 + Pe) / se, ft), we.data, W, ie, se, Je), W === 0 && this._addTileFeatures(we.range(1 - Pe / se, Ne, 1, ft), we.data, se, ie, se, Je), W === se - 1 && this._addTileFeatures(we.range(0, Ne, Pe / se, ft), we.data, -1, ie, se, Je), Je.features.length ? Je : null
                }

                getClusterExpansionZoom($) {
                    let W = this._getOriginZoom($) - 1;
                    for (; W <= this.options.maxZoom;) {
                        const ie = this.getChildren($);
                        if (W++, ie.length !== 1) break;
                        $ = ie[0].properties.cluster_id
                    }
                    return W
                }

                _appendLeaves($, W, ie, we, se) {
                    const Ae = this.getChildren(W);
                    for (const Ve of Ae) {
                        const Pe = Ve.properties;
                        if (Pe && Pe.cluster ? se + Pe.point_count <= we ? se += Pe.point_count : se = this._appendLeaves($, Pe.cluster_id, ie, we, se) : se < we ? se++ : $.push(Ve), $.length === ie) break
                    }
                    return se
                }

                _createTree($) {
                    const W = new o.c0($.length / this.stride | 0, this.options.nodeSize, Float32Array);
                    for (let ie = 0; ie < $.length; ie += this.stride) W.add($[ie], $[ie + 1]);
                    return W.finish(), W.data = $, W
                }

                _addTileFeatures($, W, ie, we, se, Ae) {
                    for (const Ve of $) {
                        const Pe = Ve * this.stride, Ne = W[Pe + ar] > 1;
                        let ft, Je, Gt;
                        if (Ne) ft = Do(W, Pe, this.clusterProps), Je = W[Pe], Gt = W[Pe + 1]; else {
                            const zi = this.points[W[Pe + Bn]];
                            ft = zi.properties;
                            const [Ti, Di] = zi.geometry.coordinates;
                            Je = Xr(Ti), Gt = Nn(Di)
                        }
                        const ii = {
                            type: 1,
                            geometry: [[Math.round(this.options.extent * (Je * se - ie)), Math.round(this.options.extent * (Gt * se - we))]],
                            tags: ft
                        };
                        let li;
                        li = Ne || this.options.generateId ? W[Pe + Bn] : this.points[W[Pe + Bn]].id, li !== void 0 && (ii.id = li), Ae.features.push(ii)
                    }
                }

                _limitZoom($) {
                    return Math.max(this.options.minZoom, Math.min(Math.floor(+$), this.options.maxZoom + 1))
                }

                _cluster($, W) {
                    const {radius: ie, extent: we, reduce: se, minPoints: Ae} = this.options,
                        Ve = ie / (we * Math.pow(2, W)), Pe = $.data, Ne = [], ft = this.stride;
                    for (let Je = 0; Je < Pe.length; Je += ft) {
                        if (Pe[Je + 2] <= W) continue;
                        Pe[Je + 2] = W;
                        const Gt = Pe[Je], ii = Pe[Je + 1], li = $.within(Pe[Je], Pe[Je + 1], Ve), zi = Pe[Je + ar];
                        let Ti = zi;
                        for (const Di of li) {
                            const mn = Di * ft;
                            Pe[mn + 2] > W && (Ti += Pe[mn + ar])
                        }
                        if (Ti > zi && Ti >= Ae) {
                            let Di, mn = Gt * zi, Li = ii * zi, Xn = -1;
                            const mr = (Je / ft << 5) + (W + 1) + this.points.length;
                            for (const lr of li) {
                                const un = lr * ft;
                                if (Pe[un + 2] <= W) continue;
                                Pe[un + 2] = W;
                                const Zi = Pe[un + ar];
                                mn += Pe[un] * Zi, Li += Pe[un + 1] * Zi, Pe[un + 4] = mr, se && (Di || (Di = this._map(Pe, Je, !0), Xn = this.clusterProps.length, this.clusterProps.push(Di)), se(Di, this._map(Pe, un)))
                            }
                            Pe[Je + 4] = mr, Ne.push(mn / Ti, Li / Ti, 1 / 0, mr, -1, Ti), se && Ne.push(Xn)
                        } else {
                            for (let Di = 0; Di < ft; Di++) Ne.push(Pe[Je + Di]);
                            if (Ti > 1) for (const Di of li) {
                                const mn = Di * ft;
                                if (!(Pe[mn + 2] <= W)) {
                                    Pe[mn + 2] = W;
                                    for (let Li = 0; Li < ft; Li++) Ne.push(Pe[mn + Li])
                                }
                            }
                        }
                    }
                    return Ne
                }

                _getOriginId($) {
                    return $ - this.points.length >> 5
                }

                _getOriginZoom($) {
                    return ($ - this.points.length) % 32
                }

                _map($, W, ie) {
                    if ($[W + ar] > 1) {
                        const Ae = this.clusterProps[$[W + An]];
                        return ie ? Object.assign({}, Ae) : Ae
                    }
                    const we = this.points[$[W + Bn]].properties, se = this.options.map(we);
                    return ie && se === we ? Object.assign({}, se) : se
                }
            }

            function wo(Le, $, W) {
                return {
                    type: "Feature",
                    id: Le[$ + Bn],
                    properties: Do(Le, $, W),
                    geometry: {type: "Point", coordinates: [(ie = Le[$], 360 * (ie - .5)), Ar(Le[$ + 1])]}
                };
                var ie
            }

            function Do(Le, $, W) {
                const ie = Le[$ + ar],
                    we = ie >= 1e4 ? `${Math.round(ie / 1e3)}k` : ie >= 1e3 ? Math.round(ie / 100) / 10 + "k" : ie,
                    se = Le[$ + An], Ae = se === -1 ? {} : Object.assign({}, W[se]);
                return Object.assign(Ae, {
                    cluster: !0,
                    cluster_id: Le[$ + Bn],
                    point_count: ie,
                    point_count_abbreviated: we
                })
            }

            function Xr(Le) {
                return Le / 360 + .5
            }

            function Nn(Le) {
                const $ = Math.sin(Le * Math.PI / 180), W = .5 - .25 * Math.log((1 + $) / (1 - $)) / Math.PI;
                return W < 0 ? 0 : W > 1 ? 1 : W
            }

            function Ar(Le) {
                const $ = (180 - 360 * Le) * Math.PI / 180;
                return 360 * Math.atan(Math.exp($)) / Math.PI - 90
            }

            function fs(Le, $, W, ie) {
                let we = ie;
                const se = $ + (W - $ >> 1);
                let Ae, Ve = W - $;
                const Pe = Le[$], Ne = Le[$ + 1], ft = Le[W], Je = Le[W + 1];
                for (let Gt = $ + 3; Gt < W; Gt += 3) {
                    const ii = Rs(Le[Gt], Le[Gt + 1], Pe, Ne, ft, Je);
                    if (ii > we) Ae = Gt, we = ii; else if (ii === we) {
                        const li = Math.abs(Gt - se);
                        li < Ve && (Ae = Gt, Ve = li)
                    }
                }
                we > ie && (Ae - $ > 3 && fs(Le, $, Ae, ie), Le[Ae + 2] = we, W - Ae > 3 && fs(Le, Ae, W, ie))
            }

            function Rs(Le, $, W, ie, we, se) {
                let Ae = we - W, Ve = se - ie;
                if (Ae !== 0 || Ve !== 0) {
                    const Pe = ((Le - W) * Ae + ($ - ie) * Ve) / (Ae * Ae + Ve * Ve);
                    Pe > 1 ? (W = we, ie = se) : Pe > 0 && (W += Ae * Pe, ie += Ve * Pe)
                }
                return Ae = Le - W, Ve = $ - ie, Ae * Ae + Ve * Ve
            }

            function lo(Le, $, W, ie) {
                const we = {
                    id: Le ?? null,
                    type: $,
                    geometry: W,
                    tags: ie,
                    minX: 1 / 0,
                    minY: 1 / 0,
                    maxX: -1 / 0,
                    maxY: -1 / 0
                };
                if ($ === "Point" || $ === "MultiPoint" || $ === "LineString") co(we, W); else if ($ === "Polygon") co(we, W[0]); else if ($ === "MultiLineString") for (const se of W) co(we, se); else if ($ === "MultiPolygon") for (const se of W) co(we, se[0]);
                return we
            }

            function co(Le, $) {
                for (let W = 0; W < $.length; W += 3) Le.minX = Math.min(Le.minX, $[W]), Le.minY = Math.min(Le.minY, $[W + 1]), Le.maxX = Math.max(Le.maxX, $[W]), Le.maxY = Math.max(Le.maxY, $[W + 1])
            }

            function Ir(Le, $, W, ie) {
                if (!$.geometry) return;
                const we = $.geometry.coordinates;
                if (we && we.length === 0) return;
                const se = $.geometry.type, Ae = Math.pow(W.tolerance / ((1 << W.maxZoom) * W.extent), 2);
                let Ve = [], Pe = $.id;
                if (W.promoteId ? Pe = $.properties[W.promoteId] : W.generateId && (Pe = ie || 0), se === "Point") ps(we, Ve); else if (se === "MultiPoint") for (const Ne of we) ps(Ne, Ve); else if (se === "LineString") Yr(we, Ve, Ae, !1); else if (se === "MultiLineString") {
                    if (W.lineMetrics) {
                        for (const Ne of we) Ve = [], Yr(Ne, Ve, Ae, !1), Le.push(lo(Pe, "LineString", Ve, $.properties));
                        return
                    }
                    fa(we, Ve, Ae, !1)
                } else if (se === "Polygon") fa(we, Ve, Ae, !0); else {
                    if (se !== "MultiPolygon") {
                        if (se === "GeometryCollection") {
                            for (const Ne of $.geometry.geometries) Ir(Le, {
                                id: Pe,
                                geometry: Ne,
                                properties: $.properties
                            }, W, ie);
                            return
                        }
                        throw new Error("Input data is not a valid GeoJSON object.")
                    }
                    for (const Ne of we) {
                        const ft = [];
                        fa(Ne, ft, Ae, !0), Ve.push(ft)
                    }
                }
                Le.push(lo(Pe, se, Ve, $.properties))
            }

            function ps(Le, $) {
                $.push(Va(Le[0]), Qn(Le[1]), 0)
            }

            function Yr(Le, $, W, ie) {
                let we, se, Ae = 0;
                for (let Pe = 0; Pe < Le.length; Pe++) {
                    const Ne = Va(Le[Pe][0]), ft = Qn(Le[Pe][1]);
                    $.push(Ne, ft, 0), Pe > 0 && (Ae += ie ? (we * ft - Ne * se) / 2 : Math.sqrt(Math.pow(Ne - we, 2) + Math.pow(ft - se, 2))), we = Ne, se = ft
                }
                const Ve = $.length - 3;
                $[2] = 1, fs($, 0, Ve, W), $[Ve + 2] = 1, $.size = Math.abs(Ae), $.start = 0, $.end = $.size
            }

            function fa(Le, $, W, ie) {
                for (let we = 0; we < Le.length; we++) {
                    const se = [];
                    Yr(Le[we], se, W, ie), $.push(se)
                }
            }

            function Va(Le) {
                return Le / 360 + .5
            }

            function Qn(Le) {
                const $ = Math.sin(Le * Math.PI / 180), W = .5 - .25 * Math.log((1 + $) / (1 - $)) / Math.PI;
                return W < 0 ? 0 : W > 1 ? 1 : W
            }

            function Cr(Le, $, W, ie, we, se, Ae, Ve) {
                if (ie /= $, se >= (W /= $) && Ae < ie) return Le;
                if (Ae < W || se >= ie) return null;
                const Pe = [];
                for (const Ne of Le) {
                    const ft = Ne.geometry;
                    let Je = Ne.type;
                    const Gt = we === 0 ? Ne.minX : Ne.minY, ii = we === 0 ? Ne.maxX : Ne.maxY;
                    if (Gt >= W && ii < ie) {
                        Pe.push(Ne);
                        continue
                    }
                    if (ii < W || Gt >= ie) continue;
                    let li = [];
                    if (Je === "Point" || Je === "MultiPoint") Ml(ft, li, W, ie, we); else if (Je === "LineString") zs(ft, li, W, ie, we, !1, Ve.lineMetrics); else if (Je === "MultiLineString") Fr(ft, li, W, ie, we, !1); else if (Je === "Polygon") Fr(ft, li, W, ie, we, !0); else if (Je === "MultiPolygon") for (const zi of ft) {
                        const Ti = [];
                        Fr(zi, Ti, W, ie, we, !0), Ti.length && li.push(Ti)
                    }
                    if (li.length) {
                        if (Ve.lineMetrics && Je === "LineString") {
                            for (const zi of li) Pe.push(lo(Ne.id, Je, zi, Ne.tags));
                            continue
                        }
                        Je !== "LineString" && Je !== "MultiLineString" || (li.length === 1 ? (Je = "LineString", li = li[0]) : Je = "MultiLineString"), Je !== "Point" && Je !== "MultiPoint" || (Je = li.length === 3 ? "Point" : "MultiPoint"), Pe.push(lo(Ne.id, Je, li, Ne.tags))
                    }
                }
                return Pe.length ? Pe : null
            }

            function Ml(Le, $, W, ie, we) {
                for (let se = 0; se < Le.length; se += 3) {
                    const Ae = Le[se + we];
                    Ae >= W && Ae <= ie && uo($, Le[se], Le[se + 1], Le[se + 2])
                }
            }

            function zs(Le, $, W, ie, we, se, Ae) {
                let Ve = Ds(Le);
                const Pe = we === 0 ? ms : ho;
                let Ne, ft, Je = Le.start;
                for (let Ti = 0; Ti < Le.length - 3; Ti += 3) {
                    const Di = Le[Ti], mn = Le[Ti + 1], Li = Le[Ti + 2], Xn = Le[Ti + 3], mr = Le[Ti + 4],
                        lr = we === 0 ? Di : mn, un = we === 0 ? Xn : mr;
                    let Zi = !1;
                    Ae && (Ne = Math.sqrt(Math.pow(Di - Xn, 2) + Math.pow(mn - mr, 2))), lr < W ? un > W && (ft = Pe(Ve, Di, mn, Xn, mr, W), Ae && (Ve.start = Je + Ne * ft)) : lr > ie ? un < ie && (ft = Pe(Ve, Di, mn, Xn, mr, ie), Ae && (Ve.start = Je + Ne * ft)) : uo(Ve, Di, mn, Li), un < W && lr >= W && (ft = Pe(Ve, Di, mn, Xn, mr, W), Zi = !0), un > ie && lr <= ie && (ft = Pe(Ve, Di, mn, Xn, mr, ie), Zi = !0), !se && Zi && (Ae && (Ve.end = Je + Ne * ft), $.push(Ve), Ve = Ds(Le)), Ae && (Je += Ne)
                }
                let Gt = Le.length - 3;
                const ii = Le[Gt], li = Le[Gt + 1], zi = we === 0 ? ii : li;
                zi >= W && zi <= ie && uo(Ve, ii, li, Le[Gt + 2]), Gt = Ve.length - 3, se && Gt >= 3 && (Ve[Gt] !== Ve[0] || Ve[Gt + 1] !== Ve[1]) && uo(Ve, Ve[0], Ve[1], Ve[2]), Ve.length && $.push(Ve)
            }

            function Ds(Le) {
                const $ = [];
                return $.size = Le.size, $.start = Le.start, $.end = Le.end, $
            }

            function Fr(Le, $, W, ie, we, se) {
                for (const Ae of Le) zs(Ae, $, W, ie, we, se, !1)
            }

            function uo(Le, $, W, ie) {
                Le.push($, W, ie)
            }

            function ms(Le, $, W, ie, we, se) {
                const Ae = (se - $) / (ie - $);
                return uo(Le, se, W + (we - W) * Ae, 1), Ae
            }

            function ho(Le, $, W, ie, we, se) {
                const Ae = (se - W) / (we - W);
                return uo(Le, $ + (ie - $) * Ae, se, 1), Ae
            }

            function Ls(Le, $) {
                const W = [];
                for (let ie = 0; ie < Le.length; ie++) {
                    const we = Le[ie], se = we.type;
                    let Ae;
                    if (se === "Point" || se === "MultiPoint" || se === "LineString") Ae = bo(we.geometry, $); else if (se === "MultiLineString" || se === "Polygon") {
                        Ae = [];
                        for (const Ve of we.geometry) Ae.push(bo(Ve, $))
                    } else if (se === "MultiPolygon") {
                        Ae = [];
                        for (const Ve of we.geometry) {
                            const Pe = [];
                            for (const Ne of Ve) Pe.push(bo(Ne, $));
                            Ae.push(Pe)
                        }
                    }
                    W.push(lo(we.id, se, Ae, we.tags))
                }
                return W
            }

            function bo(Le, $) {
                const W = [];
                W.size = Le.size, Le.start !== void 0 && (W.start = Le.start, W.end = Le.end);
                for (let ie = 0; ie < Le.length; ie += 3) W.push(Le[ie] + $, Le[ie + 1], Le[ie + 2]);
                return W
            }

            function Ua(Le, $) {
                if (Le.transformed) return Le;
                const W = 1 << Le.z, ie = Le.x, we = Le.y;
                for (const se of Le.features) {
                    const Ae = se.geometry, Ve = se.type;
                    if (se.geometry = [], Ve === 1) for (let Pe = 0; Pe < Ae.length; Pe += 2) se.geometry.push(bn(Ae[Pe], Ae[Pe + 1], $, W, ie, we)); else for (let Pe = 0; Pe < Ae.length; Pe++) {
                        const Ne = [];
                        for (let ft = 0; ft < Ae[Pe].length; ft += 2) Ne.push(bn(Ae[Pe][ft], Ae[Pe][ft + 1], $, W, ie, we));
                        se.geometry.push(Ne)
                    }
                }
                return Le.transformed = !0, Le
            }

            function bn(Le, $, W, ie, we, se) {
                return [Math.round(W * (Le * ie - we)), Math.round(W * ($ * ie - se))]
            }

            function Ga(Le, $, W, ie, we) {
                const se = $ === we.maxZoom ? 0 : we.tolerance / ((1 << $) * we.extent), Ae = {
                    features: [],
                    numPoints: 0,
                    numSimplified: 0,
                    numFeatures: Le.length,
                    source: null,
                    x: W,
                    y: ie,
                    z: $,
                    transformed: !1,
                    minX: 2,
                    minY: 1,
                    maxX: -1,
                    maxY: 0
                };
                for (const Ve of Le) $a(Ae, Ve, se, we);
                return Ae
            }

            function $a(Le, $, W, ie) {
                const we = $.geometry, se = $.type, Ae = [];
                if (Le.minX = Math.min(Le.minX, $.minX), Le.minY = Math.min(Le.minY, $.minY), Le.maxX = Math.max(Le.maxX, $.maxX), Le.maxY = Math.max(Le.maxY, $.maxY), se === "Point" || se === "MultiPoint") for (let Ve = 0; Ve < we.length; Ve += 3) Ae.push(we[Ve], we[Ve + 1]), Le.numPoints++, Le.numSimplified++; else if (se === "LineString") To(Ae, we, Le, W, !1, !1); else if (se === "MultiLineString" || se === "Polygon") for (let Ve = 0; Ve < we.length; Ve++) To(Ae, we[Ve], Le, W, se === "Polygon", Ve === 0); else if (se === "MultiPolygon") for (let Ve = 0; Ve < we.length; Ve++) {
                    const Pe = we[Ve];
                    for (let Ne = 0; Ne < Pe.length; Ne++) To(Ae, Pe[Ne], Le, W, !0, Ne === 0)
                }
                if (Ae.length) {
                    let Ve = $.tags || null;
                    if (se === "LineString" && ie.lineMetrics) {
                        Ve = {};
                        for (const Ne in $.tags) Ve[Ne] = $.tags[Ne];
                        Ve.mapbox_clip_start = we.start / we.size, Ve.mapbox_clip_end = we.end / we.size
                    }
                    const Pe = {
                        geometry: Ae,
                        type: se === "Polygon" || se === "MultiPolygon" ? 3 : se === "LineString" || se === "MultiLineString" ? 2 : 1,
                        tags: Ve
                    };
                    $.id !== null && (Pe.id = $.id), Le.features.push(Pe)
                }
            }

            function To(Le, $, W, ie, we, se) {
                const Ae = ie * ie;
                if (ie > 0 && $.size < (we ? Ae : ie)) return void (W.numPoints += $.length / 3);
                const Ve = [];
                for (let Pe = 0; Pe < $.length; Pe += 3) (ie === 0 || $[Pe + 2] > Ae) && (W.numSimplified++, Ve.push($[Pe], $[Pe + 1])), W.numPoints++;
                we && function (Pe, Ne) {
                    let ft = 0;
                    for (let Je = 0, Gt = Pe.length, ii = Gt - 2; Je < Gt; ii = Je, Je += 2) ft += (Pe[Je] - Pe[ii]) * (Pe[Je + 1] + Pe[ii + 1]);
                    if (ft > 0 === Ne) for (let Je = 0, Gt = Pe.length; Je < Gt / 2; Je += 2) {
                        const ii = Pe[Je], li = Pe[Je + 1];
                        Pe[Je] = Pe[Gt - 2 - Je], Pe[Je + 1] = Pe[Gt - 1 - Je], Pe[Gt - 2 - Je] = ii, Pe[Gt - 1 - Je] = li
                    }
                }(Ve, se), Le.push(Ve)
            }

            const pa = {
                maxZoom: 14,
                indexMaxZoom: 5,
                indexMaxPoints: 1e5,
                tolerance: 3,
                extent: 4096,
                buffer: 64,
                lineMetrics: !1,
                promoteId: null,
                generateId: !1,
                debug: 0
            };

            class gs {
                constructor($, W) {
                    const ie = (W = this.options = function (se, Ae) {
                        for (const Ve in Ae) se[Ve] = Ae[Ve];
                        return se
                    }(Object.create(pa), W)).debug;
                    if (ie && console.time("preprocess data"), W.maxZoom < 0 || W.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
                    if (W.promoteId && W.generateId) throw new Error("promoteId and generateId cannot be used together.");
                    let we = function (se, Ae) {
                        const Ve = [];
                        if (se.type === "FeatureCollection") for (let Pe = 0; Pe < se.features.length; Pe++) Ir(Ve, se.features[Pe], Ae, Pe); else Ir(Ve, se.type === "Feature" ? se : {geometry: se}, Ae);
                        return Ve
                    }($, W);
                    this.tiles = {}, this.tileCoords = [], ie && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", W.indexMaxZoom, W.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), we = function (se, Ae) {
                        const Ve = Ae.buffer / Ae.extent;
                        let Pe = se;
                        const Ne = Cr(se, 1, -1 - Ve, Ve, 0, -1, 2, Ae), ft = Cr(se, 1, 1 - Ve, 2 + Ve, 0, -1, 2, Ae);
                        return (Ne || ft) && (Pe = Cr(se, 1, -Ve, 1 + Ve, 0, -1, 2, Ae) || [], Ne && (Pe = Ls(Ne, 1).concat(Pe)), ft && (Pe = Pe.concat(Ls(ft, -1)))), Pe
                    }(we, W), we.length && this.splitTile(we, 0, 0, 0), ie && (we.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)))
                }

                splitTile($, W, ie, we, se, Ae, Ve) {
                    const Pe = [$, W, ie, we], Ne = this.options, ft = Ne.debug;
                    for (; Pe.length;) {
                        we = Pe.pop(), ie = Pe.pop(), W = Pe.pop(), $ = Pe.pop();
                        const Je = 1 << W, Gt = Ha(W, ie, we);
                        let ii = this.tiles[Gt];
                        if (!ii && (ft > 1 && console.time("creation"), ii = this.tiles[Gt] = Ga($, W, ie, we, Ne), this.tileCoords.push({
                            z: W,
                            x: ie,
                            y: we
                        }), ft)) {
                            ft > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", W, ie, we, ii.numFeatures, ii.numPoints, ii.numSimplified), console.timeEnd("creation"));
                            const Zi = `z${W}`;
                            this.stats[Zi] = (this.stats[Zi] || 0) + 1, this.total++
                        }
                        if (ii.source = $, se == null) {
                            if (W === Ne.indexMaxZoom || ii.numPoints <= Ne.indexMaxPoints) continue
                        } else {
                            if (W === Ne.maxZoom || W === se) continue;
                            if (se != null) {
                                const Zi = se - W;
                                if (ie !== Ae >> Zi || we !== Ve >> Zi) continue
                            }
                        }
                        if (ii.source = null, $.length === 0) continue;
                        ft > 1 && console.time("clipping");
                        const li = .5 * Ne.buffer / Ne.extent, zi = .5 - li, Ti = .5 + li, Di = 1 + li;
                        let mn = null, Li = null, Xn = null, mr = null,
                            lr = Cr($, Je, ie - li, ie + Ti, 0, ii.minX, ii.maxX, Ne),
                            un = Cr($, Je, ie + zi, ie + Di, 0, ii.minX, ii.maxX, Ne);
                        $ = null, lr && (mn = Cr(lr, Je, we - li, we + Ti, 1, ii.minY, ii.maxY, Ne), Li = Cr(lr, Je, we + zi, we + Di, 1, ii.minY, ii.maxY, Ne), lr = null), un && (Xn = Cr(un, Je, we - li, we + Ti, 1, ii.minY, ii.maxY, Ne), mr = Cr(un, Je, we + zi, we + Di, 1, ii.minY, ii.maxY, Ne), un = null), ft > 1 && console.timeEnd("clipping"), Pe.push(mn || [], W + 1, 2 * ie, 2 * we), Pe.push(Li || [], W + 1, 2 * ie, 2 * we + 1), Pe.push(Xn || [], W + 1, 2 * ie + 1, 2 * we), Pe.push(mr || [], W + 1, 2 * ie + 1, 2 * we + 1)
                    }
                }

                getTile($, W, ie) {
                    $ = +$, W = +W, ie = +ie;
                    const we = this.options, {extent: se, debug: Ae} = we;
                    if ($ < 0 || $ > 24) return null;
                    const Ve = 1 << $, Pe = Ha($, W = W + Ve & Ve - 1, ie);
                    if (this.tiles[Pe]) return Ua(this.tiles[Pe], se);
                    Ae > 1 && console.log("drilling down to z%d-%d-%d", $, W, ie);
                    let Ne, ft = $, Je = W, Gt = ie;
                    for (; !Ne && ft > 0;) ft--, Je >>= 1, Gt >>= 1, Ne = this.tiles[Ha(ft, Je, Gt)];
                    return Ne && Ne.source ? (Ae > 1 && (console.log("found parent tile z%d-%d-%d", ft, Je, Gt), console.time("drilling down")), this.splitTile(Ne.source, ft, Je, Gt, $, W, ie), Ae > 1 && console.timeEnd("drilling down"), this.tiles[Pe] ? Ua(this.tiles[Pe], se) : null) : null
                }
            }

            function Ha(Le, $, W) {
                return 32 * ((1 << Le) * W + $) + Le
            }

            function Ze(Le, $) {
                const W = Le.tileID.canonical;
                if (!this._geoJSONIndex) return void $(null, null);
                const ie = this._geoJSONIndex.getTile(W.z, W.x, W.y);
                if (!ie) return void $(null, null);
                const we = Ne => Ne.tags && "3d_elevation_id" in Ne.tags && "source" in Ne.tags && Ne.tags.source === "elevation",
                    se = ie.features.filter(Ne => we(Ne));
                let Ae = {_geojsonTileLayer: ie.features};
                se.length > 0 && (Ae = {_geojsonTileLayer: ie.features.filter(Ne => !we(Ne)), hd_road_elevation: se});
                const Ve = new xt(Ae), Pe = function (Ne) {
                    const ft = new o.bq;
                    for (const Je of Object.keys(Ne)) ft.writeMessage(3, Ct, {name: Je, features: Ne[Je]});
                    return ft.finish()
                }(Ae).buffer;
                $(null, {vectorTile: Ve, rawData: Pe})
            }

            class xn extends Me {
                constructor($, W, ie, we, se, Ae, Ve) {
                    super($, W, ie, we, se, Ze, Ve), Ae && (this.loadGeoJSON = Ae), this._dynamicIndex = new Zt
                }

                loadData($, W) {
                    const ie = $ && $.request, we = ie && ie.collectResourceTiming;
                    this._geoJSONIndex = null, this.loadGeoJSON($, (se, Ae) => {
                        if (se || !Ae) return W(se);
                        if (typeof Ae != "object") return W(new Error(`Input data given to '${$.source}' is not a valid GeoJSON object.`));
                        {
                            try {
                                if ($.filter) {
                                    const Pe = o.X($.filter, {
                                        type: "boolean",
                                        "property-type": "data-driven",
                                        overridable: !1,
                                        transition: !1
                                    });
                                    if (Pe.result === "error") throw new Error(Pe.value.map(Ne => `${Ne.key}: ${Ne.message}`).join(", "));
                                    Ae.features = Ae.features.filter(Ne => Pe.value.evaluate({zoom: 0}, Ne))
                                }
                                $.dynamic ? (Ae.type === "Feature" && (Ae = {
                                    type: "FeatureCollection",
                                    features: [Ae]
                                }), $.append || (this._dynamicIndex.clear(), this.loaded = {}), this._dynamicIndex.load(Ae.features, this.loaded), $.cluster && (Ae.features = this._dynamicIndex.getFeatures())) : this.loaded = {}, this._geoJSONIndex = $.cluster ? new Zr(function ({
                                                                                                                                                                                                                                                                                            superclusterOptions: Pe,
                                                                                                                                                                                                                                                                                            clusterProperties: Ne
                                                                                                                                                                                                                                                                                        }) {
                                    if (!Ne || !Pe) return Pe;
                                    const ft = {}, Je = {}, Gt = {accumulated: null, zoom: 0}, ii = {properties: null},
                                        li = Object.keys(Ne);
                                    for (const zi of li) {
                                        const [Ti, Di] = Ne[zi], mn = o.X(Di),
                                            Li = o.X(typeof Ti == "string" ? [Ti, ["accumulated"], ["get", zi]] : Ti);
                                        ft[zi] = mn.value, Je[zi] = Li.value
                                    }
                                    return Pe.map = zi => {
                                        ii.properties = zi;
                                        const Ti = {};
                                        for (const Di of li) Ti[Di] = ft[Di].evaluate(Gt, ii);
                                        return Ti
                                    }, Pe.reduce = (zi, Ti) => {
                                        ii.properties = Ti;
                                        for (const Di of li) Gt.accumulated = zi[Di], zi[Di] = Je[Di].evaluate(Gt, ii)
                                    }, Pe
                                }($)).load(Ae.features) : $.dynamic ? this._dynamicIndex : function (Pe, Ne) {
                                    return new gs(Pe, Ne)
                                }(Ae, $.geojsonVtOptions)
                            } catch (Pe) {
                                return W(Pe)
                            }
                            const Ve = {};
                            if (we) {
                                const Pe = j(ie);
                                Pe && (Ve.resourceTiming = {}, Ve.resourceTiming[$.source] = JSON.parse(JSON.stringify(Pe)))
                            }
                            W(null, Ve)
                        }
                    })
                }

                reloadTile($, W) {
                    const ie = this.loaded;
                    return ie && ie[$.uid] ? $.partial ? W(null, void 0) : super.reloadTile($, W) : this.loadTile($, W)
                }

                loadGeoJSON($, W) {
                    if ($.request) o.n($.request, W); else {
                        if (typeof $.data != "string") return W(new Error(`Input data given to '${$.source}' is not a valid GeoJSON object.`));
                        setTimeout(() => {
                            try {
                                return W(null, JSON.parse($.data))
                            } catch {
                                return W(new Error(`Input data given to '${$.source}' is not a valid GeoJSON object.`))
                            }
                        }, 0)
                    }
                }

                getClusterExpansionZoom($, W) {
                    try {
                        W(null, this._geoJSONIndex.getClusterExpansionZoom($.clusterId))
                    } catch (ie) {
                        W(ie)
                    }
                }

                getClusterChildren($, W) {
                    try {
                        W(null, this._geoJSONIndex.getChildren($.clusterId))
                    } catch (ie) {
                        W(ie)
                    }
                }

                getClusterLeaves($, W) {
                    try {
                        W(null, this._geoJSONIndex.getLeaves($.clusterId, $.limit, $.offset))
                    } catch (ie) {
                        W(ie)
                    }
                }
            }

            class Jn {
                constructor($, W, ie) {
                    this.tileID = new o.aM($.tileID.overscaledZ, $.tileID.wrap, $.tileID.canonical.z, $.tileID.canonical.x, $.tileID.canonical.y), this.tileZoom = $.tileZoom, this.uid = $.uid, this.zoom = $.zoom, this.canonical = $.tileID.canonical, this.pixelRatio = $.pixelRatio, this.tileSize = $.tileSize, this.source = $.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = $.projection, this.brightness = W, this.worldview = ie
                }

                parse($, W, ie, we) {
                    this.status = "parsing";
                    const se = new o.aM(ie.tileID.overscaledZ, ie.tileID.wrap, ie.tileID.canonical.z, ie.tileID.canonical.x, ie.tileID.canonical.y),
                        Ae = [], Ve = W.familiesBySource[ie.source], Pe = new o.fc(se, ie.promoteId);
                    Pe.bucketLayerIDs = [], Pe.is3DTile = !0, o.fr($).then(Ne => {
                        if (!Ne) return we(new Error("Could not parse tile"));
                        const ft = Ne.json.extensionsUsed && Ne.json.extensionsUsed.includes("MAPBOX_mesh_features") || Ne.json.asset.extras && Ne.json.asset.extras.MAPBOX_mesh_features,
                            Je = Ne.json.extensionsUsed && Ne.json.extensionsUsed.includes("EXT_meshopt_compression"),
                            Gt = new o.aa(this.zoom, {brightness: this.brightness, worldview: this.worldview});
                        for (const ii in Ve) for (const li of Ve[ii]) {
                            const zi = li[0];
                            Pe.bucketLayerIDs.push(li.map(mn => o.C(mn.id, mn.scope))), zi.recalculate(Gt, []);
                            const Ti = o.fs(Ne, 1 / o.d4(ie.tileID.canonical)),
                                Di = new o.ft(li, Ti, se, ft, Je, this.brightness, Pe, this.worldview);
                            ft || (Di.needsUpload = !0), Ae.push(Di), Di.evaluate(zi)
                        }
                        this.status = "done", we(null, {
                            buckets: Ae,
                            featureIndex: Pe,
                            collisionBoxArray: null,
                            glyphAtlasImage: null,
                            lineAtlas: null,
                            imageAtlas: null,
                            brightness: null
                        })
                    }).catch(Ne => we(new Error(Ne.message)))
                }
            }

            class Kr {
                constructor($, W, ie, we, se, Ae, Ve, Pe) {
                    this.actor = $, this.layerIndex = W, this.availableImages = ie, this.availableModels = we, this.brightness = Ve, this.loading = {}, this.loaded = {}, this.worldview = Pe
                }

                loadTile($, W) {
                    const ie = $.uid, we = this.loading[ie] = new Jn($, this.brightness, this.worldview);
                    o.br($.request, (se, Ae) => {
                        const Ve = !this.loading[ie];
                        return delete this.loading[ie], Ve || se ? (we.status = "done", Ve || (this.loaded[ie] = we), W(se)) : Ae && Ae.byteLength !== 0 ? void we.parse(Ae, this.layerIndex, $, (Pe, Ne) => {
                            we.status = "done", this.loaded = this.loaded || {}, this.loaded[ie] = we, Pe || !Ne ? W(Pe) : W(null, Ne)
                        }) : (we.status = "done", this.loaded[ie] = we, W())
                    })
                }

                reloadTile($, W) {
                    const ie = this.loaded, we = $.uid;
                    if (ie && ie[we]) {
                        const se = ie[we];
                        se.projection = $.projection, se.brightness = $.brightness;
                        const Ae = (Ve, Pe) => {
                            se.reloadCallback && (delete se.reloadCallback, this.loadTile($, W)), W(Ve, Pe)
                        };
                        se.status === "parsing" ? se.reloadCallback = Ae : se.status === "done" && this.loadTile($, W)
                    }
                }

                abortTile($, W) {
                    const ie = $.uid;
                    this.loading[ie] && delete this.loading[ie], W()
                }

                removeTile($, W) {
                    const ie = this.loaded, we = $.uid;
                    ie && ie[we] && delete ie[we], W()
                }
            }

            class Ai {
                constructor($) {
                    this.self = $, this.actor = new o.fv($, this), this.layerIndexes = {}, this.availableImages = {}, this.availableModels = {}, this.isSpriteLoaded = {}, this.imageRasterizer = new o.y, this.rtlPluginParsingListeners = [], this.projections = {}, this.defaultProjection = o.cj({name: "mercator"}), this.workerSourceTypes = {
                        vector: Me,
                        geojson: xn,
                        "raster-dem": pe,
                        "raster-array": be,
                        "batched-model": Kr
                    }, this.workerSources = {}, this.self.registerWorkerSource = (W, ie) => {
                        if (this.workerSourceTypes[W]) throw new Error(`Worker source with name "${W}" already registered.`);
                        this.workerSourceTypes[W] = ie
                    }, this.self.registerRTLTextPlugin = W => {
                        if (o.fw.isParsed()) throw new Error("RTL text plugin already registered.");
                        o.fw.setState({
                            pluginStatus: o.fx.parsed,
                            pluginURL: o.fw.getPluginURL()
                        }), o.fw.applyArabicShaping = W.applyArabicShaping, o.fw.processBidirectionalText = W.processBidirectionalText, o.fw.processStyledBidirectionalText = W.processStyledBidirectionalText;
                        for (const ie of this.rtlPluginParsingListeners) ie(null, !0);
                        this.rtlPluginParsingListeners = []
                    }
                }

                clearCaches($, W, ie) {
                    delete this.layerIndexes[$], delete this.availableImages[$], delete this.availableModels[$], delete this.workerSources[$], ie()
                }

                checkIfReady($, W, ie) {
                    ie()
                }

                setReferrer($, W) {
                    this.referrer = W
                }

                spriteLoaded($, W) {
                    this.isSpriteLoaded[$] || (this.isSpriteLoaded[$] = {});
                    const {scope: ie, isLoaded: we} = W;
                    if (this.isSpriteLoaded[$][ie] = we, this.workerSources[$] && this.workerSources[$][ie]) for (const se in this.workerSources[$][ie]) {
                        const Ae = this.workerSources[$][ie][se];
                        for (const Ve in Ae) {
                            const Pe = Ae[Ve];
                            Pe instanceof Me && (Pe.isSpriteLoaded = we, Pe.fire(new o.A("isSpriteLoaded")))
                        }
                    }
                }

                setImages($, W, ie) {
                    this.availableImages[$] || (this.availableImages[$] = {});
                    const {scope: we, images: se} = W;
                    if (this.availableImages[$][we] = se, this.workerSources[$] && this.workerSources[$][we]) {
                        for (const Ae in this.workerSources[$][we]) {
                            const Ve = this.workerSources[$][we][Ae];
                            for (const Pe in Ve) Ve[Pe].availableImages = se
                        }
                        ie()
                    } else ie()
                }

                setModels($, {scope: W, models: ie}, we) {
                    if (this.availableModels[$] || (this.availableModels[$] = {}), this.availableModels[$][W] = ie, this.workerSources[$] && this.workerSources[$][W]) {
                        for (const se in this.workerSources[$][W]) {
                            const Ae = this.workerSources[$][W][se];
                            for (const Ve in Ae) Ae[Ve].availableModels = ie
                        }
                        we()
                    } else we()
                }

                setProjection($, W) {
                    this.projections[$] = o.cj(W)
                }

                setBrightness($, W, ie) {
                    this.brightness = W, ie()
                }

                setWorldview($, W, ie) {
                    this.worldview = W, ie()
                }

                setLayers($, W, ie) {
                    this.getLayerIndex($, W.scope).replace(W.layers, W.options), ie()
                }

                updateLayers($, W, ie) {
                    this.getLayerIndex($, W.scope).update(W.layers, W.removedIds, W.options), ie()
                }

                loadTile($, W, ie) {
                    W.projection = this.projections[$] || this.defaultProjection, this.getWorkerSource($, W.type, W.source, W.scope).loadTile(W, ie)
                }

                decodeRasterArray($, W, ie) {
                    this.getWorkerSource($, W.type, W.source, W.scope).decodeRasterArray(W, ie)
                }

                reloadTile($, W, ie) {
                    W.projection = this.projections[$] || this.defaultProjection, this.getWorkerSource($, W.type, W.source, W.scope).reloadTile(W, ie)
                }

                abortTile($, W, ie) {
                    this.getWorkerSource($, W.type, W.source, W.scope).abortTile(W, ie)
                }

                removeTile($, W, ie) {
                    this.getWorkerSource($, W.type, W.source, W.scope).removeTile(W, ie)
                }

                removeSource($, W, ie) {
                    if (!(this.workerSources[$] && this.workerSources[$][W.scope] && this.workerSources[$][W.scope][W.type] && this.workerSources[$][W.scope][W.type][W.source])) return;
                    const we = this.workerSources[$][W.scope][W.type][W.source];
                    delete this.workerSources[$][W.scope][W.type][W.source], we.removeSource !== void 0 ? we.removeSource(W, ie) : ie()
                }

                loadWorkerSource($, W, ie) {
                    try {
                        this.self.importScripts(W.url), ie()
                    } catch (we) {
                        ie(we.toString())
                    }
                }

                syncRTLPluginState($, W, ie) {
                    if (o.fw.isParsed()) ie(null, !0); else if (o.fw.isParsing()) this.rtlPluginParsingListeners.push(ie); else try {
                        o.fw.setState(W);
                        const we = o.fw.getPluginURL();
                        !o.fw.isLoaded() || o.fw.isParsed() || o.fw.isParsing() || we == null || (o.fw.setState({
                            pluginStatus: o.fx.parsing,
                            pluginURL: o.fw.getPluginURL()
                        }), this.self.importScripts(we), o.fw.isParsed() ? ie(null, !0) : this.rtlPluginParsingListeners.push(ie))
                    } catch (we) {
                        ie(we.toString())
                    }
                }

                setDracoUrl($, W) {
                    this.dracoUrl = W
                }

                getAvailableImages($, W) {
                    this.availableImages[$] || (this.availableImages[$] = {});
                    let ie = this.availableImages[$][W];
                    return ie || (ie = []), ie
                }

                getAvailableModels($, W) {
                    this.availableModels[$] || (this.availableModels[$] = {});
                    let ie = this.availableModels[$][W];
                    return ie || (ie = {}), ie
                }

                getLayerIndex($, W) {
                    this.layerIndexes[$] || (this.layerIndexes[$] = {});
                    let ie = this.layerIndexes[$][W];
                    return ie || (ie = this.layerIndexes[$][W] = new oe, ie.scope = W), ie
                }

                getWorkerSource($, W, ie, we) {
                    const se = this.workerSources;
                    return se[$] || (se[$] = {}), se[$][we] || (se[$][we] = {}), se[$][we][W] || (se[$][we][W] = {}), this.isSpriteLoaded[$] || (this.isSpriteLoaded[$] = {}), se[$][we][W][ie] || (se[$][we][W][ie] = new this.workerSourceTypes[W]({
                        send: (Ae, Ve, Pe, Ne, ft, Je) => this.actor.send(Ae, Ve, Pe, $, ft, Je),
                        scheduler: this.actor.scheduler
                    }, this.getLayerIndex($, we), this.getAvailableImages($, we), this.getAvailableModels($, we), this.isSpriteLoaded[$][we], void 0, this.brightness, this.worldview)), se[$][we][W][ie]
                }

                rasterizeImagesWorker($, W, ie) {
                    const we = new Map;
                    for (const [se, {image: Ae, imageVariant: Ve}] of W.tasks.entries()) {
                        const Pe = this.imageRasterizer.rasterize(Ve, Ae, W.scope, $);
                        we.set(se, Pe)
                    }
                    ie(void 0, we)
                }

                removeRasterizedImages($, W, ie) {
                    this.imageRasterizer.removeImagesFromCacheByIds(W.imageIds, W.scope, $), ie()
                }

                enforceCacheSizeLimit($, W) {
                    o.fy(W)
                }

                getWorkerPerformanceMetrics($, W, ie) {
                    ie(void 0, void 0)
                }
            }

            return o.fu(self) && (self.worker = new Ai(self)), Ai
        }), A(["./shared"], function (o) {
            var j = "3.14.0";
            const q = {create: "create", load: "load", fullLoad: "fullLoad"}, ee = {
                mark(u) {
                    performance.mark(u)
                }, measure(u, t, s) {
                    performance.measure(u, t, s)
                }
            };

            function oe(u) {
                const t = u.name.split("?")[0];
                return o.a(t) && t.includes("mapbox-gl.js") ? "javascript" : o.a(t) && t.includes("mapbox-gl.css") ? "css" : o.b(t) ? "fontRange" : o.c(t) ? "sprite" : o.i(t) ? "style" : o.d(t) ? "tilejson" : "other"
            }

            var de, ae = {}, Re = function () {
                if (de) return ae;

                function u(h) {
                    return !t(h)
                }

                function t(h) {
                    return typeof window > "u" || typeof document > "u" ? "not a browser" : function () {
                        if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1;
                        var g, v, b = new Blob([""], {type: "text/javascript"}), S = URL.createObjectURL(b);
                        try {
                            v = new Worker(S), g = !0
                        } catch {
                            g = !1
                        }
                        return v && v.terminate(), URL.revokeObjectURL(S), g
                    }() ? function () {
                        var g = document.createElement("canvas");
                        g.width = g.height = 1;
                        var v = g.getContext("2d");
                        if (!v) return !1;
                        var b = v.getImageData(0, 0, 1, 1);
                        return b && b.width === g.width
                    }() ? (s[m = h && h.failIfMajorPerformanceCaveat] === void 0 && (s[m] = function (g) {
                        var v, b = function (S) {
                            var P = document.createElement("canvas"), M = Object.create(u.webGLContextAttributes);
                            return M.failIfMajorPerformanceCaveat = S, P.getContext("webgl2", M)
                        }(g);
                        if (!b) return !1;
                        try {
                            v = b.createShader(b.VERTEX_SHADER)
                        } catch {
                            return !1
                        }
                        return !(!v || b.isContextLost()) && (b.shaderSource(v, "void main() {}"), b.compileShader(v), b.getShaderParameter(v, b.COMPILE_STATUS) === !0)
                    }(m)), s[m] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL2 support") : "insufficient Canvas/getImageData support" : "insufficient worker support";
                    var m
                }

                de = 1, ae.supported = u, ae.notSupportedReason = t;
                var s = {};
                return u.webGLContextAttributes = {antialias: !1, alpha: !0, stencil: !0, depth: !0}, ae
            }();

            function fe(u, t, s) {
                const h = document.createElement(u);
                return t != null && (h.className = t), s && s.appendChild(h), h
            }

            function Me(u, t, s) {
                const h = document.createElementNS("http://www.w3.org/2000/svg", u);
                for (const m of Object.keys(t)) h.setAttributeNS(null, m, String(t[m]));
                return s && s.appendChild(h), h
            }

            const pe = typeof document < "u" ? document.documentElement && document.documentElement.style : null,
                le = pe && pe.userSelect !== void 0 ? "userSelect" : "WebkitUserSelect";
            let be;

            function Ue() {
                pe && le && (be = pe[le], pe[le] = "none")
            }

            function et() {
                pe && le && (pe[le] = be)
            }

            function _t(u) {
                u.preventDefault(), u.stopPropagation(), window.removeEventListener("click", _t, !0)
            }

            function xt() {
                window.addEventListener("click", _t, !0), window.setTimeout(() => {
                    window.removeEventListener("click", _t, !0)
                }, 0)
            }

            function Mt(u, t) {
                const s = u.getBoundingClientRect();
                return Ht(u, s, t)
            }

            function Xt(u, t) {
                const s = u.getBoundingClientRect(), h = [];
                for (let m = 0; m < t.length; m++) h.push(Ht(u, s, t[m]));
                return h
            }

            function Zt(u) {
                return /firefox/i.test(navigator.userAgent) && /macintosh/i.test(navigator.userAgent) && u.button === 2 && u.ctrlKey ? 0 : u.button
            }

            function Ht(u, t, s) {
                const h = u.offsetWidth === t.width ? 1 : u.offsetWidth / t.width;
                return new o.P((s.clientX - t.left) * h, (s.clientY - t.top) * h)
            }

            const hi = "01", Mi = "NO_ACCESS_TOKEN";

            class $t {
                constructor(t, s, h) {
                    this._transformRequestFn = t, this._customAccessToken = s, this._silenceAuthErrors = !!h, this._createSkuToken()
                }

                _createSkuToken() {
                    const t = function () {
                        let s = "";
                        for (let h = 0; h < 10; h++) s += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
                        return {token: ["1", hi, s].join(""), tokenExpiresAt: Date.now() + 432e5}
                    }();
                    this._skuToken = t.token, this._skuTokenExpiresAt = t.tokenExpiresAt
                }

                _isSkuTokenExpired() {
                    return Date.now() > this._skuTokenExpiresAt
                }

                transformRequest(t, s) {
                    return this._transformRequestFn && this._transformRequestFn(t, s) || {url: t}
                }

                normalizeStyleURL(t, s) {
                    if (!o.j(t)) return t;
                    const h = si(t);
                    return h.params.push(`sdk=js-${j}`), h.path = `/styles/v1${h.path}`, this._makeAPIURL(h, this._customAccessToken || s)
                }

                normalizeGlyphsURL(t, s) {
                    if (!o.j(t)) return t;
                    const h = si(t);
                    return h.path = `/fonts/v1${h.path}`, this._makeAPIURL(h, this._customAccessToken || s)
                }

                normalizeModelURL(t, s) {
                    if (!o.j(t)) return t;
                    const h = si(t);
                    return h.path = `/models/v1${h.path}`, this._makeAPIURL(h, this._customAccessToken || s)
                }

                normalizeSourceURL(t, s, h, m) {
                    if (!o.j(t)) return t;
                    const g = si(t);
                    return g.path = `/v4/${g.authority}.json`, g.params.push("secure"), h && g.params.push(`language=${h}`), m && g.params.push(`worldview=${m}`), this._makeAPIURL(g, this._customAccessToken || s)
                }

                normalizeIconsetURL(t, s) {
                    const h = si(t);
                    return o.j(t) ? (h.path = `/styles/v1${h.path}/iconset.pbf`, this._makeAPIURL(h, this._customAccessToken || s)) : Ri(h)
                }

                normalizeSpriteURL(t, s, h, m) {
                    const g = si(t);
                    return o.j(t) ? (g.path = `/styles/v1${g.path}/sprite${s}${h}`, this._makeAPIURL(g, this._customAccessToken || m)) : (g.path += `${s}${h}`, Ri(g))
                }

                normalizeTileURL(t, s, h) {
                    if (this._isSkuTokenExpired() && this._createSkuToken(), t && !o.j(t)) return t;
                    const m = si(t);
                    m.path = m.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${s || h && m.authority !== "raster" && h === 512 ? "@2x" : ""}${o.l.supported ? ".webp" : "$1"}`), m.authority === "raster" ? m.path = `/${o.e.RASTER_URL_PREFIX}${m.path}` : m.authority === "rasterarrays" ? m.path = `/${o.e.RASTERARRAYS_URL_PREFIX}${m.path}` : m.authority === "3dtiles" ? m.path = `/${o.e.TILES3D_URL_PREFIX}${m.path}` : (m.path = m.path.replace(/^.+\/v4\//, "/"), m.path = `/${o.e.TILE_URL_VERSION}${m.path}`);
                    const g = this._customAccessToken || function (v) {
                        for (const b of v) {
                            const S = b.match(/^access_token=(.*)$/);
                            if (S) return S[1]
                        }
                        return null
                    }(m.params) || o.e.ACCESS_TOKEN;
                    return o.e.REQUIRE_ACCESS_TOKEN && g && this._skuToken && m.params.push(`sku=${this._skuToken}`), this._makeAPIURL(m, g)
                }

                canonicalizeTileURL(t, s) {
                    const h = si(t);
                    if (!h.path.match(/^(\/v4\/|\/(raster|rasterarrays)\/v1\/)/) || !h.path.match(/\.[\w]+$/)) return t;
                    let m = "mapbox://";
                    h.path.match(/^\/raster\/v1\//) ? m += `raster/${h.path.replace(`/${o.e.RASTER_URL_PREFIX}/`, "")}` : h.path.match(/^\/rasterarrays\/v1\//) ? m += `rasterarrays/${h.path.replace(`/${o.e.RASTERARRAYS_URL_PREFIX}/`, "")}` : m += `tiles/${h.path.replace(`/${o.e.TILE_URL_VERSION}/`, "")}`;
                    let g = h.params;
                    return s && (g = g.filter(v => !v.match(/^access_token=/))), g.length && (m += `?${g.join("&")}`), m
                }

                canonicalizeTileset(t, s) {
                    const h = !!s && o.j(s), m = [];
                    for (const g of t.tiles || []) o.k(g) ? m.push(this.canonicalizeTileURL(g, h)) : m.push(g);
                    return m
                }

                _makeAPIURL(t, s) {
                    const h = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes",
                        m = si(o.e.API_URL);
                    if (t.protocol = m.protocol, t.authority = m.authority, t.protocol === "http") {
                        const g = t.params.indexOf("secure");
                        g >= 0 && t.params.splice(g, 1)
                    }
                    if (m.path !== "/" && (t.path = `${m.path}${t.path}`), !o.e.REQUIRE_ACCESS_TOKEN) return Ri(t);
                    if (s = s || o.e.ACCESS_TOKEN, !this._silenceAuthErrors) {
                        if (!s) throw new Error(`An API access token is required to use Mapbox GL. ${h}`);
                        if (s[0] === "s") throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${h}`)
                    }
                    return t.params = t.params.filter(g => g.indexOf("access_token") === -1), t.params.push(`access_token=${s || ""}`), Ri(t)
                }
            }

            const _i = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;

            function si(u) {
                const t = u.match(_i);
                if (!t) throw new Error("Unable to parse URL object");
                return {protocol: t[1], authority: t[2], path: t[3] || "/", params: t[4] ? t[4].split("&") : []}
            }

            function Ri(u) {
                const t = u.params.length ? `?${u.params.join("&")}` : "";
                return `${u.protocol}://${u.authority}${u.path}${t}`
            }

            const Ct = "mapbox.eventData";

            function Rt(u) {
                if (!u) return null;
                const t = u.split(".");
                if (!t || t.length !== 3) return null;
                try {
                    return JSON.parse(o.m(t[1]))
                } catch {
                    return null
                }
            }

            class ni {
                constructor(t) {
                    this.type = t, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null
                }

                getStorageKey(t) {
                    const s = Rt(o.e.ACCESS_TOKEN);
                    let h = "";
                    return h = s && s.u ? o.f(s.u) : o.e.ACCESS_TOKEN || "", t ? `${Ct}.${t}:${h}` : `${Ct}:${h}`
                }

                fetchEventData() {
                    const t = o.s("localStorage"), s = this.getStorageKey(), h = this.getStorageKey("uuid");
                    if (t) try {
                        const m = localStorage.getItem(s);
                        m && (this.eventData = JSON.parse(m));
                        const g = localStorage.getItem(h);
                        g && (this.anonId = g)
                    } catch {
                        o.w("Unable to read from LocalStorage")
                    }
                }

                saveEventData() {
                    const t = o.s("localStorage"), s = this.getStorageKey(), h = this.getStorageKey("uuid"),
                        m = this.anonId;
                    if (t && m) try {
                        localStorage.setItem(h, m), Object.keys(this.eventData).length >= 1 && localStorage.setItem(s, JSON.stringify(this.eventData))
                    } catch {
                        o.w("Unable to write to LocalStorage")
                    }
                }

                processRequests(t) {
                }

                postEvent(t, s, h, m) {
                    if (!o.e.EVENTS_URL) return;
                    const g = si(o.e.EVENTS_URL);
                    g.params.push(`access_token=${m || o.e.ACCESS_TOKEN || ""}`);
                    const v = {event: this.type, created: new Date(t).toISOString()}, b = s ? o.h(v, s) : v,
                        S = {url: Ri(g), headers: {"Content-Type": "text/plain"}, body: JSON.stringify([b])};
                    this.pendingRequest = o.p(S, P => {
                        this.pendingRequest = null, h(P), this.saveEventData(), this.processRequests(m)
                    })
                }

                queueRequest(t, s) {
                    this.queue.push(t), this.processRequests(s)
                }
            }

            const ai = new class extends ni {
                constructor(u) {
                    super("appUserTurnstile"), this._customAccessToken = u
                }

                postTurnstileEvent(u, t) {
                    o.e.EVENTS_URL && o.e.ACCESS_TOKEN && Array.isArray(u) && u.some(s => o.j(s) || o.k(s)) && this.queueRequest(Date.now(), t)
                }

                processRequests(u) {
                    if (this.pendingRequest || this.queue.length === 0) return;
                    this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
                    const t = Rt(o.e.ACCESS_TOKEN), s = t ? t.u : o.e.ACCESS_TOKEN;
                    let h = s !== this.eventData.tokenU;
                    o.v(this.anonId) || (this.anonId = o.u(), h = !0);
                    const m = this.queue.shift();
                    if (this.eventData.lastSuccess) {
                        const g = new Date(this.eventData.lastSuccess), v = new Date(m),
                            b = (m - this.eventData.lastSuccess) / 864e5;
                        h = h || b >= 1 || b < -1 || g.getDate() !== v.getDate()
                    } else h = !0;
                    h ? this.postEvent(m, {
                        sdkIdentifier: "mapbox-gl-js",
                        sdkVersion: j,
                        skuId: hi,
                        "enabled.telemetry": !1,
                        userId: this.anonId
                    }, g => {
                        g || (this.eventData.lastSuccess = m, this.eventData.tokenU = s)
                    }, u) : this.processRequests()
                }
            }, fi = ai.postTurnstileEvent.bind(ai), nn = new class extends ni {
                constructor() {
                    super("map.load"), this.success = {}, this.skuToken = ""
                }

                postMapLoadEvent(u, t, s, h) {
                    this.skuToken = t, this.errorCb = h, o.e.EVENTS_URL && (s || o.e.ACCESS_TOKEN ? this.queueRequest({
                        id: u,
                        timestamp: Date.now()
                    }, s) : this.errorCb(new Error(Mi)))
                }

                processRequests(u) {
                    if (this.pendingRequest || this.queue.length === 0) return;
                    const {id: t, timestamp: s} = this.queue.shift();
                    t && this.success[t] || (this.anonId || this.fetchEventData(), o.v(this.anonId) || (this.anonId = o.u()), this.postEvent(s, {
                        sdkIdentifier: "mapbox-gl-js",
                        sdkVersion: j,
                        skuId: hi,
                        skuToken: this.skuToken,
                        userId: this.anonId
                    }, h => {
                        h ? this.errorCb(h) : t && (this.success[t] = !0)
                    }, u))
                }

                remove() {
                    this.errorCb = null
                }
            }, cn = nn.postMapLoadEvent.bind(nn), Zn = new class extends ni {
                constructor() {
                    super("style.load"), this.eventIdPerMapInstanceMap = new Map, this.mapInstanceIdMap = new WeakMap
                }

                getMapInstanceId(u) {
                    let t = this.mapInstanceIdMap.get(u);
                    return t || (t = o.u(), this.mapInstanceIdMap.set(u, t)), t
                }

                getEventId(u) {
                    const t = this.eventIdPerMapInstanceMap.get(u) || 0;
                    return this.eventIdPerMapInstanceMap.set(u, t + 1), t
                }

                postStyleLoadEvent(u, t) {
                    const {map: s, style: h, importedStyles: m} = t;
                    if (!o.e.EVENTS_URL || !u && !o.e.ACCESS_TOKEN) return;
                    const g = this.getMapInstanceId(s), v = {mapInstanceId: g, eventId: this.getEventId(g), style: h};
                    m.length && (v.importedStyles = m), this.queueRequest({timestamp: Date.now(), payload: v}, u)
                }

                processRequests(u) {
                    if (this.pendingRequest || this.queue.length === 0) return;
                    const {timestamp: t, payload: s} = this.queue.shift();
                    this.postEvent(t, s, () => {
                    }, u)
                }
            }, Bi = Zn.postStyleLoadEvent.bind(Zn), Ii = new class extends ni {
                constructor() {
                    super("gljs.performance")
                }

                postPerformanceEvent(u, t) {
                    o.e.EVENTS_URL && (u || o.e.ACCESS_TOKEN) && this.queueRequest({
                        timestamp: Date.now(),
                        performanceData: t
                    }, u)
                }

                processRequests(u) {
                    if (this.pendingRequest || this.queue.length === 0) return;
                    const {timestamp: t, performanceData: s} = this.queue.shift(), h = function (m) {
                        const g = performance.getEntriesByType("resource"), v = performance.getEntriesByType("mark"),
                            b = function (O) {
                                const V = {};
                                if (O) {
                                    for (const B in O) if (B !== "other") for (const G of O[B]) {
                                        const U = `${B}ResolveRangeMin`, Z = `${B}ResolveRangeMax`,
                                            Q = `${B}RequestCount`, te = `${B}RequestCachedCount`;
                                        V[U] = Math.min(V[U] || 1 / 0, G.startTime), V[Z] = Math.max(V[Z] || -1 / 0, G.responseEnd);
                                        const ce = _e => {
                                            V[_e] === void 0 && (V[_e] = 0), ++V[_e]
                                        };
                                        G.transferSize !== void 0 && G.transferSize === 0 && ce(te), ce(Q)
                                    }
                                }
                                return V
                            }(function (O, V) {
                                const B = {};
                                if (O) for (const G of O) {
                                    const U = V(G);
                                    B[U] === void 0 && (B[U] = []), B[U].push(G)
                                }
                                return B
                            }(g, oe)), S = window.devicePixelRatio,
                            P = navigator.connection || navigator.mozConnection || navigator.webkitConnection,
                            M = P ? P.effectiveType : void 0, k = {counters: [], metadata: [], attributes: []},
                            R = (O, V, B) => {
                                B != null && O.push({name: V, value: B.toString()})
                            };
                        for (const O in b) R(k.counters, O, b[O]);
                        if (m.interactionRange[0] !== 1 / 0 && m.interactionRange[1] !== -1 / 0 && (R(k.counters, "interactionRangeMin", m.interactionRange[0]), R(k.counters, "interactionRangeMax", m.interactionRange[1])), v) for (const O of Object.keys(q)) {
                            const V = q[O], B = v.find(G => G.name === V);
                            B && R(k.counters, V, B.startTime)
                        }
                        return R(k.counters, "visibilityHidden", m.visibilityHidden), R(k.attributes, "style", function (O) {
                            if (O) for (const V of O) {
                                const B = V.name.split("?")[0];
                                if (o.i(B)) {
                                    const G = B.split("/").slice(-2);
                                    if (G.length === 2) return `mapbox://styles/${G[0]}/${G[1]}`
                                }
                            }
                        }(g)), R(k.attributes, "terrainEnabled", m.terrainEnabled ? "true" : "false"), R(k.attributes, "fogEnabled", m.fogEnabled ? "true" : "false"), R(k.attributes, "projection", m.projection), R(k.attributes, "zoom", m.zoom), R(k.metadata, "devicePixelRatio", S), R(k.metadata, "connectionEffectiveType", M), R(k.metadata, "navigatorUserAgent", navigator.userAgent), R(k.metadata, "screenWidth", window.screen.width), R(k.metadata, "screenHeight", window.screen.height), R(k.metadata, "windowWidth", window.innerWidth), R(k.metadata, "windowHeight", window.innerHeight), R(k.metadata, "mapWidth", m.width / S), R(k.metadata, "mapHeight", m.height / S), R(k.metadata, "webglRenderer", m.renderer), R(k.metadata, "webglVendor", m.vendor), R(k.metadata, "sdkVersion", j), R(k.metadata, "sdkIdentifier", "mapbox-gl-js"), k
                    }(s);
                    for (const m of h.metadata) ;
                    for (const m of h.counters) ;
                    for (const m of h.attributes) ;
                    this.postEvent(t, h, () => {
                    }, u)
                }
            }, Bn = Ii.postPerformanceEvent.bind(Ii), ar = new class extends ni {
                constructor() {
                    super("map.auth"), this.success = {}, this.skuToken = ""
                }

                getSession(u, t, s, h) {
                    if (!o.e.API_URL || !o.e.SESSION_PATH) return;
                    const m = si(o.e.API_URL + o.e.SESSION_PATH);
                    m.params.push(`sku=${t || ""}`), m.params.push(`access_token=${h || o.e.ACCESS_TOKEN || ""}`);
                    const g = {url: Ri(m), headers: {"Content-Type": "text/plain"}};
                    this.pendingRequest = o.g(g, v => {
                        this.pendingRequest = null, s(v), this.saveEventData(), this.processRequests(h)
                    })
                }

                getSessionAPI(u, t, s, h) {
                    this.skuToken = t, this.errorCb = h, o.e.SESSION_PATH && o.e.API_URL && (s || o.e.ACCESS_TOKEN ? this.queueRequest({
                        id: u,
                        timestamp: Date.now()
                    }, s) : this.errorCb(new Error(Mi)))
                }

                processRequests(u) {
                    if (this.pendingRequest || this.queue.length === 0) return;
                    const {id: t, timestamp: s} = this.queue.shift();
                    t && this.success[t] || this.getSession(s, this.skuToken, h => {
                        h ? this.errorCb(h) : t && (this.success[t] = !0)
                    }, u)
                }

                remove() {
                    this.errorCb = null
                }
            }, An = ar.getSessionAPI.bind(ar), Zr = new Set;

            function wo(u, t) {
                t ? Zr.add(u) : Zr.delete(u)
            }

            class Do {
                constructor() {
                    this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = new Set, this._updatedImages = {}
                }

                isDirty() {
                    return this._changed
                }

                setDirty() {
                    this._changed = !0
                }

                getUpdatedSourceCaches() {
                    return this._updatedSourceCaches
                }

                updateSourceCache(t, s) {
                    this._updatedSourceCaches[t] = s, this.setDirty()
                }

                discardSourceCacheUpdate(t) {
                    delete this._updatedSourceCaches[t]
                }

                updateLayer(t) {
                    const s = t.scope;
                    this._updatedLayers[s] = this._updatedLayers[s] || new Set, this._updatedLayers[s].add(t.id), this.setDirty()
                }

                removeLayer(t) {
                    const s = t.scope;
                    this._removedLayers[s] = this._removedLayers[s] || {}, this._updatedLayers[s] = this._updatedLayers[s] || new Set, this._removedLayers[s][t.id] = t, this._updatedLayers[s].delete(t.id), this._updatedPaintProps.delete(t.fqid), this.setDirty()
                }

                getRemovedLayer(t) {
                    return this._removedLayers[t.scope] ? this._removedLayers[t.scope][t.id] : null
                }

                discardLayerRemoval(t) {
                    this._removedLayers[t.scope] && delete this._removedLayers[t.scope][t.id]
                }

                getLayerUpdatesByScope() {
                    const t = {};
                    for (const s in this._updatedLayers) t[s] = t[s] || {}, t[s].updatedIds = Array.from(this._updatedLayers[s].values());
                    for (const s in this._removedLayers) t[s] = t[s] || {}, t[s].removedIds = Object.keys(this._removedLayers[s]);
                    return t
                }

                getUpdatedPaintProperties() {
                    return this._updatedPaintProps
                }

                updatePaintProperties(t) {
                    this._updatedPaintProps.add(t.fqid), this.setDirty()
                }

                getUpdatedImages(t) {
                    return this._updatedImages[t] ? Array.from(this._updatedImages[t].values()) : []
                }

                updateImage(t, s) {
                    this._updatedImages[s] = this._updatedImages[s] || new Set, this._updatedImages[s].add(o.I.toString(t)), this.setDirty()
                }

                resetUpdatedImages(t) {
                    this._updatedImages[t] && this._updatedImages[t].clear()
                }

                reset() {
                    this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages = {}
                }
            }

            function Xr(u) {
                const {userImage: t} = u;
                return !!(t && t.render && t.render()) && (u.data.replace(new Uint8Array(t.data.buffer)), !0)
            }

            class Nn extends o.E {
                constructor(t) {
                    super(), this.imageProviders = new Map, this.images = new Map, this.updatedImages = new Map, this.callbackDispatchedThisFrame = new Map, this.loaded = new Map, this.requestors = [], this.patterns = new Map, this.patternsInFlight = new Set, this.atlasImage = new Map, this.atlasTexture = new Map, this.dirty = !0, this.spriteFormat = t, t !== "raster" && o.t() && (this.imageRasterizerDispatcher = new o.D(o.x(), this, "Image Rasterizer Worker", 1))
                }

                addScope(t) {
                    this.loaded.set(t, !1), this.imageProviders.set(t, new Map), this.images.set(t, new Map), this.updatedImages.set(t, new Set), this.callbackDispatchedThisFrame.set(t, new Set), this.patterns.set(t, new Map), this.atlasImage.set(t, new o.r({
                        width: 1,
                        height: 1
                    }))
                }

                removeScope(t) {
                    this.loaded.delete(t), this.imageProviders.delete(t), this.images.delete(t), this.updatedImages.delete(t), this.callbackDispatchedThisFrame.delete(t), this.patterns.delete(t), this.atlasImage.delete(t);
                    const s = this.atlasTexture.get(t);
                    s && (s.destroy(), this.atlasTexture.delete(t))
                }

                addImageProvider(t, s) {
                    this.imageProviders.has(s) || this.imageProviders.set(s, new Map), this.imageProviders.get(s).set(t.id, t)
                }

                removeImageProvider(t, s) {
                    this.imageProviders.has(s) && this.imageProviders.get(s).delete(t)
                }

                getPendingImageProviders() {
                    const t = [];
                    for (const s of this.imageProviders.values()) for (const h of s.values()) h.hasPendingRequests() && t.push(h);
                    return t
                }

                get imageRasterizer() {
                    return this._imageRasterizer || (this._imageRasterizer = new o.y), this._imageRasterizer
                }

                isLoaded() {
                    for (const t of this.loaded.keys()) if (!this.loaded.get(t)) return !1;
                    return !0
                }

                setLoaded(t, s) {
                    if (this.loaded.get(s) !== t && (this.loaded.set(s, t), t)) {
                        for (const {ids: h, callback: m} of this.requestors) this._notify(h, s, m);
                        this.requestors = []
                    }
                }

                hasImage(t, s) {
                    return !!this.getImage(t, s)
                }

                getImage(t, s) {
                    return this.images.get(s).get(t.toString())
                }

                addImage(t, s, h) {
                    this._validate(t, h) && this.images.get(s).set(t.toString(), h)
                }

                _validate(t, s) {
                    let h = !0;
                    return this._validateStretch(s.stretchX, s.data && s.data.width) || (this.fire(new o.z(new Error(`Image "${t.name}" has invalid "stretchX" value`))), h = !1), this._validateStretch(s.stretchY, s.data && s.data.height) || (this.fire(new o.z(new Error(`Image "${t.name}" has invalid "stretchY" value`))), h = !1), this._validateContent(s.content, s) || (this.fire(new o.z(new Error(`Image "${t.name}" has invalid "content" value`))), h = !1), h
                }

                _validateStretch(t, s) {
                    if (!t) return !0;
                    let h = 0;
                    for (const m of t) {
                        if (m[0] < h || m[1] < m[0] || s < m[1]) return !1;
                        h = m[1]
                    }
                    return !0
                }

                _validateContent(t, s) {
                    return t ? t.length !== 4 || !s.usvg && (t[0] < 0 || s.data.width < t[0] || t[1] < 0 || s.data.height < t[1] || t[2] < 0 || s.data.width < t[2] || t[3] < 0 || s.data.height < t[3]) ? !1 : !(t[2] < t[0] || t[3] < t[1]) : !0
                }

                updateImage(t, s, h) {
                    const m = this.images.get(s).get(t.toString());
                    h.version = m.version + 1, this.images.get(s).set(t.toString(), h), this.updatedImages.get(s).add(t), this.removeFromImageRasterizerCache(t, s)
                }

                clearUpdatedImages(t) {
                    this.updatedImages.get(t).clear()
                }

                removeFromImageRasterizerCache(t, s) {
                    this.spriteFormat !== "raster" && (o.t() ? this.imageRasterizerDispatcher.getActor().send("removeRasterizedImages", {
                        imageIds: [t],
                        scope: s
                    }) : this.imageRasterizer.removeImagesFromCacheByIds([t], s))
                }

                removeImage(t, s) {
                    const h = this.images.get(s), m = h.get(t.toString());
                    h.delete(t.toString()), this.patterns.get(s).delete(t.toString()), this.removeFromImageRasterizerCache(t, s), m.userImage && m.userImage.onRemove && m.userImage.onRemove()
                }

                listImages(t) {
                    return Array.from(this.images.get(t).keys()).map(s => o.I.from(s))
                }

                getImages(t, s, h) {
                    const m = [], g = [], v = this.imageProviders.get(s);
                    for (const M of t) {
                        if (!M.iconsetId) {
                            m.push(M);
                            continue
                        }
                        const k = v.get(M.iconsetId);
                        k && (this.getImage(M, s) ? g.push(M) : k.addPendingRequest(M))
                    }
                    if (m.length === 0) return void this._notify(g, s, h);
                    let b = !0;
                    const S = !!this.loaded.get(s), P = this.images.get(s);
                    if (!S) for (const M of m) P.has(M.toString()) || (b = !1);
                    S || b ? this._notify(m, s, h) : this.requestors.push({ids: m, scope: s, callback: h})
                }

                rasterizeImages(t, s) {
                    const h = new Map, {tasks: m, scope: g} = t;
                    for (const [v, b] of m.entries()) {
                        const S = this.getImage(b.id, g);
                        S && h.set(v, {image: S, imageVariant: b})
                    }
                    this._rasterizeImages(g, h, s)
                }

                _rasterizeImages(t, s, h) {
                    if (o.t()) this.imageRasterizerDispatcher.getActor().send("rasterizeImagesWorker", {
                        tasks: s,
                        scope: t
                    }, h); else {
                        const m = new Map;
                        for (const [g, {
                            image: v,
                            imageVariant: b
                        }] of s.entries()) m.set(g, this.imageRasterizer.rasterize(b, v, t, 0));
                        h(void 0, m)
                    }
                }

                getUpdatedImages(t) {
                    return this.updatedImages.get(t) || new Set
                }

                _notify(t, s, h) {
                    const m = this.images.get(s), g = new Map;
                    for (const v of t) {
                        if (!m.get(v.toString())) {
                            if (v.iconsetId) continue;
                            this.fire(new o.A("styleimagemissing", {id: v.name}))
                        }
                        const b = m.get(v.toString());
                        if (!b) {
                            o.w(`Image "${v.name}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
                            continue
                        }
                        const S = {
                            data: b.usvg ? null : b.data.clone(),
                            pixelRatio: b.pixelRatio,
                            sdf: b.sdf,
                            usvg: b.usvg,
                            version: b.version,
                            stretchX: b.stretchX,
                            stretchY: b.stretchY,
                            content: b.content,
                            hasRenderCallback: !!(b.userImage && b.userImage.render)
                        };
                        b.usvg && Object.assign(S, {
                            width: b.icon.usvg_tree.width,
                            height: b.icon.usvg_tree.height
                        }), g.set(o.I.toString(v), S)
                    }
                    h(null, g)
                }

                getPixelSize(t) {
                    const {width: s, height: h} = this.atlasImage.get(t);
                    return {width: s, height: h}
                }

                getPattern(t, s, h) {
                    const m = t.toString(), g = this.patterns.get(s), v = g.get(m), b = this.getImage(t, s);
                    if (!b) return null;
                    if (v) {
                        if (v.position.version === b.version) return v.position;
                        v.position.version = b.version
                    } else {
                        if (b.usvg && !b.data) {
                            const S = this.getPatternInFlightId(m, s);
                            if (this.patternsInFlight.has(S)) return null;
                            this.patternsInFlight.add(S);
                            const P = new o.B(t).scaleSelf(o.q.devicePixelRatio),
                                M = new Map([[P.toString(), {image: b, imageVariant: P}]]);
                            return this._rasterizeImages(s, M, (k, R) => this.storePatternImage(P, s, b, h, R)), null
                        }
                        this.storePattern(t, s, b)
                    }
                    return this._updatePatternAtlas(s, h), g.get(m).position
                }

                getPatternInFlightId(t, s) {
                    return o.C(t, s)
                }

                hasPatternsInFlight() {
                    return this.patternsInFlight.size !== 0
                }

                storePatternImage(t, s, h, m, g) {
                    const v = t.toString(), b = g ? g.get(v) : void 0;
                    b && (h.data = b, this.storePattern(t.id, s, h), this._updatePatternAtlas(s, m), this.patternsInFlight.delete(this.getPatternInFlightId(t.id.toString(), s)))
                }

                storePattern(t, s, h) {
                    const m = {w: h.data.width + 2 * o.F, h: h.data.height + 2 * o.F, x: 0, y: 0},
                        g = new o.G(m, h, o.F);
                    this.patterns.get(s).set(t.toString(), {bin: m, position: g})
                }

                destroyAtlasTextures() {
                    for (const t of this.atlasTexture.values()) t && t.destroy();
                    this.atlasTexture.clear()
                }

                bind(t, s) {
                    const h = t.gl;
                    let m = this.atlasTexture.get(s);
                    m ? this.dirty && (m.update(this.atlasImage.get(s)), this.dirty = !1) : (m = new o.T(t, this.atlasImage.get(s), h.RGBA8), this.atlasTexture.set(s, m)), m.bind(h.LINEAR, h.CLAMP_TO_EDGE)
                }

                _updatePatternAtlas(t, s) {
                    const h = this.patterns.get(t), m = Array.from(h.values()).map(({bin: P}) => P), {
                        w: g,
                        h: v
                    } = o.H(m), b = this.atlasImage.get(t);
                    b.resize({width: g || 1, height: v || 1});
                    const S = this.images.get(t);
                    for (const [P, {bin: M, position: k}] of h.entries()) {
                        let R = k.padding;
                        const O = M.x + R, V = M.y + R, B = S.get(P).data, G = B.width, U = B.height;
                        R = R > 1 ? R - 1 : R, o.r.copy(B, b, {x: 0, y: 0}, {x: O, y: V}, {
                            width: G,
                            height: U
                        }, s), o.r.copy(B, b, {x: 0, y: U - R}, {x: O, y: V - R}, {
                            width: G,
                            height: R
                        }, s), o.r.copy(B, b, {x: 0, y: 0}, {x: O, y: V + U}, {
                            width: G,
                            height: R
                        }, s), o.r.copy(B, b, {x: G - R, y: 0}, {x: O - R, y: V}, {
                            width: R,
                            height: U
                        }, s), o.r.copy(B, b, {x: 0, y: 0}, {x: O + G, y: V}, {
                            width: R,
                            height: U
                        }, s), o.r.copy(B, b, {x: G - R, y: U - R}, {x: O - R, y: V - R}, {
                            width: R,
                            height: R
                        }, s), o.r.copy(B, b, {x: 0, y: U - R}, {x: O + G, y: V - R}, {
                            width: R,
                            height: R
                        }, s), o.r.copy(B, b, {x: 0, y: 0}, {x: O + G, y: V + U}, {
                            width: R,
                            height: R
                        }, s), o.r.copy(B, b, {x: G - R, y: 0}, {x: O - R, y: V + U}, {width: R, height: R}, s)
                    }
                    this.dirty = !0
                }

                beginFrame() {
                    for (const t of this.images.keys()) this.callbackDispatchedThisFrame.set(t, new Set)
                }

                dispatchRenderCallbacks(t, s) {
                    const h = this.images.get(s);
                    for (const m of t) {
                        if (this.callbackDispatchedThisFrame.get(s).has(m.toString())) continue;
                        this.callbackDispatchedThisFrame.get(s).add(m.toString());
                        const g = h.get(m.toString());
                        Xr(g) && this.updateImage(m, s, g)
                    }
                }

                destroy() {
                    this.imageRasterizerDispatcher && this.imageRasterizerDispatcher.remove()
                }
            }

            function Ar(u) {
                const t = u.key, s = u.value, h = u.valueSpec || {}, m = u.objectElementValidators || {}, g = u.style,
                    v = u.styleSpec;
                let b = [];
                const S = o.J(s);
                if (S !== "object") return [new o.V(t, s, `object expected, ${S} found`)];
                for (const P in s) {
                    const M = P.split(".")[0];
                    let k;
                    m[M] ? k = m[M] : h[M] ? k = bn : m["*"] ? k = m["*"] : h["*"] && (k = bn), k ? b = b.concat(k({
                        key: (t && `${t}.`) + P,
                        value: s[P],
                        valueSpec: h[M] || h["*"],
                        style: g,
                        styleSpec: v,
                        object: s,
                        objectKey: P
                    }, s)) : b.push(new o.K(t, s[P], `unknown property "${P}"`))
                }
                for (const P in h) m[P] || h[P].required && h[P].default === void 0 && s[P] === void 0 && b.push(new o.V(t, s, `missing required property "${P}"`));
                return b
            }

            function fs(u) {
                const t = u.value, s = u.valueSpec, h = u.style, m = u.styleSpec, g = u.key,
                    v = u.arrayElementValidator || bn;
                if (o.J(t) !== "array") return [new o.V(g, t, `array expected, ${o.J(t)} found`)];
                if (s.length && t.length !== s.length) return [new o.V(g, t, `array length ${s.length} expected, length ${t.length} found`)];
                if (s["min-length"] && t.length < s["min-length"]) return [new o.V(g, t, `array length at least ${s["min-length"]} expected, length ${t.length} found`)];
                let b = {type: s.value, values: s.values, minimum: s.minimum, maximum: s.maximum, function: void 0};
                m.$version < 7 && (b.function = s.function), o.J(s.value) === "object" && (b = s.value);
                let S = [];
                for (let P = 0; P < t.length; P++) S = S.concat(v({
                    array: t,
                    arrayIndex: P,
                    value: t[P],
                    valueSpec: b,
                    style: h,
                    styleSpec: m,
                    key: `${g}[${P}]`
                }, !0));
                return S
            }

            function Rs(u) {
                const t = u.key, s = u.value, h = u.valueSpec;
                let m = o.J(s);
                if (m === "number" && s != s && (m = "NaN"), m !== "number") return [new o.V(t, s, `number expected, ${m} found`)];
                if ("minimum" in h) {
                    let g = h.minimum;
                    if (o.J(h.minimum) === "array" && (g = h.minimum[u.arrayIndex]), s < g) return [new o.V(t, s, `${s} is less than the minimum value ${g}`)]
                }
                if ("maximum" in h) {
                    let g = h.maximum;
                    if (o.J(h.maximum) === "array" && (g = h.maximum[u.arrayIndex]), s > g) return [new o.V(t, s, `${s} is greater than the maximum value ${g}`)]
                }
                return []
            }

            function lo(u) {
                const t = u.valueSpec, s = o.M(u.value.type);
                let h, m, g, v = {};
                const b = s !== "categorical" && u.value.property === void 0, S = !b,
                    P = o.J(u.value.stops) === "array" && o.J(u.value.stops[0]) === "array" && o.J(u.value.stops[0][0]) === "object",
                    M = Ar({
                        key: u.key,
                        value: u.value,
                        valueSpec: u.styleSpec.function,
                        style: u.style,
                        styleSpec: u.styleSpec,
                        objectElementValidators: {
                            stops: function (O) {
                                if (s === "identity") return [new o.V(O.key, O.value, 'identity function may not have a "stops" property')];
                                let V = [];
                                const B = O.value;
                                return V = V.concat(fs({
                                    key: O.key,
                                    value: B,
                                    valueSpec: O.valueSpec,
                                    style: O.style,
                                    styleSpec: O.styleSpec,
                                    arrayElementValidator: k
                                })), o.J(B) === "array" && B.length === 0 && V.push(new o.V(O.key, B, "array must have at least one stop")), V
                            }, default: function (O) {
                                return bn({
                                    key: O.key,
                                    value: O.value,
                                    valueSpec: t,
                                    style: O.style,
                                    styleSpec: O.styleSpec
                                })
                            }
                        }
                    });
                return s === "identity" && b && M.push(new o.V(u.key, u.value, 'missing required property "property"')), s === "identity" || u.value.stops || M.push(new o.V(u.key, u.value, 'missing required property "stops"')), s === "exponential" && u.valueSpec.expression && !o.N(u.valueSpec) && M.push(new o.V(u.key, u.value, "exponential functions not supported")), u.styleSpec.$version >= 8 && (S && !o.O(u.valueSpec) ? M.push(new o.V(u.key, u.value, "property functions not supported")) : b && !o.Q(u.valueSpec) && M.push(new o.V(u.key, u.value, "zoom functions not supported"))), s !== "categorical" && !P || u.value.property !== void 0 || M.push(new o.V(u.key, u.value, '"property" property is required')), M;

                function k(O) {
                    let V = [];
                    const B = O.value, G = O.key;
                    if (o.J(B) !== "array") return [new o.V(G, B, `array expected, ${o.J(B)} found`)];
                    if (B.length !== 2) return [new o.V(G, B, `array length 2 expected, length ${B.length} found`)];
                    if (P) {
                        if (o.J(B[0]) !== "object") return [new o.V(G, B, `object expected, ${o.J(B[0])} found`)];
                        if (B[0].zoom === void 0) return [new o.V(G, B, "object stop key must have zoom")];
                        if (B[0].value === void 0) return [new o.V(G, B, "object stop key must have value")];
                        const U = o.M(B[0].zoom);
                        if (typeof U != "number") return [new o.V(G, B[0].zoom, "stop zoom values must be numbers")];
                        if (g && g > U) return [new o.V(G, B[0].zoom, "stop zoom values must appear in ascending order")];
                        U !== g && (g = U, m = void 0, v = {}), V = V.concat(Ar({
                            key: `${G}[0]`,
                            value: B[0],
                            valueSpec: {zoom: {}},
                            style: O.style,
                            styleSpec: O.styleSpec,
                            objectElementValidators: {zoom: Rs, value: R}
                        }))
                    } else V = V.concat(R({key: `${G}[0]`, value: B[0], style: O.style, styleSpec: O.styleSpec}, B));
                    return o.S(o.U(B[1])) ? V.concat([new o.V(`${G}[1]`, B[1], "expressions are not allowed in function stops.")]) : V.concat(bn({
                        key: `${G}[1]`,
                        value: B[1],
                        valueSpec: t,
                        style: O.style,
                        styleSpec: O.styleSpec
                    }))
                }

                function R(O, V) {
                    const B = o.J(O.value), G = o.M(O.value), U = O.value !== null ? O.value : V;
                    if (h) {
                        if (B !== h) return [new o.V(O.key, U, `${B} stop domain type must match previous stop domain type ${h}`)]
                    } else h = B;
                    if (B !== "number" && B !== "string" && B !== "boolean" && typeof G != "number" && typeof G != "string" && typeof G != "boolean") return [new o.V(O.key, U, "stop domain value must be a number, string, or boolean")];
                    if (B !== "number" && s !== "categorical") {
                        let Z = `number expected, ${B} found`;
                        return o.O(t) && s === void 0 && (Z += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new o.V(O.key, U, Z)]
                    }
                    return s !== "categorical" || B !== "number" || typeof G == "number" && isFinite(G) && Math.floor(G) === G ? s !== "categorical" && B === "number" && typeof G == "number" && typeof m == "number" && m !== void 0 && G < m ? [new o.V(O.key, U, "stop domain values must appear in ascending order")] : (m = G, s === "categorical" && G in v ? [new o.V(O.key, U, "stop domain values must be unique")] : (v[G] = !0, [])) : [new o.V(O.key, U, `integer expected, found ${String(G)}`)]
                }
            }

            function co(u) {
                const t = (u.expressionContext === "property" ? o.W : o.X)(o.U(u.value), u.valueSpec);
                if (t.result === "error") return t.value.map(h => new o.V(`${u.key}${h.key}`, u.value, h.message));
                const s = t.value.expression || t.value._styleExpression.expression;
                if (u.expressionContext === "property" && u.propertyKey === "text-font" && !s.outputDefined()) return [new o.V(u.key, u.value, `Invalid data expression for "${u.propertyKey}". Output values must be contained as literals within the expression.`)];
                if (u.expressionContext === "property" && u.propertyType === "layout" && !o.Y(s)) return [new o.V(u.key, u.value, '"feature-state" data expressions are not supported with layout properties.')];
                if (u.expressionContext === "filter") return Ir(s, u);
                if (u.expressionContext && u.expressionContext.indexOf("cluster") === 0) {
                    if (!o.Z(s, ["zoom", "feature-state"])) return [new o.V(u.key, u.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
                    if (u.expressionContext === "cluster-initial" && !o._(s)) return [new o.V(u.key, u.value, "Feature data expressions are not supported with initial expression part of cluster properties.")]
                }
                return []
            }

            function Ir(u, t) {
                const s = new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
                if (t.valueSpec && t.valueSpec.expression) for (const m of t.valueSpec.expression.parameters) s.delete(m);
                if (s.size === 0) return [];
                const h = [];
                return u instanceof o.$ && s.has(u.name) ? [new o.V(t.key, t.value, `["${u.name}"] expression is not supported in a filter for a ${t.object.type} layer with id: ${t.object.id}`)] : (u.eachChild(m => {
                    h.push(...Ir(m, t))
                }), h)
            }

            function ps(u) {
                const t = u.key, s = u.value, h = u.valueSpec, m = [];
                return Array.isArray(h.values) ? h.values.indexOf(o.M(s)) === -1 && m.push(new o.V(t, s, `expected one of [${h.values.join(", ")}], ${JSON.stringify(s)} found`)) : Object.keys(h.values).indexOf(o.M(s)) === -1 && m.push(new o.V(t, s, `expected one of [${Object.keys(h.values).join(", ")}], ${JSON.stringify(s)} found`)), m
            }

            function Yr(u) {
                return o.a1(o.U(u.value)) ? co(o.L({}, u, {
                    expressionContext: "filter",
                    valueSpec: u.styleSpec[`filter_${u.layerType || "fill"}`]
                })) : fa(u)
            }

            function fa(u) {
                const t = u.value, s = u.key;
                if (o.J(t) !== "array") return [new o.V(s, t, `array expected, ${o.J(t)} found`)];
                const h = u.styleSpec;
                let m, g = [];
                if (t.length < 1) return [new o.V(s, t, "filter array must have at least 1 element")];
                switch (g = g.concat(ps({
                    key: `${s}[0]`,
                    value: t[0],
                    valueSpec: h.filter_operator,
                    style: u.style,
                    styleSpec: u.styleSpec
                })), o.M(t[0])) {
                    case"<":
                    case"<=":
                    case">":
                    case">=":
                        t.length >= 2 && o.M(t[1]) === "$type" && g.push(new o.V(s, t, `"$type" cannot be use with operator "${t[0]}"`));
                    case"==":
                    case"!=":
                        t.length !== 3 && g.push(new o.V(s, t, `filter array for operator "${t[0]}" must have 3 elements`));
                    case"in":
                    case"!in":
                        t.length >= 2 && (m = o.J(t[1]), m !== "string" && g.push(new o.V(`${s}[1]`, t[1], `string expected, ${m} found`)));
                        for (let v = 2; v < t.length; v++) m = o.J(t[v]), o.M(t[1]) === "$type" ? g = g.concat(ps({
                            key: `${s}[${v}]`,
                            value: t[v],
                            valueSpec: h.geometry_type,
                            style: u.style,
                            styleSpec: u.styleSpec
                        })) : m !== "string" && m !== "number" && m !== "boolean" && g.push(new o.V(`${s}[${v}]`, t[v], `string, number, or boolean expected, ${m} found`));
                        break;
                    case"any":
                    case"all":
                    case"none":
                        for (let v = 1; v < t.length; v++) g = g.concat(fa({
                            key: `${s}[${v}]`,
                            value: t[v],
                            style: u.style,
                            styleSpec: u.styleSpec
                        }));
                        break;
                    case"has":
                    case"!has":
                        m = o.J(t[1]), t.length !== 2 ? g.push(new o.V(s, t, `filter array for "${t[0]}" operator must have 2 elements`)) : m !== "string" && g.push(new o.V(`${s}[1]`, t[1], `string expected, ${m} found`))
                }
                return g
            }

            function Va(u, t) {
                const s = u.key, h = u.style, m = u.layer, g = u.styleSpec, v = u.value, b = u.objectKey,
                    S = g[`${t}_${u.layerType}`];
                if (!S) return [];
                const P = b.match(/^(.*)-use-theme$/);
                if (t === "paint" && P && S[P[1]]) return o.S(v) ? [].concat(bn({
                    key: u.key,
                    value: v,
                    valueSpec: {
                        type: "string",
                        expression: {interpolated: !1, parameters: ["zoom", "feature"]},
                        "property-type": "data-driven"
                    },
                    style: h,
                    styleSpec: g,
                    expressionContext: "property",
                    propertyType: t,
                    propertyKey: b
                })) : bn({key: s, value: v, valueSpec: {type: "string"}, style: h, styleSpec: g});
                const M = b.match(/^(.*)-transition$/);
                if (t === "paint" && M && S[M[1]] && S[M[1]].transition) return bn({
                    key: s,
                    value: v,
                    valueSpec: g.transition,
                    style: h,
                    styleSpec: g
                });
                const k = u.valueSpec || S[b];
                if (!k) return [new o.K(s, v, `unknown property "${b}"`)];
                let R;
                if (o.J(v) === "string" && o.O(k) && !k.tokens && (R = /^{([^}]+)}$/.exec(v))) {
                    const V = `\`{ "type": "identity", "property": ${R ? JSON.stringify(R[1]) : '"_"'} }\``;
                    return [new o.V(s, v, `"${b}" does not support interpolation syntax
Use an identity property function instead: ${V}.`)]
                }
                const O = [];
                if (u.layerType === "symbol") b !== "text-field" || !h || h.glyphs || h.imports || O.push(new o.V(s, v, 'use of "text-field" requires a style "glyphs" property')), b === "text-font" && o.a2(o.U(v)) && o.M(v.type) === "identity" && O.push(new o.V(s, v, '"text-font" does not support identity functions')); else if (u.layerType === "model" && t === "paint" && m && m.layout && m.layout.hasOwnProperty("model-id") && o.O(k) && (o.a3(k) || o.Q(k))) {
                    const V = o.W(o.U(v), k), B = V.value.expression || V.value._styleExpression.expression;
                    B && !o.Z(B, ["measure-light"]) && (b === "model-emissive-strength" && o._(B) && o.Y(B) || O.push(new o.V(s, v, `${b} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)))
                }
                return O.concat(bn({
                    key: u.key,
                    value: v,
                    valueSpec: k,
                    style: h,
                    styleSpec: g,
                    expressionContext: "property",
                    propertyType: t,
                    propertyKey: b
                }))
            }

            function Qn(u) {
                return Va(u, "paint")
            }

            function Cr(u) {
                return Va(u, "layout")
            }

            function Ml(u) {
                let t = [];
                const s = u.value, h = u.key, m = u.style, g = u.styleSpec;
                s.type || s.ref || t.push(new o.V(h, s, 'either "type" or "ref" is required'));
                let v = o.M(s.type);
                const b = o.M(s.ref);
                if (s.id) {
                    const S = o.M(s.id);
                    for (let P = 0; P < u.arrayIndex; P++) {
                        const M = m.layers[P];
                        o.M(M.id) === S && t.push(new o.V(h, s.id, `duplicate layer id "${s.id}", previously used at line ${M.id.__line__}`))
                    }
                }
                if ("ref" in s) {
                    let S;
                    ["type", "source", "source-layer", "filter", "layout"].forEach(P => {
                        P in s && t.push(new o.V(h, s[P], `"${P}" is prohibited for ref layers`))
                    }), m.layers.forEach(P => {
                        o.M(P.id) === b && (S = P)
                    }), S ? S.ref ? t.push(new o.V(h, s.ref, "ref cannot reference another ref layer")) : v = o.M(S.type) : typeof b == "string" && t.push(new o.V(h, s.ref, `ref layer "${b}" not found`))
                } else if (v !== "background" && v !== "sky" && v !== "slot") if (s.source) {
                    const S = m.sources && m.sources[s.source], P = S && o.M(S.type);
                    S ? P === "vector" && v === "raster" ? t.push(new o.V(h, s.source, `layer "${s.id}" requires a raster source`)) : P === "raster" && v !== "raster" ? t.push(new o.V(h, s.source, `layer "${s.id}" requires a vector source`)) : P !== "vector" || s["source-layer"] ? P === "raster-dem" && v !== "hillshade" ? t.push(new o.V(h, s.source, "raster-dem source can only be used with layer type 'hillshade'.")) : P !== "raster-array" || ["raster", "raster-particle"].includes(v) ? v === "line" && s.paint && (s.paint["line-gradient"] || s.paint["line-trim-offset"]) && P === "geojson" && !S.lineMetrics ? t.push(new o.V(h, s, `layer "${s.id}" specifies a line-gradient, which requires the GeoJSON source to have \`lineMetrics\` enabled.`)) : v === "raster-particle" && P !== "raster-array" && t.push(new o.V(h, s.source, `layer "${s.id}" requires a 'raster-array' source.`)) : t.push(new o.V(h, s.source, "raster-array source can only be used with layer type 'raster'.")) : t.push(new o.V(h, s, `layer "${s.id}" must specify a "source-layer"`)) : t.push(new o.V(h, s.source, `source "${s.source}" not found`))
                } else t.push(new o.V(h, s, 'missing required property "source"'));
                return t = t.concat(Ar({
                    key: h,
                    value: s,
                    valueSpec: g.layer,
                    style: u.style,
                    styleSpec: u.styleSpec,
                    objectElementValidators: {
                        "*": () => [],
                        type: () => bn({
                            key: `${h}.type`,
                            value: s.type,
                            valueSpec: g.layer.type,
                            style: u.style,
                            styleSpec: u.styleSpec,
                            object: s,
                            objectKey: "type"
                        }),
                        filter: S => Yr(o.L({layerType: v}, S)),
                        layout: S => Ar({
                            layer: s,
                            key: S.key,
                            value: S.value,
                            valueSpec: {},
                            style: S.style,
                            styleSpec: S.styleSpec,
                            objectElementValidators: {"*": P => Cr(o.L({layerType: v}, P))}
                        }),
                        paint: S => Ar({
                            layer: s,
                            key: S.key,
                            value: S.value,
                            valueSpec: {},
                            style: S.style,
                            styleSpec: S.styleSpec,
                            objectElementValidators: {"*": P => Qn(o.L({layerType: v, layer: s}, P))}
                        })
                    }
                })), t
            }

            function zs(u) {
                const t = u.value, s = u.key, h = o.J(t);
                return h !== "string" ? [new o.V(s, t, `string expected, ${h} found`)] : []
            }

            const Ds = {
                promoteId: function u({key: t, value: s}) {
                    if (o.J(s) === "string") return zs({key: t, value: s});
                    if (Array.isArray(s)) {
                        const h = [], m = o.U(s), g = o.X(m);
                        return g.result === "error" && g.value.forEach(v => {
                            h.push(new o.V(`${t}${v.key}`, null, `${v.message}`))
                        }), o.Z(g.value.expression, ["zoom", "heatmap-density", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light", "raster-particle-speed"]) || h.push(new o.V(`${t}`, null, "promoteId expression should be only feature dependent")), h
                    }
                    {
                        const h = [];
                        for (const m in s) h.push(...u({key: `${t}.${m}`, value: s[m]}));
                        return h
                    }
                }
            };

            function Fr(u) {
                const t = u.value, s = u.key, h = u.styleSpec, m = u.style;
                if (!t.type) return [new o.V(s, t, '"type" is required')];
                const g = o.M(t.type);
                let v = [];
                switch (["vector", "raster", "raster-dem", "raster-array"].includes(g) && (t.url || t.tiles || v.push(new o.K(s, t, 'Either "url" or "tiles" is required.'))), g) {
                    case"vector":
                    case"raster":
                    case"raster-dem":
                    case"raster-array":
                        return v = v.concat(Ar({
                            key: s,
                            value: t,
                            valueSpec: h[`source_${g.replace("-", "_")}`],
                            style: u.style,
                            styleSpec: h,
                            objectElementValidators: Ds
                        })), v;
                    case"geojson":
                        if (v = Ar({
                            key: s,
                            value: t,
                            valueSpec: h.source_geojson,
                            style: m,
                            styleSpec: h,
                            objectElementValidators: Ds
                        }), t.cluster) for (const b in t.clusterProperties) {
                            const [S, P] = t.clusterProperties[b],
                                M = typeof S == "string" ? [S, ["accumulated"], ["get", b]] : S;
                            v.push(...co({
                                key: `${s}.${b}.map`,
                                value: P,
                                expressionContext: "cluster-map"
                            })), v.push(...co({key: `${s}.${b}.reduce`, value: M, expressionContext: "cluster-reduce"}))
                        }
                        return v;
                    case"video":
                        return Ar({key: s, value: t, valueSpec: h.source_video, style: m, styleSpec: h});
                    case"image":
                        return Ar({key: s, value: t, valueSpec: h.source_image, style: m, styleSpec: h});
                    case"canvas":
                        return [new o.V(s, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
                    default:
                        return ps({key: `${s}.type`, value: t.type, valueSpec: {values: uo(h)}})
                }
            }

            function uo(u) {
                return u.source.reduce((t, s) => {
                    const h = u[s];
                    return h.type.type === "enum" && (t = t.concat(Object.keys(h.type.values))), t
                }, [])
            }

            function ms(u) {
                const t = u.value, s = u.styleSpec, h = s.light, m = u.style;
                let g = [];
                const v = o.J(t);
                if (t === void 0) return g;
                if (v !== "object") return g = g.concat([new o.V("light", t, `object expected, ${v} found`)]), g;
                for (const b in t) {
                    const S = b.match(/^(.*)-transition$/), P = b.match(/^(.*)-use-theme$/);
                    g = g.concat(P && h[P[1]] ? bn({
                        key: b,
                        value: t[b],
                        valueSpec: {type: "string"},
                        style: m,
                        styleSpec: s
                    }) : S && h[S[1]] && h[S[1]].transition ? bn({
                        key: b,
                        value: t[b],
                        valueSpec: s.transition,
                        style: m,
                        styleSpec: s
                    }) : h[b] ? bn({
                        key: b,
                        value: t[b],
                        valueSpec: h[b],
                        style: m,
                        styleSpec: s
                    }) : [new o.V(b, t[b], `unknown property "${b}"`)])
                }
                return g
            }

            function ho(u) {
                const t = u.value;
                let s = [];
                if (!t) return s;
                const h = o.J(t);
                if (h !== "object") return s = s.concat([new o.V("light-3d", t, `object expected, ${h} found`)]), s;
                const m = u.styleSpec, g = m["light-3d"], v = u.key, b = u.style, S = u.style.lights;
                for (const k of ["type", "id"]) if (!(k in t)) return s = s.concat([new o.V("light-3d", t, `missing property ${k} on light`)]), s;
                if (t.type && S) for (let k = 0; k < u.arrayIndex; k++) {
                    const R = o.M(t.type), O = S[k];
                    o.M(O.type) === R && s.push(new o.V(v, t.id, `duplicate light type "${t.type}", previously defined at line ${O.id.__line__}`))
                }
                const P = `properties_light_${t.type}`;
                if (!(P in m)) return s = s.concat([new o.V("light-3d", t, `Invalid light type ${t.type}`)]), s;
                const M = m[P];
                for (const k in t) if (k === "properties") {
                    const R = t[k], O = o.J(R);
                    if (O !== "object") return s = s.concat([new o.V("properties", R, `object expected, ${O} found`)]), s;
                    for (const V in R) {
                        const B = V.match(/^(.*)-transition$/), G = V.match(/^(.*)-use-theme$/);
                        s = s.concat(G && M[G[1]] ? bn({
                            key: k,
                            value: R[V],
                            valueSpec: {type: "string"},
                            style: b,
                            styleSpec: m
                        }) : B && M[B[1]] && M[B[1]].transition ? bn({
                            key: k,
                            value: t[k],
                            valueSpec: m.transition,
                            style: b,
                            styleSpec: m
                        }) : M[V] ? bn({
                            key: V,
                            value: R[V],
                            valueSpec: M[V],
                            style: b,
                            styleSpec: m
                        }) : [new o.K(u.key, R[V], `unknown property "${V}"`)])
                    }
                } else s = s.concat(g[k] ? bn({
                    key: k,
                    value: t[k],
                    valueSpec: g[k],
                    style: b,
                    styleSpec: m
                }) : [new o.K(k, t[k], `unknown property "${k}"`)]);
                return s
            }

            function Ls(u) {
                const t = u.value, s = u.key, h = u.style, m = u.styleSpec, g = m.terrain;
                let v = [];
                const b = o.J(t);
                if (t === void 0 || b === "null") return v;
                if (b !== "object") return v = v.concat([new o.V("terrain", t, `object expected, ${b} found`)]), v;
                for (const S in t) {
                    const P = S.match(/^(.*)-transition$/), M = S.match(/^(.*)-use-theme$/);
                    v = v.concat(M && g[M[1]] ? bn({
                        key: S,
                        value: t[S],
                        valueSpec: {type: "string"},
                        style: h,
                        styleSpec: m
                    }) : P && g[P[1]] && g[P[1]].transition ? bn({
                        key: S,
                        value: t[S],
                        valueSpec: m.transition,
                        style: h,
                        styleSpec: m
                    }) : g[S] ? bn({
                        key: S,
                        value: t[S],
                        valueSpec: g[S],
                        style: h,
                        styleSpec: m
                    }) : [new o.K(S, t[S], `unknown property "${S}"`)])
                }
                if (t.source) {
                    const S = h.sources && h.sources[t.source], P = S && o.M(S.type);
                    S ? P !== "raster-dem" && v.push(new o.V(s, t.source, `terrain cannot be used with a source of type ${String(P)}, it only be used with a "raster-dem" source type`)) : v.push(new o.V(s, t.source, `source "${t.source}" not found`))
                } else v.push(new o.V(s, t, 'terrain is missing required property "source"'));
                return v
            }

            function bo(u) {
                const t = u.value, s = u.style, h = u.styleSpec, m = h.fog;
                let g = [];
                const v = o.J(t);
                if (t === void 0) return g;
                if (v !== "object") return g = g.concat([new o.V("fog", t, `object expected, ${v} found`)]), g;
                for (const b in t) {
                    const S = b.match(/^(.*)-transition$/), P = b.match(/^(.*)-use-theme$/);
                    g = g.concat(P && m[P[1]] ? bn({
                        key: b,
                        value: t[b],
                        valueSpec: {type: "string"},
                        style: s,
                        styleSpec: h
                    }) : S && m[S[1]] && m[S[1]].transition ? bn({
                        key: b,
                        value: t[b],
                        valueSpec: h.transition,
                        style: s,
                        styleSpec: h
                    }) : m[b] ? bn({
                        key: b,
                        value: t[b],
                        valueSpec: m[b],
                        style: s,
                        styleSpec: h
                    }) : [new o.K(b, t[b], `unknown property "${b}"`)])
                }
                return g
            }

            const Ua = {
                "*": () => [],
                array: fs,
                boolean: function (u) {
                    const t = u.value, s = u.key, h = o.J(t);
                    return h !== "boolean" ? [new o.V(s, t, `boolean expected, ${h} found`)] : []
                },
                number: Rs,
                color: function (u) {
                    const t = u.key, s = u.value, h = o.J(s);
                    return h !== "string" ? [new o.V(t, s, `color expected, ${h} found`)] : o.a0.parseCSSColor(s) === null ? [new o.V(t, s, `color expected, "${s}" found`)] : []
                },
                enum: ps,
                filter: Yr,
                function: lo,
                layer: Ml,
                object: Ar,
                source: Fr,
                model: o.a4,
                light: ms,
                "light-3d": ho,
                terrain: Ls,
                fog: bo,
                string: zs,
                formatted: function (u) {
                    return zs(u).length === 0 ? [] : co(u)
                },
                resolvedImage: function (u) {
                    return zs(u).length === 0 ? [] : co(u)
                },
                projection: function (u) {
                    const t = u.value, s = u.styleSpec, h = s.projection, m = u.style;
                    let g = [];
                    const v = o.J(t);
                    if (v === "object") for (const b in t) g = g.concat(bn({
                        key: b,
                        value: t[b],
                        valueSpec: h[b],
                        style: m,
                        styleSpec: s
                    })); else v !== "string" && (g = g.concat([new o.V("projection", t, `object or string expected, ${v} found`)]));
                    return g
                },
                import: function (u) {
                    const {value: t, styleSpec: s} = u, {data: h, ...m} = t;
                    Object.defineProperty(m, "__line__", {value: t.__line__, enumerable: !1});
                    let g = Ar(o.L({}, u, {value: m, valueSpec: s.import}));
                    return o.M(m.id) === "" && g.push(new o.V(`${u.key}.id`, m, "import id can't be an empty string")), h && (g = g.concat($a(h, s, {key: `${u.key}.data`}))), g
                },
                iconset: function (u) {
                    const t = u.value, s = u.key, h = u.styleSpec, m = u.style;
                    if (!t.type) return [new o.V(s, t, '"type" is required')];
                    const g = o.M(t.type);
                    let v = [];
                    if (v = v.concat(Ar({
                        key: s,
                        value: t,
                        valueSpec: h[`iconset_${g}`],
                        style: m,
                        styleSpec: h
                    })), g === "source" && t.source) {
                        const b = m.sources && m.sources[t.source], S = b && o.M(b.type);
                        b ? S !== "raster-array" && v.push(new o.V(s, t.source, `iconset cannot be used with a source of type ${String(S)}, it only be used with a "raster-array" source type`)) : v.push(new o.V(s, t.source, `source "${t.source}" not found`))
                    }
                    return v
                }
            };

            function bn(u, t = !1) {
                const s = u.value, h = u.valueSpec, m = u.styleSpec;
                if (h.expression && o.a2(o.M(s))) return lo(u);
                if (h.expression && o.S(o.U(s))) return co(u);
                if (h.type && Ua[h.type]) {
                    const g = Ua[h.type](u);
                    return t === !0 && g.length > 0 && o.J(u.value) === "array" ? co(u) : g
                }
                return Ar(o.L({}, u, {valueSpec: h.type ? m[h.type] : h}))
            }

            function Ga(u) {
                const t = u.value, s = u.key, h = zs(u);
                return h.length || (t.indexOf("{fontstack}") === -1 && h.push(new o.V(s, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && h.push(new o.V(s, t, '"glyphs" url must include a "{range}" token'))), h
            }

            function $a(u, t = o.a5, s = {}) {
                return bn({
                    key: s.key || "",
                    value: u,
                    valueSpec: t.$root,
                    styleSpec: t,
                    style: u,
                    objectElementValidators: {glyphs: Ga, "*": () => []}
                })
            }

            function To(u, t = o.a5) {
                return we($a(u, t))
            }

            const pa = u => we(Fr(u)), gs = u => we(ms(u)), Ha = u => we(ho(u)), Ze = u => we(Ls(u)),
                xn = u => we(bo(u)), Jn = u => we(function (t) {
                    const s = t.value, h = t.style, m = t.styleSpec, g = m.snow;
                    let v = [];
                    const b = o.J(s);
                    if (s === void 0) return v;
                    if (b !== "object") return v = v.concat([new o.V("snow", s, `object expected, ${b} found`)]), v;
                    for (const S in s) {
                        const P = S.match(/^(.*)-transition$/);
                        v = v.concat(P && g[P[1]] && g[P[1]].transition ? bn({
                            key: S,
                            value: s[S],
                            valueSpec: m.transition,
                            style: h,
                            styleSpec: m
                        }) : g[S] ? bn({
                            key: S,
                            value: s[S],
                            valueSpec: g[S],
                            style: h,
                            styleSpec: m
                        }) : [new o.K(S, s[S], `unknown property "${S}"`)])
                    }
                    return v
                }(u)), Kr = u => we(function (t) {
                    const s = t.value, h = t.style, m = t.styleSpec, g = m.rain;
                    let v = [];
                    const b = o.J(s);
                    if (s === void 0) return v;
                    if (b !== "object") return v = v.concat([new o.V("rain", s, `object expected, ${b} found`)]), v;
                    for (const S in s) {
                        const P = S.match(/^(.*)-transition$/);
                        v = v.concat(P && g[P[1]] && g[P[1]].transition ? bn({
                            key: S,
                            value: s[S],
                            valueSpec: m.transition,
                            style: h,
                            styleSpec: m
                        }) : g[S] ? bn({
                            key: S,
                            value: s[S],
                            valueSpec: g[S],
                            style: h,
                            styleSpec: m
                        }) : [new o.K(S, s[S], `unknown property "${S}"`)])
                    }
                    return v
                }(u)), Ai = u => we(Ml(u)), Le = u => we(Yr(u)), $ = u => we(Qn(u)), W = u => we(Cr(u)),
                ie = u => we(o.a4(u));

            function we(u) {
                return u.slice().sort((t, s) => t.line && s.line ? t.line - s.line : 0)
            }

            function se(u, t) {
                let s = !1;
                if (t && t.length) for (const h of t) h instanceof o.K ? o.w(h.message) : (u.fire(new o.z(new Error(h.message))), s = !0);
                return s
            }

            let Ae;

            class Ve extends o.E {
                constructor(t, s = "flat") {
                    super(), this._transitionable = new o.a6(Ae || (Ae = new o.a7({
                        anchor: new o.a8(o.a5.light.anchor),
                        position: new o.a9(o.a5.light.position),
                        color: new o.a8(o.a5.light.color),
                        intensity: new o.a8(o.a5.light.intensity)
                    }))), this.setLight(t, s), this._transitioning = this._transitionable.untransitioned()
                }

                getLight() {
                    return this._transitionable.serialize()
                }

                setLight(t, s, h = {}) {
                    this._validate(gs, t, h) || (this._transitionable.setTransitionOrValue(t), this.id = s)
                }

                updateTransitions(t) {
                    this._transitioning = this._transitionable.transitioned(t, this._transitioning)
                }

                hasTransition() {
                    return this._transitioning.hasTransition()
                }

                recalculate(t) {
                    this.properties = this._transitioning.possiblyEvaluate(t)
                }

                _validate(t, s, h) {
                    return (!h || h.validate !== !1) && se(this, t.call(To, o.h({
                        value: s,
                        style: {glyphs: !0, sprite: !0},
                        styleSpec: o.a5
                    })))
                }
            }

            let Pe = class extends o.E {
                constructor(u, t, s, h, m) {
                    super(), this.scope = s, this._transitionable = new o.a6(new o.a7({
                        source: new o.a8(o.a5.terrain.source),
                        exaggeration: new o.a8(o.a5.terrain.exaggeration)
                    }), s, h), this._transitionable.setTransitionOrValue(u, h), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = t, this.worldview = m
                }

                get() {
                    return this._transitionable.serialize()
                }

                set(u, t) {
                    this._transitionable.setTransitionOrValue(u, t)
                }

                updateTransitions(u) {
                    this._transitioning = this._transitionable.transitioned(u, this._transitioning)
                }

                hasTransition() {
                    return this._transitioning.hasTransition()
                }

                recalculate(u) {
                    this.properties = this._transitioning.possiblyEvaluate(u)
                }

                getExaggeration(u) {
                    return this._transitioning.possiblyEvaluate(new o.aa(u, {worldview: this.worldview})).get("exaggeration")
                }

                getAttenuationRange() {
                    if (!this.isZoomDependent()) return null;
                    const u = this._transitionable._values.exaggeration;
                    if (!u) return null;
                    const t = u.value.expression;
                    if (!t) return null;
                    let s = -1, h = -1, m = 1;
                    for (const g of t.zoomStops) m = t.evaluate(new o.aa(g, {worldview: this.worldview})), m > .01 ? (s = g, h = -1) : h = g;
                    return m < .01 && s > 0 && h > s ? [s, h] : null
                }

                isZoomDependent() {
                    const u = this._transitionable._values.exaggeration;
                    return u != null && u.value != null && u.value.expression != null && u.value.expression instanceof o.ab
                }
            };
            const Ne = 45, ft = 65, Je = .05;

            function Gt(u, t, s, h) {
                const m = o.af(Ne, ft, s), [g, v] = ii(u, h);
                let b = 1 - Math.min(1, Math.exp((t - g) / (v - g) * -6));
                return b *= b * b, b = Math.min(1, 1.00747 * b), b * m * u.alpha
            }

            function ii(u, t) {
                const s = .5 / Math.tan(.5 * t);
                return [u.range[0] + s, u.range[1] + s]
            }

            function li(u, t, s, h, m) {
                const g = o.ad([], [t, s, h], m.mercatorFogMatrix);
                return Gt(u, o.ae(g), m.pitch, m._fov)
            }

            function zi(u, t, s, h, m, g, v) {
                const b = [[s, h, 0], [m, h, 0], [m, g, 0], [s, g, 0]];
                let S = Number.MAX_VALUE, P = -Number.MAX_VALUE;
                for (const M of b) {
                    const k = o.ad([], M, t), R = o.ae(k);
                    S = Math.min(S, R), P = Math.max(P, R)
                }
                return [Gt(u, S, v.pitch, v._fov), Gt(u, P, v.pitch, v._fov)]
            }

            class Ti extends o.E {
                constructor(t, s, h, m) {
                    super();
                    const g = new o.a7({
                        range: new o.a8(o.a5.fog.range),
                        color: new o.a8(o.a5.fog.color),
                        "color-use-theme": new o.a8({
                            type: "string",
                            "property-type": "data-constant",
                            default: "default"
                        }),
                        "high-color": new o.a8(o.a5.fog["high-color"]),
                        "high-color-use-theme": new o.a8({
                            type: "string",
                            "property-type": "data-constant",
                            default: "default"
                        }),
                        "space-color": new o.a8(o.a5.fog["space-color"]),
                        "space-color-use-theme": new o.a8({
                            type: "string",
                            "property-type": "data-constant",
                            default: "default"
                        }),
                        "horizon-blend": new o.a8(o.a5.fog["horizon-blend"]),
                        "star-intensity": new o.a8(o.a5.fog["star-intensity"]),
                        "vertical-range": new o.a8(o.a5.fog["vertical-range"])
                    });
                    this._transitionable = new o.a6(g, h, new Map(m)), this.set(t, m), this._transitioning = this._transitionable.untransitioned(), this._transform = s, this.properties = new o.ag(g), this.scope = h
                }

                get state() {
                    const t = this._transform, s = t.projection.name === "globe", h = o.ah(t.zoom),
                        m = this.properties.get("range"), g = [.5, 3];
                    return {
                        range: s ? [o.ai(g[0], m[0], h), o.ai(g[1], m[1], h)] : m,
                        horizonBlend: this.properties.get("horizon-blend"),
                        alpha: this.properties.get("color").a
                    }
                }

                get() {
                    return this._transitionable.serialize()
                }

                set(t, s, h = {}) {
                    if (this._validate(xn, t, h)) return;
                    const m = o.h({}, t);
                    for (const g of Object.keys(o.a5.fog)) m[g] === void 0 && (m[g] = o.a5.fog[g].default);
                    this._options = m, this._transitionable.setTransitionOrValue(this._options, s)
                }

                getOpacity(t) {
                    if (!this._transform.projection.supportsFog) return 0;
                    const s = this.properties && this.properties.get("color") || 1;
                    return (this._transform.projection.name === "globe" ? 1 : o.af(Ne, ft, t)) * s.a
                }

                getOpacityAtLatLng(t, s) {
                    return this._transform.projection.supportsFog ? function (h, m, g) {
                        const v = o.ac.fromLngLat(m), b = g.elevation ? g.elevation.getAtPointOrZero(v) : 0;
                        return li(h, v.x, v.y, b, g)
                    }(this.state, t, s) : 0
                }

                getOpacityForTile(t) {
                    if (!this._transform.projection.supportsFog) return [1, 1];
                    const s = this._transform.calculateFogTileMatrix(t.toUnwrapped());
                    return zi(this.state, s, 0, 0, o.aj, o.aj, this._transform)
                }

                getOpacityForBounds(t, s, h, m, g) {
                    return this._transform.projection.supportsFog ? zi(this.state, t, s, h, m, g, this._transform) : [1, 1]
                }

                getFovAdjustedRange(t) {
                    return this._transform.projection.supportsFog ? ii(this.state, t) : [0, 1]
                }

                isVisibleOnFrustum(t) {
                    if (!this._transform.projection.supportsFog) return !1;
                    const s = [4, 5, 6, 7];
                    for (const h of s) {
                        const m = t.points[h];
                        let g;
                        if (m[2] >= 0) g = m; else {
                            const v = t.points[h - 4];
                            g = o.ak(v, m, v[2] / (v[2] - m[2]))
                        }
                        if (li(this.state, g[0], g[1], 0, this._transform) >= Je) return !0
                    }
                    return !1
                }

                updateConfig(t) {
                    this._transitionable.setTransitionOrValue(this._options, new Map(t))
                }

                updateTransitions(t) {
                    this._transitioning = this._transitionable.transitioned(t, this._transitioning)
                }

                hasTransition() {
                    return this._transitioning.hasTransition()
                }

                recalculate(t) {
                    this.properties = this._transitioning.possiblyEvaluate(t)
                }

                _validate(t, s, h) {
                    return (!h || h.validate !== !1) && se(this, t.call(To, o.h({
                        value: s,
                        style: {glyphs: !0, sprite: !0},
                        styleSpec: o.a5
                    })))
                }
            }

            let Di, mn, Li, Xn, mr = class extends o.E {
                constructor(u, t, s, h) {
                    super();
                    const m = Di || (Di = new o.a7({
                        density: new o.a8(o.a5.snow.density),
                        intensity: new o.a8(o.a5.snow.intensity),
                        color: new o.a8(o.a5.snow.color),
                        opacity: new o.a8(o.a5.snow.opacity),
                        vignette: new o.a8(o.a5.snow.vignette),
                        "vignette-color": new o.a8(o.a5.snow["vignette-color"]),
                        "center-thinning": new o.a8(o.a5.snow["center-thinning"]),
                        direction: new o.a8(o.a5.snow.direction),
                        "flake-size": new o.a8(o.a5.snow["flake-size"])
                    }));
                    this._transitionable = new o.a6(m, s, new Map(h)), this.set(u, h), this._transitioning = this._transitionable.untransitioned(), this.properties = new o.ag(m), this.scope = s
                }

                get state() {
                    const u = this.properties.get("opacity"), t = this.properties.get("color"),
                        s = this.properties.get("direction"), h = o.al(s[0]), m = -Math.max(o.al(s[1]), .01),
                        g = [Math.cos(h) * Math.cos(m), Math.sin(h) * Math.cos(m), Math.sin(m)],
                        v = this.properties.get("vignette"), b = this.properties.get("vignette-color");
                    return b.a = v, {
                        density: this.properties.get("density"),
                        intensity: this.properties.get("intensity"),
                        color: new o.am(t.r, t.g, t.b, t.a * u),
                        direction: g,
                        centerThinning: this.properties.get("center-thinning"),
                        flakeSize: this.properties.get("flake-size"),
                        vignetteColor: b
                    }
                }

                get() {
                    return this._transitionable.serialize()
                }

                set(u, t, s = {}) {
                    if (this._validate(Jn, u, s)) return;
                    const h = o.h({}, u);
                    for (const m of Object.keys(o.a5.snow)) h[m] === void 0 && (h[m] = o.a5.snow[m].default);
                    this._options = h, this._transitionable.setTransitionOrValue(this._options, t)
                }

                updateConfig(u) {
                    this._transitionable.setTransitionOrValue(this._options, new Map(u))
                }

                updateTransitions(u) {
                    this._transitioning = this._transitionable.transitioned(u, this._transitioning)
                }

                hasTransition() {
                    return this._transitioning.hasTransition()
                }

                recalculate(u) {
                    this.properties = this._transitioning.possiblyEvaluate(u)
                }

                _validate(u, t, s) {
                    return (!s || s.validate !== !1) && se(this, u.call(To, o.h({
                        value: t,
                        style: {glyphs: !0, sprite: !0},
                        styleSpec: o.a5
                    })))
                }
            }, lr = class extends o.E {
                constructor(u, t, s, h) {
                    super();
                    const m = mn || (mn = new o.a7({
                        density: new o.a8(o.a5.rain.density),
                        intensity: new o.a8(o.a5.rain.intensity),
                        color: new o.a8(o.a5.rain.color),
                        opacity: new o.a8(o.a5.rain.opacity),
                        vignette: new o.a8(o.a5.rain.vignette),
                        "vignette-color": new o.a8(o.a5.rain["vignette-color"]),
                        "center-thinning": new o.a8(o.a5.rain["center-thinning"]),
                        direction: new o.a8(o.a5.rain.direction),
                        "droplet-size": new o.a8(o.a5.rain["droplet-size"]),
                        "distortion-strength": new o.a8(o.a5.rain["distortion-strength"])
                    }));
                    this._transitionable = new o.a6(m, s, new Map(h)), this.set(u, h), this._transitioning = this._transitionable.untransitioned(), this.properties = new o.ag(m), this.scope = s
                }

                get state() {
                    const u = this.properties.get("opacity"), t = this.properties.get("color"),
                        s = this.properties.get("direction"), h = o.al(s[0]), m = -Math.max(o.al(s[1]), .01),
                        g = [Math.cos(h) * Math.cos(m), Math.sin(h) * Math.cos(m), Math.sin(m)],
                        v = this.properties.get("vignette-color");
                    return v.a = this.properties.get("vignette"), {
                        density: this.properties.get("density"),
                        intensity: this.properties.get("intensity"),
                        color: new o.am(t.r, t.g, t.b, t.a * u),
                        direction: g,
                        centerThinning: this.properties.get("center-thinning"),
                        dropletSize: this.properties.get("droplet-size"),
                        distortionStrength: this.properties.get("distortion-strength"),
                        vignetteColor: v
                    }
                }

                get() {
                    return this._transitionable.serialize()
                }

                set(u, t, s = {}) {
                    if (this._validate(Kr, u, s)) return;
                    const h = o.h({}, u);
                    for (const m of Object.keys(o.a5.rain)) h[m] === void 0 && (h[m] = o.a5.rain[m].default);
                    this._options = h, this._transitionable.setTransitionOrValue(this._options, t)
                }

                updateConfig(u) {
                    this._transitionable.setTransitionOrValue(this._options, new Map(u))
                }

                updateTransitions(u) {
                    this._transitioning = this._transitionable.transitioned(u, this._transitioning)
                }

                hasTransition() {
                    return this._transitioning.hasTransition()
                }

                recalculate(u) {
                    this.properties = this._transitioning.possiblyEvaluate(u)
                }

                _validate(u, t, s) {
                    return (!s || s.validate !== !1) && se(this, u.call(To, o.h({
                        value: t,
                        style: {glyphs: !0, sprite: !0},
                        styleSpec: o.a5
                    })))
                }
            };

            class un extends o.E {
                constructor(t, s, h, m) {
                    super(), this.scope = h, this._options = t, this.properties = new o.ag(s), this._transitionable = new o.a6(s, h, new Map(m)), this._transitionable.setTransitionOrValue(t.properties), this._transitioning = this._transitionable.untransitioned()
                }

                updateConfig(t) {
                    this._transitionable.setTransitionOrValue(this._options.properties, new Map(t))
                }

                updateTransitions(t) {
                    this._transitioning = this._transitionable.transitioned(t, this._transitioning)
                }

                hasTransition() {
                    return this._transitioning.hasTransition()
                }

                recalculate(t) {
                    this.properties = this._transitioning.possiblyEvaluate(t)
                }

                get() {
                    return this._options.properties = this._transitionable.serialize(), this._options
                }

                set(t, s) {
                    this._options = t, this._transitionable.setTransitionOrValue(t.properties, s)
                }

                shadowsEnabled() {
                    return !!this.properties && this.properties.get("cast-shadows") === !0
                }
            }

            class Zi {
                constructor(t, s, h) {
                    this.screenBounds = t, this.cameraPoint = h.getCameraPoint(), this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = s, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, h)
                }

                static createFromScreenPoints(t, s) {
                    let h, m;
                    if (t instanceof o.P || typeof t[0] == "number") {
                        const g = o.P.convert(t);
                        h = [g], m = s.isPointAboveHorizon(g)
                    } else {
                        const g = o.P.convert(t[0]), v = o.P.convert(t[1]), b = g.add(v)._div(2);
                        h = [g, v], m = o.ao(g, v).every(S => s.isPointAboveHorizon(S)) && s.isPointAboveHorizon(b)
                    }
                    return new Zi(h, m, s)
                }

                isPointQuery() {
                    return this.screenBounds.length === 1
                }

                bufferedScreenGeometry(t) {
                    return o.ao(this.screenBounds[0], this.screenBounds.length === 1 ? this.screenBounds[0] : this.screenBounds[1], t)
                }

                bufferedCameraGeometry(t) {
                    const s = this.screenBounds[0],
                        h = this.screenBounds.length === 1 ? this.screenBounds[0].add(new o.P(1, 1)) : this.screenBounds[1],
                        m = o.ao(s, h, 0, !1);
                    return this.cameraPoint.y > h.y && (this.cameraPoint.x > s.x && this.cameraPoint.x < h.x ? m.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= h.x ? m[2] = this.cameraPoint : this.cameraPoint.x <= s.x && (m[3] = this.cameraPoint)), o.ap(m, t)
                }

                bufferedCameraGeometryGlobe(t) {
                    const s = this.screenBounds[0],
                        h = this.screenBounds.length === 1 ? this.screenBounds[0].add(new o.P(1, 1)) : this.screenBounds[1],
                        m = o.ao(s, h, t), g = this.cameraPoint.clone();
                    switch (3 * ((g.y > s.y) + (g.y > h.y)) + ((g.x > s.x) + (g.x > h.x))) {
                        case 0:
                            m[0] = g, m[4] = g.clone();
                            break;
                        case 1:
                            m.splice(1, 0, g);
                            break;
                        case 2:
                            m[1] = g;
                            break;
                        case 3:
                            m.splice(4, 0, g);
                            break;
                        case 5:
                            m.splice(2, 0, g);
                            break;
                        case 6:
                            m[3] = g;
                            break;
                        case 7:
                            m.splice(3, 0, g);
                            break;
                        case 8:
                            m[2] = g
                    }
                    return m
                }

                containsTile(t, s, h, m = 0) {
                    const g = t.queryPadding / s._pixelsPerMercatorPixel + 1,
                        v = h ? this._bufferedCameraMercator(g, s) : this._bufferedScreenMercator(g, s);
                    let b = t.tileID.wrap + (v.unwrapped ? m : 0);
                    const S = v.polygon.map(G => o.aq(t.tileTransform, G, b));
                    if (!o.ar(S, 0, 0, o.aj, o.aj)) return;
                    b = t.tileID.wrap + (this.screenGeometryMercator.unwrapped ? m : 0);
                    const P = this.screenGeometryMercator.polygon.map(G => o.as(t.tileTransform, G, b)),
                        M = P.map(G => new o.P(G[0], G[1])), k = s.getFreeCameraOptions().position || new o.ac(0, 0, 0),
                        R = o.as(t.tileTransform, k, b), O = P.map(G => {
                            const U = o.at(G, G, R);
                            return o.au(U, U), new o.av(R, U)
                        }), V = o.aw(t, 1, s.zoom) * s._pixelsPerMercatorPixel;
                    return {
                        queryGeometry: this,
                        tilespaceGeometry: M,
                        tilespaceRays: O,
                        bufferedTilespaceGeometry: S,
                        bufferedTilespaceBounds: (B = o.ax(S), B.min.x = o.ay(B.min.x, 0, o.aj), B.min.y = o.ay(B.min.y, 0, o.aj), B.max.x = o.ay(B.max.x, 0, o.aj), B.max.y = o.ay(B.max.y, 0, o.aj), B),
                        tile: t,
                        tileID: t.tileID,
                        pixelToTileUnitsFactor: V
                    };
                    var B
                }

                _bufferedScreenMercator(t, s) {
                    const h = Dn(t);
                    if (this._screenRaycastCache[h]) return this._screenRaycastCache[h];
                    {
                        let m;
                        return m = s.projection.name === "globe" ? this._projectAndResample(this.bufferedScreenGeometry(t), s) : {
                            polygon: this.bufferedScreenGeometry(t).map(g => s.pointCoordinate3D(g)),
                            unwrapped: !0
                        }, this._screenRaycastCache[h] = m, m
                    }
                }

                _bufferedCameraMercator(t, s) {
                    const h = Dn(t);
                    if (this._cameraRaycastCache[h]) return this._cameraRaycastCache[h];
                    {
                        let m;
                        return m = s.projection.name === "globe" ? this._projectAndResample(this.bufferedCameraGeometryGlobe(t), s) : {
                            polygon: this.bufferedCameraGeometry(t).map(g => s.pointCoordinate3D(g)),
                            unwrapped: !0
                        }, this._cameraRaycastCache[h] = m, m
                    }
                }

                _projectAndResample(t, s) {
                    const h = function (g, v) {
                        const b = o.az([], v.pixelMatrix, v.globeMatrix), S = [0, -o.aB, 0, 1], P = [0, o.aB, 0, 1],
                            M = [0, 0, 0, 1];
                        o.aA(S, S, b), o.aA(P, P, b), o.aA(M, M, b);
                        const k = new o.P(S[0] / S[3], S[1] / S[3]), R = new o.P(P[0] / P[3], P[1] / P[3]),
                            O = o.aC(g, k) && S[3] < M[3], V = o.aC(g, R) && P[3] < M[3];
                        if (!O && !V) return null;
                        const B = function (ve, ue, he) {
                            for (let me = 1; me < ve.length; me++) {
                                const Oe = jn(ue.pointCoordinate3D(ve[me - 1]).x),
                                    Se = jn(ue.pointCoordinate3D(ve[me]).x);
                                if (he < 0) {
                                    if (Oe < Se) return {idx: me, t: -Oe / (Se - 1 - Oe)}
                                } else if (Se < Oe) return {idx: me, t: (1 - Oe) / (Se + 1 - Oe)}
                            }
                            return null
                        }(g, v, O ? -1 : 1);
                        if (!B) return null;
                        const {idx: G, t: U} = B;
                        let Z = G > 1 ? Hn(g.slice(0, G), v) : [], Q = G < g.length ? Hn(g.slice(G), v) : [];
                        Z = Z.map(ve => new o.P(jn(ve.x), ve.y)), Q = Q.map(ve => new o.P(jn(ve.x), ve.y));
                        const te = [...Z];
                        te.length === 0 && te.push(Q[Q.length - 1]);
                        const ce = o.ai(te[te.length - 1].y, (Q.length === 0 ? Z[0] : Q[0]).y, U);
                        let _e;
                        return _e = O ? [new o.P(0, ce), new o.P(0, 0), new o.P(1, 0), new o.P(1, ce)] : [new o.P(1, ce), new o.P(1, 1), new o.P(0, 1), new o.P(0, ce)], te.push(..._e), Q.length === 0 ? te.push(Z[0]) : te.push(...Q), {
                            polygon: te.map(ve => new o.ac(ve.x, ve.y)),
                            unwrapped: !1
                        }
                    }(t, s);
                    if (h) return h;
                    const m = function (g, v) {
                        let b = !1, S = -1 / 0, P = 0;
                        for (let k = 0; k < g.length - 1; k++) g[k].x > S && (S = g[k].x, P = k);
                        for (let k = 0; k < g.length - 1; k++) {
                            const R = (P + k) % (g.length - 1), O = g[R], V = g[R + 1];
                            Math.abs(O.x - V.x) > .5 && (O.x < V.x ? (O.x += 1, R === 0 && (g[g.length - 1].x += 1)) : (V.x += 1, R + 1 === g.length - 1 && (g[0].x += 1)), b = !0)
                        }
                        const M = o.aD(v.center.lng);
                        return b && M < Math.abs(M - 1) && g.forEach(k => {
                            k.x -= 1
                        }), {polygon: g, unwrapped: b}
                    }(Hn(t, s).map(g => new o.P(jn(g.x), g.y)), s);
                    return {polygon: m.polygon.map(g => new o.ac(g.x, g.y)), unwrapped: m.unwrapped}
                }
            }

            function Hn(u, t) {
                return o.aE(u, s => {
                    const h = t.pointCoordinate3D(s);
                    s.x = h.x, s.y = h.y
                }, 1 / 256)
            }

            function jn(u) {
                return u < 0 ? 1 + u % 1 : u % 1
            }

            function Dn(u) {
                return 100 * u | 0
            }

            function Pr(u, t, s, h, m) {
                const g = function (b, S) {
                    if (b) return m(b);
                    if (S) {
                        if (u.url && S.tiles && u.tiles && delete u.tiles, S.variants) {
                            if (!Array.isArray(S.variants)) return m(new Error("variants must be an array"));
                            for (const M of S.variants) {
                                if (M == null || typeof M != "object" || M.constructor !== Object) return m(new Error("variant must be an object"));
                                if (!Array.isArray(M.capabilities)) return m(new Error("capabilities must be an array"));
                                if (M.capabilities.length === 1 && M.capabilities[0] === "meshopt") {
                                    S = o.h(S, M);
                                    break
                                }
                            }
                        }
                        const P = o.aF(o.h({}, S, u), ["tilejson", "tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "extra_bounds", "scheme", "tileSize", "encoding", "vector_layers", "raster_layers", "worldview_options", "worldview_default", "worldview"]);
                        P.tiles = t.canonicalizeTileset(P, u.url), m(null, P)
                    }
                }, v = function (b, S, P) {
                    if (!b) return null;
                    if (!S && !P) return b;
                    P = P || b.worldview_default;
                    const M = Object.values(b.language || {});
                    if (M.length === 0) return null;
                    const k = Object.values(b.worldview || {});
                    if (k.length === 0) return null;
                    const R = M.every(V => V === S), O = k.every(V => V === P);
                    return R && O ? b : S in (b.language_options || {}) || P in (b.worldview_options || {}) ? null : b.language_options && b.worldview_options ? b : null
                }(u.data, s, h);
                return v ? o.q.frame(() => g(null, v)) : u.url ? o.n(t.transformRequest(t.normalizeSourceURL(u.url, null, s, h), o.R.Source), g) : o.q.frame(() => {
                    const {data: b, ...S} = u;
                    g(null, S)
                })
            }

            function So(u, t) {
                const s = Math.pow(2, t.z), h = Math.floor(o.aD(u.getWest()) * s),
                    m = Math.floor(o.aH(u.getNorth()) * s), g = Math.ceil(o.aD(u.getEast()) * s),
                    v = Math.ceil(o.aH(u.getSouth()) * s);
                return t.x >= h && t.x < g && t.y >= m && t.y < v
            }

            class Qr {
                constructor(t, s, h) {
                    this.bounds = t ? o.aG.convert(this.validateBounds(t)) : null, this.minzoom = s || 0, this.maxzoom = h || 24
                }

                validateBounds(t) {
                    return Array.isArray(t) && t.length === 4 ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90]
                }

                addExtraBounds(t) {
                    if (t) {
                        this.extraBounds || (this.extraBounds = []);
                        for (const s of t) this.extraBounds.push(o.aG.convert(this.validateBounds(s)))
                    }
                }

                contains(t) {
                    if (t.z > this.maxzoom || t.z < this.minzoom || this.bounds && !So(this.bounds, t)) return !1;
                    if (!this.extraBounds) return !0;
                    for (const s of this.extraBounds) if (So(s, t)) return !0;
                    return !1
                }

                static fromTileJSON(t) {
                    if (!t.bounds && !t.extra_bounds) return null;
                    const s = new Qr(t.bounds, t.minzoom, t.maxzoom);
                    return s.addExtraBounds(t.extra_bounds), s
                }
            }

            class Gu extends o.E {
                constructor(t, s, h, m) {
                    if (super(), this.id = t, this.dispatcher = h, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, o.h(this, o.aF(s, ["url", "scheme", "tileSize", "promoteId"])), this._options = o.h({type: "vector"}, s), this._collectResourceTiming = !!s.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
                    this.setEventedParent(m), this._tileWorkers = {}, this._deduped = new o.aI
                }

                load(t) {
                    this._loaded = !1, this.fire(new o.A("dataloading", {dataType: "source"}));
                    const s = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language,
                        h = this.map.getWorldview();
                    this._tileJSONRequest = Pr(this._options, this.map._requestManager, s, h, (m, g) => {
                        if (this._tileJSONRequest = null, this._loaded = !0, m) s && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${s}`), h && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${h}`), this.fire(new o.z(m)); else if (g) {
                            if (o.h(this, g), this.hasWorldviews = !!g.worldview_options, g.worldview_default && (this.worldviewDefault = g.worldview_default), g.vector_layers) {
                                this.vectorLayers = g.vector_layers, this.vectorLayerIds = [], this.localizableLayerIds = new Set;
                                for (const v of g.vector_layers) this.vectorLayerIds.push(v.id), g.worldview && g.worldview[v.source] && this.localizableLayerIds.add(v.id)
                            }
                            this.tileBounds = Qr.fromTileJSON(g), fi(g.tiles, this.map._requestManager._customAccessToken), this.fire(new o.A("data", {
                                dataType: "source",
                                sourceDataType: "metadata"
                            })), this.fire(new o.A("data", {dataType: "source", sourceDataType: "content"}))
                        }
                        t && t(m)
                    })
                }

                loaded() {
                    return this._loaded
                }

                hasTile(t) {
                    return !this.tileBounds || this.tileBounds.contains(t.canonical)
                }

                onAdd(t) {
                    this.map = t, this.load()
                }

                reload() {
                    this.cancelTileJSONRequest();
                    const t = o.C(this.id, this.scope);
                    this.load(() => this.map.style.clearSource(t))
                }

                setTiles(t) {
                    return this._options.tiles = t, this.reload(), this
                }

                setUrl(t) {
                    return this.url = t, this._options.url = t, this.reload(), this
                }

                onRemove(t) {
                    this.cancelTileJSONRequest()
                }

                serialize() {
                    return o.h({}, this._options)
                }

                loadTile(t, s) {
                    const h = t.tileID.canonical.url(this.tiles, this.scheme),
                        m = this.map._requestManager.normalizeTileURL(h),
                        g = this.map._requestManager.transformRequest(m, o.R.Tile),
                        v = this.map.style ? this.map.style.getLut(this.scope) : null,
                        b = v ? {image: v.image.clone()} : null, S = {
                            request: g,
                            data: void 0,
                            uid: t.uid,
                            tileID: t.tileID,
                            tileZoom: t.tileZoom,
                            zoom: t.tileID.overscaledZ,
                            maxZoom: this.maxzoom,
                            lut: b,
                            tileSize: this.tileSize * t.tileID.overscaleFactor(),
                            type: this.type,
                            source: this.id,
                            scope: this.scope,
                            pixelRatio: o.q.devicePixelRatio,
                            showCollisionBoxes: this.map.showCollisionBoxes,
                            promoteId: this.promoteId,
                            isSymbolTile: t.isSymbolTile,
                            brightness: this.map.style && this.map.style.getBrightness() || 0,
                            extraShadowCaster: t.isExtraShadowCaster,
                            tessellationStep: this.map._tessellationStep,
                            scaleFactor: this.map.getScaleFactor(),
                            worldview: this.map.getWorldview() || this.worldviewDefault
                        };
                    if (this.hasWorldviews && o.j(h) && (S.localizableLayerIds = this.localizableLayerIds), S.request.collectResourceTiming = this._collectResourceTiming, t.actor && t.state !== "expired") t.state === "loading" ? t.reloadCallback = s : t.request = t.actor.send("reloadTile", S, P.bind(this)); else if (t.actor = this._tileWorkers[m] = this._tileWorkers[m] || this.dispatcher.getActor(), this.dispatcher.ready) t.request = t.actor.send("loadTile", S, P.bind(this), void 0, !0); else {
                        const M = o.aJ.call({deduped: this._deduped}, S, (k, R) => {
                            k || !R ? P.call(this, k) : (S.data = {
                                cacheControl: R.cacheControl,
                                expires: R.expires,
                                rawData: R.rawData.slice(0)
                            }, t.actor && t.actor.send("loadTile", S, P.bind(this), void 0, !0))
                        }, !0);
                        t.request = {cancel: M}
                    }

                    function P(M, k) {
                        return delete t.request, t.aborted ? s(null) : M && M.status !== 404 ? s(M) : (k && k.resourceTiming && (t.resourceTiming = k.resourceTiming), this.map._refreshExpiredTiles && k && t.setExpiryData(k), t.loadVectorData(k, this.map.painter), o.aK(this.dispatcher), s(null), void (t.reloadCallback && (this.loadTile(t, t.reloadCallback), t.reloadCallback = null)))
                    }
                }

                abortTile(t) {
                    t.request && (t.request.cancel(), delete t.request), t.actor && t.actor.send("abortTile", {
                        uid: t.uid,
                        type: this.type,
                        source: this.id,
                        scope: this.scope
                    })
                }

                unloadTile(t, s) {
                    t.actor && t.actor.send("removeTile", {
                        uid: t.uid,
                        type: this.type,
                        source: this.id,
                        scope: this.scope
                    }), t.destroy()
                }

                hasTransition() {
                    return !1
                }

                afterUpdate() {
                    this._tileWorkers = {}
                }

                cancelTileJSONRequest() {
                    this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null)
                }
            }

            class Br extends o.E {
                constructor(t, s, h, m) {
                    super(), this.id = t, this.dispatcher = h, this.setEventedParent(m), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = o.h({type: "raster"}, s), o.h(this, o.aF(s, ["url", "scheme", "tileSize"]))
                }

                load(t) {
                    this._loaded = !1, this.fire(new o.A("dataloading", {dataType: "source"}));
                    const s = this.map.getWorldview();
                    this._tileJSONRequest = Pr(this._options, this.map._requestManager, null, s, (h, m) => {
                        this._tileJSONRequest = null, this._loaded = !0, h ? this.fire(new o.z(h)) : m && (o.h(this, m), m.raster_layers && (this.rasterLayers = m.raster_layers, this.rasterLayerIds = this.rasterLayers.map(g => g.id)), this.tileBounds = Qr.fromTileJSON(m), fi(m.tiles), this.fire(new o.A("data", {
                            dataType: "source",
                            sourceDataType: "metadata"
                        })), this.fire(new o.A("data", {dataType: "source", sourceDataType: "content"}))), t && t(h)
                    })
                }

                loaded() {
                    return this._loaded
                }

                onAdd(t) {
                    this.map = t, this.load()
                }

                reload() {
                    this.cancelTileJSONRequest();
                    const t = o.C(this.id, this.scope);
                    this.load(() => this.map.style.clearSource(t))
                }

                setTiles(t) {
                    return this._options.tiles = t, this.reload(), this
                }

                setUrl(t) {
                    return this.url = t, this._options.url = t, this.reload(), this
                }

                onRemove(t) {
                    this.cancelTileJSONRequest()
                }

                serialize() {
                    return o.h({}, this._options)
                }

                hasTile(t) {
                    return !this.tileBounds || this.tileBounds.contains(t.canonical)
                }

                loadTile(t, s) {
                    const h = o.q.devicePixelRatio >= 2,
                        m = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), h, this.tileSize);
                    t.request = o.o(this.map._requestManager.transformRequest(m, o.R.Tile), (g, v, b, S) => (delete t.request, t.aborted ? (t.state = "unloaded", s(null)) : g ? (t.state = "errored", s(g)) : v ? (this.map._refreshExpiredTiles && t.setExpiryData({
                        cacheControl: b,
                        expires: S
                    }), t.setTexture(v, this.map.painter), t.state = "loaded", o.aK(this.dispatcher), void s(null)) : s(null)))
                }

                abortTile(t, s) {
                    t.request && (t.request.cancel(), delete t.request), s && s()
                }

                unloadTile(t, s) {
                    t.texture && t.texture instanceof o.T ? (t.destroy(!0), t.texture && t.texture instanceof o.T && this.map.painter.saveTileTexture(t.texture)) : t.destroy(), s && s()
                }

                hasTransition() {
                    return !1
                }

                cancelTileJSONRequest() {
                    this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null)
                }
            }

            class qa extends Br {
                constructor(t, s, h, m) {
                    super(t, s, h, m), this.type = "raster-array", this.maxzoom = 22, this.partial = !0, this._options = o.h({type: "raster-array"}, s)
                }

                triggerRepaint(t) {
                    const s = this.map.painter._terrain, h = this.map.style.getSourceCache(this.id);
                    s && s.enabled && h && s._clearRenderCacheForTile(h.id, t.tileID), this.map.triggerRepaint()
                }

                loadTile(t, s) {
                    const h = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize),
                        m = this.map._requestManager.transformRequest(h, o.R.Tile), g = {
                            request: m,
                            uid: t.uid,
                            tileID: t.tileID,
                            type: this.type,
                            source: this.id,
                            scope: this.scope,
                            partial: this.partial
                        };
                    t.source = this.id, t.scope = this.scope, t.requestParams = m, t.actor || (t.actor = this.dispatcher.getActor());
                    const v = (b, S, P, M) => {
                        if (delete t.request, t.aborted) return t.state = "unloaded", s(null);
                        if (b) return b.name === "AbortError" ? void 0 : (t.state = "errored", s(b));
                        if (this.map._refreshExpiredTiles && S && t.setExpiryData({
                            cacheControl: P,
                            expires: M
                        }), this.partial) t.state = "empty"; else {
                            if (!S) return s(null);
                            t.state = "loaded", t._isHeaderLoaded = !0, t._mrt = S
                        }
                        s(null)
                    };
                    t.request = this.partial ? t.fetchHeader(void 0, v.bind(this)) : t.actor.send("loadTile", g, v.bind(this), void 0, !0)
                }

                abortTile(t) {
                    t.request && (t.request.cancel(), delete t.request), t.actor && t.actor.send("abortTile", {
                        uid: t.uid,
                        type: this.type,
                        source: this.id,
                        scope: this.scope
                    })
                }

                unloadTile(t, s) {
                    const h = t.texturePerLayer;
                    if (t.flushAllQueues(), h.size) {
                        t.destroy(!0);
                        for (const m of h.values()) this.map.painter.saveTileTexture(m)
                    } else t.destroy()
                }

                prepareTile(t, s, h, m) {
                    t._isHeaderLoaded && (t.state !== "empty" && (t.state = "reloading"), t.fetchBand(s, h, m, (g, v) => {
                        if (g) return t.state = "errored", this.fire(new o.z(g)), void this.triggerRepaint(t);
                        v && (t._isHeaderLoaded = !0, t.setTexturePerLayer(h, v, this.map.painter), t.state = "loaded", this.triggerRepaint(t))
                    }))
                }

                getInitialBand(t) {
                    if (!this.rasterLayers) return 0;
                    const s = this.rasterLayers.find(({id: g}) => g === t), h = s && s.fields,
                        m = h && h.bands && h.bands;
                    return m ? m[0] : 0
                }

                getTextureDescriptor(t, s, h) {
                    if (!t) return;
                    const m = s.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0];
                    if (!m) return;
                    let g = null;
                    s instanceof o.aN ? g = s.paint.get("raster-array-band") : s instanceof o.aO && (g = s.paint.get("raster-particle-array-band"));
                    const v = g || this.getInitialBand(m);
                    if (v == null) return;
                    if (!t.textureDescriptorPerLayer.get(s.id)) return void this.prepareTile(t, m, s.id, v);
                    if (t.updateNeeded(s.id, v) && !h) return;
                    const b = t.textureDescriptorPerLayer.get(s.id);
                    return Object.assign({}, b, {texture: t.texturePerLayer.get(s.id)})
                }

                getImages(t, s) {
                    const h = new Map;
                    for (const m of t) for (const g of s) {
                        const [v, b] = g.split("/"), S = m.getLayer(v);
                        if (!S || !S.hasBand(b) || !S.hasDataForBand(b)) continue;
                        const {bytes: P, tileSize: M, buffer: k} = S.getBandView(b), R = M + 2 * k,
                            O = {data: new o.r({width: R, height: R}, P), pixelRatio: 2, sdf: !1, usvg: !1, version: 0};
                        h.set(g, O)
                    }
                    return h
                }
            }

            const cd = {
                vector: Gu, raster: Br, "raster-dem": class extends Br {
                    constructor(u, t, s, h) {
                        super(u, t, s, h), this.type = "raster-dem", this.maxzoom = 22, this._options = o.h({type: "raster-dem"}, t), this.encoding = t.encoding || "mapbox"
                    }

                    loadTile(u, t) {
                        const s = this.map._requestManager.normalizeTileURL(u.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);

                        function h(m, g) {
                            m && (u.state = "errored", t(m)), g && (u.dem = g, u.dem.onDeserialize(), u.needsHillshadePrepare = !0, u.needsDEMTextureUpload = !0, u.state = "loaded", t(null))
                        }

                        u.request = o.o(this.map._requestManager.transformRequest(s, o.R.Tile), (function (m, g, v, b) {
                            if (delete u.request, u.aborted) u.state = "unloaded", t(null); else if (m) u.state = "errored", t(m); else if (g) {
                                this.map._refreshExpiredTiles && u.setExpiryData({cacheControl: v, expires: b});
                                const S = ImageBitmap && g instanceof ImageBitmap && o.t(),
                                    P = 1 - (g.width - o.aL(g.width)) / 2;
                                P < 1 || u.neighboringTiles || (u.neighboringTiles = this._getNeighboringTiles(u.tileID));
                                const M = S ? g : o.q.getImageData(g, P), k = {
                                    uid: u.uid,
                                    tileID: u.tileID,
                                    source: this.id,
                                    type: this.type,
                                    scope: this.scope,
                                    rawImageData: M,
                                    encoding: this.encoding,
                                    padding: P
                                };
                                u.actor && u.state !== "expired" || (u.actor = this.dispatcher.getActor(), u.actor.send("loadTile", k, h.bind(this), void 0, !0))
                            }
                        }).bind(this))
                    }

                    _getNeighboringTiles(u) {
                        const t = u.canonical, s = Math.pow(2, t.z), h = (t.x - 1 + s) % s,
                            m = t.x === 0 ? u.wrap - 1 : u.wrap, g = (t.x + 1 + s) % s,
                            v = t.x + 1 === s ? u.wrap + 1 : u.wrap, b = {};
                        return b[new o.aM(u.overscaledZ, m, t.z, h, t.y).key] = {backfilled: !1}, b[new o.aM(u.overscaledZ, v, t.z, g, t.y).key] = {backfilled: !1}, t.y > 0 && (b[new o.aM(u.overscaledZ, m, t.z, h, t.y - 1).key] = {backfilled: !1}, b[new o.aM(u.overscaledZ, u.wrap, t.z, t.x, t.y - 1).key] = {backfilled: !1}, b[new o.aM(u.overscaledZ, v, t.z, g, t.y - 1).key] = {backfilled: !1}), t.y + 1 < s && (b[new o.aM(u.overscaledZ, m, t.z, h, t.y + 1).key] = {backfilled: !1}, b[new o.aM(u.overscaledZ, u.wrap, t.z, t.x, t.y + 1).key] = {backfilled: !1}, b[new o.aM(u.overscaledZ, v, t.z, g, t.y + 1).key] = {backfilled: !1}), b
                    }
                }, "raster-array": qa, geojson: class extends o.E {
                    constructor(u, t, s, h) {
                        super(), this.id = u, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = s.getActor(), this.setEventedParent(h), this._data = t.data, this._options = o.h({}, t), this._collectResourceTiming = t.collectResourceTiming, t.maxzoom !== void 0 && (this.maxzoom = t.maxzoom), t.minzoom !== void 0 && (this.minzoom = t.minzoom), t.type && (this.type = t.type), t.attribution && (this.attribution = t.attribution), this.promoteId = t.promoteId;
                        const m = o.aj / this.tileSize;
                        this.workerOptions = o.h({
                            source: this.id,
                            scope: this.scope,
                            cluster: t.cluster || !1,
                            geojsonVtOptions: {
                                buffer: (t.buffer !== void 0 ? t.buffer : 128) * m,
                                tolerance: (t.tolerance !== void 0 ? t.tolerance : .375) * m,
                                extent: o.aj,
                                maxZoom: this.maxzoom,
                                lineMetrics: t.lineMetrics || !1,
                                generateId: t.generateId || !1
                            },
                            superclusterOptions: {
                                maxZoom: t.clusterMaxZoom !== void 0 ? t.clusterMaxZoom : this.maxzoom - 1,
                                minPoints: Math.max(2, t.clusterMinPoints || 2),
                                extent: o.aj,
                                radius: (t.clusterRadius !== void 0 ? t.clusterRadius : 50) * m,
                                log: !1,
                                generateId: t.generateId || !1
                            },
                            clusterProperties: t.clusterProperties,
                            filter: t.filter,
                            dynamic: t.dynamic
                        }, t.workerOptions)
                    }

                    onAdd(u) {
                        this.map = u, this.setData(this._data)
                    }

                    setData(u) {
                        return this._data = u, this._updateWorkerData(), this
                    }

                    updateData(u) {
                        if (!this._options.dynamic) return this.fire(new o.z(new Error("Can't call updateData on a GeoJSON source with dynamic set to false.")));
                        if (typeof u != "string" && (u.type === "Feature" && (u = {
                            type: "FeatureCollection",
                            features: [u]
                        }), u.type !== "FeatureCollection")) return this.fire(new o.z(new Error("Data to update should be a feature or a feature collection.")));
                        if (this._coalesce && typeof u != "string" && typeof this._data != "string" && this._data.type === "FeatureCollection") {
                            const t = new Map;
                            for (const s of this._data.features) t.set(s.id, s);
                            for (const s of u.features) t.set(s.id, s);
                            this._data.features = [...t.values()]
                        } else this._data = u;
                        return this._updateWorkerData(!0), this
                    }

                    getClusterExpansionZoom(u, t) {
                        return this.actor.send("geojson.getClusterExpansionZoom", {
                            clusterId: u,
                            source: this.id,
                            scope: this.scope
                        }, t), this
                    }

                    getClusterChildren(u, t) {
                        return this.actor.send("geojson.getClusterChildren", {
                            clusterId: u,
                            source: this.id,
                            scope: this.scope
                        }, t), this
                    }

                    getClusterLeaves(u, t, s, h) {
                        return this.actor.send("geojson.getClusterLeaves", {
                            source: this.id,
                            scope: this.scope,
                            clusterId: u,
                            limit: t,
                            offset: s
                        }, h), this
                    }

                    _updateWorkerData(u = !1) {
                        if (this._pendingLoad) return void (this._coalesce = !0);
                        this.fire(new o.A("dataloading", {dataType: "source"})), this._loaded = !1;
                        const t = o.h({append: u}, this.workerOptions);
                        t.scope = this.scope;
                        const s = this._data;
                        typeof s == "string" ? (t.request = this.map._requestManager.transformRequest(o.q.resolveURL(s), o.R.Source), t.request.collectResourceTiming = this._collectResourceTiming) : t.data = JSON.stringify(s), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t, (h, m) => {
                            if (this._loaded = !0, this._pendingLoad = null, h) this.fire(new o.z(h)); else {
                                const g = {
                                    dataType: "source",
                                    sourceDataType: this._metadataFired ? "content" : "metadata"
                                };
                                this._collectResourceTiming && m && m.resourceTiming && m.resourceTiming[this.id] && (g.resourceTiming = m.resourceTiming[this.id]), u && (this._partialReload = !0), this.fire(new o.A("data", g)), this._partialReload = !1, this._metadataFired = !0
                            }
                            this._coalesce && (this._updateWorkerData(u), this._coalesce = !1)
                        })
                    }

                    loaded() {
                        return this._loaded
                    }

                    reload() {
                        const u = o.C(this.id, this.scope);
                        this.map.style.clearSource(u), this._updateWorkerData()
                    }

                    loadTile(u, t) {
                        const s = u.actor ? "reloadTile" : "loadTile";
                        u.actor = this.actor;
                        const h = this.map.style ? this.map.style.getLut(this.scope) : null,
                            m = h ? {image: h.image.clone()} : null, g = this._partialReload, v = {
                                type: this.type,
                                uid: u.uid,
                                tileID: u.tileID,
                                tileZoom: u.tileZoom,
                                zoom: u.tileID.overscaledZ,
                                maxZoom: this.maxzoom,
                                tileSize: this.tileSize,
                                source: this.id,
                                lut: m,
                                scope: this.scope,
                                pixelRatio: o.q.devicePixelRatio,
                                showCollisionBoxes: this.map.showCollisionBoxes,
                                promoteId: this.promoteId,
                                brightness: this.map.style && this.map.style.getBrightness() || 0,
                                extraShadowCaster: u.isExtraShadowCaster,
                                scaleFactor: this.map.getScaleFactor(),
                                partial: g,
                                worldview: this.map.getWorldview()
                            };
                        u.request = this.actor.send(s, v, (b, S) => g && !S ? (u.state = "loaded", t(null)) : (delete u.request, u.destroy(), u.aborted ? t(null) : b ? t(b) : (u.loadVectorData(S, this.map.painter, s === "reloadTile"), t(null))), void 0, s === "loadTile")
                    }

                    abortTile(u) {
                        u.request && (u.request.cancel(), delete u.request), u.aborted = !0
                    }

                    unloadTile(u, t) {
                        this.actor.send("removeTile", {
                            uid: u.uid,
                            type: this.type,
                            source: this.id,
                            scope: this.scope
                        }), u.destroy()
                    }

                    onRemove(u) {
                        this._pendingLoad && this._pendingLoad.cancel()
                    }

                    serialize() {
                        return o.h({}, this._options, {type: this.type, data: this._data})
                    }

                    hasTransition() {
                        return !1
                    }
                }, video: class extends o.aP {
                    constructor(u, t, s, h) {
                        super(u, t, s, h), this.roundZoom = !0, this.type = "video", this.options = t
                    }

                    load() {
                        this._loaded = !1;
                        const u = this.options;
                        this.urls = [];
                        for (const t of u.urls) this.urls.push(this.map._requestManager.transformRequest(t, o.R.Source).url);
                        o.aQ(this.urls, (t, s) => {
                            this._loaded = !0, t ? this.fire(new o.z(t)) : s && (this.video = s, this.video.loop = !0, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
                                this.map.triggerRepaint()
                            }), this.map && this.video.play(), this._finishLoading())
                        })
                    }

                    pause() {
                        this.video && this.video.pause()
                    }

                    play() {
                        this.video && this.video.play()
                    }

                    seek(u) {
                        if (this.video) {
                            const t = this.video.seekable;
                            u < t.start(0) || u > t.end(0) ? this.fire(new o.z(new o.V(`sources.${this.id}`, null, `Playback for this video can be set only between the ${t.start(0)} and ${t.end(0)}-second mark.`))) : this.video.currentTime = u
                        }
                    }

                    getVideo() {
                        return this.video
                    }

                    onAdd(u) {
                        this.map || (this.map = u, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)))
                    }

                    prepare() {
                        if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
                        const u = this.map.painter.context, t = u.gl;
                        this.texture ? this.video.paused || (this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE), t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, t.RGBA, t.UNSIGNED_BYTE, this.video)) : (this.texture = new o.T(u, this.video, t.RGBA8), this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(u)
                    }

                    serialize() {
                        return {type: "video", urls: this.urls, coordinates: this.coordinates}
                    }

                    hasTransition() {
                        return this.video && !this.video.paused
                    }
                }, image: o.aP, model: class extends o.E {
                    constructor(u, t, s, h) {
                        super(), this.id = u, this.type = "model", this.models = [], this._loaded = !1, this._options = t
                    }

                    load() {
                        const u = [];
                        for (const t in this._options.models) {
                            const s = this._options.models[t],
                                h = o.aS(this.map._requestManager.transformRequest(s.uri, o.R.Model).url).then(m => {
                                    if (!m) return;
                                    const g = o.aT(m), v = new o.aU(t, s.position, s.orientation, g);
                                    v.computeBoundsAndApplyParent(), this.models.push(v)
                                }).catch(m => {
                                    this.fire(new o.z(new Error(`Could not load model ${t} from ${s.uri}: ${m.message}`)))
                                });
                            u.push(h)
                        }
                        Promise.allSettled(u).then(() => {
                            this._loaded = !0, this.fire(new o.A("data", {
                                dataType: "source",
                                sourceDataType: "metadata"
                            }))
                        }).catch(t => {
                            this._loaded = !0, this.fire(new o.z(new Error(`Could not load models: ${t.message}`)))
                        })
                    }

                    onAdd(u) {
                        this.map = u, this.load()
                    }

                    hasTransition() {
                        return !1
                    }

                    loaded() {
                        return this._loaded
                    }

                    getModels() {
                        return this.models
                    }

                    loadTile(u, t) {
                    }

                    serialize() {
                        return this._options
                    }
                }, "batched-model": class extends o.E {
                    constructor(u, t, s, h) {
                        super(), this.type = "batched-model", this.id = u, this.tileSize = 512, this._options = t, this.tiles = this._options.tiles, this.maxzoom = t.maxzoom || 19, this.minzoom = t.minzoom || 0, this.roundZoom = !0, this.usedInConflation = !0, this.dispatcher = s, this.reparseOverscaled = !1, this.scheme = "xyz", this._loaded = !1, this.setEventedParent(h)
                    }

                    onAdd(u) {
                        this.map = u, this.load()
                    }

                    reload() {
                        this.cancelTileJSONRequest();
                        const u = o.C(this.id, this.scope);
                        this.load(() => this.map.style.clearSource(u))
                    }

                    cancelTileJSONRequest() {
                        this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null)
                    }

                    load(u) {
                        this._loaded = !1, this.fire(new o.A("dataloading", {dataType: "source"}));
                        const t = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language,
                            s = this.map.getWorldview();
                        this._tileJSONRequest = Pr(this._options, this.map._requestManager, t, s, (h, m) => {
                            this._tileJSONRequest = null, this._loaded = !0, h ? (t && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${t}`), s && s.length !== 2 && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${s}`), this.fire(new o.z(h))) : m && (o.h(this, m), m.bounds && (this.tileBounds = new Qr(m.bounds, this.minzoom, this.maxzoom)), fi(m.tiles, this.map._requestManager._customAccessToken), this.fire(new o.A("data", {
                                dataType: "source",
                                sourceDataType: "metadata"
                            })), this.fire(new o.A("data", {dataType: "source", sourceDataType: "content"}))), u && u(h)
                        })
                    }

                    hasTransition() {
                        return !1
                    }

                    hasTile(u) {
                        return !this.tileBounds || this.tileBounds.contains(u.canonical)
                    }

                    loaded() {
                        return this._loaded
                    }

                    loadTile(u, t) {
                        const s = this.map._requestManager.normalizeTileURL(u.tileID.canonical.url(this.tiles, this.scheme)),
                            h = {
                                request: this.map._requestManager.transformRequest(s, o.R.Tile),
                                data: void 0,
                                uid: u.uid,
                                tileID: u.tileID,
                                tileZoom: u.tileZoom,
                                zoom: u.tileID.overscaledZ,
                                tileSize: this.tileSize * u.tileID.overscaleFactor(),
                                type: this.type,
                                source: this.id,
                                scope: this.scope,
                                showCollisionBoxes: this.map.showCollisionBoxes,
                                isSymbolTile: u.isSymbolTile,
                                brightness: this.map.style && this.map.style.getBrightness() || 0,
                                pixelRatio: o.q.devicePixelRatio,
                                promoteId: this.promoteId
                            };
                        if (u.actor && u.state !== "expired") if (u.state === "loading") u.reloadCallback = t; else {
                            if (u.buckets) {
                                const g = Object.values(u.buckets);
                                for (const v of g) v.dirty = !0;
                                return void (u.state = "loaded")
                            }
                            u.request = u.actor.send("reloadTile", h, m.bind(this))
                        } else u.actor = this.dispatcher.getActor(), u.request = u.actor.send("loadTile", h, m.bind(this), void 0, !0);

                        function m(g, v) {
                            return u.aborted ? t(null) : g && g.status !== 404 ? t(g) : (this.map._refreshExpiredTiles && v && u.setExpiryData(v), u.loadModelData(v, this.map.painter), u.state = "loaded", void t(null))
                        }
                    }

                    serialize() {
                        return o.h({}, this._options)
                    }
                }, canvas: class extends o.aP {
                    constructor(u, t, s, h) {
                        super(u, t, s, h), t.coordinates ? Array.isArray(t.coordinates) && t.coordinates.length === 4 && !t.coordinates.some(m => !Array.isArray(m) || m.length !== 2 || m.some(g => typeof g != "number")) || this.fire(new o.z(new o.V(`sources.${u}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new o.z(new o.V(`sources.${u}`, null, 'missing required property "coordinates"'))), t.animate && typeof t.animate != "boolean" && this.fire(new o.z(new o.V(`sources.${u}`, null, 'optional "animate" property must be a boolean value'))), t.canvas ? typeof t.canvas == "string" || t.canvas instanceof HTMLCanvasElement || this.fire(new o.z(new o.V(`sources.${u}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new o.z(new o.V(`sources.${u}`, null, 'missing required property "canvas"'))), this.options = t, this.animate = t.animate === void 0 || t.animate
                    }

                    load() {
                        this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new o.z(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function () {
                            this._playing = !0, this.map.triggerRepaint()
                        }, this.pause = function () {
                            this._playing && (this.prepare(), this._playing = !1)
                        }, this._finishLoading())
                    }

                    getCanvas() {
                        return this.canvas
                    }

                    onAdd(u) {
                        this.map = u, this.load(), this.canvas && this.animate && this.play()
                    }

                    onRemove(u) {
                        this.pause()
                    }

                    prepare() {
                        let u = !1;
                        if (this.canvas.width !== this.width && (this.width = this.canvas.width, u = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, u = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
                        const t = this.map.painter.context;
                        this.texture ? !u && !this._playing || this.texture instanceof o.aR || this.texture.update(this.canvas, {premultiply: !0}) : this.texture = new o.T(t, this.canvas, t.gl.RGBA8, {premultiply: !0}), this._prepareData(t)
                    }

                    serialize() {
                        return {type: "canvas", coordinates: this.coordinates}
                    }

                    hasTransition() {
                        return this._playing
                    }

                    _hasInvalidDimensions() {
                        for (const u of [this.canvas.width, this.canvas.height]) if (isNaN(u) || u <= 0) return !0;
                        return !1
                    }
                }, custom: class extends o.E {
                    constructor(u, t, s, h) {
                        super(), this.id = u, this.type = "custom", this._dataType = "raster", this._dispatcher = s, this._implementation = t, this.setEventedParent(h), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new o.z(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new o.z(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new Qr(this._implementation.bounds, this.minzoom, this.maxzoom)), t.update = this._update.bind(this), t.clearTiles = this._clearTiles.bind(this), t.coveringTiles = this._coveringTiles.bind(this), o.h(this, o.aF(t, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]))
                    }

                    serialize() {
                        return o.aF(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"])
                    }

                    load() {
                        this._loaded = !0, this.fire(new o.A("data", {
                            dataType: "source",
                            sourceDataType: "metadata"
                        })), this.fire(new o.A("data", {dataType: "source", sourceDataType: "content"}))
                    }

                    loaded() {
                        return this._loaded
                    }

                    onAdd(u) {
                        this.map = u, this._loaded = !1, this.fire(new o.A("dataloading", {dataType: "source"})), this._implementation.onAdd && this._implementation.onAdd(u), this.load()
                    }

                    onRemove(u) {
                        this._implementation.onRemove && this._implementation.onRemove(u)
                    }

                    hasTile(u) {
                        if (this._implementation.hasTile) {
                            const {x: t, y: s, z: h} = u.canonical;
                            return this._implementation.hasTile({x: t, y: s, z: h})
                        }
                        return !this.tileBounds || this.tileBounds.contains(u.canonical)
                    }

                    loadTile(u, t) {
                        const {x: s, y: h, z: m} = u.tileID.canonical, g = new AbortController;
                        u.request = Promise.resolve(this._implementation.loadTile({
                            x: s,
                            y: h,
                            z: m
                        }, {signal: g.signal})).then((function (v) {
                            return delete u.request, u.aborted ? (u.state = "unloaded", t(null)) : v === void 0 ? (u.state = "errored", t(null)) : v === null ? (this.loadTileData(u, {
                                width: this.tileSize,
                                height: this.tileSize,
                                data: null
                            }), u.state = "loaded", t(null)) : function (b) {
                                return b instanceof ImageData || b instanceof HTMLCanvasElement || b instanceof ImageBitmap || b instanceof HTMLImageElement
                            }(v) ? (this.loadTileData(u, v), u.state = "loaded", void t(null)) : (u.state = "errored", t(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)))
                        }).bind(this)).catch(v => {
                            v.name !== "AbortError" && (u.state = "errored", t(v))
                        }), u.request.cancel = () => g.abort()
                    }

                    loadTileData(u, t) {
                        u.setTexture(t, this.map.painter)
                    }

                    unloadTile(u, t) {
                        if (u.texture && u.texture instanceof o.T ? (u.destroy(!0), u.texture && u.texture instanceof o.T && this.map.painter.saveTileTexture(u.texture)) : u.destroy(), this._implementation.unloadTile) {
                            const {x: s, y: h, z: m} = u.tileID.canonical;
                            this._implementation.unloadTile({x: s, y: h, z: m})
                        }
                        t && t()
                    }

                    abortTile(u, t) {
                        u.request && u.request.cancel && (u.request.cancel(), delete u.request), t && t()
                    }

                    hasTransition() {
                        return !1
                    }

                    _coveringTiles() {
                        return this.map.transform.coveringTiles({
                            tileSize: this.tileSize,
                            minzoom: this.minzoom,
                            maxzoom: this.maxzoom,
                            roundZoom: this.roundZoom
                        }).map(u => ({x: u.canonical.x, y: u.canonical.y, z: u.canonical.z}))
                    }

                    _clearTiles() {
                        const u = o.C(this.id, this.scope);
                        this.map.style.clearSource(u)
                    }

                    _update() {
                        this.fire(new o.A("data", {dataType: "source", sourceDataType: "content"}))
                    }
                }
            }, $u = function (u, t, s, h) {
                const m = new cd[t.type](u, t, s, h);
                if (m.id !== u) throw new Error(`Expected Source id to be ${u} instead of ${m.id}`);
                return o.aV(["load", "abort", "unload", "serialize", "prepare"], m), m
            };

            function Hu(u, t, s = "") {
                return `${s}:${t.id || ""}:${t.layer.id}:${function (h) {
                    if ("layerId" in h) return `layer:${h.layerId}`;
                    {
                        const {featuresetId: m, importId: g} = h;
                        return `featureset:${m}${g ? `:import:${g}` : ""}`
                    }
                }(u.target)}`
            }

            function ud(u, t, s, h = "") {
                if (u.uniqueFeatureID) {
                    const m = Hu(u, t, h);
                    if (s.has(m)) return !0;
                    s.add(m)
                }
                return !1
            }

            function hd(u, t, s, h, m = !1) {
                const g = t.sourceCache.transform, v = t.sourceCache.tilesIn(u, t.has3DLayers, m);
                v.sort(dd);
                const b = [];
                for (const S of v) {
                    const P = S.tile.queryRenderedFeatures(t, S, s, h, g, m);
                    Object.keys(P).length && b.push({wrappedTileID: S.tile.tileID.wrapped().key, queryResults: P})
                }
                return b.length === 0 ? {} : function (S) {
                    const P = {}, M = {};
                    for (const k of S) {
                        const R = k.queryResults, O = k.wrappedTileID, V = M[O] = M[O] || {};
                        for (const B in R) {
                            const G = R[B], U = V[B] = V[B] || {}, Z = P[B] = P[B] || [];
                            for (const Q of G) U[Q.featureIndex] || (U[Q.featureIndex] = !0, Z.push(Q))
                        }
                    }
                    return P
                }(b)
            }

            function Rl(u, t, s, h, m, g) {
                const v = {}, b = h.queryRenderedSymbols(u), S = [];
                for (const P of Object.keys(b).map(Number)) S.push(m[P]);
                S.sort(dd);
                for (const P of S) {
                    const M = P.featureIndex.lookupSymbolFeatures(b[P.bucketInstanceId], P.bucketIndex, P.sourceLayerIndex, t, s, g);
                    for (const k in M) {
                        const R = v[k] = v[k] || [], O = M[k];
                        O.sort((V, B) => {
                            const G = P.featureSortOrder;
                            if (G) {
                                const U = G.indexOf(V.featureIndex);
                                return G.indexOf(B.featureIndex) - U
                            }
                            return B.featureIndex - V.featureIndex
                        });
                        for (const V of O) R.push(V)
                    }
                }
                return v
            }

            function qu(u, t) {
                const s = u.getRenderableIds().map(g => u.getTileByID(g)), h = [], m = {};
                for (let g = 0; g < s.length; g++) {
                    const v = s[g], b = v.tileID.canonical.key;
                    m[b] || (m[b] = !0, v.querySourceFeatures(h, t))
                }
                return h
            }

            function dd(u, t) {
                const s = u.tileID, h = t.tileID;
                return s.overscaledZ - h.overscaledZ || s.canonical.y - h.canonical.y || s.wrap - h.wrap || s.canonical.x - h.canonical.x
            }

            function ks(u, t) {
                const s = {};
                if (!t) return s;
                for (const h of u) {
                    const m = h.layerIds.map(g => t.getLayer(g)).filter(Boolean);
                    if (m.length !== 0) {
                        h.layers = m, h.stateDependentLayerIds && (h.stateDependentLayers = h.stateDependentLayerIds.map(g => m.filter(v => v.id === g)[0]));
                        for (const g of m) s[g.fqid] = h
                    }
                }
                return s
            }

            const Zo = 32, _s = 33, ma = new Uint16Array(8184);
            for (let u = 0; u < 2046; u++) {
                let t = u + 2, s = 0, h = 0, m = 0, g = 0, v = 0, b = 0;
                for (1 & t ? m = g = v = Zo : s = h = b = Zo; (t >>= 1) > 1;) {
                    const P = s + m >> 1, M = h + g >> 1;
                    1 & t ? (m = s, g = h, s = v, h = b) : (s = m, h = g, m = v, g = b), v = P, b = M
                }
                const S = 4 * u;
                ma[S + 0] = s, ma[S + 1] = h, ma[S + 2] = m, ma[S + 3] = g
            }
            const Os = new Uint16Array(2178), ga = new Uint8Array(1089), Wu = new Uint16Array(1089);

            function Ys(u) {
                return u === 0 ? -.03125 : u === 32 ? .03125 : 0
            }

            const Zu = {
                type: 2,
                extent: o.aj,
                loadGeometry: () => [[new o.P(0, 0), new o.P(o.aj + 1, 0), new o.P(o.aj + 1, o.aj + 1), new o.P(0, o.aj + 1), new o.P(0, 0)]]
            };

            class zl {
                constructor(t, s, h, m, g, v) {
                    this.tileID = t, this.uid = o.a$(), this.uses = 0, this.tileSize = s, this.tileZoom = h, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = g, m && m.style && (this._lastUpdatedBrightness = m.style.getBrightness()), this.expiredRequestCount = 0, this.state = "loading", m && m.transform && (this.projection = m.transform.projection), this.worldview = v
                }

                registerFadeDuration(t) {
                    const s = t + this.timeAdded;
                    s < o.q.now() || this.fadeEndTime && s < this.fadeEndTime || (this.fadeEndTime = s)
                }

                wasRequested() {
                    return this.state === "errored" || this.state === "loaded" || this.state === "reloading"
                }

                get tileTransform() {
                    return this._tileTransform || (this._tileTransform = o.aW(this.tileID.canonical, this.projection)), this._tileTransform
                }

                loadVectorData(t, s, h) {
                    if (this.unloadVectorData(), this.state = "loaded", t) {
                        t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = ks(t.buckets, s.style), this.hasSymbolBuckets = !1;
                        for (const m in this.buckets) {
                            const g = this.buckets[m];
                            if (g instanceof o.b1) {
                                if (this.hasSymbolBuckets = !0, !h) break;
                                g.justReloaded = !0
                            }
                        }
                        if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const m in this.buckets) {
                            const g = this.buckets[m];
                            if (g instanceof o.b1 && g.hasRTLText) {
                                this.hasRTLText = !0, o.b2();
                                break
                            }
                        }
                        this.queryPadding = 0;
                        for (const m in this.buckets) {
                            const g = this.buckets[m], v = s.style.getOwnLayer(m);
                            if (!v) continue;
                            const b = v.queryRadius(g);
                            this.queryPadding = Math.max(this.queryPadding, b)
                        }
                        t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage), t.lineAtlas && (this.lineAtlas = t.lineAtlas), this._lastUpdatedBrightness = t.brightness
                    } else this.collisionBoxArray = new o.b0
                }

                unloadVectorData() {
                    if (this.hasData()) {
                        for (const t in this.buckets) this.buckets[t].destroy();
                        this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded"
                    }
                }

                loadModelData(t, s, h) {
                    t && (t.resourceTiming && (this.resourceTiming = t.resourceTiming), this.buckets = Object.assign({}, this.buckets, ks(t.buckets, s.style)), t.featureIndex && (this.latestFeatureIndex = t.featureIndex))
                }

                getBucket(t) {
                    return this.buckets[t.fqid]
                }

                upload(t) {
                    for (const m in this.buckets) {
                        const g = this.buckets[m];
                        g.uploadPending() && g.upload(t)
                    }
                    const s = t.gl, h = this.imageAtlas;
                    h && !h.uploaded && (this.imageAtlasTexture = new o.T(t, h.image, s.RGBA8, {useMipmap: !!h.patternPositions.size}), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new o.T(t, this.glyphAtlasImage, s.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new o.T(t, this.lineAtlas.image, s.R8), this.lineAtlas.uploaded = !0)
                }

                prepare(t, s, h) {
                    if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture, h), !s || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) return;
                    const m = s.style.getBrightness();
                    (this._lastUpdatedBrightness || m) && (this._lastUpdatedBrightness && m && Math.abs(this._lastUpdatedBrightness - m) < .001 || (this.updateBuckets(s, this._lastUpdatedBrightness !== m), this._lastUpdatedBrightness = m))
                }

                queryRenderedFeatures(t, s, h, m, g, v) {
                    if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData && !this.latestFeatureIndex.is3DTile) return {};
                    const b = function (S, P) {
                        const M = o.bn([], [.5 * S.width, .5 * -S.height, 1]);
                        return o.bo(M, M, [1, -1, 0]), o.az(M, M, S.calculateProjMatrix(P.toUnwrapped())), Float32Array.from(M)
                    }(g, this.tileID);
                    return this.latestFeatureIndex.query(t, {
                        tilespaceGeometry: s,
                        pixelPosMatrix: b,
                        transform: m,
                        availableImages: h,
                        tileTransform: this.tileTransform,
                        worldview: this.worldview
                    })
                }

                querySourceFeatures(t, s) {
                    const h = this.latestFeatureIndex;
                    if (!h || !h.rawTileData) return;
                    const m = h.loadVTLayers(), g = s ? s.sourceLayer : "", v = m._geojsonTileLayer || m[g];
                    if (!v) return;
                    const b = o.b3(s && s.filter), {z: S, x: P, y: M} = this.tileID.canonical, k = {z: S, x: P, y: M};
                    for (let R = 0; R < v.length; R++) {
                        const O = v.feature(R);
                        if (b.needGeometry) {
                            const G = o.b4(O, !0);
                            if (!b.filter(new o.aa(this.tileID.overscaledZ, {worldview: this.worldview}), G, this.tileID.canonical)) continue
                        } else if (!b.filter(new o.aa(this.tileID.overscaledZ, {worldview: this.worldview}), O)) continue;
                        const V = h.getId(O, g), B = new o.b5(O, S, P, M, V);
                        B.tile = k, t.push(B)
                    }
                }

                loaded() {
                    return this.state === "loaded" || this.state === "errored"
                }

                hasData() {
                    return this.state === "loaded" || this.state === "reloading" || this.state === "expired"
                }

                patternsLoaded() {
                    return !!this.imageAtlas && !!this.imageAtlas.patternPositions.size
                }

                setExpiryData(t) {
                    const s = this.expirationTime;
                    if (t.cacheControl) {
                        const h = o.b6(t.cacheControl);
                        h["max-age"] && (this.expirationTime = Date.now() + 1e3 * h["max-age"])
                    } else t.expires && (this.expirationTime = new Date(t.expires).getTime());
                    if (this.expirationTime) {
                        const h = Date.now();
                        let m = !1;
                        if (this.expirationTime > h) m = !1; else if (s) if (this.expirationTime < s) m = !0; else {
                            const g = this.expirationTime - s;
                            g ? this.expirationTime = h + Math.max(g, 3e4) : m = !0
                        } else m = !0;
                        m ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0
                    }
                }

                getExpiryTimeout() {
                    if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1)
                }

                refreshFeatureState(t) {
                    this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) && t && this.updateBuckets(t)
                }

                updateBuckets(t, s) {
                    if (!this.latestFeatureIndex || !t.style) return;
                    const h = this.latestFeatureIndex.loadVTLayers(), m = t.style.listImages(),
                        g = t.style.getBrightness();
                    for (const v in this.buckets) {
                        if (!t.style.hasLayer(v)) continue;
                        const b = this.buckets[v], S = b.layers[0], P = S.sourceLayer || "_geojsonTileLayer", M = h[P],
                            k = t.style.getLayerSourceCache(S);
                        let R = {};
                        k && (R = k._state.getState(P, void 0));
                        const O = this.imageAtlas ? Object.fromEntries(this.imageAtlas.patternPositions) : {},
                            V = Object.keys(R).length > 0 && !s;
                        V && !b.stateDependentLayers.length && !s || b.update(R, M, m, O, V ? b.stateDependentLayers : b.layers, s, g), (b instanceof o.b7 || b instanceof o.b8) && t._terrain && t._terrain.enabled && k && b.uploadPending() && t._terrain._clearRenderCacheForTile(k.id, this.tileID);
                        const B = t && t.style && t.style.getOwnLayer(v);
                        B && (this.queryPadding = Math.max(this.queryPadding, B.queryRadius(b)))
                    }
                }

                holdingForFade() {
                    return this.symbolFadeHoldUntil !== void 0
                }

                symbolFadeFinished() {
                    return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < o.q.now()
                }

                clearFadeHold() {
                    this.symbolFadeHoldUntil = void 0
                }

                setHoldDuration(t) {
                    this.symbolFadeHoldUntil = o.q.now() + t
                }

                setTexture(t, s) {
                    const h = s.context, m = h.gl;
                    this.texture = this.texture || s.getTileTexture(t.width), this.texture && this.texture instanceof o.T ? this.texture.update(t) : (this.texture = new o.T(h, t, m.RGBA8, {useMipmap: !0}), this.texture.bind(m.LINEAR, m.CLAMP_TO_EDGE))
                }

                setDependencies(t, s) {
                    const h = {};
                    for (const m of s) h[m] = !0;
                    this.dependencies[t] = h
                }

                hasDependency(t, s) {
                    for (const h of t) {
                        const m = this.dependencies[h];
                        if (m) {
                            for (const g of s) if (m[g]) return !0
                        }
                    }
                    return !1
                }

                clearQueryDebugViz() {
                }

                _makeDebugTileBoundsBuffers(t, s) {
                    if (!s || s.name === "mercator" || this._tileDebugBuffer) return;
                    const h = o.b9(Zu, this.tileID.canonical, this.tileTransform)[0], m = new o.ba, g = new o.bb;
                    for (let v = 0; v < h.length; v++) {
                        const {x: b, y: S} = h[v];
                        m.emplaceBack(b, S), g.emplaceBack(v)
                    }
                    g.emplaceBack(0), this._tileDebugIndexBuffer = t.createIndexBuffer(g), this._tileDebugBuffer = t.createVertexBuffer(m, o.bc.members), this._tileDebugSegments = o.bd.simpleSegment(0, 0, m.length, g.length)
                }

                _makeTileBoundsBuffers(t, s) {
                    if (this._tileBoundsBuffer || !s || s.name === "mercator") return;
                    const h = o.b9(Zu, this.tileID.canonical, this.tileTransform)[0];
                    let m, g;
                    if (this.isRaster) {
                        const v = function (b, S) {
                            const P = o.aW(b, S), M = Math.pow(2, b.z);
                            for (let G = 0; G < _s; G++) for (let U = 0; U < _s; U++) {
                                const Z = o.aX((b.x + (U + Ys(U)) / Zo) / M), Q = o.aY((b.y + (G + Ys(G)) / Zo) / M),
                                    te = S.project(Z, Q), ce = G * _s + U;
                                Os[2 * ce + 0] = Math.round((te.x * P.scale - P.x) * o.aj), Os[2 * ce + 1] = Math.round((te.y * P.scale - P.y) * o.aj)
                            }
                            ga.fill(0), Wu.fill(0);
                            for (let G = 2045; G >= 0; G--) {
                                const U = 4 * G, Z = ma[U + 0], Q = ma[U + 1], te = ma[U + 2], ce = ma[U + 3],
                                    _e = Z + te >> 1, ve = Q + ce >> 1, ue = _e + ve - Q, he = ve + Z - _e,
                                    me = Q * _s + Z, Oe = ce * _s + te, Se = ve * _s + _e,
                                    Xe = Math.hypot((Os[2 * me + 0] + Os[2 * Oe + 0]) / 2 - Os[2 * Se + 0], (Os[2 * me + 1] + Os[2 * Oe + 1]) / 2 - Os[2 * Se + 1]) >= 16;
                                ga[Se] = ga[Se] || (Xe ? 1 : 0), G < 1022 && (ga[Se] = ga[Se] || ga[(Q + he >> 1) * _s + (Z + ue >> 1)] || ga[(ce + he >> 1) * _s + (te + ue >> 1)])
                            }
                            const k = new o.aZ, R = new o.a_;
                            let O = 0;

                            function V(G, U) {
                                const Z = U * _s + G;
                                return Wu[Z] === 0 && (k.emplaceBack(Os[2 * Z + 0], Os[2 * Z + 1], G * o.aj / Zo, U * o.aj / Zo), Wu[Z] = ++O), Wu[Z] - 1
                            }

                            function B(G, U, Z, Q, te, ce) {
                                const _e = G + Z >> 1, ve = U + Q >> 1;
                                if (Math.abs(G - te) + Math.abs(U - ce) > 1 && ga[ve * _s + _e]) B(te, ce, G, U, _e, ve), B(Z, Q, te, ce, _e, ve); else {
                                    const ue = V(G, U), he = V(Z, Q), me = V(te, ce);
                                    R.emplaceBack(ue, he, me)
                                }
                            }

                            return B(0, 0, Zo, Zo, Zo, 0), B(Zo, Zo, 0, 0, 0, Zo), {vertices: k, indices: R}
                        }(this.tileID.canonical, s);
                        m = v.vertices, g = v.indices
                    } else {
                        m = new o.aZ, g = new o.a_;
                        for (const {x: b, y: S} of h) m.emplaceBack(b, S, 0, 0);
                        const v = o.be(m.int16.subarray(0, 4 * m.length), void 0, 4);
                        for (let b = 0; b < v.length; b += 3) g.emplaceBack(v[b], v[b + 1], v[b + 2])
                    }
                    this._tileBoundsBuffer = t.createVertexBuffer(m, o.bf.members), this._tileBoundsIndexBuffer = t.createIndexBuffer(g), this._tileBoundsSegments = o.bd.simpleSegment(0, 0, m.length, g.length)
                }

                _makeGlobeTileDebugBuffers(t, s) {
                    const h = s.projection;
                    if (!h || h.name !== "globe" || s.freezeTileCoverage) return;
                    const m = this.tileID.canonical, g = o.bg(m, s), v = o.bh(g), b = o.ah(s.zoom);
                    let S;
                    b > 0 && (S = o.bi(new Float64Array(16), s.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t, m, s, v, S, b), this._makeGlobeTileDebugTextBuffer(t, m, s, v, S, b)
                }

                _globePoint(t, s, h, m, g, v, b) {
                    let S = o.bj(t, s, h);
                    if (v) {
                        const P = 1 << h.z, M = o.aD(m.center.lng), k = o.aH(m.center.lat), R = (h.x + .5) / P - M;
                        let O = 0;
                        R > .5 ? O = -1 : R < -.5 && (O = 1);
                        let V = (t / o.aj + h.x) / P + O, B = (s / o.aj + h.y) / P;
                        V = (V - M) * m._pixelsPerMercatorPixel + M, B = (B - k) * m._pixelsPerMercatorPixel + k;
                        const G = [V * m.worldSize, B * m.worldSize, 0];
                        o.ad(G, G, v), S = o.bk(S, G, b)
                    }
                    return o.ad(S, S, g)
                }

                _makeGlobeTileDebugBorderBuffer(t, s, h, m, g, v) {
                    const b = new o.ba, S = new o.bb, P = new o.bl, M = (R, O, V, B, G) => {
                        const U = (V - R) / (G - 1), Z = (B - O) / (G - 1), Q = b.length;
                        for (let te = 0; te < G; te++) {
                            const ce = R + te * U, _e = O + te * Z;
                            b.emplaceBack(ce, _e);
                            const ve = this._globePoint(ce, _e, s, h, m, g, v);
                            P.emplaceBack(ve[0], ve[1], ve[2]), S.emplaceBack(Q + te)
                        }
                    }, k = o.aj;
                    M(0, 0, k, 0, 16), M(k, 0, k, k, 16), M(k, k, 0, k, 16), M(0, k, 0, 0, 16), this._tileDebugIndexBuffer = t.createIndexBuffer(S), this._tileDebugBuffer = t.createVertexBuffer(b, o.bc.members), this._globeTileDebugBorderBuffer = t.createVertexBuffer(P, o.bm.members), this._tileDebugSegments = o.bd.simpleSegment(0, 0, b.length, S.length)
                }

                _makeGlobeTileDebugTextBuffer(t, s, h, m, g, v) {
                    const b = o.aj / 4, S = new o.ba, P = new o.a_, M = new o.bl, k = 25;
                    P.reserve(32), S.reserve(k), M.reserve(k);
                    const R = (O, V) => k * O + V;
                    for (let O = 0; O < k; O++) {
                        const V = O * b;
                        for (let B = 0; B < k; B++) {
                            const G = B * b;
                            S.emplaceBack(G, V);
                            const U = this._globePoint(G, V, s, h, m, g, v);
                            M.emplaceBack(U[0], U[1], U[2])
                        }
                    }
                    for (let O = 0; O < 4; O++) for (let V = 0; V < 4; V++) {
                        const B = R(O, V), G = R(O, V + 1), U = R(O + 1, V), Z = R(O + 1, V + 1);
                        P.emplaceBack(B, G, U), P.emplaceBack(U, G, Z)
                    }
                    this._tileDebugTextIndexBuffer = t.createIndexBuffer(P), this._tileDebugTextBuffer = t.createVertexBuffer(S, o.bc.members), this._globeTileDebugTextBuffer = t.createVertexBuffer(M, o.bm.members), this._tileDebugTextSegments = o.bd.simpleSegment(0, 0, k, 32)
                }

                destroy(t = !1) {
                    for (const s in this.buckets) this.buckets[s].destroy();
                    this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), !t && this.texture && this.texture instanceof o.T && (this.texture.destroy(), delete this.texture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.rasterParticleState && (this.rasterParticleState.destroy(), delete this.rasterParticleState), this.latestFeatureIndex = null, this.state = "unloaded"
                }
            }

            o.bp.setPbf(o.bq);

            class gc extends zl {
                constructor(t, s, h, m, g) {
                    super(t, s, h, m, g), this._workQueuePerLayer = new Map, this._fetchQueuePerLayer = new Map, this._isHeaderLoaded = !1, this.textureDescriptorPerLayer = new Map, this.texturePerLayer = new Map
                }

                getLayers() {
                    return this._mrt ? Object.values(this._mrt.layers) : []
                }

                getLayer(t) {
                    return this._mrt && this._mrt.getLayer(t)
                }

                setTexturePerLayer(t, s, h) {
                    const m = h.context, g = m.gl;
                    let v = this.texturePerLayer.get(t) || h.getTileTexture(s.width);
                    v && v instanceof o.T ? v.update(s, {premultiply: !1}) : v = new o.T(m, s, g.RGBA8, {premultiply: !1}), this.texturePerLayer.has(t) || this.texturePerLayer.set(t, v)
                }

                flushQueues(t) {
                    const s = this._workQueuePerLayer.get(t) || [], h = this._fetchQueuePerLayer.get(t) || [];
                    for (; s.length;) s.pop()();
                    for (; h.length;) h.pop()()
                }

                flushAllQueues() {
                    for (const t of this._workQueuePerLayer.keys()) {
                        const s = this._workQueuePerLayer.get(t) || [];
                        for (; s.length;) s.pop()()
                    }
                    for (const t of this._fetchQueuePerLayer.keys()) {
                        const s = this._fetchQueuePerLayer.get(t) || [];
                        for (; s.length;) s.pop()()
                    }
                }

                fetchHeader(t = 16384, s) {
                    const h = this._mrt = new o.bp(30),
                        m = Object.assign({}, this.requestParams, {headers: {Range: "bytes=0-" + (t - 1)}});
                    return this.entireBuffer = null, this.request = o.br(m, (g, v, b, S) => {
                        if (g) s(g); else try {
                            const P = h.getHeaderLength(v);
                            if (P > t) return void (this.request = this.fetchHeader(P, s));
                            h.parseHeader(v), this._isHeaderLoaded = !0;
                            let M = 0;
                            for (const k of Object.values(h.layers)) M = Math.max(M, k.dataIndex[k.dataIndex.length - 1].lastByte);
                            v.byteLength >= M && (this.entireBuffer = v), s(null, this.entireBuffer || v, b, S)
                        } catch (P) {
                            s(P)
                        }
                    }), this.request
                }

                fetchBand(t, s, h, m) {
                    const g = this._mrt;
                    if (!this._isHeaderLoaded || !g) return void m(new Error("Tile header is not ready"));
                    const v = this.actor;
                    if (!v) return void m(new Error("Can't fetch tile band without an actor"));
                    let b;
                    const S = (R, O) => {
                        if (b.complete(R, O), R) return void m(R);
                        this.updateTextureDescriptor(t, s, h);
                        const V = this.textureDescriptorPerLayer.get(s);
                        m(null, V && V.img)
                    }, P = (R, O) => {
                        if (R) return m(R);
                        const V = v.send("decodeRasterArray", {
                            type: "raster-array",
                            source: this.source,
                            scope: this.scope,
                            tileID: this.tileID,
                            uid: this.uid,
                            buffer: O,
                            task: b
                        }, S, void 0, !0), B = this._workQueuePerLayer.get(s) || [];
                        B.push(() => {
                            V && V.cancel(), b.cancel()
                        }), this._workQueuePerLayer.has(s) || this._workQueuePerLayer.set(s, B)
                    }, M = g.getLayer(t);
                    if (!M) return void m(new Error(`Unknown sourceLayer "${t}"`));
                    if (M.hasDataForBand(h)) {
                        this.updateTextureDescriptor(t, s, h);
                        const R = this.textureDescriptorPerLayer.get(s);
                        return void m(null, R ? R.img : null)
                    }
                    const k = M.getDataRange([h]);
                    if (b = g.createDecodingTask(k), !b || b.tasks.length) if (this.flushQueues(s), this.entireBuffer) P(null, this.entireBuffer.slice(k.firstByte, k.lastByte + 1)); else {
                        const R = Object.assign({}, this.requestParams, {headers: {Range: `bytes=${k.firstByte}-${k.lastByte}`}}),
                            O = o.br(R, P), V = this._fetchQueuePerLayer.get(s) || [];
                        V.push(() => {
                            O.cancel(), b.cancel()
                        }), this._fetchQueuePerLayer.has(s) || this._fetchQueuePerLayer.set(s, V)
                    } else m(null)
                }

                updateNeeded(t, s) {
                    return (!this.textureDescriptorPerLayer.get(t) || this.textureDescriptorPerLayer.get(t).band !== s) && this.state !== "errored"
                }

                updateTextureDescriptor(t, s, h) {
                    if (!this._mrt) return;
                    const m = this._mrt.getLayer(t);
                    if (!m || !m.hasBand(h) || !m.hasDataForBand(h)) return;
                    const {bytes: g, tileSize: v, buffer: b, offset: S, scale: P} = m.getBandView(h), M = v + 2 * b,
                        k = new o.r({width: M, height: M}, g), R = this.texturePerLayer.get(s);
                    R && R instanceof o.T && R.update(k, {premultiply: !1}), this.textureDescriptorPerLayer.set(s, {
                        layer: t,
                        band: h,
                        img: k,
                        buffer: b,
                        offset: S,
                        tileSize: v,
                        format: m.pixelFormat,
                        mix: [P, 256 * P, 65536 * P, 16777216 * P]
                    })
                }

                destroy(t = !1) {
                    if (super.destroy(t), delete this._mrt, !t) for (const s of this.texturePerLayer.values()) s && s instanceof o.T && s.destroy();
                    this.texturePerLayer.clear(), this.textureDescriptorPerLayer.clear(), this.fbo && (this.fbo.destroy(), delete this.fbo), delete this.request, delete this.requestParams, this._isHeaderLoaded = !1
                }
            }

            class Pp {
                constructor(t, s) {
                    this.max = t, this.onRemove = s, this.reset()
                }

                reset() {
                    for (const t in this.data) for (const s of this.data[t]) s.timeout && clearTimeout(s.timeout), this.onRemove(s.value);
                    return this.data = {}, this.order = [], this
                }

                add(t, s, h) {
                    const m = t.wrapped().key;
                    this.data[m] === void 0 && (this.data[m] = []);
                    const g = {value: s, timeout: void 0};
                    if (h !== void 0 && (g.timeout = setTimeout(() => {
                        this.remove(t, g)
                    }, h)), this.data[m].push(g), this.order.push(m), this.order.length > this.max) {
                        const v = this._getAndRemoveByKey(this.order[0]);
                        v && this.onRemove(v)
                    }
                    return this
                }

                has(t) {
                    return t.wrapped().key in this.data
                }

                getAndRemove(t) {
                    return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null
                }

                _getAndRemoveByKey(t) {
                    const s = this.data[t].shift();
                    return s.timeout && clearTimeout(s.timeout), this.data[t].length === 0 && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), s.value
                }

                getByKey(t) {
                    const s = this.data[t];
                    return s ? s[0].value : null
                }

                get(t) {
                    return this.has(t) ? this.data[t.wrapped().key][0].value : null
                }

                remove(t, s) {
                    if (!this.has(t)) return this;
                    const h = t.wrapped().key, m = s === void 0 ? 0 : this.data[h].indexOf(s), g = this.data[h][m];
                    return this.data[h].splice(m, 1), g.timeout && clearTimeout(g.timeout), this.data[h].length === 0 && delete this.data[h], this.onRemove(g.value), this.order.splice(this.order.indexOf(h), 1), this
                }

                setMaxSize(t) {
                    for (this.max = t; this.order.length > this.max;) {
                        const s = this._getAndRemoveByKey(this.order[0]);
                        s && this.onRemove(s)
                    }
                    return this
                }

                filter(t) {
                    const s = [];
                    for (const h in this.data) for (const m of this.data[h]) t(m.value) || s.push(m);
                    for (const h of s) this.remove(h.value.tileID, h)
                }
            }

            class Mp {
                constructor() {
                    this.state = {}, this.stateChanges = {}, this.deletedStates = {}
                }

                updateState(t, s, h) {
                    const m = String(s);
                    if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][m] = this.stateChanges[t][m] || {}, o.h(this.stateChanges[t][m], h), this.deletedStates[t] === null) {
                        this.deletedStates[t] = {};
                        for (const g in this.state[t]) g !== m && (this.deletedStates[t][g] = null)
                    } else if (this.deletedStates[t] && this.deletedStates[t][m] === null) {
                        this.deletedStates[t][m] = {};
                        for (const g in this.state[t][m]) h[g] || (this.deletedStates[t][m][g] = null)
                    } else for (const g in h) this.deletedStates[t] && this.deletedStates[t][m] && this.deletedStates[t][m][g] === null && delete this.deletedStates[t][m][g]
                }

                removeFeatureState(t, s, h) {
                    if (this.deletedStates[t] === null) return;
                    const m = String(s);
                    if (this.deletedStates[t] = this.deletedStates[t] || {}, h && s !== void 0) this.deletedStates[t][m] !== null && (this.deletedStates[t][m] = this.deletedStates[t][m] || {}, this.deletedStates[t][m][h] = null); else if (s !== void 0) if (this.stateChanges[t] && this.stateChanges[t][m]) for (h in this.deletedStates[t][m] = {}, this.stateChanges[t][m]) this.deletedStates[t][m][h] = null; else this.deletedStates[t][m] = null; else this.deletedStates[t] = null
                }

                getState(t, s) {
                    const h = this.state[t] || {}, m = this.stateChanges[t] || {}, g = this.deletedStates[t];
                    if (g === null) return {};
                    if (s !== void 0) {
                        const b = String(s), S = o.h({}, h[b], m[b]);
                        if (g) {
                            const P = g[s];
                            if (P === null) return {};
                            for (const M in P) delete S[M]
                        }
                        return S
                    }
                    const v = o.h({}, h, m);
                    if (g) for (const b in g) delete v[b];
                    return v
                }

                initializeTileState(t, s) {
                    t.refreshFeatureState(s)
                }

                coalesceChanges(t, s) {
                    const h = {};
                    for (const m in this.stateChanges) {
                        this.state[m] = this.state[m] || {};
                        const g = {};
                        for (const v in this.stateChanges[m]) this.state[m][v] || (this.state[m][v] = {}), o.h(this.state[m][v], this.stateChanges[m][v]), g[v] = this.state[m][v];
                        h[m] = g
                    }
                    for (const m in this.deletedStates) {
                        this.state[m] = this.state[m] || {};
                        const g = {};
                        if (this.deletedStates[m] === null) for (const v in this.state[m]) g[v] = {}, this.state[m][v] = {}; else for (const v in this.deletedStates[m]) {
                            if (this.deletedStates[m][v] === null) this.state[m][v] = {}; else if (this.state[m][v]) for (const b of Object.keys(this.deletedStates[m][v])) delete this.state[m][v][b];
                            g[v] = this.state[m][v]
                        }
                        h[m] = h[m] || {}, o.h(h[m], g)
                    }
                    if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(h).length !== 0) for (const m in t) t[m].refreshFeatureState(s)
                }
            }

            class Eo extends o.E {
                constructor(t, s, h) {
                    super(), this.id = t, this._onlySymbols = h, s.on("data", m => {
                        m.dataType === "source" && m.sourceDataType === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && m.dataType === "source" && m.sourceDataType === "content" && (this.reload(), this.transform && this.update(this.transform))
                    }), s.on("error", () => {
                        this._sourceErrored = !0
                    }), this._source = s, this._tiles = {}, this._cache = new Pp(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = s.minTileCacheSize, this._maxTileCacheSize = s.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = !1, this.tileCoverLift = 0, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new Mp, this._isRaster = this._source.type === "raster" || this._source.type === "raster-dem" || this._source.type === "raster-array" || this._source.type === "custom" && this._source._dataType === "raster"
                }

                onAdd(t) {
                    this.map = t, this._minTileCacheSize = this._minTileCacheSize === void 0 && t ? t._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = this._maxTileCacheSize === void 0 && t ? t._maxTileCacheSize : this._maxTileCacheSize
                }

                loaded() {
                    if (this._sourceErrored) return !0;
                    if (!this._sourceLoaded || !this._source.loaded()) return !1;
                    for (const t in this._tiles) if (!this._tiles[t].loaded()) return !1;
                    return !0
                }

                getSource() {
                    return this._source
                }

                pause() {
                    this._paused = !0
                }

                resume() {
                    if (!this._paused) return;
                    const t = this._shouldReloadOnResume;
                    this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform)
                }

                _loadTile(t, s) {
                    return t.isSymbolTile = this._onlySymbols, t.isExtraShadowCaster = this._shadowCasterTiles[t.tileID.key], this._source.loadTile(t, s)
                }

                _unloadTile(t) {
                    if (this._source.unloadTile) return this._source.unloadTile(t)
                }

                _abortTile(t) {
                    if (this._source.abortTile) return this._source.abortTile(t)
                }

                serialize() {
                    return this._source.serialize()
                }

                prepare(t) {
                    this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
                    for (const s in this._tiles) {
                        const h = this._tiles[s];
                        h.upload(t), h.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope)
                    }
                }

                getIds() {
                    return Object.values(this._tiles).map(t => t.tileID).sort(Dl).map(t => t.key)
                }

                getRenderableIds(t, s) {
                    const h = [];
                    for (const m in this._tiles) this._isIdRenderable(+m, t, s) && h.push(this._tiles[m]);
                    return t ? h.sort((m, g) => {
                        const v = m.tileID, b = g.tileID,
                            S = new o.P(v.canonical.x, v.canonical.y)._rotate(this.transform.angle),
                            P = new o.P(b.canonical.x, b.canonical.y)._rotate(this.transform.angle);
                        return v.overscaledZ - b.overscaledZ || P.y - S.y || P.x - S.x
                    }).map(m => m.tileID.key) : h.map(m => m.tileID).sort(Dl).map(m => m.key)
                }

                hasRenderableParent(t) {
                    const s = this.findLoadedParent(t, 0);
                    return !!s && this._isIdRenderable(s.tileID.key)
                }

                _isIdRenderable(t, s, h) {
                    return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (s || !this._tiles[t].holdingForFade()) && (h || !this._shadowCasterTiles[t])
                }

                reload() {
                    if (this._paused) this._shouldReloadOnResume = !0; else {
                        this._cache.reset();
                        for (const t in this._tiles) this._tiles[t].state !== "errored" && this._reloadTile(+t, "reloading")
                    }
                }

                _reloadTile(t, s) {
                    const h = this._tiles[t];
                    h && (h.state !== "loading" && (h.state = s), this._loadTile(h, this._tileLoaded.bind(this, h, t, s)))
                }

                _tileLoaded(t, s, h, m) {
                    if (m) if (t.state = "errored", m.status !== 404) this._source.fire(new o.z(m, {tile: t})); else {
                        if (this._source.fire(new o.A("data", {
                            dataType: "source",
                            sourceDataType: "error",
                            sourceId: this._source.id,
                            tile: t
                        })), !(t.tileID.key in this._loadedParentTiles)) return;
                        if (this._source.type === "raster-dem" && this.usedForTerrain && this.map.painter.terrain) {
                            const g = this.map.painter.terrain;
                            this.update(this.transform, g.getScaledDemTileSize(), !0), g.resetTileLookupCache(this.id)
                        } else this.update(this.transform)
                    } else t.timeAdded = o.q.now(), h === "expired" && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(s, t), this._source.type === "raster-dem" && t.dem && this._backfillDEM(t), this._state.initializeTileState(t, this.map ? this.map.painter : null), this._source.fire(new o.A("data", {
                        dataType: "source",
                        tile: t,
                        coord: t.tileID,
                        sourceCacheId: this.id
                    }))
                }

                _backfillDEM(t) {
                    const s = this.getRenderableIds();
                    for (let m = 0; m < s.length; m++) {
                        const g = s[m];
                        if (t.neighboringTiles && t.neighboringTiles[g]) {
                            const v = this.getTileByID(g);
                            h(t, v), h(v, t)
                        }
                    }

                    function h(m, g) {
                        if (!m.dem || m.dem.borderReady) return;
                        m.needsHillshadePrepare = !0, m.needsDEMTextureUpload = !0;
                        let v = g.tileID.canonical.x - m.tileID.canonical.x;
                        const b = g.tileID.canonical.y - m.tileID.canonical.y, S = Math.pow(2, m.tileID.canonical.z),
                            P = g.tileID.key;
                        v === 0 && b === 0 || Math.abs(b) > 1 || (Math.abs(v) > 1 && (Math.abs(v + S) === 1 ? v += S : Math.abs(v - S) === 1 && (v -= S)), g.dem && m.dem && (m.dem.backfillBorder(g.dem, v, b), m.neighboringTiles && m.neighboringTiles[P] && (m.neighboringTiles[P].backfilled = !0)))
                    }
                }

                getTile(t) {
                    return this.getTileByID(t.key)
                }

                getTileByID(t) {
                    return this._tiles[t]
                }

                _retainLoadedChildren(t, s, h, m) {
                    for (const g in this._tiles) {
                        let v = this._tiles[g];
                        if (m[g] || !v.hasData() || v.tileID.overscaledZ <= s || v.tileID.overscaledZ > h) continue;
                        let b = v.tileID;
                        for (; v && v.tileID.overscaledZ > s + 1;) {
                            const P = v.tileID.scaledTo(v.tileID.overscaledZ - 1);
                            v = this._tiles[P.key], v && v.hasData() && (b = P)
                        }
                        let S = b;
                        for (; S.overscaledZ > s;) if (S = S.scaledTo(S.overscaledZ - 1), t[S.key]) {
                            m[b.key] = b;
                            break
                        }
                    }
                }

                findLoadedParent(t, s) {
                    if (t.key in this._loadedParentTiles) {
                        const h = this._loadedParentTiles[t.key];
                        return h && h.tileID.overscaledZ >= s ? h : null
                    }
                    for (let h = t.overscaledZ - 1; h >= s; h--) {
                        const m = t.scaledTo(h), g = this._getLoadedTile(m);
                        if (g) return g
                    }
                }

                _getLoadedTile(t) {
                    const s = this._tiles[t.key];
                    return s && s.hasData() ? s : this._cache.getByKey(this._source.reparseOverscaled ? t.wrapped().key : t.canonical.key)
                }

                updateCacheSize(t, s) {
                    s = s || this._source.tileSize;
                    const h = Math.ceil(t.width / s) + 1, m = Math.ceil(t.height / s) + 1, g = Math.floor(h * m * 5),
                        v = typeof this._minTileCacheSize == "number" ? Math.max(this._minTileCacheSize, g) : g,
                        b = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, v) : v;
                    this._cache.setMaxSize(b)
                }

                handleWrapJump(t) {
                    const s = Math.round((t - (this._prevLng === void 0 ? t : this._prevLng)) / 360);
                    if (this._prevLng = t, s) {
                        const h = {};
                        for (const m in this._tiles) {
                            const g = this._tiles[m];
                            g.tileID = g.tileID.unwrapTo(g.tileID.wrap + s), h[g.tileID.key] = g
                        }
                        this._tiles = h;
                        for (const m in this._timers) clearTimeout(this._timers[m]), delete this._timers[m];
                        for (const m in this._tiles) this._setTileReloadTimer(+m, this._tiles[m])
                    }
                }

                update(t, s, h, m, g) {
                    if (this.transform = t, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage || this.usedForTerrain && !h) return;
                    this.updateCacheSize(t, s), this.transform.projection.name !== "globe" && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {};
                    const v = this._source.type === "batched-model";
                    let b, S = this._source.maxzoom;
                    const P = this.map && this.map.painter ? this.map.painter._terrain : null;
                    if (P && P.sourceCache === this && P.attenuationRange()) {
                        const R = P.attenuationRange()[0], O = Math.floor(R) - Math.log2(P.getDemUpscale());
                        S > O && (S = O)
                    }
                    if (this.used || this.usedForTerrain) {
                        if (this._source.tileID) b = t.getVisibleUnwrappedCoordinates(this._source.tileID).map(R => new o.aM(R.canonical.z, R.wrap, R.canonical.z, R.canonical.x, R.canonical.y)); else if (this.tileCoverLift !== 0) {
                            const R = t.clone();
                            R.tileCoverLift = this.tileCoverLift, b = R.coveringTiles({
                                tileSize: s || this._source.tileSize,
                                minzoom: this._source.minzoom,
                                maxzoom: S,
                                roundZoom: this._source.roundZoom && !h,
                                reparseOverscaled: this._source.reparseOverscaled,
                                isTerrainDEM: this.usedForTerrain,
                                calculateQuadrantVisibility: v
                            }), this._source.minzoom <= 1 && t.projection.name === "globe" && (b.push(new o.aM(1, 0, 1, 0, 0)), b.push(new o.aM(1, 0, 1, 1, 0)), b.push(new o.aM(1, 0, 1, 0, 1)), b.push(new o.aM(1, 0, 1, 1, 1)))
                        } else if (b = t.coveringTiles({
                            tileSize: s || this._source.tileSize,
                            minzoom: this._source.minzoom,
                            maxzoom: S,
                            roundZoom: this._source.roundZoom && !h,
                            reparseOverscaled: this._source.reparseOverscaled,
                            isTerrainDEM: this.usedForTerrain,
                            calculateQuadrantVisibility: v
                        }), this._source.hasTile) {
                            const R = this._source.hasTile.bind(this._source);
                            b = b.filter(O => R(O))
                        }
                    } else b = [];
                    if (b.length > 0 && this.transform.projection.name !== "globe" && !this.usedForTerrain && !Xu(this._source.type)) {
                        const R = t.coveringZoomLevel({
                            tileSize: s || this._source.tileSize,
                            roundZoom: this._source.roundZoom && !h
                        }), O = Math.min(R, this._source.maxzoom);
                        if (v) {
                            const V = t.extendTileCover(b, O);
                            for (const B of V) b.push(B)
                        } else if (g) {
                            const V = t.extendTileCoverToNearPlane(b, this.transform.getFrustum(O), O);
                            for (const B of V) b.push(B)
                        } else if (this.castsShadows && m) {
                            const V = t.extendTileCover(b, O, m);
                            for (const B of V) this._shadowCasterTiles[B.key] = !0, b.push(B)
                        }
                    }
                    const M = this._updateRetainedTiles(b);
                    if (Xu(this._source.type) && b.length !== 0) {
                        const R = {}, O = {}, V = Object.keys(M);
                        for (const G of V) {
                            const U = M[G], Z = this._tiles[G];
                            if (!Z || Z.fadeEndTime && Z.fadeEndTime <= o.q.now()) continue;
                            const Q = this.findLoadedParent(U, Math.max(U.overscaledZ - Eo.maxOverzooming, this._source.minzoom));
                            Q && (this._addTile(Q.tileID), R[Q.tileID.key] = Q.tileID), O[G] = U
                        }
                        const B = b[b.length - 1].overscaledZ;
                        for (const G in this._tiles) {
                            const U = this._tiles[G];
                            if (M[G] || !U.hasData()) continue;
                            let Z = U.tileID;
                            for (; Z.overscaledZ > B;) {
                                Z = Z.scaledTo(Z.overscaledZ - 1);
                                const Q = this._tiles[Z.key];
                                if (Q && Q.hasData() && O[Z.key]) {
                                    M[G] = U.tileID;
                                    break
                                }
                            }
                        }
                        for (const G in R) M[G] || (this._coveredTiles[G] = !0, M[G] = R[G])
                    }
                    for (const R in M) this._tiles[R].clearFadeHold();
                    const k = o.bs(this._tiles, M);
                    for (const R of k) {
                        const O = this._tiles[R];
                        O.hasSymbolBuckets && !O.holdingForFade() ? O.setHoldDuration(this.map._fadeDuration) : O.hasSymbolBuckets && !O.symbolFadeFinished() || this._removeTile(+R)
                    }
                    this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate()
                }

                releaseSymbolFadeTiles() {
                    for (const t in this._tiles) this._tiles[t].holdingForFade() && this._removeTile(+t)
                }

                _updateRetainedTiles(t) {
                    const s = {};
                    if (t.length === 0) return s;
                    const h = {}, m = t.reduce((P, M) => Math.min(P, M.overscaledZ), 1 / 0), g = t[0].overscaledZ,
                        v = Math.max(g - Eo.maxOverzooming, this._source.minzoom),
                        b = Math.max(g + Eo.maxUnderzooming, this._source.minzoom), S = {};
                    for (const P of t) {
                        const M = this._addTile(P);
                        s[P.key] = P, M.hasData() || m < this._source.maxzoom && (S[P.key] = P)
                    }
                    this._retainLoadedChildren(S, m, b, s);
                    for (const P of t) {
                        let M = this._tiles[P.key];
                        if (M.hasData()) continue;
                        if (P.canonical.z >= this._source.maxzoom) {
                            const R = P.children(this._source.maxzoom)[0], O = this.getTile(R);
                            if (O && O.hasData()) {
                                s[R.key] = R;
                                continue
                            }
                        } else {
                            const R = P.children(this._source.maxzoom);
                            if (s[R[0].key] && s[R[1].key] && s[R[2].key] && s[R[3].key]) continue
                        }
                        let k = M.wasRequested();
                        for (let R = P.overscaledZ - 1; R >= v; --R) {
                            const O = P.scaledTo(R);
                            if (h[O.key] || (h[O.key] = !0, M = this.getTile(O), !M && k && (M = this._addTile(O)), M && (s[O.key] = O, k = M.wasRequested(), M.hasData()))) break
                        }
                    }
                    return s
                }

                _updateLoadedParentTileCache() {
                    this._loadedParentTiles = {};
                    for (const t in this._tiles) {
                        const s = [];
                        let h, m = this._tiles[t].tileID;
                        for (; m.overscaledZ > 0;) {
                            if (m.key in this._loadedParentTiles) {
                                h = this._loadedParentTiles[m.key];
                                break
                            }
                            s.push(m.key);
                            const g = m.scaledTo(m.overscaledZ - 1);
                            if (h = this._getLoadedTile(g), h) break;
                            m = g
                        }
                        for (const g of s) this._loadedParentTiles[g] = h
                    }
                }

                _addTile(t) {
                    let s = this._tiles[t.key];
                    if (s) return s.isExtraShadowCaster !== !0 || this._shadowCasterTiles[t.key] || this._reloadTile(t.key, "reloading"), s;
                    s = this._cache.getAndRemove(t), s && (this._setTileReloadTimer(t.key, s), s.tileID = t, this._state.initializeTileState(s, this.map ? this.map.painter : null), this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]), delete this._cacheTimers[t.key], this._setTileReloadTimer(t.key, s)));
                    const h = !!s;
                    if (!h) {
                        const m = this.map ? this.map.painter : null, g = this._source.tileSize * t.overscaleFactor();
                        s = this._source.type === "raster-array" ? new gc(t, g, this.transform.tileZoom, m, this._isRaster) : new zl(t, g, this.transform.tileZoom, m, this._isRaster, this._source.worldview), this._loadTile(s, this._tileLoaded.bind(this, s, t.key, s.state))
                    }
                    return s.uses++, this._tiles[t.key] = s, h || this._source.fire(new o.A("dataloading", {
                        tile: s,
                        coord: s.tileID,
                        dataType: "source"
                    })), s
                }

                _setTileReloadTimer(t, s) {
                    t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]);
                    const h = s.getExpiryTimeout();
                    h && (this._timers[t] = setTimeout(() => {
                        this._reloadTile(t, "expired"), delete this._timers[t]
                    }, h))
                }

                _removeTile(t) {
                    const s = this._tiles[t];
                    s && (s.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), s.uses > 0 || (s.hasData() && s.state !== "reloading" || s.state === "empty" ? this._cache.add(s.tileID, s, s.getExpiryTimeout()) : (s.aborted = !0, this._abortTile(s), this._unloadTile(s))))
                }

                clearTiles() {
                    this._shouldReloadOnResume = !1, this._paused = !1;
                    for (const t in this._tiles) this._removeTile(+t);
                    this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id)
                }

                tilesIn(t, s, h) {
                    const m = [], g = this.transform;
                    if (!g) return m;
                    const v = g.projection.name === "globe", b = o.aD(g.center.lng);
                    for (const S in this._tiles) {
                        const P = this._tiles[S];
                        if (h && P.clearQueryDebugViz(), P.holdingForFade()) continue;
                        let M;
                        if (v) {
                            const k = P.tileID.canonical;
                            if (k.z === 0) {
                                const R = [Math.abs(o.ay(b, ..._c(k, -1)) - b), Math.abs(o.ay(b, ..._c(k, 1)) - b)];
                                M = [0, 2 * R.indexOf(Math.min(...R)) - 1]
                            } else {
                                const R = [Math.abs(o.ay(b, ..._c(k, -1)) - b), Math.abs(o.ay(b, ..._c(k, 0)) - b), Math.abs(o.ay(b, ..._c(k, 1)) - b)];
                                M = [R.indexOf(Math.min(...R)) - 1]
                            }
                        } else M = [0];
                        for (const k of M) {
                            const R = t.containsTile(P, g, s, k);
                            R && m.push(R)
                        }
                    }
                    return m
                }

                getShadowCasterCoordinates() {
                    return this._getRenderableCoordinates(!1, !0)
                }

                getVisibleCoordinates(t) {
                    return this._getRenderableCoordinates(t)
                }

                _getRenderableCoordinates(t, s) {
                    const h = this.getRenderableIds(t, s).map(g => this._tiles[g].tileID),
                        m = this.transform.projection.name === "globe";
                    for (const g of h) g.projMatrix = this.transform.calculateProjMatrix(g.toUnwrapped()), g.expandedProjMatrix = m ? this.transform.calculateProjMatrix(g.toUnwrapped(), !1, !0) : g.projMatrix;
                    return h
                }

                sortCoordinatesByDistance(t) {
                    const s = t.slice(), h = this.transform._camera.position, m = this.transform._camera.forward(),
                        g = {};
                    for (const v of s) {
                        const b = 1 / (1 << v.canonical.z);
                        g[v.key] = ((v.canonical.x + .5) * b + v.wrap - h[0]) * m[0] + ((v.canonical.y + .5) * b - h[1]) * m[1] - h[2] * m[2]
                    }
                    return s.sort((v, b) => g[v.key] - g[b.key]), s
                }

                hasTransition() {
                    if (this._source.hasTransition()) return !0;
                    if (Xu(this._source.type)) for (const t in this._tiles) {
                        const s = this._tiles[t];
                        if (s.fadeEndTime !== void 0 && s.fadeEndTime >= o.q.now()) return !0
                    }
                    return !1
                }

                setFeatureState(t, s, h) {
                    this._state.updateState(t = t || "_geojsonTileLayer", s, h)
                }

                removeFeatureState(t, s, h) {
                    this._state.removeFeatureState(t = t || "_geojsonTileLayer", s, h)
                }

                getFeatureState(t, s) {
                    return this._state.getState(t = t || "_geojsonTileLayer", s)
                }

                setDependencies(t, s, h) {
                    const m = this._tiles[t];
                    m && m.setDependencies(s, h)
                }

                reloadTilesForDependencies(t, s) {
                    for (const h in this._tiles) this._tiles[h].hasDependency(t, s) && this._reloadTile(+h, "reloading");
                    this._cache.filter(h => !h.hasDependency(t, s))
                }

                _preloadTiles(t, s) {
                    if (!this._sourceLoaded) {
                        const S = () => {
                            this._sourceLoaded && (this._source.off("data", S), this._preloadTiles(t, s))
                        };
                        return void this._source.on("data", S)
                    }
                    const h = new Map, m = Array.isArray(t) ? t : [t], g = this.map.painter.terrain,
                        v = this.usedForTerrain && g ? g.getScaledDemTileSize() : this._source.tileSize;
                    for (const S of m) {
                        const P = S.coveringTiles({
                            tileSize: v,
                            minzoom: this._source.minzoom,
                            maxzoom: this._source.maxzoom,
                            roundZoom: this._source.roundZoom && !this.usedForTerrain,
                            reparseOverscaled: this._source.reparseOverscaled,
                            isTerrainDEM: this.usedForTerrain
                        });
                        for (const M of P) h.set(M.key, M);
                        this.usedForTerrain && S.updateElevation(!1)
                    }
                    const b = Array.from(h.values());
                    o.bt(b, (S, P) => {
                        const M = new zl(S, this._source.tileSize * S.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster, this._source.worldview);
                        this._loadTile(M, k => {
                            this._source.type === "raster-dem" && M.dem && this._backfillDEM(M), P(k, M)
                        })
                    }, s)
                }
            }

            function Dl(u, t) {
                const s = Math.abs(2 * u.wrap) - +(u.wrap < 0), h = Math.abs(2 * t.wrap) - +(t.wrap < 0);
                return u.overscaledZ - t.overscaledZ || h - s || t.canonical.y - u.canonical.y || t.canonical.x - u.canonical.x
            }

            function Xu(u) {
                return u === "raster" || u === "image" || u === "video" || u === "custom"
            }

            function _c(u, t) {
                const s = 1 << u.z;
                return [u.x / s + t, (u.x + 1) / s + t]
            }

            Eo.maxOverzooming = 10, Eo.maxUnderzooming = 3;

            class L_ {
                constructor(t) {
                    this.style = t, this.layersGotHidden = !1, this.layers = []
                }

                processLayersChanged() {
                    this.layers = [];
                    const t = !1, s = !1;
                    for (const h in this.style._mergedLayers) {
                        const m = this.style._mergedLayers[h];
                        if (m.type === "fill-extrusion" || m.type === "building") this.layers.push({
                            layer: m,
                            visible: t,
                            visibilityChanged: s
                        }); else if (m.type === "model") {
                            const g = this.style.getLayerSource(m);
                            g && g.type === "batched-model" && this.layers.push({
                                layer: m,
                                visible: t,
                                visibilityChanged: s
                            })
                        }
                    }
                }

                onNewFrame(t) {
                    this.layersGotHidden = !1;
                    for (const s of this.layers) {
                        const h = s.layer;
                        let m = !1;
                        h.type === "fill-extrusion" ? m = !h.isHidden(t) && h.paint.get("fill-extrusion-opacity") > 0 : h.type === "building" ? m = !h.isHidden(t) && h.paint.get("building-opacity") > 0 : h.type === "model" && (m = !h.isHidden(t) && h.paint.get("model-opacity").constantOr(1) > 0), this.layersGotHidden = this.layersGotHidden || !m && s.visible, s.visible = m
                    }
                }

                updateZOffset(t, s) {
                    this.currentBuildingBuckets = [];
                    for (const m of this.layers) {
                        const g = m.layer, v = this.style.getLayerSourceCache(g);
                        let b = 1;
                        g.type === "fill-extrusion" ? b = m.visible ? g.paint.get("fill-extrusion-vertical-scale") : 0 : g.type === "building" && (b = m.visible ? g.paint.get("building-vertical-scale") : 0);
                        let S = v ? v.getTile(s) : null;
                        if (!S && v) for (const P in v._tiles) {
                            const M = v._tiles[P];
                            if (s.canonical.isChildOf(M.tileID.canonical)) {
                                S = M;
                                break
                            }
                        }
                        this.currentBuildingBuckets.push({
                            bucket: S ? S.getBucket(g) : null,
                            tileID: S ? S.tileID : s,
                            verticalScale: b
                        })
                    }
                    t.hasAnyZOffset = !1;
                    let h = !1;
                    for (let m = 0; m < t.symbolInstances.length; m++) {
                        const g = t.symbolInstances.get(m), v = g.zOffset,
                            b = this._getHeightAtTileOffset(s, g.tileAnchorX, g.tileAnchorY);
                        g.zOffset = b !== Number.NEGATIVE_INFINITY ? b : v, h || v === g.zOffset || (h = !0), t.hasAnyZOffset || g.zOffset === 0 || (t.hasAnyZOffset = !0)
                    }
                    h && (t.zOffsetBuffersNeedUpload = !0, t.zOffsetSortDirty = !0)
                }

                _mapCoordToOverlappingTile(t, s, h, m) {
                    let g = s, v = h;
                    if (t.canonical.z !== m.canonical.z) {
                        const b = m.canonical, S = 1 / (1 << t.canonical.z - b.z);
                        g = (s + t.canonical.x * o.aj) * S - b.x * o.aj | 0, v = (h + t.canonical.y * o.aj) * S - b.y * o.aj | 0
                    }
                    return {tileX: g, tileY: v}
                }

                _getHeightAtTileOffset(t, s, h) {
                    let m, g;
                    for (let v = 0; v < this.layers.length; ++v) {
                        const b = this.layers[v].layer;
                        if (b.type !== "fill-extrusion" && b.type !== "building") continue;
                        const {bucket: S, tileID: P, verticalScale: M} = this.currentBuildingBuckets[v];
                        if (!S) continue;
                        const {tileX: k, tileY: R} = this._mapCoordToOverlappingTile(t, s, h, P),
                            O = S.getHeightAtTileCoord(k, R);
                        O && O.height !== void 0 && (O.hidden ? m = O.height : g = Math.max(O.height * M, g || 0))
                    }
                    if (g !== void 0) return g;
                    for (let v = 0; v < this.layers.length; ++v) {
                        const b = this.layers[v];
                        if (b.layer.type !== "model" || !b.visible) continue;
                        const {bucket: S, tileID: P} = this.currentBuildingBuckets[v];
                        if (!S) continue;
                        const {tileX: M, tileY: k} = this._mapCoordToOverlappingTile(t, s, h, P),
                            R = S.getHeightAtTileCoord(M, k);
                        if (R && !R.hidden) return R.height === void 0 && m !== void 0 ? Math.min(R.maxHeight, m) * R.verticalScale : R.height ? R.height * R.verticalScale : Number.NEGATIVE_INFINITY
                    }
                    return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY
                }
            }

            function k_(u, t) {
                const s = {};
                for (const h in u) h !== "ref" && (s[h] = u[h]);
                return o.bu.forEach(h => {
                    h in t && (s[h] = t[h])
                }), s
            }

            function Yu(u) {
                u = u.slice();
                const t = Object.create(null);
                for (let s = 0; s < u.length; s++) t[u[s].id] = u[s];
                for (let s = 0; s < u.length; s++) "ref" in u[s] && (u[s] = k_(u[s], t[u[s].ref]));
                return u
            }

            const Vi = {
                setStyle: "setStyle",
                addLayer: "addLayer",
                removeLayer: "removeLayer",
                setPaintProperty: "setPaintProperty",
                setLayoutProperty: "setLayoutProperty",
                setSlot: "setSlot",
                setFilter: "setFilter",
                addSource: "addSource",
                removeSource: "removeSource",
                setGeoJSONSourceData: "setGeoJSONSourceData",
                setLayerZoomRange: "setLayerZoomRange",
                setLayerProperty: "setLayerProperty",
                setCenter: "setCenter",
                setZoom: "setZoom",
                setBearing: "setBearing",
                setPitch: "setPitch",
                setSprite: "setSprite",
                setGlyphs: "setGlyphs",
                setTransition: "setTransition",
                setLight: "setLight",
                setTerrain: "setTerrain",
                setFog: "setFog",
                setSnow: "setSnow",
                setRain: "setRain",
                setCamera: "setCamera",
                setLights: "setLights",
                setProjection: "setProjection",
                addImport: "addImport",
                removeImport: "removeImport",
                updateImport: "updateImport",
                addIconset: "addIconset",
                removeIconset: "removeIconset"
            };

            function fd(u, t, s) {
                s.push({command: Vi.addSource, args: [u, t[u]]})
            }

            function yc(u, t, s) {
                t.push({command: Vi.removeSource, args: [u]}), s[u] = !0
            }

            function Ku(u, t, s, h) {
                yc(u, s, h), fd(u, t, s)
            }

            function Nx(u, t, s) {
                let h;
                for (h in u[s]) if (u[s].hasOwnProperty(h) && h !== "data" && !o.bv(u[s][h], t[s][h])) return !1;
                for (h in t[s]) if (t[s].hasOwnProperty(h) && h !== "data" && !o.bv(u[s][h], t[s][h])) return !1;
                return !0
            }

            function Qu(u, t, s, h, m, g) {
                let v;
                for (v in t = t || {}, u = u || {}) u.hasOwnProperty(v) && (o.bv(u[v], t[v]) || s.push({
                    command: g,
                    args: [h, v, t[v], m]
                }));
                for (v in t) t.hasOwnProperty(v) && !u.hasOwnProperty(v) && (o.bv(u[v], t[v]) || s.push({
                    command: g,
                    args: [h, v, t[v], m]
                }))
            }

            function Ll(u) {
                return u.id
            }

            function Wa(u, t) {
                return u[t.id] = t, u
            }

            function Ju(u, t, s) {
                const h = t.createTileMatrix(u, u.worldSize, s.toUnwrapped());
                return o.az(new Float32Array(16), u.projMatrix, h)
            }

            function O_(u, t, s) {
                if (t.projection.name === s.projection.name) return u.projMatrix;
                const h = s.clone();
                return h.setProjection(t.projection), Ju(h, t.getProjection(), u)
            }

            function pd(u, t, s) {
                return t.name === s.projection.name ? u.projMatrix : Ju(s, t, u)
            }

            class F_ {
                constructor(t, s) {
                    this.reset(t, s)
                }

                reset(t, s) {
                    this.points = t || [], this._distances = [0];
                    for (let h = 1; h < this.points.length; h++) this._distances[h] = this._distances[h - 1] + this.points[h].dist(this.points[h - 1]);
                    this.length = this._distances[this._distances.length - 1], this.padding = Math.min(s || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding
                }

                lerp(t) {
                    if (this.points.length === 1) return this.points[0];
                    t = o.ay(t, 0, 1);
                    let s = 1, h = this._distances[s];
                    const m = t * this.paddedLength + this.padding;
                    for (; h < m && s < this._distances.length;) h = this._distances[++s];
                    const g = s - 1, v = this._distances[g], b = h - v, S = b > 0 ? (m - v) / b : 0;
                    return this.points[g].mult(1 - S).add(this.points[s].mult(S))
                }
            }

            class vc {
                constructor(t, s, h) {
                    const m = this.boxCells = [], g = this.circleCells = [];
                    this.xCellCount = Math.ceil(t / h), this.yCellCount = Math.ceil(s / h);
                    for (let v = 0; v < this.xCellCount * this.yCellCount; v++) m.push([]), g.push([]);
                    this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t, this.height = s, this.xScale = this.xCellCount / t, this.yScale = this.yCellCount / s, this.boxUid = 0, this.circleUid = 0
                }

                keysLength() {
                    return this.boxKeys.length + this.circleKeys.length
                }

                insert(t, s, h, m, g) {
                    this._forEachCell(s, h, m, g, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t), this.bboxes.push(s), this.bboxes.push(h), this.bboxes.push(m), this.bboxes.push(g)
                }

                insertCircle(t, s, h, m) {
                    this._forEachCell(s - m, h - m, s + m, h + m, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t), this.circles.push(s), this.circles.push(h), this.circles.push(m)
                }

                _insertBoxCell(t, s, h, m, g, v) {
                    this.boxCells[g].push(v)
                }

                _insertCircleCell(t, s, h, m, g, v) {
                    this.circleCells[g].push(v)
                }

                _query(t, s, h, m, g, v) {
                    if (h < 0 || t > this.width || m < 0 || s > this.height) return !g && [];
                    const b = [];
                    if (t <= 0 && s <= 0 && this.width <= h && this.height <= m) {
                        if (g) return !0;
                        for (let S = 0; S < this.boxKeys.length; S++) b.push({
                            key: this.boxKeys[S],
                            x1: this.bboxes[4 * S],
                            y1: this.bboxes[4 * S + 1],
                            x2: this.bboxes[4 * S + 2],
                            y2: this.bboxes[4 * S + 3]
                        });
                        for (let S = 0; S < this.circleKeys.length; S++) {
                            const P = this.circles[3 * S], M = this.circles[3 * S + 1], k = this.circles[3 * S + 2];
                            b.push({key: this.circleKeys[S], x1: P - k, y1: M - k, x2: P + k, y2: M + k})
                        }
                        return v ? b.filter(v) : b
                    }
                    return this._forEachCell(t, s, h, m, this._queryCell, b, {
                        hitTest: g,
                        seenUids: {box: {}, circle: {}}
                    }, v), g ? b.length > 0 : b
                }

                _queryCircle(t, s, h, m, g) {
                    const v = t - h, b = t + h, S = s - h, P = s + h;
                    if (b < 0 || v > this.width || P < 0 || S > this.height) return !m && [];
                    const M = [];
                    return this._forEachCell(v, S, b, P, this._queryCellCircle, M, {
                        hitTest: m,
                        circle: {x: t, y: s, radius: h},
                        seenUids: {box: {}, circle: {}}
                    }, g), m ? M.length > 0 : M
                }

                query(t, s, h, m, g) {
                    return this._query(t, s, h, m, !1, g)
                }

                hitTest(t, s, h, m, g) {
                    return this._query(t, s, h, m, !0, g)
                }

                hitTestCircle(t, s, h, m) {
                    return this._queryCircle(t, s, h, !0, m)
                }

                _queryCell(t, s, h, m, g, v, b, S) {
                    const P = b.seenUids, M = this.boxCells[g];
                    if (M !== null) {
                        const R = this.bboxes;
                        for (const O of M) if (!P.box[O]) {
                            P.box[O] = !0;
                            const V = 4 * O;
                            if (t <= R[V + 2] && s <= R[V + 3] && h >= R[V + 0] && m >= R[V + 1] && (!S || S(this.boxKeys[O]))) {
                                if (b.hitTest) return v.push(!0), !0;
                                v.push({key: this.boxKeys[O], x1: R[V], y1: R[V + 1], x2: R[V + 2], y2: R[V + 3]})
                            }
                        }
                    }
                    const k = this.circleCells[g];
                    if (k !== null) {
                        const R = this.circles;
                        for (const O of k) if (!P.circle[O]) {
                            P.circle[O] = !0;
                            const V = 3 * O;
                            if (this._circleAndRectCollide(R[V], R[V + 1], R[V + 2], t, s, h, m) && (!S || S(this.circleKeys[O]))) {
                                if (b.hitTest) return v.push(!0), !0;
                                {
                                    const B = R[V], G = R[V + 1], U = R[V + 2];
                                    v.push({key: this.circleKeys[O], x1: B - U, y1: G - U, x2: B + U, y2: G + U})
                                }
                            }
                        }
                    }
                }

                _queryCellCircle(t, s, h, m, g, v, b, S) {
                    const P = b.circle, M = b.seenUids, k = this.boxCells[g];
                    if (k !== null) {
                        const O = this.bboxes;
                        for (const V of k) if (!M.box[V]) {
                            M.box[V] = !0;
                            const B = 4 * V;
                            if (this._circleAndRectCollide(P.x, P.y, P.radius, O[B + 0], O[B + 1], O[B + 2], O[B + 3]) && (!S || S(this.boxKeys[V]))) return v.push(!0), !0
                        }
                    }
                    const R = this.circleCells[g];
                    if (R !== null) {
                        const O = this.circles;
                        for (const V of R) if (!M.circle[V]) {
                            M.circle[V] = !0;
                            const B = 3 * V;
                            if (this._circlesCollide(O[B], O[B + 1], O[B + 2], P.x, P.y, P.radius) && (!S || S(this.circleKeys[V]))) return v.push(!0), !0
                        }
                    }
                }

                _forEachCell(t, s, h, m, g, v, b, S) {
                    const P = this._convertToXCellCoord(t), M = this._convertToYCellCoord(s),
                        k = this._convertToXCellCoord(h), R = this._convertToYCellCoord(m);
                    for (let O = P; O <= k; O++) for (let V = M; V <= R; V++) if (g.call(this, t, s, h, m, this.xCellCount * V + O, v, b, S)) return
                }

                _convertToXCellCoord(t) {
                    return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale)))
                }

                _convertToYCellCoord(t) {
                    return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale)))
                }

                _circlesCollide(t, s, h, m, g, v) {
                    const b = m - t, S = g - s, P = h + v;
                    return P * P > b * b + S * S
                }

                _circleAndRectCollide(t, s, h, m, g, v, b) {
                    const S = (v - m) / 2, P = Math.abs(t - (m + S));
                    if (P > S + h) return !1;
                    const M = (b - g) / 2, k = Math.abs(s - (g + M));
                    if (k > M + h) return !1;
                    if (P <= S || k <= M) return !0;
                    const R = P - S, O = k - M;
                    return R * R + O * O <= h * h
                }
            }

            const kl = {unknown: 0, flipRequired: 1, flipNotRequired: 2}, B_ = Math.tan(85 * Math.PI / 180);

            function eh(u, t, s, h, m, g, v) {
                const b = o.bz();
                if (s) if (g.name === "globe") {
                    const S = o.bA(m, t);
                    o.az(b, b, S)
                } else {
                    const S = o.bB([], v);
                    b[0] = S[0], b[1] = S[1], b[4] = S[2], b[5] = S[3], h || o.by(b, b, m.angle)
                } else o.az(b, m.labelPlaneMatrix, u);
                return b
            }

            function xc(u, t, s, h, m, g, v) {
                const b = eh(u, t, s, h, m, g, v);
                return g.name === "globe" && s || (b[2] = b[6] = b[10] = b[14] = 0), b
            }

            function _a(u, t, s, h, m, g, v) {
                if (s) {
                    if (g.name === "globe") {
                        const b = eh(u, t, s, h, m, g, v);
                        return o.bi(b, b), o.az(b, u, b), b
                    }
                    {
                        const b = o.bw(u), S = o.bx([]);
                        return S[0] = v[0], S[1] = v[1], S[4] = v[2], S[5] = v[3], o.az(b, b, S), h || o.by(b, b, -m.angle), b
                    }
                }
                return m.glCoordMatrix
            }

            function Xo(u, t, s, h) {
                const m = [u, t, s, 1];
                s ? o.aA(m, m, h) : N_(m, m, h);
                const g = m[3];
                return m[0] /= g, m[1] /= g, m[2] /= g, m
            }

            function Rp(u, t) {
                return Math.min(.5 + u / t * .5, 1.5)
            }

            function zp(u, t) {
                const s = u[0] / u[3], h = u[1] / u[3];
                return s >= -t[0] && s <= t[0] && h >= -t[1] && h <= t[1]
            }

            function Ol(u, t, s, h, m, g, v, b, S, P) {
                const M = s.transform, k = h ? u.textSizeData : u.iconSizeData, R = o.bH(k, s.transform.zoom),
                    O = M.projection.name === "globe", V = [256 / s.width * 2 + 1, 256 / s.height * 2 + 1],
                    B = h ? u.text.dynamicLayoutVertexArray : u.icon.dynamicLayoutVertexArray;
                B.clear();
                let G = null;
                O && (G = h ? u.text.globeExtVertexArray : u.icon.globeExtVertexArray);
                const U = u.lineVertexArray, Z = h ? u.text.placedSymbolArray : u.icon.placedSymbolArray,
                    Q = s.transform.width / s.transform.height;
                let te, ce = !1;
                for (let _e = 0; _e < Z.length; _e++) {
                    const ve = Z.get(_e), {numGlyphs: ue, writingMode: he} = ve;
                    if (he !== o.bI.vertical || ce || te === o.bI.horizontal || (ce = !0), te = he, (ve.hidden || he === o.bI.vertical) && !ce) {
                        wc(ue, B);
                        continue
                    }
                    ce = !1;
                    const me = new o.P(ve.tileAnchorX, ve.tileAnchorY);
                    let {x: Oe, y: Se, z: Xe} = M.projection.projectTilePoint(me.x, me.y, P.canonical);
                    if (S) {
                        const [Ot, Ut, St] = S(me);
                        Oe += Ot, Se += Ut, Xe += St
                    }
                    const je = [Oe, Se, Xe, 1];
                    if (o.aA(je, je, t), !zp(je, V)) {
                        wc(ue, B);
                        continue
                    }
                    const Ke = je[3], ut = Rp(s.transform.getCameraToCenterDistance(M.projection), Ke),
                        Fe = o.bJ(k, R, ve), Te = v ? Fe / ut : Fe * ut, $e = Xo(Oe, Se, Xe, m);
                    if ($e[3] <= 0) {
                        wc(ue, B);
                        continue
                    }
                    let Be = {};
                    const tt = o.al(u.layers[0].layout.get("text-max-angle")), it = Math.cos(tt), rt = v ? null : S,
                        gt = md(ve, Te, !1, b, t, m, g, u.glyphOffsetArray, U, B, G, $e, me, Be, Q, rt, M.projection, P, v, it);
                    ce = gt.useVertical, rt && gt.needsFlipping && (Be = {}), (gt.notEnoughRoom || ce || gt.needsFlipping && md(ve, Te, !0, b, t, m, g, u.glyphOffsetArray, U, B, G, $e, me, Be, Q, rt, M.projection, P, v, it).notEnoughRoom) && wc(ue, B)
                }
                h ? (u.text.dynamicLayoutVertexBuffer.updateData(B), G && u.text.globeExtVertexBuffer && u.text.globeExtVertexBuffer.updateData(G)) : (u.icon.dynamicLayoutVertexBuffer.updateData(B), G && u.icon.globeExtVertexBuffer && u.icon.globeExtVertexBuffer.updateData(G))
            }

            function Lo(u, t, s, h, m, g, v, b, S, P, M, k, R, O, V, B, G) {
                const {lineStartIndex: U, glyphStartIndex: Z, segment: Q} = b, te = Z + b.numGlyphs,
                    ce = U + b.lineLength, _e = t.getoffsetX(Z), ve = t.getoffsetX(te - 1),
                    ue = th(u * _e, s, h, m, g, v, Q, U, ce, S, P, M, k, R, !0, O, V, B, G);
                if (!ue) return null;
                const he = th(u * ve, s, h, m, g, v, Q, U, ce, S, P, M, k, R, !0, O, V, B, G);
                return he ? {first: ue, last: he} : null
            }

            function Dp(u, t, s, h) {
                return u === o.bI.horizontal && Math.abs(h) > Math.abs(s) ? {useVertical: !0} : u === o.bI.vertical ? h > 0 ? {needsFlipping: !0} : null : t !== kl.unknown && function (m, g) {
                    return m === 0 || Math.abs(g / m) > B_
                }(s, h) ? t === kl.flipRequired ? {needsFlipping: !0} : null : s < 0 ? {needsFlipping: !0} : null
            }

            function md(u, t, s, h, m, g, v, b, S, P, M, k, R, O, V, B, G, U, Z, Q) {
                const te = t / 24, ce = u.lineOffsetX * te, _e = u.lineOffsetY * te, {
                    lineStartIndex: ve,
                    glyphStartIndex: ue,
                    numGlyphs: he,
                    segment: me,
                    writingMode: Oe,
                    flipState: Se
                } = u, Xe = ve + u.lineLength, je = Ke => {
                    if (M) {
                        const [$e, Be, tt] = Ke.up, it = P.length;
                        o.bK(M, it + 0, $e, Be, tt), o.bK(M, it + 1, $e, Be, tt), o.bK(M, it + 2, $e, Be, tt), o.bK(M, it + 3, $e, Be, tt)
                    }
                    const [ut, Fe, Te] = Ke.point;
                    o.bL(P, ut, Fe, Te, Ke.angle)
                };
                if (he > 1) {
                    const Ke = Lo(te, b, ce, _e, s, k, R, u, S, g, O, B, !1, G, U, Z, Q);
                    if (!Ke) return {notEnoughRoom: !0};
                    if (h && !s) {
                        let [ut, Fe, Te] = Ke.first.point, [$e, Be, tt] = Ke.last.point;
                        [ut, Fe] = Xo(ut, Fe, Te, v), [$e, Be] = Xo($e, Be, tt, v);
                        const it = Dp(Oe, Se, ($e - ut) * V, Be - Fe);
                        if (u.flipState = it && it.needsFlipping ? kl.flipRequired : kl.flipNotRequired, it) return it
                    }
                    je(Ke.first);
                    for (let ut = ue + 1; ut < ue + he - 1; ut++) {
                        const Fe = th(te * b.getoffsetX(ut), ce, _e, s, k, R, me, ve, Xe, S, g, O, B, !1, !1, G, U, Z, Q);
                        if (!Fe) return P.length -= 4 * (ut - ue), {notEnoughRoom: !0};
                        je(Fe)
                    }
                    je(Ke.last)
                } else {
                    if (h && !s) {
                        const ut = Xo(R.x, R.y, 0, m), Fe = ve + me + 1, Te = new o.P(S.getx(Fe), S.gety(Fe)),
                            $e = Xo(Te.x, Te.y, 0, m),
                            Be = $e[3] > 0 ? $e : Ji(R, Te, ut, 1, m, void 0, G, U.canonical),
                            tt = Dp(Oe, Se, (Be[0] - ut[0]) * V, Be[1] - ut[1]);
                        if (u.flipState = tt && tt.needsFlipping ? kl.flipRequired : kl.flipNotRequired, tt) return tt
                    }
                    const Ke = th(te * b.getoffsetX(ue), ce, _e, s, k, R, me, ve, Xe, S, g, O, B, !1, !1, G, U, Z, Q);
                    if (!Ke) return {notEnoughRoom: !0};
                    je(Ke)
                }
                return {}
            }

            function Lp(u, t, s, h, m) {
                const {x: g, y: v, z: b} = h.projectTilePoint(u.x, u.y, t);
                if (!m) return Xo(g, v, b, s);
                const [S, P, M] = m(u);
                return Xo(g + S, v + P, b + M, s)
            }

            function Ji(u, t, s, h, m, g, v, b) {
                const S = Lp(u.sub(t)._unit()._add(u), b, m, v, g);
                return o.at(S, s, S), o.au(S, S), o.bE(S, s, S, h)
            }

            function th(u, t, s, h, m, g, v, b, S, P, M, k, R, O, V, B, G, U, Z) {
                const Q = h ? u - t : u + t;
                let te = Q > 0 ? 1 : -1, ce = 0;
                h && (te *= -1, ce = Math.PI), te < 0 && (ce += Math.PI);
                let _e = b + v + (te > 0 ? 0 : 1) | 0, ve = m, ue = m, he = 0, me = 0;
                const Oe = Math.abs(Q), Se = [], Xe = [];
                let je = g, Ke = je, ut = o.bC([]);
                const Fe = () => Ji(Ke, je, ue, Oe - he + 1, M, R, B, G.canonical);
                for (; he + me <= Oe;) {
                    if (_e += te, _e < b || _e >= S) return null;
                    if (ue = ve, Ke = je, Se.push(ue), O && Xe.push(Ke), je = new o.P(P.getx(_e), P.gety(_e)), ve = k[_e], !ve) {
                        const St = Lp(je, G.canonical, M, B, R);
                        ve = St[3] > 0 ? k[_e] = St : Fe()
                    }
                    he += me;
                    const Ot = o.at([], ve, ue), Ut = o.bD(ue, ve);
                    if (s && Ut > 0 && me > 0 && o.bG(ut, Ot) / (me * Ut) < Z) return null;
                    me = Ut, ut = Ot
                }
                V && R && (k[_e] && (ve = Fe(), me = o.bD(ue, ve), ut = o.at([], ve, ue)), k[_e] = ve);
                const Te = (Oe - he) / me, $e = je.sub(Ke)._mult(Te)._add(Ke), Be = o.bE([], ue, ut, Te);
                let tt = [0, 0, 1], it = ut[0], rt = ut[1];
                if (U && (tt = B.upVector(G.canonical, $e.x, $e.y), tt[0] !== 0 || tt[1] !== 0 || tt[2] !== 1)) {
                    const Ot = [tt[2], 0, -tt[0]], Ut = o.bF([], tt, Ot);
                    o.au(Ot, Ot), o.au(Ut, Ut), it = o.bG(ut, Ot), rt = o.bG(ut, Ut)
                }
                if (s) {
                    const Ot = o.bF([], tt, ut);
                    o.au(Ot, Ot), o.bE(Be, Be, Ot, s * te)
                }
                const gt = ce + Math.atan2(rt, it);
                return Se.push(Be), O && Xe.push($e), {point: Be, angle: gt, path: Se, tilePath: Xe, up: tt}
            }

            function wc(u, t) {
                const s = t.length, h = s + 4 * u;
                t.resize(h), t.float32.fill(-1 / 0, 4 * s, 4 * h)
            }

            function N_(u, t, s) {
                const h = t[0], m = t[1];
                return u[0] = s[0] * h + s[4] * m + s[12], u[1] = s[1] * h + s[5] * m + s[13], u[3] = s[3] * h + s[7] * m + s[15], u
            }

            const qt = 100;

            class j_ {
                constructor(t, s, h = new vc(t.width + 200, t.height + 200, 25), m = new vc(t.width + 200, t.height + 200, 25)) {
                    this.transform = t, this.grid = h, this.ignoredGrid = m, this.pitchfactor = Math.cos(t._pitch) * t.cameraToCenterDistance, this.screenRightBoundary = t.width + qt, this.screenBottomBoundary = t.height + qt, this.gridRightBoundary = t.width + 200, this.gridBottomBoundary = t.height + 200, this.fogState = s
                }

                placeCollisionBox(t, s, h, m, g, v, b, S, P, M, k) {
                    let R = h.projectedAnchorX, O = h.projectedAnchorY, V = h.projectedAnchorZ;
                    const B = h.tileAnchorX, G = h.tileAnchorY, U = h.elevation, Z = h.tileID, Q = t.getProjection();
                    if (U && Z) {
                        const [Xe, je, Ke] = Q.upVector(Z.canonical, h.tileAnchorX, h.tileAnchorY),
                            ut = Q.upVectorScale(Z.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
                        R += Xe * U * ut, O += je * U * ut, V += Ke * U * ut
                    }
                    const te = t.projection.name === "globe",
                        ce = t.projection.name === "globe" ? o.ah(this.transform.zoom) : 0;
                    if (Z && te && ce < 1 && !v) {
                        const Xe = 1 << Z.canonical.z, je = o.bM(B, G);
                        o.bN(je, je, 1 / o.aj), o.bO(je, je, o.bM(Z.canonical.x, Z.canonical.y)), o.bN(je, je, 1 / Xe), o.bP(je, je, o.bM(m[0], m[1])), je[0] = o.bQ(je[0], -.5, .5), o.bN(je, je, o.aj);
                        const Ke = o.bR(je[0], je[1], o.aj / (2 * Math.PI), 1);
                        o.aA(Ke, Ke, g), R = o.ai(R, Ke[0], ce), O = o.ai(O, Ke[1], ce), V = o.ai(V, Ke[2], ce)
                    }
                    const _e = this.projectAndGetPerspectiveRatio(M, R, O, V, h.tileID, Q.name === "globe" || !!U || this.transform.pitch > 0, Q),
                        ve = P * _e.perspectiveRatio, ue = (h.x1 * s + b.x - h.padding) * ve + _e.point.x,
                        he = (h.y1 * s + b.y - h.padding) * ve + _e.point.y,
                        me = (h.x2 * s + b.x + h.padding) * ve + _e.point.x,
                        Oe = (h.y2 * s + b.y + h.padding) * ve + _e.point.y,
                        Se = _e.perspectiveRatio <= .55 || _e.occluded;
                    return !this.isInsideGrid(ue, he, me, Oe) || !S && this.grid.hitTest(ue, he, me, Oe, k) || Se ? {
                        box: [],
                        offscreen: !1,
                        occluded: _e.occluded
                    } : {box: [ue, he, me, Oe], offscreen: this.isOffscreen(ue, he, me, Oe), occluded: !1}
                }

                placeCollisionCircles(t, s, h, m, g, v, b, S, P, M, k, R, O, V, B) {
                    const G = [], U = this.transform.elevation, Z = t.getProjection(),
                        Q = U ? U.getAtTileOffsetFunc(B, this.transform.center.lat, this.transform.worldSize, Z) : null,
                        te = new o.P(h.tileAnchorX, h.tileAnchorY);
                    let {x: ce, y: _e, z: ve} = Z.projectTilePoint(te.x, te.y, B.canonical);
                    if (Q) {
                        const [tt, it, rt] = Q(te);
                        ce += tt, _e += it, ve += rt
                    }
                    const ue = Z.name === "globe",
                        he = this.projectAndGetPerspectiveRatio(b, ce, _e, ve, B, ue || !!U || this.transform.pitch > 0, Z), {perspectiveRatio: me} = he,
                        Oe = (k ? v / me : v * me) / o.bU, Se = Xo(ce, _e, ve, S), Xe = h.lineOffsetX * Oe,
                        je = h.lineOffsetY * Oe, Ke = o.al(t.layers[0].layout.get("text-max-angle")), ut = Math.cos(Ke),
                        Fe = he.signedDistanceFromCamera > 0 ? Lo(Oe, g, Xe, je, !1, Se, te, h, m, S, {}, U && !k ? Q : null, k && !!U, Z, B, k, ut) : null;
                    let Te = !1, $e = !1, Be = !0;
                    if (Fe && !he.occluded) {
                        const tt = .5 * O * me + V, it = new o.P(-100, -100),
                            rt = new o.P(this.screenRightBoundary, this.screenBottomBoundary), gt = new F_, {
                                first: Ot,
                                last: Ut
                            } = Fe, St = Ot.path.length;
                        let Nt = [];
                        for (let di = St - 1; di >= 1; di--) Nt.push(Ot.path[di]);
                        for (let di = 1; di < Ut.path.length; di++) Nt.push(Ut.path[di]);
                        const Ft = 2.5 * tt;
                        P && (Nt = Nt.map(([di, Si, Ui], ci) => (Q && !ue && (Ui = Q(ci < St - 1 ? Ot.tilePath[St - 1 - ci] : Ut.tilePath[ci - St + 2])[2]), Xo(di, Si, Ui, P))), Nt.some(di => di[3] <= 0) && (Nt = []));
                        let ri = [];
                        if (Nt.length > 0) {
                            let di = 1 / 0, Si = -1 / 0, Ui = 1 / 0, ci = -1 / 0;
                            for (const Gi of Nt) di = Math.min(di, Gi[0]), Ui = Math.min(Ui, Gi[1]), Si = Math.max(Si, Gi[0]), ci = Math.max(ci, Gi[1]);
                            Si >= it.x && di <= rt.x && ci >= it.y && Ui <= rt.y && (ri = [Nt.map(Gi => new o.P(Gi[0], Gi[1]))], (di < it.x || Si > rt.x || Ui < it.y || ci > rt.y) && (ri = o.bS(ri, it.x, it.y, rt.x, rt.y)))
                        }
                        for (const di of ri) {
                            gt.reset(di, .25 * tt);
                            let Si = 0;
                            Si = gt.length <= .5 * tt ? 1 : Math.ceil(gt.paddedLength / Ft) + 1;
                            for (let Ui = 0; Ui < Si; Ui++) {
                                const ci = Ui / Math.max(Si - 1, 1), Gi = gt.lerp(ci), qi = Gi.x + qt, pn = Gi.y + qt;
                                G.push(qi, pn, tt, 0);
                                const wi = qi - tt, $i = pn - tt, Hi = qi + tt, Xi = pn + tt;
                                if (Be = Be && this.isOffscreen(wi, $i, Hi, Xi), $e = $e || this.isInsideGrid(wi, $i, Hi, Xi), !s && this.grid.hitTestCircle(qi, pn, tt, R) && (Te = !0, !M)) return {
                                    circles: [],
                                    offscreen: !1,
                                    collisionDetected: Te,
                                    occluded: !1
                                }
                            }
                        }
                    }
                    return {
                        circles: !M && Te || !$e ? [] : G,
                        offscreen: Be,
                        collisionDetected: Te,
                        occluded: he.occluded
                    }
                }

                queryRenderedSymbols(t) {
                    if (t.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
                    const s = [];
                    let h = 1 / 0, m = 1 / 0, g = -1 / 0, v = -1 / 0;
                    for (const M of t) {
                        const k = new o.P(M.x + qt, M.y + qt);
                        h = Math.min(h, k.x), m = Math.min(m, k.y), g = Math.max(g, k.x), v = Math.max(v, k.y), s.push(k)
                    }
                    const b = this.grid.query(h, m, g, v).concat(this.ignoredGrid.query(h, m, g, v)), S = {}, P = {};
                    for (const M of b) {
                        const k = M.key;
                        if (S[k.bucketInstanceId] === void 0 && (S[k.bucketInstanceId] = {}), S[k.bucketInstanceId][k.featureIndex]) continue;
                        const R = [new o.P(M.x1, M.y1), new o.P(M.x2, M.y1), new o.P(M.x2, M.y2), new o.P(M.x1, M.y2)];
                        o.bT(s, R) && (S[k.bucketInstanceId][k.featureIndex] = !0, P[k.bucketInstanceId] === void 0 && (P[k.bucketInstanceId] = []), P[k.bucketInstanceId].push(k.featureIndex))
                    }
                    return P
                }

                insertCollisionBox(t, s, h, m, g) {
                    (s ? this.ignoredGrid : this.grid).insert({
                        bucketInstanceId: h,
                        featureIndex: m,
                        collisionGroupID: g
                    }, t[0], t[1], t[2], t[3])
                }

                insertCollisionCircles(t, s, h, m, g) {
                    const v = s ? this.ignoredGrid : this.grid,
                        b = {bucketInstanceId: h, featureIndex: m, collisionGroupID: g};
                    for (let S = 0; S < t.length; S += 4) v.insertCircle(b, t[S], t[S + 1], t[S + 2])
                }

                projectAndGetPerspectiveRatio(t, s, h, m, g, v, b) {
                    const S = [s, h, m, 1];
                    let P = !1;
                    m || this.transform.pitch > 0 ? (o.aA(S, S, t), this.fogState && g && b.name !== "globe" && (P = function (R, O, V, B, G, U) {
                        const Z = U.calculateFogTileMatrix(G), Q = [O, V, B];
                        return o.ad(Q, Q, Z), Gt(R, o.ae(Q), U.pitch, U._fov)
                    }(this.fogState, s, h, m, g.toUnwrapped(), this.transform) > .9)) : N_(S, S, t);
                    const M = S[3];
                    return {
                        point: new o.P((S[0] / M + 1) / 2 * this.transform.width + qt, (-S[1] / M + 1) / 2 * this.transform.height + qt),
                        perspectiveRatio: Math.min(.5 + this.transform.getCameraToCenterDistance(b) / M * .5, 1.5),
                        signedDistanceFromCamera: M,
                        occluded: v && S[2] > M || P
                    }
                }

                isOffscreen(t, s, h, m) {
                    return h < qt || t >= this.screenRightBoundary || m < qt || s > this.screenBottomBoundary
                }

                isInsideGrid(t, s, h, m) {
                    return h >= 0 && t < this.gridRightBoundary && m >= 0 && s < this.gridBottomBoundary
                }

                getViewportMatrix() {
                    const t = o.bx([]);
                    return o.bo(t, t, [-100, -100, 0]), t
                }
            }

            class ih {
                constructor(t, s, h, m) {
                    this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? s : -s))) : m && h ? 1 : 0, this.placed = h
                }

                isHidden() {
                    return this.opacity === 0 && !this.placed
                }
            }

            class Fl {
                constructor(t, s, h, m, g, v = !1) {
                    this.text = new ih(t ? t.text : null, s, h, g), this.icon = new ih(t ? t.icon : null, s, m, g), this.clipped = v
                }

                isHidden() {
                    return this.text.isHidden() && this.icon.isHidden()
                }
            }

            class Yo {
                constructor(t, s, h, m = !1) {
                    this.text = t, this.icon = s, this.skipFade = h, this.clipped = m
                }
            }

            class kp {
                constructor() {
                    this.invProjMatrix = o.bz(), this.viewportMatrix = o.bz(), this.circles = []
                }
            }

            class bc {
                constructor(t, s, h, m, g) {
                    this.bucketInstanceId = t, this.featureIndex = s, this.sourceLayerIndex = h, this.bucketIndex = m, this.tileID = g
                }
            }

            class Vt {
                constructor(t) {
                    this.crossSourceCollisions = t, this.maxGroupID = 0, this.collisionGroups = {}
                }

                get(t) {
                    if (this.crossSourceCollisions) return {ID: 0, predicate: null};
                    if (!this.collisionGroups[t]) {
                        const s = ++this.maxGroupID;
                        this.collisionGroups[t] = {ID: s, predicate: h => h.collisionGroupID === s}
                    }
                    return this.collisionGroups[t]
                }
            }

            function Ki(u, t, s, h, m) {
                const {horizontalAlign: g, verticalAlign: v} = o.bZ(u), b = -(g - .5) * t, S = -(v - .5) * s,
                    P = o.b_(u, h);
                return new o.P(b + P[0] * m, S + P[1] * m)
            }

            function Qi(u, t, s, h, m) {
                const g = new o.P(u, t);
                return s && g._rotate(h ? m : -m), g
            }

            class ko {
                constructor(t, s, h, m, g, v) {
                    this.transform = t.clone(), this.projection = t.projection.name, this.collisionIndex = new j_(this.transform, g), this.buildingIndex = v, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = s, this.retainedQueryData = {}, this.collisionGroups = new Vt(h), this.collisionCircleArrays = {}, this.prevPlacement = m, m && (m.prevPlacement = void 0), this.placedOrientations = {}
                }

                getBucketParts(t, s, h, m, g = 1) {
                    const v = h.getBucket(s), b = h.latestFeatureIndex;
                    if (!v || !b || s.fqid !== v.layerIds[0]) return;
                    const S = v.layers[0].layout, P = v.layers[0].paint, M = h.collisionBoxArray,
                        k = Math.pow(2, this.transform.zoom - h.tileID.overscaledZ), R = h.tileSize / o.aj,
                        O = h.tileID.toUnwrapped();
                    this.transform.setProjection(v.projection);
                    const V = (B = h.tileID, G = v.getProjection(), U = this.transform, G.name === this.projection ? U.calculateProjMatrix(B.toUnwrapped()) : Ju(U, G, B));
                    var B, G, U;
                    const Z = S.get("text-pitch-alignment") === "map", Q = S.get("text-rotation-alignment") === "map";
                    s.compileFilter(s.options);
                    const te = s.dynamicFilter(), ce = s.dynamicFilterNeedsFeature(),
                        _e = this.transform.calculatePixelsToTileUnitsMatrix(h),
                        ve = xc(V, h.tileID.canonical, Z, Q, this.transform, v.getProjection(), _e);
                    let ue = null;
                    const he = v.getProjection().createInversionMatrix(this.transform, h.tileID.canonical);
                    if (Z) {
                        const Te = _a(V, h.tileID.canonical, Z, Q, this.transform, v.getProjection(), _e);
                        ue = o.az([], this.transform.labelPlaneMatrix, Te)
                    }
                    let me = null;
                    te && h.latestFeatureIndex && (me = {
                        unwrappedTileID: O,
                        dynamicFilter: te,
                        dynamicFilterNeedsFeature: ce
                    }), this.retainedQueryData[v.bucketInstanceId] = new bc(v.bucketInstanceId, b, v.sourceLayerIndex, v.index, h.tileID);
                    const [Oe, Se] = v.layers[0].layout.get("text-size-scale-range"),
                        Xe = o.ay(g, Oe, Se), [je, Ke] = S.get("icon-size-scale-range"), ut = o.ay(g, je, Ke), Fe = {
                            bucket: v,
                            layout: S,
                            paint: P,
                            posMatrix: V,
                            invMatrix: he,
                            mercatorCenter: [o.aD(this.transform.center.lng), o.aH(this.transform.center.lat)],
                            textLabelPlaneMatrix: ve,
                            labelToScreenMatrix: ue,
                            clippingData: me,
                            scale: k,
                            textPixelRatio: R,
                            holdingForFade: h.holdingForFade(),
                            collisionBoxArray: M,
                            partiallyEvaluatedTextSize: o.bH(v.textSizeData, this.transform.zoom, Xe),
                            partiallyEvaluatedIconSize: o.bH(v.iconSizeData, this.transform.zoom, ut),
                            collisionGroup: this.collisionGroups.get(v.sourceID),
                            latestFeatureIndex: h.latestFeatureIndex
                        };
                    if (m) for (const Te of v.sortKeyRanges) {
                        const {sortKey: $e, symbolInstanceStart: Be, symbolInstanceEnd: tt} = Te;
                        t.push({sortKey: $e, symbolInstanceStart: Be, symbolInstanceEnd: tt, parameters: Fe})
                    } else t.push({symbolInstanceStart: 0, symbolInstanceEnd: v.symbolInstances.length, parameters: Fe})
                }

                attemptAnchorPlacement(t, s, h, m, g, v, b, S, P, M, k, R, O, V, B, G, U, Z, Q, te, ce) {
                    const {textOffset0: _e, textOffset1: ve, crossTileID: ue} = B, he = [_e, ve],
                        me = Ki(t, v, b, he, S),
                        Oe = this.collisionIndex.placeCollisionBox(U, S, s, h, m, g, Qi(me.x, me.y, P, M, this.transform.angle), V, k, R, O.predicate);
                    if (Q) {
                        const Se = U.getSymbolInstanceIconSize(ce, this.transform.zoom, B.placedIconSymbolIndex);
                        if (this.collisionIndex.placeCollisionBox(U, Se, Q, h, m, g, Qi(me.x, me.y, P, M, this.transform.angle), V, k, R, O.predicate).box.length === 0) return
                    }
                    if (Oe.box.length > 0) {
                        let Se;
                        return this.prevPlacement && this.prevPlacement.variableOffsets[ue] && this.prevPlacement.placements[ue] && this.prevPlacement.placements[ue].text && (Se = this.prevPlacement.variableOffsets[ue].anchor), this.variableOffsets[ue] = {
                            textOffset: he,
                            width: v,
                            height: b,
                            anchor: t,
                            textScale: S,
                            prevAnchor: Se
                        }, this.markUsedJustification(U, t, B, Z), U.allowVerticalPlacement && (this.markUsedOrientation(U, Z, B), this.placedOrientations[ue] = Z), {
                            shift: me,
                            placedGlyphBoxes: Oe
                        }
                    }
                }

                placeLayerBucketPart(t, s, h, m, g = 1) {
                    const {
                            bucket: v,
                            layout: b,
                            paint: S,
                            posMatrix: P,
                            textLabelPlaneMatrix: M,
                            labelToScreenMatrix: k,
                            clippingData: R,
                            textPixelRatio: O,
                            mercatorCenter: V,
                            invMatrix: B,
                            holdingForFade: G,
                            collisionBoxArray: U,
                            partiallyEvaluatedTextSize: Z,
                            partiallyEvaluatedIconSize: Q,
                            collisionGroup: te,
                            latestFeatureIndex: ce
                        } = t.parameters, _e = b.get("text-optional"), ve = b.get("icon-optional"),
                        ue = b.get("text-allow-overlap"), he = b.get("icon-allow-overlap"),
                        me = b.get("text-rotation-alignment") === "map",
                        Oe = b.get("icon-rotation-alignment") === "map", Se = b.get("text-pitch-alignment") === "map",
                        Xe = S.get("symbol-z-offset"), je = b.get("symbol-elevation-reference") === "sea",
                        Ke = b.get("symbol-placement"), [ut, Fe] = b.get("text-size-scale-range"), [Te, $e] = b.get("icon-size-scale-range"),
                        Be = o.ay(g, ut, Fe), tt = o.ay(g, Te, $e), it = b.get("text-variable-anchor"),
                        rt = me && Ke !== "point", gt = Oe && Ke !== "point", Ot = it && v.hasTextData(),
                        Ut = v.hasIconTextFit() && Ot && v.hasIconData();
                    this.transform.setProjection(v.projection);
                    const St = Ot || rt, Nt = gt || Ut;
                    let Ft = ue && (he || !v.hasIconData() || ve), ri = he && (ue || !v.hasTextData() || _e);
                    const di = !Xe.isConstant();
                    !v.collisionArrays && U && v.deserializeCollisionBoxes(U), h && m && v.updateCollisionDebugBuffers(this.transform.zoom, U, Be, tt);
                    const Si = (ci, Gi, qi) => {
                        const {crossTileID: pn, numVerticalGlyphVertices: wi} = ci;
                        let $i = null;
                        if (R && R.dynamicFilterNeedsFeature || di) {
                            const Yn = this.retainedQueryData[v.bucketInstanceId];
                            $i = ce.loadFeature({
                                featureIndex: ci.featureIndex,
                                bucketIndex: Yn.bucketIndex,
                                sourceLayerIndex: Yn.sourceLayerIndex,
                                layoutVertexArrayOffset: 0
                            })
                        }
                        if (R && !(0, R.dynamicFilter)({
                            zoom: this.transform.zoom,
                            pitch: this.transform.pitch
                        }, $i, this.retainedQueryData[v.bucketInstanceId].tileID.canonical, new o.P(ci.tileAnchorX, ci.tileAnchorY), this.transform.calculateDistanceTileData(R.unwrappedTileID))) return this.placements[pn] = new Yo(!1, !1, !1, !0), void s.add(pn);
                        const Hi = Xe.evaluate($i, {});
                        if (s.has(pn)) return;
                        if (G) return void (this.placements[pn] = new Yo(!1, !1, !1));
                        let Xi = !1, Ei = !1, rn = !0, Wi = !1, kn = !1, ji = null,
                            Yi = {box: null, offscreen: null, occluded: null}, hn = {box: null}, ir = null, er = null,
                            rr = null, Rr = 0, Ns = 0, _o = 0;
                        qi.textFeatureIndex ? Rr = qi.textFeatureIndex : ci.useRuntimeCollisionCircles && (Rr = ci.featureIndex), qi.verticalTextFeatureIndex && (Ns = qi.verticalTextFeatureIndex);
                        const Fo = Yn => {
                            Yn.tileID = this.retainedQueryData[v.bucketInstanceId].tileID;
                            const Un = this.transform.elevation;
                            Yn.elevation = je ? Hi : Hi + (Un ? Un.getAtTileOffset(Yn.tileID, Yn.tileAnchorX, Yn.tileAnchorY) : 0), Yn.elevation += ci.zOffset
                        }, Ur = qi.textBox;
                        if (Ur) {
                            Fo(Ur);
                            const Yn = gn => {
                                let ur = o.bI.horizontal;
                                if (v.allowVerticalPlacement && !gn && this.prevPlacement) {
                                    const zr = this.prevPlacement.placedOrientations[pn];
                                    zr && (this.placedOrientations[pn] = zr, ur = zr, this.markUsedOrientation(v, ur, ci))
                                }
                                return ur
                            }, Un = (gn, ur) => {
                                if (v.allowVerticalPlacement && wi > 0 && qi.verticalTextBox) {
                                    for (const zr of v.writingModes) if (zr === o.bI.vertical ? (Yi = ur(), hn = Yi) : Yi = gn(), Yi && Yi.box && Yi.box.length) break
                                } else Yi = gn()
                            };
                            if (it) {
                                let gn = it;
                                if (this.prevPlacement && this.prevPlacement.variableOffsets[pn]) {
                                    const Kn = this.prevPlacement.variableOffsets[pn];
                                    gn.indexOf(Kn.anchor) > 0 && (gn = gn.filter(is => is !== Kn.anchor), gn.unshift(Kn.anchor))
                                }
                                const ur = (Kn, is, Yl) => {
                                    const dl = v.getSymbolInstanceTextSize(Z, ci, this.transform.zoom, Gi),
                                        Kc = (Kn.x2 - Kn.x1) * dl + 2 * Kn.padding,
                                        Qc = (Kn.y2 - Kn.y1) * dl + 2 * Kn.padding,
                                        ns = ci.hasIconTextFit && !he ? is : null;
                                    ns && Fo(ns);
                                    let ia = {box: [], offscreen: !1, occluded: !1};
                                    const hr = ue ? 2 * gn.length : gn.length;
                                    for (let rs = 0; rs < hr; ++rs) {
                                        const Kl = this.attemptAnchorPlacement(gn[rs % gn.length], Kn, V, B, St, Kc, Qc, dl, me, Se, O, P, te, rs >= gn.length, ci, Gi, v, Yl, ns, Z, Q);
                                        if (Kl && (ia = Kl.placedGlyphBoxes, ia && ia.box && ia.box.length)) {
                                            Xi = !0, ji = Kl.shift;
                                            break
                                        }
                                    }
                                    return ia
                                };
                                Un(() => ur(Ur, qi.iconBox, o.bI.horizontal), () => {
                                    const Kn = qi.verticalTextBox;
                                    return Kn && Fo(Kn), v.allowVerticalPlacement && !(Yi && Yi.box && Yi.box.length) && wi > 0 && Kn ? ur(Kn, qi.verticalIconBox, o.bI.vertical) : {
                                        box: null,
                                        offscreen: null,
                                        occluded: null
                                    }
                                }), Yi && (Xi = Yi.box, rn = Yi.offscreen, Wi = Yi.occluded);
                                const zr = Yn(!(!Yi || !Yi.box));
                                if (!Xi && this.prevPlacement) {
                                    const Kn = this.prevPlacement.variableOffsets[pn];
                                    Kn && (this.variableOffsets[pn] = Kn, this.markUsedJustification(v, Kn.anchor, ci, zr))
                                }
                            } else {
                                const gn = (ur, zr) => {
                                    const Kn = v.getSymbolInstanceTextSize(Z, ci, this.transform.zoom, Gi, g),
                                        is = this.collisionIndex.placeCollisionBox(v, Kn, ur, V, B, St, new o.P(0, 0), ue, O, P, te.predicate);
                                    return is && is.box && is.box.length && (this.markUsedOrientation(v, zr, ci), this.placedOrientations[pn] = zr), is
                                };
                                Un(() => gn(Ur, o.bI.horizontal), () => {
                                    const ur = qi.verticalTextBox;
                                    return v.allowVerticalPlacement && wi > 0 && ur ? (Fo(ur), gn(ur, o.bI.vertical)) : {
                                        box: null,
                                        offscreen: null,
                                        occluded: null
                                    }
                                }), Yn(!!(Yi && Yi.box && Yi.box.length))
                            }
                        }
                        if (ir = Yi, Xi = ir && ir.box && ir.box.length > 0, rn = ir && ir.offscreen, Wi = ir && ir.occluded, ci.useRuntimeCollisionCircles) {
                            const Yn = v.text.placedSymbolArray.get(ci.centerJustifiedTextSymbolIndex >= 0 ? ci.centerJustifiedTextSymbolIndex : ci.verticalPlacedTextSymbolIndex),
                                Un = o.bJ(v.textSizeData, Z, Yn), gn = b.get("text-padding");
                            er = this.collisionIndex.placeCollisionCircles(v, ue, Yn, v.lineVertexArray, v.glyphOffsetArray, Un, P, M, k, h, Se, te.predicate, ci.collisionCircleDiameter * Un / o.bU, gn, this.retainedQueryData[v.bucketInstanceId].tileID), Xi = ue || er.circles.length > 0 && !er.collisionDetected, rn = rn && er.offscreen, Wi = er.occluded
                        }
                        if (qi.iconFeatureIndex && (_o = qi.iconFeatureIndex), qi.iconBox) {
                            const Yn = Un => {
                                Fo(Un);
                                const gn = ci.hasIconTextFit && ji ? Qi(ji.x, ji.y, me, Se, this.transform.angle) : new o.P(0, 0),
                                    ur = v.getSymbolInstanceIconSize(Q, this.transform.zoom, ci.placedIconSymbolIndex);
                                return this.collisionIndex.placeCollisionBox(v, ur, Un, V, B, Nt, gn, he, O, P, te.predicate)
                            };
                            hn && hn.box && hn.box.length && qi.verticalIconBox ? (rr = Yn(qi.verticalIconBox), Ei = rr.box.length > 0) : (rr = Yn(qi.iconBox), Ei = rr.box.length > 0), rn = rn && rr.offscreen, kn = rr.occluded
                        }
                        const ts = _e || ci.numHorizontalGlyphVertices === 0 && wi === 0,
                            Ss = ve || ci.numIconVertices === 0;
                        if (ts || Ss ? Ss ? ts || (Ei = Ei && Xi) : Xi = Ei && Xi : Ei = Xi = Ei && Xi, Xi && ir && ir.box && this.collisionIndex.insertCollisionBox(ir.box, b.get("text-ignore-placement"), v.bucketInstanceId, hn && hn.box && Ns ? Ns : Rr, te.ID), Ei && rr && this.collisionIndex.insertCollisionBox(rr.box, b.get("icon-ignore-placement"), v.bucketInstanceId, _o, te.ID), er && (Xi && this.collisionIndex.insertCollisionCircles(er.circles, b.get("text-ignore-placement"), v.bucketInstanceId, Rr, te.ID), h)) {
                            const Yn = v.bucketInstanceId;
                            let Un = this.collisionCircleArrays[Yn];
                            Un === void 0 && (Un = this.collisionCircleArrays[Yn] = new kp);
                            for (let gn = 0; gn < er.circles.length; gn += 4) Un.circles.push(er.circles[gn + 0]), Un.circles.push(er.circles[gn + 1]), Un.circles.push(er.circles[gn + 2]), Un.circles.push(er.collisionDetected ? 1 : 0)
                        }
                        const Gr = v.projection.name !== "globe";
                        Ft = Ft && (Gr || !Wi), ri = ri && (Gr || !kn), this.placements[pn] = new Yo(Xi || Ft, Ei || ri, rn || v.justReloaded), s.add(pn)
                    }, Ui = this.retainedQueryData[v.bucketInstanceId].tileID;
                    if (v.elevationType === "offset" && this.buildingIndex && this.buildingIndex.updateZOffset(v, Ui), v.elevationType === "road" && v.updateRoadElevation(Ui.canonical), v.updateZOffset(), v.sortFeaturesByY) {
                        const ci = v.getSortedSymbolIndexes(this.transform.angle);
                        for (let Gi = ci.length - 1; Gi >= 0; --Gi) {
                            const qi = ci[Gi];
                            Si(v.symbolInstances.get(qi), qi, v.collisionArrays[qi])
                        }
                        v.hasAnyZOffset && o.w(`${v.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`)
                    } else if (v.hasAnyZOffset) {
                        const ci = v.getSortedIndexesByZOffset();
                        for (let Gi = 0; Gi < ci.length; ++Gi) {
                            const qi = ci[Gi];
                            Si(v.symbolInstances.get(qi), qi, v.collisionArrays[qi])
                        }
                    } else for (let ci = t.symbolInstanceStart; ci < t.symbolInstanceEnd; ci++) Si(v.symbolInstances.get(ci), ci, v.collisionArrays[ci]);
                    if (h && v.bucketInstanceId in this.collisionCircleArrays) {
                        const ci = this.collisionCircleArrays[v.bucketInstanceId];
                        o.bi(ci.invProjMatrix, P), ci.viewportMatrix = this.collisionIndex.getViewportMatrix()
                    }
                    v.justReloaded = !1
                }

                markUsedJustification(t, s, h, m) {
                    const {
                            leftJustifiedTextSymbolIndex: g,
                            centerJustifiedTextSymbolIndex: v,
                            rightJustifiedTextSymbolIndex: b,
                            verticalPlacedTextSymbolIndex: S,
                            crossTileID: P
                        } = h, M = o.b$(s),
                        k = m === o.bI.vertical ? S : M === "left" ? g : M === "center" ? v : M === "right" ? b : -1;
                    g >= 0 && (t.text.placedSymbolArray.get(g).crossTileID = k >= 0 && g !== k ? 0 : P), v >= 0 && (t.text.placedSymbolArray.get(v).crossTileID = k >= 0 && v !== k ? 0 : P), b >= 0 && (t.text.placedSymbolArray.get(b).crossTileID = k >= 0 && b !== k ? 0 : P), S >= 0 && (t.text.placedSymbolArray.get(S).crossTileID = k >= 0 && S !== k ? 0 : P)
                }

                markUsedOrientation(t, s, h) {
                    const m = s === o.bI.horizontal || s === o.bI.horizontalOnly ? s : 0,
                        g = s === o.bI.vertical ? s : 0, {
                            leftJustifiedTextSymbolIndex: v,
                            centerJustifiedTextSymbolIndex: b,
                            rightJustifiedTextSymbolIndex: S,
                            verticalPlacedTextSymbolIndex: P
                        } = h, M = t.text.placedSymbolArray;
                    v >= 0 && (M.get(v).placedOrientation = m), b >= 0 && (M.get(b).placedOrientation = m), S >= 0 && (M.get(S).placedOrientation = m), P >= 0 && (M.get(P).placedOrientation = g)
                }

                commit(t) {
                    this.commitTime = t, this.zoomAtLastRecencyCheck = this.transform.zoom;
                    const s = this.prevPlacement;
                    let h = !1;
                    this.prevZoomAdjustment = s ? s.zoomAdjustment(this.transform.zoom) : 0;
                    const m = s ? s.symbolFadeChange(t) : 1, g = s ? s.opacities : {}, v = s ? s.variableOffsets : {},
                        b = s ? s.placedOrientations : {};
                    for (const S in this.placements) {
                        const P = this.placements[S], M = g[S];
                        M ? (this.opacities[S] = new Fl(M, m, P.text, P.icon, null, P.clipped), h = h || P.text !== M.text.placed || P.icon !== M.icon.placed) : (this.opacities[S] = new Fl(null, m, P.text, P.icon, P.skipFade, P.clipped), h = h || P.text || P.icon)
                    }
                    for (const S in g) {
                        const P = g[S];
                        if (!this.opacities[S]) {
                            const M = new Fl(P, m, !1, !1);
                            M.isHidden() || (this.opacities[S] = M, h = h || P.text.placed || P.icon.placed)
                        }
                    }
                    for (const S in v) this.variableOffsets[S] || !this.opacities[S] || this.opacities[S].isHidden() || (this.variableOffsets[S] = v[S]);
                    for (const S in b) this.placedOrientations[S] || !this.opacities[S] || this.opacities[S].isHidden() || (this.placedOrientations[S] = b[S]);
                    h ? this.lastPlacementChangeTime = t : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = s ? s.lastPlacementChangeTime : t)
                }

                updateLayerOpacities(t, s, h, m) {
                    const g = new Set;
                    for (const v of s) {
                        const b = v.getBucket(t);
                        b && v.latestFeatureIndex && t.fqid === b.layerIds[0] && (this.updateBucketOpacities(b, g, v, v.collisionBoxArray, h, m, v.tileID, t.scope), b.elevationType === "offset" && this.buildingIndex && this.buildingIndex.updateZOffset(b, v.tileID), b.elevationType === "road" && b.updateRoadElevation(v.tileID.canonical), b.updateZOffset())
                    }
                }

                updateBucketOpacities(t, s, h, m, g, v, b, S) {
                    t.hasTextData() && t.text.opacityVertexArray.clear(), t.hasIconData() && t.icon.opacityVertexArray.clear(), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();
                    const P = t.layers[0].layout, M = t.layers[0].paint, k = !!t.layers[0].dynamicFilter(),
                        R = new Fl(null, 0, !1, !1, !0), O = P.get("text-allow-overlap"),
                        V = P.get("icon-allow-overlap"), B = P.get("text-variable-anchor"),
                        G = P.get("text-rotation-alignment") === "map", U = P.get("text-pitch-alignment") === "map",
                        Z = M.get("symbol-z-offset"), Q = P.get("symbol-elevation-reference") === "sea",
                        te = !Z.isConstant(),
                        ce = new Fl(null, 0, O && (V || !t.hasIconData() || P.get("icon-optional")), V && (O || !t.hasTextData() || P.get("text-optional")), !0);
                    !t.collisionArrays && m && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(m);
                    const _e = (ue, he, me) => {
                        for (let Oe = 0; Oe < he / 4; Oe++) ue.opacityVertexArray.emplaceBack(me)
                    };
                    let ve = 0;
                    v && t.updateReplacement(b, v);
                    for (let ue = 0; ue < t.symbolInstances.length; ue++) {
                        const he = t.symbolInstances.get(ue), {
                            numHorizontalGlyphVertices: me,
                            numVerticalGlyphVertices: Oe,
                            crossTileID: Se,
                            numIconVertices: Xe,
                            tileAnchorX: je,
                            tileAnchorY: Ke
                        } = he;
                        let ut = null;
                        const Fe = this.retainedQueryData[t.bucketInstanceId];
                        te && he && Fe && (ut = h.latestFeatureIndex.loadFeature({
                            featureIndex: he.featureIndex,
                            bucketIndex: Fe.bucketIndex,
                            sourceLayerIndex: Fe.sourceLayerIndex,
                            layoutVertexArrayOffset: 0
                        }));
                        const Te = Z.evaluate(ut, {}), $e = s.has(Se);
                        let Be = this.opacities[Se];
                        $e ? Be = R : Be || (Be = ce, this.opacities[Se] = Be), s.add(Se);
                        const tt = me > 0 || Oe > 0, it = Xe > 0, rt = this.placedOrientations[Se],
                            gt = rt === o.bI.vertical, Ot = rt === o.bI.horizontal || rt === o.bI.horizontalOnly;
                        !tt && !it || Be.isHidden() || ve++;
                        let Ut = !1;
                        if ((tt || it) && v) for (const St of t.activeReplacements) {
                            if (o.bV(St, g, o.bW.Symbol, S) || St.min.x > je || je > St.max.x || St.min.y > Ke || Ke > St.max.y) continue;
                            const Nt = o.bX(je, Ke, b.canonical, St.footprintTileId.canonical);
                            if (Ut = o.bY(Nt, St.footprint), Ut) break
                        }
                        if (tt) {
                            const St = Ut ? Za : Tc(Be.text);
                            _e(t.text, me, gt ? Za : St), _e(t.text, Oe, Ot ? Za : St);
                            const Nt = Be.text.isHidden(), {
                                leftJustifiedTextSymbolIndex: Ft,
                                centerJustifiedTextSymbolIndex: ri,
                                rightJustifiedTextSymbolIndex: di,
                                verticalPlacedTextSymbolIndex: Si
                            } = he, Ui = t.text.placedSymbolArray, ci = Nt || gt ? 1 : 0;
                            Ft >= 0 && (Ui.get(Ft).hidden = ci), ri >= 0 && (Ui.get(ri).hidden = ci), di >= 0 && (Ui.get(di).hidden = ci), Si >= 0 && (Ui.get(Si).hidden = Nt || Ot ? 1 : 0);
                            const Gi = this.variableOffsets[Se];
                            Gi && this.markUsedJustification(t, Gi.anchor, he, rt);
                            const qi = this.placedOrientations[Se];
                            qi && (this.markUsedJustification(t, "left", he, qi), this.markUsedOrientation(t, qi, he))
                        }
                        if (it) {
                            const St = Ut ? Za : Tc(Be.icon), {
                                placedIconSymbolIndex: Nt,
                                verticalPlacedIconSymbolIndex: Ft
                            } = he, ri = t.icon.placedSymbolArray, di = Be.icon.isHidden() ? 1 : 0;
                            Nt >= 0 && (_e(t.icon, Xe, gt ? Za : St), ri.get(Nt).hidden = di), Ft >= 0 && (_e(t.icon, he.numVerticalIconVertices, Ot ? Za : St), ri.get(Ft).hidden = di)
                        }
                        if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {
                            const St = t.collisionArrays[ue];
                            if (St) {
                                let Nt = new o.P(0, 0), Ft = !0;
                                if (St.textBox || St.verticalTextBox) {
                                    if (B) {
                                        const di = this.variableOffsets[Se];
                                        di ? (Nt = Ki(di.anchor, di.width, di.height, di.textOffset, di.textScale), G && Nt._rotate(U ? this.transform.angle : -this.transform.angle)) : Ft = !1
                                    }
                                    k && (Ft = !Be.clipped), St.textBox && ya(t.textCollisionBox.collisionVertexArray, Be.text.placed, !Ft || gt, Te, Q, Nt.x, Nt.y), St.verticalTextBox && ya(t.textCollisionBox.collisionVertexArray, Be.text.placed, !Ft || Ot, Te, Q, Nt.x, Nt.y)
                                }
                                const ri = Ft && !!(!Ot && St.verticalIconBox);
                                St.iconBox && ya(t.iconCollisionBox.collisionVertexArray, Be.icon.placed, ri, Te, Q, he.hasIconTextFit ? Nt.x : 0, he.hasIconTextFit ? Nt.y : 0), St.verticalIconBox && ya(t.iconCollisionBox.collisionVertexArray, Be.icon.placed, !ri, Te, Q, he.hasIconTextFit ? Nt.x : 0, he.hasIconTextFit ? Nt.y : 0)
                            }
                        }
                    }
                    if (t.fullyClipped = ve === 0, t.sortFeatures(this.transform.angle), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.bucketInstanceId in this.collisionCircleArrays) {
                        const ue = this.collisionCircleArrays[t.bucketInstanceId];
                        t.placementInvProjMatrix = ue.invProjMatrix, t.placementViewportMatrix = ue.viewportMatrix, t.collisionCircleArray = ue.circles, delete this.collisionCircleArrays[t.bucketInstanceId]
                    }
                }

                symbolFadeChange(t) {
                    return this.fadeDuration === 0 ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
                }

                zoomAdjustment(t) {
                    return Math.max(0, (this.transform.zoom - t) / 1.5)
                }

                hasTransitions(t) {
                    return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration
                }

                stillRecent(t, s) {
                    const h = this.zoomAtLastRecencyCheck === s ? 1 - this.zoomAdjustment(s) : 1;
                    return this.zoomAtLastRecencyCheck = s, this.commitTime + this.fadeDuration * h > t
                }

                setStale() {
                    this.stale = !0
                }
            }

            function ya(u, t, s, h, m, g, v) {
                u.emplaceBack(t ? 1 : 0, s ? 1 : 0, g || 0, v || 0, h, m ? 1 : 0), u.emplaceBack(t ? 1 : 0, s ? 1 : 0, g || 0, v || 0, h, m ? 1 : 0), u.emplaceBack(t ? 1 : 0, s ? 1 : 0, g || 0, v || 0, h, m ? 1 : 0), u.emplaceBack(t ? 1 : 0, s ? 1 : 0, g || 0, v || 0, h, m ? 1 : 0)
            }

            const en = Math.pow(2, 25), gd = Math.pow(2, 24), nh = Math.pow(2, 17), rh = Math.pow(2, 16),
                Jr = Math.pow(2, 9), cr = Math.pow(2, 8), jx = Math.pow(2, 1);

            function Tc(u) {
                if (u.opacity === 0 && !u.placed) return 0;
                if (u.opacity === 1 && u.placed) return 4294967295;
                const t = u.placed ? 1 : 0, s = Math.floor(127 * u.opacity);
                return s * en + t * gd + s * nh + t * rh + s * Jr + t * cr + s * jx + t
            }

            const Za = 0;

            class oh {
                constructor(t) {
                    this._sortAcrossTiles = t.layout.get("symbol-z-order") !== "viewport-y" && t.layout.get("symbol-sort-key").constantOr(1) !== void 0, this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = new Set, this._bucketParts = []
                }

                continuePlacement(t, s, h, m, g, v) {
                    const b = this._bucketParts;
                    for (; this._currentTileIndex < t.length;) if (s.getBucketParts(b, m, t[this._currentTileIndex], this._sortAcrossTiles, v), this._currentTileIndex++, g()) return !0;
                    for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, b.sort((S, P) => S.sortKey - P.sortKey)); this._currentPartIndex < b.length;) {
                        const S = b[this._currentPartIndex];
                        if (s.placeLayerBucketPart(S, this._seenCrossTileIDs, h, S.symbolInstanceStart === 0, v), this._currentPartIndex++, g()) return !0
                    }
                    return !1
                }
            }

            class _d {
                constructor(t, s, h, m, g, v, b, S, P) {
                    this.placement = new ko(t, g, v, b, S, P), this._currentPlacementIndex = s.length - 1, this._forceFullPlacement = h, this._showCollisionBoxes = m, this._done = !1
                }

                isDone() {
                    return this._done
                }

                continuePlacement(t, s, h, m, g) {
                    const v = o.q.now(), b = () => {
                        const S = o.q.now() - v;
                        return !this._forceFullPlacement && S > 2
                    };
                    for (; this._currentPlacementIndex >= 0;) {
                        const S = s[t[this._currentPlacementIndex]], P = this.placement.collisionIndex.transform.zoom;
                        if (S.type === "symbol" && (!S.minzoom || S.minzoom <= P) && (!S.maxzoom || S.maxzoom > P)) {
                            const M = S, k = M.layout.get("symbol-z-elevate"),
                                R = M.layout.get("symbol-sort-key").constantOr(1) !== void 0,
                                O = M.layout.get("symbol-z-order"),
                                V = O === "viewport-y" || O === "auto" && !(O !== "viewport-y" && R),
                                B = M.layout.get("text-allow-overlap") || M.layout.get("icon-allow-overlap") || M.layout.get("text-ignore-placement") || M.layout.get("icon-ignore-placement"),
                                G = V && B, U = this._inProgressLayer = this._inProgressLayer || new oh(M),
                                Z = o.C(S.source, S.scope);
                            if (U.continuePlacement(k || G ? m[Z] : h[Z], this.placement, this._showCollisionBoxes, S, b, g)) return;
                            delete this._inProgressLayer
                        }
                        this._currentPlacementIndex--
                    }
                    this._done = !0
                }

                commit(t) {
                    return this.placement.commit(t), this.placement
                }
            }

            const sh = 512 / o.aj / 2;

            class yd {
                constructor(t, s, h) {
                    this.tileID = t, this.bucketInstanceId = h, this.index = new o.c0(s.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
                    const m = t.canonical.x * o.aj, g = t.canonical.y * o.aj;
                    for (let v = 0; v < s.length; v++) {
                        const {key: b, crossTileID: S, tileAnchorX: P, tileAnchorY: M} = s.get(v),
                            k = Math.floor((m + P) * sh), R = Math.floor((g + M) * sh);
                        this.index.add(k, R), this.keys.push(b), this.crossTileIDs.push(S)
                    }
                    this.index.finish()
                }

                findMatches(t, s, h) {
                    const m = this.tileID.canonical.z < s.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - s.canonical.z),
                        g = sh / Math.pow(2, s.canonical.z - this.tileID.canonical.z), v = s.canonical.x * o.aj,
                        b = s.canonical.y * o.aj;
                    for (let S = 0; S < t.length; S++) {
                        const P = t.get(S);
                        if (P.crossTileID) continue;
                        const {key: M, tileAnchorX: k, tileAnchorY: R} = P, O = Math.floor((v + k) * g),
                            V = Math.floor((b + R) * g),
                            B = this.index.range(O - m, V - m, O + m, V + m).sort((G, U) => G - U);
                        for (const G of B) {
                            const U = this.crossTileIDs[G];
                            if (this.keys[G] === M && !h.has(U)) {
                                h.add(U), P.crossTileID = U;
                                break
                            }
                        }
                    }
                }
            }

            class fo {
                constructor() {
                    this.maxCrossTileID = 0
                }

                generate() {
                    return ++this.maxCrossTileID
                }
            }

            class va {
                constructor() {
                    this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0
                }

                handleWrapJump(t) {
                    const s = Math.round((t - this.lng) / 360);
                    if (s !== 0) for (const h in this.indexes) {
                        const m = this.indexes[h], g = {};
                        for (const v in m) {
                            const b = m[v];
                            b.tileID = b.tileID.unwrapTo(b.tileID.wrap + s), g[b.tileID.key] = b
                        }
                        this.indexes[h] = g
                    }
                    this.lng = t
                }

                addBucket(t, s, h) {
                    if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) {
                        if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === s.bucketInstanceId) return !1;
                        this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key])
                    }
                    for (let g = 0; g < s.symbolInstances.length; g++) s.symbolInstances.get(g).crossTileID = 0;
                    this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = new Set);
                    const m = this.usedCrossTileIDs[t.overscaledZ];
                    for (const g in this.indexes) {
                        const v = this.indexes[g];
                        if (Number(g) > t.overscaledZ) for (const b in v) {
                            const S = v[b];
                            S.tileID.isChildOf(t) && S.findMatches(s.symbolInstances, t, m)
                        } else {
                            const b = v[t.scaledTo(Number(g)).key];
                            b && b.findMatches(s.symbolInstances, t, m)
                        }
                    }
                    for (let g = 0; g < s.symbolInstances.length; g++) {
                        const v = s.symbolInstances.get(g);
                        v.crossTileID || (v.crossTileID = h.generate(), m.add(v.crossTileID))
                    }
                    return this.indexes[t.overscaledZ] === void 0 && (this.indexes[t.overscaledZ] = {}), this.indexes[t.overscaledZ][t.key] = new yd(t, s.symbolInstances, s.bucketInstanceId), !0
                }

                removeBucketCrossTileIDs(t, s) {
                    for (const h of s.crossTileIDs) this.usedCrossTileIDs[t].delete(h)
                }

                removeStaleBuckets(t) {
                    let s = !1;
                    for (const h in this.indexes) {
                        const m = this.indexes[h];
                        for (const g in m) t[m[g].bucketInstanceId] || (this.removeBucketCrossTileIDs(h, m[g]), delete m[g], s = !0)
                    }
                    return s
                }
            }

            class Ao {
                constructor() {
                    this.layerIndexes = {}, this.crossTileIDs = new fo, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {}
                }

                addLayer(t, s, h, m) {
                    let g = this.layerIndexes[t.fqid];
                    g === void 0 && (g = this.layerIndexes[t.fqid] = new va);
                    let v = !1;
                    const b = {};
                    m.name !== "globe" && g.handleWrapJump(h);
                    for (const S of s) {
                        const P = S.getBucket(t);
                        P && t.fqid === P.layerIds[0] && (P.bucketInstanceId || (P.bucketInstanceId = ++this.maxBucketInstanceId), g.addBucket(S.tileID, P, this.crossTileIDs) && (v = !0), b[P.bucketInstanceId] = !0)
                    }
                    return g.removeStaleBuckets(b) && (v = !0), v
                }

                pruneUnusedLayers(t) {
                    const s = {};
                    t.forEach(h => {
                        s[h] = !0
                    });
                    for (const h in this.layerIndexes) s[h] || delete this.layerIndexes[h]
                }
            }

            const Bl = 771;

            class gi {
                constructor(t, s, h, m) {
                    this.blendFunction = t, this.blendColor = s.toNonPremultipliedRenderColor(null), this.mask = h, this.blendEquation = m
                }
            }

            gi.Replace = [1, 0, 1, 0], gi.disabled = new gi(gi.Replace, o.am.transparent, [!1, !1, !1, !1]), gi.unblended = new gi(gi.Replace, o.am.transparent, [!0, !0, !0, !0]), gi.alphaBlended = new gi([1, Bl, 1, Bl], o.am.transparent, [!0, !0, !0, !0]), gi.alphaBlendedNonPremultiplied = new gi([770, Bl, 770, Bl], o.am.transparent, [!0, !0, !0, !0]), gi.multiply = new gi([774, 0, 774, 0], o.am.transparent, [!0, !0, !0, !0]);

            class It {
                constructor(t, s, h) {
                    this.func = t, this.mask = s, this.range = h
                }
            }

            It.ReadOnly = !1, It.ReadWrite = !0, It.disabled = new It(519, It.ReadOnly, [0, 1]);
            const ys = 7680;

            class ei {
                constructor(t, s, h, m, g, v) {
                    this.test = t, this.ref = s, this.mask = h, this.fail = m, this.depthFail = g, this.pass = v
                }
            }

            ei.disabled = new ei({func: 519, mask: 0}, 0, 0, ys, ys, ys);
            const or = 1029, ah = 2305;

            class Yt {
                constructor(t, s, h) {
                    this.enable = t, this.mode = s, this.frontFace = h
                }
            }

            function Sc(u, t) {
                const s = o.c6(u, 3);
                o.c8(u, t), o.cc(u, 3, s)
            }

            function Ec(u, t) {
                const s = o.c3([]);
                return o.c4(s, s, -t), o.c5(s, s, -u), s
            }

            function Xa(u, t) {
                const s = [u[0], u[1], 0], h = [t[0], t[1], 0];
                if (o.ae(s) >= 1e-15) {
                    const v = o.au([], s);
                    o.c1(h, v, o.bG(h, v)), t[0] = h[0], t[1] = h[1]
                }
                const m = o.bF([], t, u);
                if (o.c2(m) < 1e-15) return null;
                const g = Math.atan2(-m[1], m[0]);
                return Ec(Math.atan2(Math.sqrt(u[0] * u[0] + u[1] * u[1]), -u[2]), g)
            }

            Yt.disabled = new Yt(!1, or, ah), Yt.backCCW = new Yt(!0, or, ah), Yt.backCW = new Yt(!0, or, 2304), Yt.frontCW = new Yt(!0, 1028, 2304), Yt.frontCCW = new Yt(!0, 1028, ah);

            class V_ {
                constructor(t, s) {
                    this.position = t, this.orientation = s
                }

                get position() {
                    return this._position
                }

                set position(t) {
                    if (t) {
                        const s = t instanceof o.ac ? t : new o.ac(t[0], t[1], t[2]);
                        this._renderWorldCopies && (s.x = o.bQ(s.x, 0, 1)), this._position = s
                    } else this._position = null
                }

                lookAtPoint(t, s) {
                    if (this.orientation = null, !this.position) return;
                    const h = this.position,
                        m = this._elevation ? this._elevation.getAtPointOrZero(o.ac.fromLngLat(t)) : 0,
                        g = o.ac.fromLngLat(t, m), v = [g.x - h.x, g.y - h.y, g.z - h.z];
                    s || (s = [0, 0, 1]), s[2] = Math.abs(s[2]), this.orientation = Xa(v, s)
                }

                setPitchBearing(t, s) {
                    this.orientation = Ec(o.al(t), o.al(-s))
                }
            }

            class vs {
                constructor(t, s) {
                    this._transform = o.bx([]), this.orientation = s, this.position = t
                }

                get mercatorPosition() {
                    const t = this.position;
                    return new o.ac(t[0], t[1], t[2])
                }

                get position() {
                    const t = o.c6(this._transform, 3);
                    return [t[0], t[1], t[2]]
                }

                set position(t) {
                    var s;
                    t && o.cc(this._transform, 3, [(s = t)[0], s[1], s[2], 1])
                }

                get orientation() {
                    return this._orientation
                }

                set orientation(t) {
                    this._orientation = t || o.c3([]), t && Sc(this._transform, this._orientation)
                }

                getPitchBearing() {
                    const t = this.forward(), s = this.right();
                    return {
                        bearing: Math.atan2(-s[1], s[0]),
                        pitch: Math.atan2(Math.sqrt(t[0] * t[0] + t[1] * t[1]), -t[2])
                    }
                }

                setPitchBearing(t, s) {
                    this._orientation = Ec(t, s), Sc(this._transform, this._orientation)
                }

                forward() {
                    const t = o.c6(this._transform, 2);
                    return [-t[0], -t[1], -t[2]]
                }

                up() {
                    const t = o.c6(this._transform, 1);
                    return [-t[0], -t[1], -t[2]]
                }

                right() {
                    const t = o.c6(this._transform, 0);
                    return [t[0], t[1], t[2]]
                }

                getCameraToWorld(t, s) {
                    const h = new Float64Array(16);
                    return o.bi(h, this.getWorldToCamera(t, s)), h
                }

                getCameraToWorldMercator() {
                    return this._transform
                }

                getWorldToCameraPosition(t, s, h) {
                    const m = this.position;
                    o.c1(m, m, -t);
                    const g = new Float64Array(16);
                    return o.bn(g, [h, h, h]), o.bo(g, g, m), g[10] *= s, g
                }

                getWorldToCamera(t, s) {
                    const h = new Float64Array(16), m = new Float64Array(4), g = this.position;
                    return o.c7(m, this._orientation), o.c1(g, g, -t), o.c8(h, m), o.bo(h, h, g), h[1] *= -1, h[5] *= -1, h[9] *= -1, h[13] *= -1, h[8] *= s, h[9] *= s, h[10] *= s, h[11] *= s, h
                }

                getCameraToClipPerspective(t, s, h, m) {
                    const g = new Float64Array(16);
                    return o.c9(g, t, s, h, m), g
                }

                getCameraToClipOrthographic(t, s, h, m, g, v) {
                    const b = new Float64Array(16);
                    return o.ca(b, t, s, h, m, g, v), b
                }

                getDistanceToElevation(t, s = !1) {
                    const h = t === 0 ? 0 : o.cb(t, s ? o.aY(this.position[1]) : this.position[1]), m = this.forward();
                    return (h - this.position[2]) / m[2]
                }

                clone() {
                    return new vs([...this.position], [...this.orientation])
                }
            }

            const po = {
                BaseColor: 5,
                MetallicRoughness: 6,
                Normal: 7,
                Occlusion: 8,
                Emission: 9,
                LUT: 10,
                ShadowMap0: 11
            };

            class lh {
                constructor(t = 0, s = 0, h = 0, m = 0) {
                    if (isNaN(t) || t < 0 || isNaN(s) || s < 0 || isNaN(h) || h < 0 || isNaN(m) || m < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
                    this.top = t, this.bottom = s, this.left = h, this.right = m
                }

                interpolate(t, s, h) {
                    return s.top != null && t.top != null && (this.top = o.ai(t.top, s.top, h)), s.bottom != null && t.bottom != null && (this.bottom = o.ai(t.bottom, s.bottom, h)), s.left != null && t.left != null && (this.left = o.ai(t.left, s.left, h)), s.right != null && t.right != null && (this.right = o.ai(t.right, s.right, h)), this
                }

                getCenter(t, s) {
                    const h = o.ay((this.left + t - this.right) / 2, 0, t),
                        m = o.ay((this.top + s - this.bottom) / 2, 0, s);
                    return new o.P(h, m)
                }

                equals(t) {
                    return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right
                }

                clone() {
                    return new lh(this.top, this.bottom, this.left, this.right)
                }

                toJSON() {
                    return {top: this.top, bottom: this.bottom, left: this.left, right: this.right}
                }
            }

            const Mr = 15;

            class Op {
                constructor(t, s, h, m, g, v, b) {
                    this.tileSize = 512, this._renderWorldCopies = g === void 0 || g, this._minZoom = t || 0, this._maxZoom = s || 22, this._minPitch = h ?? 0, this._maxPitch = m ?? 60, this.setProjection(v), this.setMaxBounds(b), this.width = 0, this.height = 0, this._center = new o.ci(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new lh, this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new vs, this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._tileCoverLift = 0, this.freezeTileCoverage = !1, this._horizonShift = .1, this._orthographicProjectionAtLowPitch = !1, this._allowWorldUnderZoom = !1
                }

                clone() {
                    const t = new Op(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection(), this.maxBounds);
                    return t._elevation = this._elevation, t._centerAltitude = this._centerAltitude, t._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, t.tileSize = this.tileSize, t.mercatorFromTransition = this.mercatorFromTransition, t.width = this.width, t.height = this.height, t.cameraElevationReference = this.cameraElevationReference, t._center = this._center, t._setZoom(this.zoom), t._seaLevelZoom = this._seaLevelZoom, t.angle = this.angle, t._fov = this._fov, t._pitch = this._pitch, t._nearZ = this._nearZ, t._farZ = this._farZ, t._averageElevation = this._averageElevation, t._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, t._unmodified = this._unmodified, t._edgeInsets = this._edgeInsets.clone(), t._camera = this._camera.clone(), t._calcMatrices(), t.freezeTileCoverage = this.freezeTileCoverage, t.frustumCorners = this.frustumCorners, t._allowWorldUnderZoom = this._allowWorldUnderZoom, t
                }

                get isOrthographic() {
                    return this.projection.name !== "globe" && this._orthographicProjectionAtLowPitch && this.pitch < Mr
                }

                get elevation() {
                    return this._elevation
                }

                set elevation(t) {
                    this._elevation !== t && (this._elevation = t, this._updateCameraOnTerrain(), this._calcMatrices())
                }

                get depthOcclusionForSymbolsAndCircles() {
                    return this.projection.name !== "globe" && !this.isOrthographic
                }

                updateElevation(t, s = !1) {
                    const h = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
                    (this._seaLevelZoom == null || h) && this._updateCameraOnTerrain(), (t || h) && this._constrainCamera(s), this._calcMatrices()
                }

                getProjection() {
                    return o.aF(this.projection, ["name", "center", "parallels"])
                }

                setProjection(t) {
                    this.projectionOptions = t || {name: "mercator"};
                    const s = this.projection ? this.getProjection() : void 0;
                    this.projection = o.cj(this.projectionOptions);
                    const h = this.getProjection(), m = !o.bv(s, h);
                    return m && this._calcMatrices(), this.mercatorFromTransition = !1, m
                }

                setOrthographicProjectionAtLowPitch(t) {
                    return this._orthographicProjectionAtLowPitch !== t && (this._orthographicProjectionAtLowPitch = t, this._calcMatrices(), !0)
                }

                setMercatorFromTransition() {
                    const t = this.projection.name;
                    this.mercatorFromTransition = !0, this.projectionOptions = {name: "mercator"}, this.projection = o.cj({name: "mercator"});
                    const s = t !== this.projection.name;
                    return s && this._calcMatrices(), s
                }

                get minZoom() {
                    return this._minZoom
                }

                set minZoom(t) {
                    this._minZoom !== t && (this._minZoom = t, this.zoom = Math.max(this.zoom, t))
                }

                get maxZoom() {
                    return this._maxZoom
                }

                set maxZoom(t) {
                    this._maxZoom !== t && (this._maxZoom = t, this.zoom = Math.min(this.zoom, t))
                }

                get minPitch() {
                    return this._minPitch
                }

                set minPitch(t) {
                    this._minPitch !== t && (this._minPitch = t, this.pitch = Math.max(this.pitch, t))
                }

                get maxPitch() {
                    return this._maxPitch
                }

                set maxPitch(t) {
                    this._maxPitch !== t && (this._maxPitch = t, this.pitch = Math.min(this.pitch, t))
                }

                get renderWorldCopies() {
                    return this._renderWorldCopies && this.projection.supportsWorldCopies === !0
                }

                set renderWorldCopies(t) {
                    t === void 0 ? t = !0 : t === null && (t = !1), this._renderWorldCopies = t
                }

                get worldSize() {
                    return this.tileSize * this.scale
                }

                get cameraWorldSizeForFog() {
                    const t = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
                    return this._worldSizeFromZoom(this._zoomFromMercatorZ(t))
                }

                get cameraWorldSize() {
                    const t = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);
                    return this._worldSizeFromZoom(this._zoomFromMercatorZ(t))
                }

                get pixelsPerMeter() {
                    return this.projection.pixelsPerMeter(this.center.lat, this.worldSize)
                }

                get cameraPixelsPerMeter() {
                    return o.cb(1, this.center.lat) * this.cameraWorldSizeForFog
                }

                get centerOffset() {
                    return this.centerPoint._sub(this.size._div(2))
                }

                get size() {
                    return new o.P(this.width, this.height)
                }

                get bearing() {
                    return o.bQ(this.rotation, -180, 180)
                }

                set bearing(t) {
                    this.rotation = t
                }

                get rotation() {
                    return -this.angle / Math.PI * 180
                }

                set rotation(t) {
                    const s = -t * Math.PI / 180;
                    this.angle !== s && (this._unmodified = !1, this.angle = s, this._calcMatrices(), this.rotationMatrix = o.ck(), o.cl(this.rotationMatrix, this.rotationMatrix, this.angle))
                }

                get pitch() {
                    return this._pitch / Math.PI * 180
                }

                set pitch(t) {
                    const s = o.ay(t, this.minPitch, this.maxPitch) / 180 * Math.PI;
                    this._pitch !== s && (this._unmodified = !1, this._pitch = s, this._calcMatrices())
                }

                get aspect() {
                    return this.width / this.height
                }

                get fov() {
                    return this._fov / Math.PI * 180
                }

                set fov(t) {
                    t = Math.max(.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = o.al(t), this._calcMatrices())
                }

                get fovX() {
                    return this._fov
                }

                get fovY() {
                    const t = 1 / Math.tan(.5 * this.fovX);
                    return 2 * Math.atan(1 / this.aspect / t)
                }

                get averageElevation() {
                    return this._averageElevation
                }

                set averageElevation(t) {
                    this._averageElevation = t, this._calcFogMatrices(), this._distanceTileDataCache = {}
                }

                get zoom() {
                    return this._zoom
                }

                set zoom(t) {
                    const s = Math.min(Math.max(t, this.minZoom), this.maxZoom);
                    this._zoom !== s && (this._unmodified = !1, this._setZoom(s), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices())
                }

                _setZoom(t) {
                    this._zoom = t, this.scale = this.zoomScale(t), this.tileZoom = Math.floor(t), this.zoomFraction = t - this.tileZoom
                }

                get tileCoverLift() {
                    return this._tileCoverLift
                }

                set tileCoverLift(t) {
                    this._tileCoverLift !== t && (this._tileCoverLift = t)
                }

                _updateCameraOnTerrain() {
                    const t = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY,
                        s = this.elevation && t === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;
                    if (!this._elevation || t === Number.NEGATIVE_INFINITY && (!s || !this._centerAltitude)) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
                    const h = this._elevation;
                    s || this._centerAltitude && this._centerAltitudeValidForExaggeration && h.exaggeration() && this._centerAltitudeValidForExaggeration !== h.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * h.exaggeration(), this._centerAltitudeValidForExaggeration = h.exaggeration()) : (this._centerAltitude = t || 0, this._centerAltitudeValidForExaggeration = h.exaggeration()), this._updateSeaLevelZoom()
                }

                _updateSeaLevelZoom() {
                    if (this._centerAltitudeValidForExaggeration === void 0) return;
                    const t = Math.max(0, (this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize);
                    this._seaLevelZoom = this._zoomFromMercatorZ(t)
                }

                sampleAverageElevation() {
                    if (!this._elevation) return 0;
                    const t = this._elevation, s = [[.5, .2], [.3, .5], [.5, .5], [.7, .5], [.5, .8]],
                        h = this.horizonLineFromTop();
                    let m = 0, g = 0;
                    for (let v = 0; v < s.length; v++) {
                        const b = new o.P(s[v][0] * this.width, h + s[v][1] * (this.height - h)),
                            S = t.pointCoordinate(b);
                        if (!S) continue;
                        const P = 1 / Math.hypot(S[0] - this._camera.position[0], S[1] - this._camera.position[1]);
                        m += S[3] * P, g += P
                    }
                    return g === 0 ? NaN : m / g
                }

                get center() {
                    return this._center
                }

                set center(t) {
                    t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1, this._center = t, this._terrainEnabled() && (this.cameraElevationReference === "ground" ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices())
                }

                _updateZoomFromElevation() {
                    if (this._seaLevelZoom == null || !this._elevation) return;
                    const t = this._seaLevelZoom,
                        s = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)),
                        h = this.pixelsPerMeter / this.worldSize * s, m = this._mercatorZfromZoom(t),
                        g = this._mercatorZfromZoom(this._maxZoom), v = Math.max(m - h, g);
                    this._setZoom(this._zoomFromMercatorZ(v))
                }

                get padding() {
                    return this._edgeInsets.toJSON()
                }

                set padding(t) {
                    this._edgeInsets.equals(t) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, t, 1), this._calcMatrices())
                }

                computeZoomRelativeTo(t) {
                    const s = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t.toAltitude()));
                    let h;
                    h = t.z < this._camera.position[2] ? [s.x, s.y, s.z] : [t.x, t.y, t.z];
                    const m = o.ae(o.at([], this._camera.position, h));
                    return o.ay(this._zoomFromMercatorZ(m), this._minZoom, this._maxZoom)
                }

                setFreeCameraOptions(t) {
                    if (!this.height || !t.position && !t.orientation) return;
                    this._updateCameraState();
                    let s = !1;
                    if (t.orientation && !o.cm(t.orientation, this._camera.orientation) && (s = this._setCameraOrientation(t.orientation)), t.position) {
                        const h = [t.position.x, t.position.y, t.position.z];
                        o.cn(h, this._camera.position) || (this._setCameraPosition(h), s = !0)
                    }
                    s && (this._updateStateFromCamera(), this.recenterOnTerrain())
                }

                getFreeCameraOptions() {
                    this._updateCameraState();
                    const t = this._camera.position, s = new V_;
                    return s.position = new o.ac(t[0], t[1], t[2]), s.orientation = this._camera.orientation, s._elevation = this.elevation, s._renderWorldCopies = this.renderWorldCopies, s
                }

                _setCameraOrientation(t) {
                    if (!o.co(t)) return !1;
                    o.cp(t, t);
                    const s = o.cq([], [0, 0, -1], t), h = o.cq([], [0, -1, 0], t);
                    if (h[2] < 0) return !1;
                    const m = Xa(s, h);
                    return !!m && (this._camera.orientation = m, !0)
                }

                _setCameraPosition(t) {
                    const s = this.zoomScale(this.minZoom) * this.tileSize,
                        h = this.zoomScale(this.maxZoom) * this.tileSize, m = this.cameraToCenterDistance;
                    t[2] = o.ay(t[2], m / h, m / s), this._camera.position = t
                }

                get centerPoint() {
                    return this._edgeInsets.getCenter(this.width, this.height)
                }

                get fovAboveCenter() {
                    return this._fov * (.5 + this.centerOffset.y / this.height)
                }

                isPaddingEqual(t) {
                    return this._edgeInsets.equals(t)
                }

                interpolatePadding(t, s, h) {
                    this._unmodified = !1, this._edgeInsets.interpolate(t, s, h), this._constrain(), this._calcMatrices()
                }

                coveringZoomLevel(t) {
                    const s = (t.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t.tileSize));
                    return Math.max(0, s)
                }

                getVisibleUnwrappedCoordinates(t) {
                    const s = [new o.cr(0, t)];
                    if (this.renderWorldCopies) {
                        const h = this.pointCoordinate(new o.P(0, 0)), m = this.pointCoordinate(new o.P(this.width, 0)),
                            g = this.pointCoordinate(new o.P(this.width, this.height)),
                            v = this.pointCoordinate(new o.P(0, this.height)),
                            b = Math.floor(Math.min(h.x, m.x, g.x, v.x)), S = Math.floor(Math.max(h.x, m.x, g.x, v.x)),
                            P = 1;
                        for (let M = b - P; M <= S + P; M++) M !== 0 && s.push(new o.cr(M, t))
                    }
                    return s
                }

                isLODDisabled(t) {
                    return (!t || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace
                }

                extendTileCover(t, s, h) {
                    let m = [];
                    const g = h != null, v = !g;
                    if (v && this.zoom < s || g && h[0] === 0 && h[1] === 0) return m;
                    const b = new Set, S = (M, k, R, O, V) => {
                        const B = o.cV(k, M, R, O, V);
                        b.has(B) || (m.push(new o.aM(M, k, R, O, V)), b.add(B))
                    };
                    for (let M = 0; M < t.length; M++) {
                        const k = t[M];
                        if (v && k.canonical.z !== s) continue;
                        const R = k.canonical, O = k.overscaledZ, V = k.wrap, B = 1 << R.z, G = R.x + 1 < B,
                            U = R.x > 0, Z = R.y + 1 < B, Q = R.y > 0, te = k.wrap - (U ? 0 : 1),
                            ce = k.wrap + (G ? 0 : 1), _e = U ? R.x - 1 : B - 1, ve = G ? R.x + 1 : 0;
                        if (g) h[0] < 0 ? (S(O, ce, R.z, ve, R.y), h[1] < 0 && Z && (S(O, V, R.z, R.x, R.y + 1), S(O, ce, R.z, ve, R.y + 1)), h[1] > 0 && Q && (S(O, V, R.z, R.x, R.y - 1), S(O, ce, R.z, ve, R.y - 1))) : h[0] > 0 ? (S(O, te, R.z, _e, R.y), h[1] < 0 && Z && (S(O, V, R.z, R.x, R.y + 1), S(O, te, R.z, _e, R.y + 1)), h[1] > 0 && Q && (S(O, V, R.z, R.x, R.y - 1), S(O, te, R.z, _e, R.y - 1))) : h[1] < 0 && Z ? S(O, V, R.z, R.x, R.y + 1) : Q && S(O, V, R.z, R.x, R.y - 1); else {
                            const ue = k.visibleQuadrants;
                            1 & ue && (S(O, te, R.z, _e, R.y), Q && (S(O, V, R.z, R.x, R.y - 1), S(O, te, R.z, _e, R.y - 1))), 2 & ue && (S(O, ce, R.z, ve, R.y), Q && (S(O, V, R.z, R.x, R.y - 1), S(O, ce, R.z, ve, R.y - 1))), 4 & ue && (S(O, te, R.z, _e, R.y), Z && (S(O, V, R.z, R.x, R.y + 1), S(O, te, R.z, _e, R.y + 1))), 8 & ue && (S(O, ce, R.z, ve, R.y), Z && (S(O, V, R.z, R.x, R.y + 1), S(O, ce, R.z, ve, R.y + 1)))
                        }
                    }
                    const P = [];
                    for (const M of m) m.some(k => M.isChildOf(k)) || P.push(M);
                    if (m = P.filter(M => !t.some(k => !!(M.overscaledZ < s && k.isChildOf(M)) || M.equals(k) || M.isChildOf(k))), v) {
                        const M = 1 << s,
                            k = this.projection.name === "globe" ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()),
                            R = [M * k.x, M * k.y], O = 4, V = O * O;
                        m = m.filter(B => {
                            const G = B.canonical.x + .5 - R[0], U = B.canonical.y + .5 - R[1];
                            return G * G + U * U < V
                        })
                    }
                    return m
                }

                extendTileCoverToNearPlane(t, s, h) {
                    const m = [], g = new Set;
                    for (const Z of t) g.add(Z.key);
                    const v = (Z, Q, te, ce, _e) => {
                            const ve = o.cV(Q, Z, te, ce, _e);
                            g.has(ve) || (m.push(new o.aM(Z, Q, te, ce, _e)), g.add(ve))
                        }, b = t.reduce((Z, Q) => Math.max(Z, Q.overscaledZ), h), S = 1 << h,
                        P = [new o.P(0, 0), new o.P(o.aj, 0), new o.P(o.aj, o.aj), new o.P(0, o.aj)], M = new o.P(0, 0),
                        k = new o.P(0, 0), R = (Z, Q) => {
                            const te = Math.floor(Z[0]), ce = Math.floor(Z[1]), _e = (Z[0] - te) * o.aj,
                                ve = (Z[1] - ce) * o.aj, ue = Math.floor(Q[0]), he = Math.floor(Q[1]),
                                me = (Q[0] - ue) * o.aj, Oe = (Q[1] - he) * o.aj;
                            for (let Se = -1; Se <= 1; Se++) {
                                const Xe = te + Se;
                                if (!(Xe < 0 || Xe >= S)) {
                                    M.x = _e - Se * o.aj, k.x = me - (Xe - ue) * o.aj;
                                    for (let je = -1; je <= 1; je++) {
                                        const Ke = ce + je;
                                        M.y = ve - je * o.aj, k.y = Oe - (Ke - he) * o.aj, o.cW(M, k, P) && v(b, 0, h, Xe, Ke)
                                    }
                                }
                            }
                        }, O = s.points, V = O[o.cs], B = O[o.ct], G = this._projectToGround(V, O[o.cu]),
                        U = this._projectToGround(B, O[o.cv]);
                    return R(V, G), R(B, U), m
                }

                _projectToGround(t, s) {
                    return o.cw(o.cx(), t, s, t[2] / (t[2] - s[2]))
                }

                coveringTiles(t) {
                    let s = this.coveringZoomLevel(t);
                    const h = s, m = this.elevation && this.elevation.exaggeration(), g = m && !t.isTerrainDEM,
                        v = this.projection.name === "mercator";
                    if (t.minzoom !== void 0 && s < t.minzoom) return [];
                    t.maxzoom !== void 0 && s > t.maxzoom && (s = t.maxzoom);
                    const b = this.locationCoordinate(this.center), S = this.center.lat, P = 1 << s,
                        M = [P * b.x, P * b.y, 0], k = this.projection.name === "globe", R = !k,
                        O = o.cy.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, s, R),
                        V = k ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()),
                        B = P * o.cb(1, this.center.lat), G = this._camera.position[2] / o.cb(1, this.center.lat),
                        U = [P * V.x, P * V.y, G * (R ? 1 : B)], Z = k || m,
                        Q = this.cameraToCenterDistance / t.tileSize * (t.roundZoom ? 1 : .502),
                        te = this.isLODDisabled(!0) ? s : 0;
                    let ce;
                    if (this._elevation && t.isTerrainDEM) ce = 1e4 * this._elevation.exaggeration(); else if (this._elevation) {
                        const Te = this._elevation.getMinMaxForVisibleTiles();
                        ce = Te ? Te.max : this._centerAltitude
                    } else ce = this._centerAltitude;
                    const _e = t.isTerrainDEM ? -ce : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0,
                        ve = this.projection.isReprojectedInTileSpace ? o.cz(this) : 1, ue = Te => {
                            const Be = new o.ac(Te.x + 25e-6, Te.y, Te.z), tt = new o.ac(Te.x, Te.y + 25e-6, Te.z),
                                it = Te.toLngLat(), rt = Be.toLngLat(), gt = tt.toLngLat(),
                                Ot = this.locationCoordinate(it), Ut = this.locationCoordinate(rt),
                                St = this.locationCoordinate(gt), Nt = Math.hypot(Ut.x - Ot.x, Ut.y - Ot.y),
                                Ft = Math.hypot(St.x - Ot.x, St.y - Ot.y);
                            return Math.sqrt(Nt * Ft) * ve / 25e-6
                        }, he = Te => {
                            const $e = ce, Be = _e;
                            return {
                                aabb: o.cC(this, P, 0, 0, 0, Te, Be, $e, this.projection),
                                zoom: 0,
                                x: 0,
                                y: 0,
                                minZ: Be,
                                maxZ: $e,
                                wrap: Te,
                                fullyVisible: !1
                            }
                        }, me = [];
                    let Oe = [];
                    const Se = s, Xe = t.reparseOverscaled ? h : s, je = (G - this._centerAltitude) * B, Ke = Te => {
                        if (!this._elevation || !Te.tileID || !v) return;
                        const $e = this._elevation.getMinMaxForTile(Te.tileID), Be = Te.aabb;
                        $e ? (Be.min[2] = $e.min, Be.max[2] = $e.max, Be.center[2] = (Be.min[2] + Be.max[2]) / 2) : (Te.shouldSplit = Fe(Te), Te.shouldSplit || (Be.min[2] = Be.max[2] = Be.center[2] = this._centerAltitude))
                    }, ut = (Te, $e) => {
                        if (.707 * $e < Te) return 1;
                        const Be = $e / Te;
                        return Be / (1.4144271570014144 + (Math.pow(1.1, Be - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1)
                    }, Fe = Te => {
                        if (Te.zoom < te) return !0;
                        if (Te.zoom === Se) return !1;
                        if (Te.shouldSplit != null) return Te.shouldSplit;
                        const $e = Te.aabb.distanceX(U), Be = Te.aabb.distanceY(U);
                        let tt = je, it = 1;
                        if (k) {
                            tt = Te.aabb.distanceZ(U);
                            const Ft = Math.pow(2, Te.zoom), ri = o.aY((Te.y + 1) / Ft), di = o.aY(Te.y / Ft),
                                Si = Math.min(Math.max(S, ri), di), Ui = o.c_(Si) / o.c_(S);
                            if (it = Si === S ? 1 / Math.max(1, this._mercatorScaleRatio - .3) : Math.min(1, Ui / this._mercatorScaleRatio), this.zoom <= o.cX && Te.zoom === Se - 1 && Ui >= .9) return !0
                        } else if (g && (tt = Te.aabb.distanceZ(U) * B), this.projection.isReprojectedInTileSpace && h <= 5) {
                            const Ft = Math.pow(2, Te.zoom), ri = ue(new o.ac((Te.x + .5) / Ft, (Te.y + .5) / Ft));
                            it = ri > .85 ? 1 : ri
                        }
                        if (!v) {
                            const Ft = Math.sqrt($e * $e + Be * Be + tt * tt);
                            let ri = (1 << Se - Te.zoom) * Q * it;
                            return ri *= ut(Math.max(tt, je), Ft), Ft < ri
                        }
                        let rt = Number.MAX_VALUE, gt = 0;
                        const Ot = Te.aabb.getCorners(), Ut = [];
                        for (const Ft of Ot) {
                            o.at(Ut, Ft, U), k || (g ? Ut[2] *= B : Ut[2] = je);
                            const ri = o.bG(Ut, this._camera.forward());
                            ri < rt && (rt = ri, gt = Math.abs(Ut[2]))
                        }
                        let St = (1 << Se - Te.zoom) * Q * it;
                        if (St *= ut(Math.max(gt, je), rt), rt < St) return !0;
                        const Nt = Te.aabb.closestPoint(M);
                        return Nt[0] === M[0] && Nt[1] === M[1]
                    };
                    if (this.renderWorldCopies) for (let Te = 1; Te <= 3; Te++) me.push(he(-Te)), me.push(he(Te));
                    for (me.push(he(0)); me.length > 0;) {
                        const Te = me.pop(), $e = Te.x, Be = Te.y;
                        let tt = Te.fullyVisible;
                        const it = () => this.projection.name === "globe" && (Te.y === 0 || Te.y === (1 << Te.zoom) - 1);
                        if (!tt) {
                            let rt = Z ? Te.aabb.intersects(O) : Te.aabb.intersectsFlat(O);
                            if (rt === 0 && it()) {
                                const gt = new o.cA(Te.zoom, $e, Be);
                                rt = o.cB(this, P, gt, !0).intersects(O)
                            }
                            if (rt === 0) continue;
                            tt = rt === 2
                        }
                        if (Te.zoom !== Se && Fe(Te)) for (let rt = 0; rt < 4; rt++) {
                            const gt = ($e << 1) + rt % 2, Ot = (Be << 1) + (rt >> 1), Ut = {
                                aabb: v ? Te.aabb.quadrant(rt) : o.cC(this, P, Te.zoom + 1, gt, Ot, Te.wrap, Te.minZ, Te.maxZ, this.projection),
                                zoom: Te.zoom + 1,
                                x: gt,
                                y: Ot,
                                wrap: Te.wrap,
                                fullyVisible: tt,
                                tileID: void 0,
                                shouldSplit: void 0,
                                minZ: Te.minZ,
                                maxZ: Te.maxZ
                            };
                            g && !k && (Ut.tileID = new o.aM(Te.zoom + 1 === Se ? Xe : Te.zoom + 1, Te.wrap, Te.zoom + 1, gt, Ot), Ke(Ut)), me.push(Ut)
                        } else {
                            const rt = Te.zoom === Se ? Xe : Te.zoom;
                            if (t.minzoom && t.minzoom > rt) continue;
                            let gt = 0;
                            if (!tt) {
                                let Nt = Z ? Te.aabb.intersectsPrecise(O) : Te.aabb.intersectsPreciseFlat(O);
                                if (Nt === 0 && it()) {
                                    const Ft = new o.cA(Te.zoom, $e, Be);
                                    Nt = o.cB(this, P, Ft, !0).intersectsPrecise(O)
                                }
                                if (Nt === 0) continue;
                                if (t.calculateQuadrantVisibility) if (O.containsPoint(Te.aabb.center)) gt = 15; else for (let Ft = 0; Ft < 4; Ft++) Te.aabb.quadrant(Ft).intersects(O) !== 0 && (gt |= 1 << Ft)
                            }
                            const Ot = M[0] - (.5 + $e + (Te.wrap << Te.zoom)) * (1 << s - Te.zoom),
                                Ut = M[1] - .5 - Be,
                                St = Te.tileID ? Te.tileID : new o.aM(rt, Te.wrap, Te.zoom, $e, Be);
                            t.calculateQuadrantVisibility && (St.visibleQuadrants = gt), Oe.push({
                                tileID: St,
                                distanceSq: Ot * Ot + Ut * Ut
                            })
                        }
                    }
                    if (this.fogCullDistSq) {
                        const Te = this.fogCullDistSq, $e = this.horizonLineFromTop();
                        Oe = Oe.filter(Be => {
                            const tt = [0, 0, 0, 1], it = [o.aj, o.aj, 0, 1],
                                rt = this.calculateFogTileMatrix(Be.tileID.toUnwrapped());
                            o.aA(tt, tt, rt), o.aA(it, it, rt);
                            const gt = o.cD([], tt, it), Ot = o.cE([], tt, it), Ut = o.cY(gt, Ot);
                            if (Ut === 0) return !0;
                            let St = !1;
                            const Nt = this._elevation;
                            if (Nt && Ut > Te && $e !== 0) {
                                const Ft = this.calculateProjMatrix(Be.tileID.toUnwrapped());
                                let ri;
                                t.isTerrainDEM || (ri = Nt.getMinMaxForTile(Be.tileID)), ri || (ri = {
                                    min: _e,
                                    max: ce
                                });
                                const di = o.cF(this.rotation), Si = [di[0] * o.aj, di[1] * o.aj, ri.max];
                                o.ad(Si, Si, Ft), St = (1 - Si[1]) * this.height * .5 < $e
                            }
                            return Ut < Te || St
                        })
                    }
                    return Oe.sort((Te, $e) => Te.distanceSq - $e.distanceSq).map(Te => Te.tileID)
                }

                resize(t, s) {
                    this.width = t, this.height = s, this.pixelsToGLUnits = [2 / t, -2 / s], this._constrain(), this._calcMatrices()
                }

                get unmodified() {
                    return this._unmodified
                }

                zoomScale(t) {
                    return Math.pow(2, t)
                }

                scaleZoom(t) {
                    return Math.log(t) / Math.LN2
                }

                project(t) {
                    const s = o.ay(t.lat, -o.cG, o.cG), h = this.projection.project(t.lng, s);
                    return new o.P(h.x * this.worldSize, h.y * this.worldSize)
                }

                unproject(t) {
                    return this.projection.unproject(t.x / this.worldSize, t.y / this.worldSize)
                }

                get point() {
                    return this.project(this.center)
                }

                get pointMerc() {
                    return this.point._div(this.worldSize)
                }

                get pixelsPerMeterRatio() {
                    return this.pixelsPerMeter / o.cb(1, this.center.lat) / this.worldSize
                }

                setLocationAtPoint(t, s) {
                    let h, m;
                    const g = this.centerPoint;
                    if (this.projection.name === "globe") {
                        const b = this.worldSize;
                        h = (s.x - g.x) / b, m = (s.y - g.y) / b
                    } else {
                        const b = this.pointCoordinate(s), S = this.pointCoordinate(g);
                        h = b.x - S.x, m = b.y - S.y
                    }
                    const v = this.locationCoordinate(t);
                    this.setLocation(new o.ac(v.x - h, v.y - m))
                }

                setLocation(t) {
                    this.center = this.coordinateLocation(t), this.projection.wrap && (this.center = this.center.wrap())
                }

                locationPoint(t, s) {
                    return this.projection.locationPoint(this, t, s)
                }

                locationPoint3D(t, s) {
                    return this.projection.locationPoint(this, t, s, !0)
                }

                pointLocation(t) {
                    return this.coordinateLocation(this.pointCoordinate(t))
                }

                pointLocation3D(t, s) {
                    return this.coordinateLocation(this.pointCoordinate3D(t, s))
                }

                locationCoordinate(t, s) {
                    const h = s ? o.cb(s, t.lat) : void 0, m = this.projection.project(t.lng, t.lat);
                    return new o.ac(m.x, m.y, h)
                }

                coordinateLocation(t) {
                    return this.projection.unproject(t.x, t.y)
                }

                pointRayIntersection(t, s) {
                    const h = s ?? this._centerAltitude, m = [t.x, t.y, 0, 1], g = [t.x, t.y, 1, 1];
                    o.aA(m, m, this.pixelMatrixInverse), o.aA(g, g, this.pixelMatrixInverse);
                    const v = g[3];
                    o.cH(m, m, 1 / m[3]), o.cH(g, g, 1 / v);
                    const b = m[2], S = g[2];
                    return {p0: m, p1: g, t: b === S ? 0 : (h - b) / (S - b)}
                }

                screenPointToMercatorRay(t) {
                    const s = [t.x, t.y, 0, 1], h = [t.x, t.y, 1, 1];
                    return o.aA(s, s, this.pixelMatrixInverse), o.aA(h, h, this.pixelMatrixInverse), o.cH(s, s, 1 / s[3]), o.cH(h, h, 1 / h[3]), s[2] = o.cb(s[2], this._center.lat) * this.worldSize, h[2] = o.cb(h[2], this._center.lat) * this.worldSize, o.cH(s, s, 1 / this.worldSize), o.cH(h, h, 1 / this.worldSize), new o.av([s[0], s[1], s[2]], o.au([], o.at([], h, s)))
                }

                rayIntersectionCoordinate(t) {
                    const {p0: s, p1: h, t: m} = t, g = o.cb(s[2], this._center.lat), v = o.cb(h[2], this._center.lat);
                    return new o.ac(o.ai(s[0], h[0], m) / this.worldSize, o.ai(s[1], h[1], m) / this.worldSize, o.ai(g, v, m))
                }

                pointCoordinate(t, s = this._centerAltitude) {
                    return this.projection.pointCoordinate(this, t.x, t.y, s)
                }

                pointCoordinate3D(t, s) {
                    if (!this.elevation) return this.pointCoordinate(t, s);
                    let h = this.projection.pointCoordinate3D(this, t.x, t.y);
                    if (h) return new o.ac(h[0], h[1], h[2]);
                    let m = 0, g = this.horizonLineFromTop();
                    if (t.y > g) return this.pointCoordinate(t, s);
                    const v = .02 * g, b = t.clone();
                    for (let S = 0; S < 10 && g - m > v; S++) {
                        b.y = o.ai(m, g, .66);
                        const P = this.projection.pointCoordinate3D(this, b.x, b.y);
                        P ? (g = b.y, h = P) : m = b.y
                    }
                    return h ? new o.ac(h[0], h[1], h[2]) : this.pointCoordinate(t)
                }

                isPointAboveHorizon(t) {
                    return this.projection.isPointAboveHorizon(this, t)
                }

                isPointOnSurface(t) {
                    if (t.y < 0 || t.y > this.height || t.x < 0 || t.x > this.width) return !1;
                    if (this.elevation || this.zoom >= o.cI) return !this.isPointAboveHorizon(t);
                    const s = this.pointCoordinate(t);
                    return s.y >= 0 && s.y <= 1
                }

                _coordinatePoint(t, s) {
                    const h = s && this.elevation ? this.elevation.getAtPointOrZero(t, this._centerAltitude) : this._centerAltitude,
                        m = [t.x * this.worldSize, t.y * this.worldSize, h + t.toAltitude(), 1];
                    return o.aA(m, m, this.pixelMatrix), m[3] > 0 ? new o.P(m[0] / m[3], m[1] / m[3]) : new o.P(Number.MAX_VALUE, Number.MAX_VALUE)
                }

                _getBoundsNonRectangular() {
                    const {top: t, left: s} = this._edgeInsets, h = this.height - this._edgeInsets.bottom,
                        m = this.width - this._edgeInsets.right, g = this.pointLocation3D(new o.P(s, t)),
                        v = this.pointLocation3D(new o.P(m, t)), b = this.pointLocation3D(new o.P(m, h)),
                        S = this.pointLocation3D(new o.P(s, h));
                    let P = Math.min(g.lng, v.lng, b.lng, S.lng), M = Math.max(g.lng, v.lng, b.lng, S.lng),
                        k = Math.min(g.lat, v.lat, b.lat, S.lat), R = Math.max(g.lat, v.lat, b.lat, S.lat);
                    const O = Math.pow(2, -this.zoom) / 16 * 270, V = this.projection.name === "globe" ? 1 : 4,
                        B = (G, U, Z, Q, te) => {
                            const ce = (G + Z) / 2, _e = (U + Q) / 2, ve = new o.P(ce, _e), {
                                lng: ue,
                                lat: he
                            } = this.pointLocation3D(ve), me = Math.max(0, P - ue, k - he, ue - M, he - R);
                            P = Math.min(P, ue), M = Math.max(M, ue), k = Math.min(k, he), R = Math.max(R, he), (te < V || me > O) && (B(G, U, ce, _e, te + 1), B(ce, _e, Z, Q, te + 1))
                        };
                    if (B(s, t, m, t, 1), B(m, t, m, h, 1), B(m, h, s, h, 1), B(s, h, s, t, 1), this.projection.name === "globe") {
                        const [G, U] = o.cJ(this);
                        G ? (R = 90, M = 180, P = -180) : U && (k = -90, M = 180, P = -180)
                    }
                    return new o.aG(new o.ci(P, k), new o.ci(M, R))
                }

                _getBoundsRectangular(t, s) {
                    const {top: h, left: m} = this._edgeInsets, g = this.height - this._edgeInsets.bottom,
                        v = this.width - this._edgeInsets.right, b = new o.P(m, h), S = new o.P(v, h),
                        P = new o.P(v, g), M = new o.P(m, g);
                    let k = this.pointCoordinate(b, t), R = this.pointCoordinate(S, t);
                    const O = this.pointCoordinate(P, s), V = this.pointCoordinate(M, s),
                        B = (G, U) => (U.y - G.y) / (U.x - G.x);
                    return k.y > 1 && R.y >= 0 ? k = new o.ac((1 - V.y) / B(V, k) + V.x, 1) : k.y < 0 && R.y <= 1 && (k = new o.ac(-V.y / B(V, k) + V.x, 0)), R.y > 1 && k.y >= 0 ? R = new o.ac((1 - O.y) / B(O, R) + O.x, 1) : R.y < 0 && k.y <= 1 && (R = new o.ac(-O.y / B(O, R) + O.x, 0)), new o.aG().extend(this.coordinateLocation(k)).extend(this.coordinateLocation(R)).extend(this.coordinateLocation(V)).extend(this.coordinateLocation(O))
                }

                _getBoundsRectangularTerrain() {
                    const t = this.elevation;
                    if (!t.visibleDemTiles.length || t.isUsingMockSource()) return this._getBoundsRectangular(0, 0);
                    const s = t.visibleDemTiles.reduce((h, m) => {
                        if (m.dem) {
                            const g = m.dem.tree;
                            h.min = Math.min(h.min, g.minimums[0]), h.max = Math.max(h.max, g.maximums[0])
                        }
                        return h
                    }, {min: Number.MAX_VALUE, max: 0});
                    return this._getBoundsRectangular(s.min * t.exaggeration(), s.max * t.exaggeration())
                }

                getBounds() {
                    return this.projection.name === "mercator" || this.projection.name === "equirectangular" ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular()
                }

                horizonLineFromTop(t = !0) {
                    const s = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) - this.centerOffset.y,
                        h = this.height / 2 - s * (1 - this._horizonShift);
                    return t ? Math.max(0, h) : h
                }

                getMaxBounds() {
                    return this.maxBounds
                }

                setMaxBounds(t) {
                    this.maxBounds = t, this.minLat = -o.cG, this.maxLat = o.cG, this.minLng = -180, this.maxLng = 180, t && (this.minLat = t.getSouth(), this.maxLat = t.getNorth(), this.minLng = t.getWest(), this.maxLng = t.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = o.aD(this.minLng) * this.tileSize, this.worldMaxX = o.aD(this.maxLng) * this.tileSize, this.worldMinY = o.aH(this.maxLat) * this.tileSize, this.worldMaxY = o.aH(this.minLat) * this.tileSize, this._constrain()
                }

                calculatePosMatrix(t, s) {
                    return this.projection.createTileMatrix(this, s, t)
                }

                calculateDistanceTileData(t) {
                    const s = t.key, h = this._distanceTileDataCache;
                    if (h[s]) return h[s];
                    const m = t.canonical, g = 1 / this.height, v = this.cameraWorldSize, b = v / this.zoomScale(m.z),
                        S = (m.x + Math.pow(2, m.z) * t.wrap) * b, P = m.y * b, M = this.point;
                    M.x *= v / this.worldSize, M.y *= v / this.worldSize;
                    const k = this.angle, R = Math.sin(-k), O = -Math.cos(-k);
                    return h[s] = {bearing: [R, O], center: [(M.x - S) * g, (M.y - P) * g], scale: b / o.aj * g}, h[s]
                }

                calculateFogTileMatrix(t) {
                    const s = t.key, h = this._fogTileMatrixCache;
                    if (h[s]) return h[s];
                    const m = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t);
                    return o.az(m, this.worldToFogMatrix, m), h[s] = new Float32Array(m), h[s]
                }

                calculateProjMatrix(t, s = !1, h = !1) {
                    const m = t.key;
                    let g;
                    if (g = h ? this._expandedProjMatrixCache : s ? this._alignedProjMatrixCache : this._projMatrixCache, g[m]) return g[m];
                    const v = this.calculatePosMatrix(t, this.worldSize);
                    let b;
                    return b = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : h ? this.expandedFarZProjMatrix : s ? this.alignedProjMatrix : this.projMatrix, o.az(v, b, v), g[m] = new Float32Array(v), g[m]
                }

                calculatePixelsToTileUnitsMatrix(t) {
                    const s = t.tileID.key, h = this._pixelsToTileUnitsCache;
                    if (h[s]) return h[s];
                    const m = o.cK(t, this);
                    return h[s] = m, h[s]
                }

                customLayerMatrix() {
                    return this.mercatorMatrix.slice()
                }

                globeToMercatorMatrix() {
                    if (this.projection.name === "globe") {
                        const t = 1 / this.worldSize, s = o.bn([], [t, t, t]);
                        return o.az(s, s, this.globeMatrix), s
                    }
                }

                recenterOnTerrain() {
                    if (!this._elevation || this.projection.name === "globe") return;
                    const t = this._elevation;
                    this._updateCameraState();
                    const s = o.cb(1, this._center.lat) * this.worldSize, h = this._computeCameraPosition(s),
                        m = this._camera.forward(), g = o.cb(1, this._center.lat);
                    h[2] /= g, m[2] /= g, o.au(m, m);
                    const v = t.raycast(h, m, t.exaggeration());
                    if (v) {
                        const b = o.bE([], h, m, v), S = new o.ac(b[0], b[1], o.cb(b[2], o.aY(b[1]))),
                            P = (S.z + o.ae([S.x - h[0], S.y - h[1], S.z - h[2] * g])) * this._pixelsPerMercatorPixel;
                        this._seaLevelZoom = this._zoomFromMercatorZ(P), this._centerAltitude = S.toAltitude(), this._center = this.coordinateLocation(S), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices()
                    }
                }

                _constrainCamera(t = !1) {
                    if (!this._elevation) return;
                    const s = this._elevation, h = o.cb(1, this._center.lat) * this.worldSize,
                        m = this._computeCameraPosition(h), g = s.getAtPointOrZero(new o.ac(...m)),
                        v = this.pixelsPerMeter / this.worldSize * g, b = this._minimumHeightOverTerrain(),
                        S = m[2] - v;
                    if (S <= b) if (S < 0 || t) {
                        const P = this.locationCoordinate(this._center, this._centerAltitude),
                            M = [m[0], m[1], P.z - m[2]], k = o.ae(M);
                        M[2] -= (b - S) / this._pixelsPerMercatorPixel;
                        const R = o.ae(M);
                        if (R === 0) return;
                        o.c1(M, M, k / R * this._pixelsPerMercatorPixel), this._camera.position = [m[0], m[1], P.z * this._pixelsPerMercatorPixel - M[2]], this._updateStateFromCamera()
                    } else this._isCameraConstrained = !0
                }

                _constrain() {
                    if (!this.center || !this.width || !this.height || this._constraining) return;
                    this._constraining = !0;
                    const t = this.projection.name === "globe" || this.mercatorFromTransition;
                    if (this.projection.isReprojectedInTileSpace || t) {
                        const R = this.center;
                        return R.lat = o.ay(R.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t) && (R.lng = o.ay(R.lng, this.minLng, this.maxLng)), this.center = R, void (this._constraining = !1)
                    }
                    const s = this._unmodified, {x: h, y: m} = this.point;
                    let g = 0, v = h, b = m;
                    const S = this.width / 2, P = this.height / 2, M = this.worldMinY * this.scale,
                        k = this.worldMaxY * this.scale;
                    if (m - P < M && (b = M + P), m + P > k && (b = k - P), k - M < this.height && (g = Math.max(g, this.height / (k - M)), b = (k + M) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
                        const R = this.worldMinX * this.scale, O = this.worldMaxX * this.scale,
                            V = this.worldSize / 2 - (R + O) / 2;
                        v = (h + V + this.worldSize) % this.worldSize - V, v - S < R && (v = R + S), v + S > O && (v = O - S), O - R < this.width && (g = Math.max(g, this.width / (O - R)), v = (O + R) / 2)
                    }
                    v === h && b === m || this._allowWorldUnderZoom || (this.center = this.unproject(new o.P(v, b))), g && !this._allowWorldUnderZoom && (this.zoom += this.scaleZoom(g)), this._constrainCamera(), this._unmodified = s, this._constraining = !1
                }

                _minZoomForBounds() {
                    let t = Math.max(0, this.scaleZoom(Math.max(0, this.height) / (this.worldMaxY - this.worldMinY)));
                    return this.maxBounds && (t = Math.max(t, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), t
                }

                _maxCameraBoundsDistance() {
                    return this._mercatorZfromZoom(this._minZoomForBounds())
                }

                _calcMatrices() {
                    if (!this.height) return;
                    const t = this.centerOffset, s = this.projection.name === "globe", h = this.pixelsPerMeter;
                    this.projection.name === "globe" && (this._mercatorScaleRatio = o.cb(1, this.center.lat) / o.cb(1, o.c$));
                    const m = o.cL(this.projection, this.zoom, this.width, this.height, 1024);
                    this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, m), this.cameraToCenterDistance = .5 / Math.tan(.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
                    const g = this.projection.zAxisUnit === "meters" ? h : 1,
                        v = this._camera.getWorldToCamera(this.worldSize, g);
                    let b;
                    const S = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
                    if (S[8] = 2 * -t.x / this.width, S[9] = 2 * t.y / this.height, this.isOrthographic) {
                        let he = .5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(.5 * this._fov),
                            me = he * this.aspect, Oe = -me, Se = -he;
                        me -= t.x, Oe -= t.x, he += t.y, Se += t.y, b = this._camera.getCameraToClipOrthographic(Oe, me, Se, he, this._nearZ, this._farZ), ((Xe, je, Ke, ut) => {
                            for (let Fe = 0; Fe < 16; Fe++) Xe[Fe] = o.ai(je[Fe], Ke[Fe], ut)
                        })(b, b, S, o.cZ(this.pitch >= Mr ? 1 : this.pitch / Mr))
                    } else b = S;
                    const P = o.cM([], S, v);
                    let M = o.cM([], b, v);
                    if (this.projection.isReprojectedInTileSpace) {
                        const he = this.locationCoordinate(this.center), me = o.bx([]);
                        o.bo(me, me, [he.x * this.worldSize, he.y * this.worldSize, 0]), o.az(me, me, o.cN(this)), o.bo(me, me, [-he.x * this.worldSize, -he.y * this.worldSize, 0]), o.az(M, M, me), o.az(P, P, me), this.inverseAdjustmentMatrix = o.cO(this)
                    } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];
                    if (this.mercatorMatrix = o.cP([], M, [this.worldSize, this.worldSize, this.worldSize / g, 1]), this.projMatrix = M, this.invProjMatrix = o.bi(new Float64Array(16), this.projMatrix), s) {
                        const he = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);
                        he[8] = 2 * -t.x / this.width, he[9] = 2 * t.y / this.height, this.expandedFarZProjMatrix = o.cM([], he, v)
                    } else this.expandedFarZProjMatrix = this.projMatrix;
                    const k = o.bi([], b);
                    this.frustumCorners = o.cQ.fromInvProjectionMatrix(k, this.horizonLineFromTop(), this.height), this.cameraFrustum = o.cy.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !s);
                    const R = new Float32Array(16);
                    o.bx(R), o.cP(R, R, [1, -1, 1]), o.cR(R, R, this._pitch), o.by(R, R, this.angle);
                    const O = o.c9(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);
                    this.starsProjMatrix = o.bw(O);
                    const V = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
                    O[8] = 2 * -t.x / this.width, O[9] = 2 * (t.y + V) / this.height, this.skyboxMatrix = o.az(R, O, R);
                    const B = this.point, G = B.x, U = B.y, Z = this.width % 2 / 2, Q = this.height % 2 / 2,
                        te = Math.cos(this.angle), ce = Math.sin(this.angle), _e = G - Math.round(G) + te * Z + ce * Q,
                        ve = U - Math.round(U) + te * Q + ce * Z, ue = new Float64Array(M);
                    if (o.bo(ue, ue, [_e > .5 ? _e - 1 : _e, ve > .5 ? ve - 1 : ve, 0]), this.alignedProjMatrix = ue, M = o.bz(), o.cP(M, M, [this.width / 2, -this.height / 2, 1]), o.bo(M, M, [1, -1, 0]), this.labelPlaneMatrix = M, M = o.bz(), o.cP(M, M, [1, -1, 1]), o.bo(M, M, [-1, -1, 0]), o.cP(M, M, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = M, this.pixelMatrix = o.az(new Float64Array(16), this.labelPlaneMatrix, P), this._calcFogMatrices(), this._distanceTileDataCache = {}, M = o.bi(new Float64Array(16), this.pixelMatrix), !M) throw new Error("failed to invert matrix");
                    if (this.pixelMatrixInverse = M, this.projection.name === "globe" || this.mercatorFromTransition) {
                        this.globeMatrix = o.cS(this);
                        const he = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
                        this.globeCenterInViewSpace = o.ad(he, he, v), this.globeRadius = this.worldSize / 2 / Math.PI - 1
                    } else this.globeMatrix = M;
                    this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {}
                }

                _calcFogMatrices() {
                    this._fogTileMatrixCache = {};
                    const t = this.cameraWorldSizeForFog, s = this.cameraPixelsPerMeter, h = this._camera.position,
                        m = 1 / this.height / this._pixelsPerMercatorPixel, g = [t, t, s];
                    o.c1(g, g, m), o.c1(h, h, -1), o.cT(h, h, g);
                    const v = o.bz();
                    o.bo(v, v, h), o.cP(v, v, g), this.mercatorFogMatrix = v, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t, s, m)
                }

                _computeCameraPosition(t) {
                    const s = (t = t || this.pixelsPerMeter) / this.pixelsPerMeter, h = this._camera.forward(),
                        m = this.point,
                        g = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * s - t / this.worldSize * this._centerAltitude;
                    return [m.x / this.worldSize - h[0] * g, m.y / this.worldSize - h[1] * g, t / this.worldSize * this._centerAltitude - h[2] * g]
                }

                _updateCameraState() {
                    this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition())
                }

                _translateCameraConstrained(t) {
                    const s = this._maxCameraBoundsDistance() * Math.cos(this._pitch), h = this._camera.position[2],
                        m = t[2];
                    let g = 1;
                    this.projection.wrap && (this.center = this.center.wrap()), m > 0 && (g = Math.min((s - h) / m, 1)), this._camera.position = o.bE([], this._camera.position, t, g), this._updateStateFromCamera()
                }

                _updateStateFromCamera() {
                    const t = this._camera.position, s = this._camera.forward(), {
                            pitch: h,
                            bearing: m
                        } = this._camera.getPitchBearing(),
                        g = o.cb(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel,
                        v = this._mercatorZfromZoom(this._maxZoom) * Math.cos(o.al(this._maxPitch)),
                        b = Math.max((t[2] - g) / Math.cos(h), v), S = this._zoomFromMercatorZ(b);
                    o.bE(t, t, s, b), this._pitch = o.ay(h, o.al(this.minPitch), o.al(this.maxPitch)), this.angle = o.bQ(m, -Math.PI, Math.PI), this._setZoom(o.ay(S, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new o.ac(t[0], t[1], t[2])), this._unmodified = !1, this._constrain(), this._calcMatrices()
                }

                _worldSizeFromZoom(t) {
                    return Math.pow(2, t) * this.tileSize
                }

                _mercatorZfromZoom(t) {
                    return this.cameraToCenterDistance / this._worldSizeFromZoom(t)
                }

                _minimumHeightOverTerrain() {
                    const t = Math.min(this._seaLevelZoom != null ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4;
                    return this._mercatorZfromZoom(t)
                }

                _zoomFromMercatorZ(t) {
                    return this.scaleZoom(this.cameraToCenterDistance / (Math.max(0, t) * this.tileSize))
                }

                zoomFromMercatorZAdjusted(t) {
                    let s = 0, h = o.cI, m = 0, g = 1 / 0;
                    for (; h - s > 1e-6 && h > s;) {
                        const v = s + .5 * (h - s), b = this.tileSize * Math.pow(2, v),
                            S = this.getCameraToCenterDistance(this.projection, v, b),
                            P = this.scaleZoom(S / (Math.max(0, t) * this.tileSize)), M = Math.abs(v - P);
                        M < g && (g = M, m = v), v < P ? s = v : h = v
                    }
                    return m
                }

                _terrainEnabled() {
                    return !(!this._elevation || !this.projection.supportsTerrain && (o.w("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1))
                }

                anyCornerOffEdge(t, s) {
                    const h = Math.min(t.x, s.x), m = Math.max(t.x, s.x), g = Math.min(t.y, s.y),
                        v = Math.max(t.y, s.y);
                    if (g < this.horizonLineFromTop(!1)) return !0;
                    if (this.projection.name !== "mercator") return !1;
                    const b = [new o.P(h, g), new o.P(m, v), new o.P(h, v), new o.P(m, g)],
                        S = this.renderWorldCopies ? -3 : 0, P = this.renderWorldCopies ? 4 : 1;
                    for (const M of b) {
                        const k = this.pointRayIntersection(M);
                        if (k.t < 0) return !0;
                        const R = this.rayIntersectionCoordinate(k);
                        if (R.x < S || R.y < 0 || R.x > P || R.y > 1) return !0
                    }
                    return !1
                }

                isHorizonVisible() {
                    return this.pitch + o.cU(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new o.P(0, 0), new o.P(this.width, this.height))
                }

                zoomDeltaToMovement(t, s) {
                    const h = o.ae(o.at([], this._camera.position, t)), m = this._zoomFromMercatorZ(h) + s;
                    return h - this._mercatorZfromZoom(m)
                }

                getCameraPoint() {
                    if (this.projection.name === "globe") {
                        const t = function ([s, h, m], g) {
                            const v = [s, h, m, 1];
                            o.aA(v, v, g);
                            const b = v[3] = Math.max(v[3], 1e-6);
                            return v[0] /= b, v[1] /= b, v[2] /= b, v
                        }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
                        return new o.P(t[0], t[1])
                    }
                    {
                        const t = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                        return this.centerPoint.add(new o.P(0, t))
                    }
                }

                getCameraToCenterDistance(t, s = this.zoom, h = this.worldSize) {
                    const m = o.cL(t, s, this.width, this.height, 1024),
                        g = t.pixelSpaceConversion(this.center.lat, h, m);
                    let v = .5 / Math.tan(.5 * this._fov) * this.height * g;
                    return this.isOrthographic && (v = o.ai(1, v, o.cZ(this.pitch >= Mr ? 1 : this.pitch / Mr))), v
                }

                getWorldToCameraMatrix() {
                    const t = this._camera.getWorldToCamera(this.worldSize, this.projection.zAxisUnit === "meters" ? this.pixelsPerMeter : 1);
                    return this.projection.name === "globe" && o.az(t, t, this.globeMatrix), t
                }

                getFrustum(t) {
                    return o.cy.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t, this.projection.zAxisUnit === "meters")
                }
            }

            const Ks = (u, t) => {
                if (t > 0 && u.terrain && o.w("Cutoff is currently disabled on terrain"), t <= 0 || u.terrain) return {
                    shouldRenderCutoff: !1,
                    uniformValues: {u_cutoff_params: [0, 0, 0, 1]}
                };
                const s = u.transform, h = Math.max(Math.abs(s._zoom - (u.minCutoffZoom - 1)), 1),
                    m = s.isLODDisabled(!1) ? o.af(60, 45, s.pitch) : o.af(30, 15, s.pitch), g = s._farZ - s._nearZ,
                    v = t * s.height, b = ((1 - (S = m)) * s.cameraToCenterDistance + S * (s._farZ + v)) * h;
                var S;
                return {
                    shouldRenderCutoff: m < 1,
                    uniformValues: {u_cutoff_params: [s._nearZ, s._farZ, (b - s._nearZ) / g, (b - v - s._nearZ) / g]}
                }
            }, eo = {cascadeCount: 2, normalOffset: 3, shadowMapResolution: 2048};

            class ch {
                constructor(t, s) {
                    this.aabb = t, this.lastCascade = s
                }
            }

            class Vx {
                add(t, s) {
                    const h = this.receivers[t.key];
                    h !== void 0 ? (h.aabb.min[0] = Math.min(h.aabb.min[0], s.min[0]), h.aabb.min[1] = Math.min(h.aabb.min[1], s.min[1]), h.aabb.min[2] = Math.min(h.aabb.min[2], s.min[2]), h.aabb.max[0] = Math.max(h.aabb.max[0], s.max[0]), h.aabb.max[1] = Math.max(h.aabb.max[1], s.max[1]), h.aabb.max[2] = Math.max(h.aabb.max[2], s.max[2])) : this.receivers[t.key] = new ch(s, null)
                }

                clear() {
                    this.receivers = {}
                }

                get(t) {
                    return this.receivers[t.key]
                }

                computeRequiredCascades(t, s, h) {
                    const m = o.d6.fromPoints(t.points);
                    let g = 0;
                    for (const v in this.receivers) {
                        const b = this.receivers[v];
                        if (!b || !m.intersectsAabb(b.aabb)) continue;
                        b.aabb.min = m.closestPoint(b.aabb.min), b.aabb.max = m.closestPoint(b.aabb.max);
                        const S = b.aabb.getCorners();
                        for (let P = 0; P < h.length; P++) {
                            let M = !0;
                            for (const k of S) {
                                const R = [k[0] * s, k[1] * s, k[2]];
                                if (o.ad(R, R, h[P].matrix), R[0] < -1 || R[0] > 1 || R[1] < -1 || R[1] > 1) {
                                    M = !1;
                                    break
                                }
                            }
                            if (b.lastCascade = P, g = Math.max(g, P), M) break
                        }
                    }
                    return g + 1
                }
            }

            class Ux {
                constructor(t) {
                    this.painter = t, this._enabled = !1, this._shadowLayerCount = 0, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new Vx, this._depthMode = new It(t.context.gl.LEQUAL, It.ReadWrite, [0, 1]), this._uniformValues = {
                        u_light_matrix_0: new Float32Array(16),
                        u_light_matrix_1: new Float32Array(16),
                        u_shadow_intensity: 0,
                        u_fade_range: [0, 0],
                        u_shadow_normal_offset: [1, 1, 1],
                        u_shadow_texel_size: 1,
                        u_shadow_map_resolution: 1,
                        u_shadow_direction: [0, 0, 1],
                        u_shadow_bias: [36e-5, .0012, .012],
                        u_shadowmap_0: 0,
                        u_shadowmap_1: 0
                    }, this._forceDisable = !1, this.useNormalOffset = !1, t.tp.registerParameter(this, ["Shadows"], "_forceDisable", {label: "forceDisable"}, () => {
                        this.painter.style.map.triggerRepaint()
                    }), t.tp.registerParameter(eo, ["Shadows"], "cascadeCount", {
                        min: 1,
                        max: 2,
                        step: 1
                    }), t.tp.registerParameter(eo, ["Shadows"], "normalOffset", {
                        min: 0,
                        max: 10,
                        step: .05
                    }), t.tp.registerParameter(eo, ["Shadows"], "shadowMapResolution", {
                        min: 32,
                        max: 2048,
                        step: 32
                    }), t.tp.registerBinding(this, ["Shadows"], "_numCascadesToRender", {
                        readonly: !0,
                        label: "numCascadesToRender"
                    })
                }

                destroy() {
                    for (const t of this._cascades) t.texture.destroy(), t.framebuffer.destroy();
                    this._cascades = []
                }

                updateShadowParameters(t, s) {
                    const h = this.painter;
                    if (this._enabled = !1, this._shadowLayerCount = 0, this._receivers.clear(), !s || !s.properties) return;
                    const m = s.properties.get("shadow-intensity");
                    if (!s.shadowsEnabled() || m <= 0 || (this._shadowLayerCount = h.style.order.reduce((V, B) => {
                        const G = h.style._mergedLayers[B];
                        return V + (G.hasShadowPass() && !G.isHidden(t.zoom) ? 1 : 0)
                    }, 0), this._enabled = this._shadowLayerCount > 0, !this.enabled)) return;
                    const g = h.context, v = eo.shadowMapResolution, b = eo.shadowMapResolution;
                    if (this._cascades.length === 0 || eo.shadowMapResolution !== this._cascades[0].texture.size[0]) {
                        this._cascades = [];
                        for (let V = 0; V < eo.cascadeCount; ++V) {
                            const B = h._shadowMapDebug, G = g.gl, U = g.createFramebuffer(v, b, B, "texture"),
                                Z = new o.T(g, {width: v, height: b, data: null}, G.DEPTH_COMPONENT16);
                            if (U.depthAttachment.set(Z.texture), B) {
                                const Q = new o.T(g, {width: v, height: b, data: null}, G.RGBA8);
                                U.colorAttachment.set(Q.texture)
                            }
                            this._cascades.push({
                                framebuffer: U,
                                texture: Z,
                                matrix: [],
                                far: 0,
                                boundingSphereRadius: 0,
                                frustum: new o.cy,
                                scale: 0
                            })
                        }
                    }
                    this.shadowDirection = Ac(s);
                    let S = 0;
                    if (t.elevation) {
                        const V = t.elevation, B = [1e4, -1e4];
                        V.visibleDemTiles.filter(G => G.dem).forEach(G => {
                            const U = G.dem.tree;
                            B[0] = Math.min(B[0], U.minimums[0]), B[1] = Math.max(B[1], U.maximums[0])
                        }), B[0] !== 1e4 && (S = (B[1] - B[0]) * V.exaggeration())
                    }
                    const P = 1.5 * t.cameraToCenterDistance, M = 3 * P, k = new Float64Array(16);
                    for (let V = 0; V < this._cascades.length; ++V) {
                        const B = this._cascades[V];
                        let G = t.height / 50, U = 1;
                        eo.cascadeCount === 1 ? U = M : V === 0 ? U = P : (G = P, U = M);
                        const [Z, Q] = Ic(t, this.shadowDirection, G, U, eo.shadowMapResolution, S);
                        B.scale = t.scale, B.matrix = Z, B.boundingSphereRadius = Q, o.bi(k, B.matrix), B.frustum = o.cy.fromInvProjectionMatrix(k, 1, 0, !0), B.far = U
                    }
                    const R = this._cascades.length - 1;
                    this._uniformValues.u_fade_range = [.75 * this._cascades[R].far, this._cascades[R].far], this._uniformValues.u_shadow_intensity = m, this._uniformValues.u_shadow_direction = [this.shadowDirection[0], this.shadowDirection[1], this.shadowDirection[2]], this._uniformValues.u_shadow_texel_size = 1 / eo.shadowMapResolution, this._uniformValues.u_shadow_map_resolution = eo.shadowMapResolution, this._uniformValues.u_shadowmap_0 = po.ShadowMap0, this._uniformValues.u_shadowmap_1 = po.ShadowMap0 + 1, this._groundShadowTiles = h.transform.coveringTiles({
                        tileSize: 512,
                        renderWorldCopies: !0
                    });
                    const O = h.transform.elevation;
                    for (const V of this._groundShadowTiles) {
                        let B = {min: 0, max: 0};
                        if (O) {
                            const G = O.getMinMaxForTile(V);
                            G && (B = G)
                        }
                        this.addShadowReceiver(V.toUnwrapped(), B.min, B.max)
                    }
                }

                get enabled() {
                    return this._enabled && !this._forceDisable
                }

                set enabled(t) {
                    this._enabled = t
                }

                drawShadowPass(t, s) {
                    if (!this.enabled) return;
                    const h = this.painter, m = h.context;
                    this._numCascadesToRender = this._receivers.computeRequiredCascades(h.transform.getFrustum(0), h.transform.worldSize, this._cascades), m.viewport.set([0, 0, eo.shadowMapResolution, eo.shadowMapResolution]);
                    for (let g = 0; g < this._numCascadesToRender; ++g) {
                        h.currentShadowCascade = g, m.bindFramebuffer.set(this._cascades[g].framebuffer.framebuffer), m.clear({
                            color: o.am.white,
                            depth: 1
                        });
                        for (const v of t.order) {
                            const b = t._mergedLayers[v];
                            if (!b.hasShadowPass() || b.isHidden(h.transform.zoom)) continue;
                            const S = t.getLayerSourceCache(b), P = S ? s[S.id] : void 0;
                            (b.type === "model" || P && P.length) && h.renderLayer(h, S, b, P)
                        }
                    }
                    h.currentShadowCascade = 0
                }

                drawGroundShadows() {
                    if (!this.enabled) return;
                    const t = this.painter, s = t.style, h = t.context, m = h.gl, g = s.directionalLight,
                        v = s.ambientLight;
                    if (!g || !v) return;
                    const b = [], S = Ks(t, t.longestCutoffRange);
                    S.shouldRenderCutoff && b.push("RENDER_CUTOFF"), b.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), this.useNormalOffset && b.push("NORMAL_OFFSET");
                    const P = Nl(s, g, v), M = new It(m.LEQUAL, It.ReadOnly, t.depthRangeFor3D),
                        k = new ei({func: m.EQUAL, mask: 255}, 0, 255, m.KEEP, m.KEEP, m.KEEP);
                    for (const R of this._groundShadowTiles) {
                        const O = R.toUnwrapped(), V = t.isTileAffectedByFog(R),
                            B = t.getOrCreateProgram("groundShadow", {defines: b, overrideFog: V});
                        this.setupShadows(O, B), t.uploadCommonUniforms(h, B, O, null, S);
                        const G = {u_matrix: t.transform.calculateProjMatrix(O), u_ground_shadow_factor: P};
                        B.draw(t, m.TRIANGLES, M, k, gi.multiply, Yt.disabled, G, "ground_shadow", t.tileExtentBuffer, t.quadTriangleIndexBuffer, t.tileExtentSegments, null, t.transform.zoom, null, null)
                    }
                }

                getShadowPassColorMode() {
                    return this.painter._shadowMapDebug ? gi.unblended : gi.disabled
                }

                getShadowPassDepthMode() {
                    return this._depthMode
                }

                getShadowCastingLayerCount() {
                    return this._shadowLayerCount
                }

                calculateShadowPassMatrixFromTile(t) {
                    const s = this.painter.transform, h = s.calculatePosMatrix(t, s.worldSize);
                    return o.az(h, this._cascades[this.painter.currentShadowCascade].matrix, h), Float32Array.from(h)
                }

                calculateShadowPassMatrixFromMatrix(t) {
                    return o.az(t, this._cascades[this.painter.currentShadowCascade].matrix, t), Float32Array.from(t)
                }

                setupShadows(t, s, h) {
                    if (!this.enabled) return;
                    const m = this.painter.transform, g = this.painter.context, v = g.gl, b = this._uniformValues,
                        S = new Float64Array(16), P = m.calculatePosMatrix(t, m.worldSize);
                    for (let M = 0; M < this._cascades.length; M++) o.az(S, this._cascades[M].matrix, P), b[M === 0 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(S), g.activeTexture.set(v.TEXTURE0 + po.ShadowMap0 + M), this._cascades[M].texture.bindExtraParam(v.LINEAR, v.LINEAR, v.CLAMP_TO_EDGE, v.CLAMP_TO_EDGE, v.GREATER);
                    if (this.useNormalOffset = !!h, this.useNormalOffset) {
                        const M = o.d4(t.canonical), k = 2 / m.tileSize * o.aj / eo.shadowMapResolution,
                            R = k * this._cascades[0].boundingSphereRadius,
                            O = k * this._cascades[this._cascades.length - 1].boundingSphereRadius,
                            V = (h === "vector-tile" ? 1 : 3) * function (B, G, U, Z, Q) {
                                const te = o.ay((B - 22) / -22, 0, 1);
                                return .125 * (1 - te) + 4 * te
                            }(m.zoom);
                        b.u_shadow_normal_offset = [M, R * V, O * V], b.u_shadow_bias = [1e-4, .0012, .012]
                    } else b.u_shadow_bias = [36e-5, .0012, .012];
                    s.setShadowUniformValues(g, b)
                }

                setupShadowsFromMatrix(t, s, h = !1) {
                    if (!this.enabled) return;
                    const m = this.painter.context, g = m.gl, v = this._uniformValues, b = new Float64Array(16);
                    for (let S = 0; S < eo.cascadeCount; S++) o.az(b, this._cascades[S].matrix, t), v[S === 0 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(b), m.activeTexture.set(g.TEXTURE0 + po.ShadowMap0 + S), this._cascades[S].texture.bindExtraParam(g.LINEAR, g.LINEAR, g.CLAMP_TO_EDGE, g.CLAMP_TO_EDGE, g.GREATER);
                    if (this.useNormalOffset = h, h) {
                        const S = eo.normalOffset;
                        v.u_shadow_normal_offset = [1, S, S], v.u_shadow_bias = [6e-5, .0012, .012]
                    } else v.u_shadow_bias = [36e-5, .0012, .012];
                    s.setShadowUniformValues(m, v)
                }

                getShadowUniformValues() {
                    return this._uniformValues
                }

                getCurrentCascadeFrustum() {
                    return this._cascades[this.painter.currentShadowCascade].frustum
                }

                computeSimplifiedTileShadowVolume(t, s, h, m) {
                    if (m[2] >= 0) return {};
                    const g = function (S, P, M) {
                        const k = M / (1 << S.canonical.z);
                        return new o.d6([S.canonical.x * k + S.wrap * M, S.canonical.y * k + S.wrap * M, 0], [(S.canonical.x + 1) * k + S.wrap * M, (S.canonical.y + 1) * k + S.wrap * M, P])
                    }(t, s, h).getCorners(), v = s / -m[2];
                    m[0] < 0 ? (o.d5(g[0], g[0], [m[0] * v, 0, 0]), o.d5(g[3], g[3], [m[0] * v, 0, 0])) : m[0] > 0 && (o.d5(g[1], g[1], [m[0] * v, 0, 0]), o.d5(g[2], g[2], [m[0] * v, 0, 0])), m[1] < 0 ? (o.d5(g[0], g[0], [0, m[1] * v, 0]), o.d5(g[1], g[1], [0, m[1] * v, 0])) : m[1] > 0 && (o.d5(g[2], g[2], [0, m[1] * v, 0]), o.d5(g[3], g[3], [0, m[1] * v, 0]));
                    const b = {};
                    return b.vertices = g, b.planes = [Ya(g[1], g[0], g[4]), Ya(g[2], g[1], g[5]), Ya(g[3], g[2], g[6]), Ya(g[0], g[3], g[7])], b
                }

                addShadowReceiver(t, s, h) {
                    this._receivers.add(t, o.d6.fromTileIdAndHeight(t, s, h))
                }

                getMaxCascadeForTile(t) {
                    const s = this._receivers.get(t);
                    return s && s.lastCascade ? s.lastCascade : 0
                }
            }

            function Ya(u, t, s) {
                const h = o.at([], s, t), m = o.at([], u, t), g = o.bF([], h, m), v = o.ae(g);
                return v === 0 ? [0, 0, 1, 0] : (o.c1(g, g, 1 / v), [g[0], g[1], g[2], -o.bG(g, t)])
            }

            function Ac(u) {
                const t = u.properties.get("direction"), s = o.d1(t.x, t.y, t.z);
                s[2] = o.ay(s[2], 0, 75);
                const h = o.d3([s[0], s[1], s[2]]);
                return o.d2(h.x, h.y, h.z)
            }

            function Nl(u, t, s) {
                const h = t.properties.get("color-use-theme") === "none", m = t.properties.get("color"),
                    g = t.properties.get("intensity"), v = t.properties.get("direction"), b = [v.x, v.y, v.z],
                    S = s.properties.get("color-use-theme") === "none", P = s.properties.get("color"),
                    M = s.properties.get("intensity"), k = Math.max(o.bG([0, 0, 1], b), 0), R = [0, 0, 0];
                o.c1(R, P.toPremultipliedRenderColor(S ? null : u.getLut(t.scope)).toArray01Linear().slice(0, 3), M);
                const O = [0, 0, 0];
                return o.c1(O, m.toPremultipliedRenderColor(h ? null : u.getLut(s.scope)).toArray01Linear().slice(0, 3), k * g), o.d8([R[0] > 0 ? R[0] / (R[0] + O[0]) : 0, R[1] > 0 ? R[1] / (R[1] + O[1]) : 0, R[2] > 0 ? R[2] / (R[2] + O[2]) : 0])
            }

            function Ic(u, t, s, h, m, g) {
                const v = u.zoom, b = u.scale, S = u.worldSize, P = 1 / S, M = u.aspect,
                    k = Math.sqrt(1 + M * M) * Math.tan(.5 * u.fovX), R = k * k, O = h - s, V = h + s;
                let B, G;
                R > O / V ? (B = h, G = h * k) : (B = .5 * V * (1 + R), G = .5 * Math.sqrt(O * O + 2 * (h * h + s * s) * R + V * V * R * R));
                const U = u.projection.pixelsPerMeter(u.center.lat, S), Z = u._camera.getCameraToWorldMercator(),
                    Q = [0, 0, -B * P];
                o.ad(Q, Q, Z);
                let te = G * P;
                const ce = u._edgeInsets;
                if (!(ce.left === 0 && ce.top === 0 && ce.right === 0 && ce.bottom === 0 || ce.left === ce.right && ce.top === ce.bottom)) {
                    const tt = u._camera.getWorldToCamera(u.worldSize, u.projection.zAxisUnit === "meters" ? U : 1),
                        it = u._camera.getCameraToClipPerspective(u._fov, u.width / u.height, s, h);
                    it[8] = 2 * -u.centerOffset.x / u.width, it[9] = 2 * u.centerOffset.y / u.height;
                    const rt = new Float64Array(16);
                    o.cM(rt, it, tt);
                    const gt = new Float64Array(16);
                    o.bi(gt, rt);
                    const Ot = o.cy.fromInvProjectionMatrix(gt, S, v, !0);
                    for (const Ut of Ot.points) {
                        const St = ((_e = Ut)[0] /= b, _e[1] /= b, _e[2] = o.cb(_e[2], u._center.lat), _e);
                        te = Math.max(te, o.c2(o.d7([], Q, St)))
                    }
                }
                var _e;
                te *= m / (m - 1);
                const ve = Math.acos(t[2]), ue = Math.atan2(-t[0], -t[1]), he = new vs;
                he.position = Q, he.setPitchBearing(ve, ue);
                const me = he.getWorldToCamera(S, U), Oe = te * S,
                    Se = Math.min(u._mercatorZfromZoom(17) * S * -2, -2 * Oe),
                    Xe = he.getCameraToClipOrthographic(-Oe, Oe, -Oe, Oe, Se, (Oe + g * U) / t[2]),
                    je = new Float64Array(16);
                o.az(je, Xe, me);
                const Ke = o.d2(Math.floor(1e6 * Q[0]) / 1e6 * S, Math.floor(1e6 * Q[1]) / 1e6 * S, 0), ut = .5 * m,
                    Fe = [0, 0, 0];
                o.ad(Fe, Ke, je), o.c1(Fe, Fe, ut);
                const Te = [Math.floor(Fe[0]), Math.floor(Fe[1]), Math.floor(Fe[2])], $e = [0, 0, 0];
                o.at($e, Fe, Te), o.c1($e, $e, -1 / ut);
                const Be = new Float64Array(16);
                return o.bx(Be), o.bo(Be, Be, $e), o.az(je, Be, je), [je, Oe]
            }

            class U_ extends o.E {
                constructor(t) {
                    super(), this.requestManager = t, this.models = {"": {}}, this.modelUris = {"": {}}, this.modelByURL = {}, this.numModelsLoading = {}
                }

                loadModel(t, s) {
                    return o.aS(this.requestManager.transformRequest(s, o.R.Model).url).then(h => {
                        if (!h) return;
                        const m = o.aT(h), g = new o.aU(t, void 0, void 0, m);
                        return g.computeBoundsAndApplyParent(), g
                    }).catch(h => {
                        if (h && h.status === 404) return null;
                        this.fire(new o.z(new Error(`Could not load model ${t} from ${s}: ${h.message}`)))
                    })
                }

                load(t, s, h = {forceReload: !1}) {
                    this.models[s] || (this.models[s] = {});
                    const m = Object.keys(t), g = [], v = [];
                    for (const b of m) {
                        const S = t[b];
                        this.hasURLBeenRequested(S) && !h.forceReload || (this.modelByURL[S] = {
                            modelId: b,
                            scope: s
                        }, g.push(this.loadModel(b, S)), v.push(b)), this.models[s][b] || (this.models[s][b] = {
                            model: null,
                            numReferences: 1
                        })
                    }
                    this.numModelsLoading[s] = (this.numModelsLoading[s] || 0) + v.length, Promise.allSettled(g).then(b => {
                        for (let S = 0; S < b.length; S++) {
                            const {status: P} = b[S];
                            if (P === "rejected") continue;
                            const {value: M} = b[S];
                            this.models[s][v[S]] || (this.models[s][v[S]] = {
                                model: null,
                                numReferences: 1
                            }), this.models[s][v[S]].model = M
                        }
                        this.numModelsLoading[s] -= v.length, this.fire(new o.A("data", {dataType: "style"}))
                    }).catch(b => {
                        this.fire(new o.z(new Error(`Could not load models: ${b.message}`)))
                    })
                }

                isLoaded() {
                    for (const t in this.numModelsLoading) if (this.numModelsLoading[t] > 0) return !1;
                    return !0
                }

                hasModel(t, s, h = {exactIdMatch: !1}) {
                    return !!(h.exactIdMatch ? this.getModel(t, s) : this.getModelByURL(this.modelUris[s][t]))
                }

                getModel(t, s) {
                    return this.models[s] || (this.models[s] = {}), this.models[s][t] ? this.models[s][t].model : void 0
                }

                getModelByURL(t) {
                    if (!t) return null;
                    const s = this.modelByURL[t];
                    return s ? this.models[s.scope][s.modelId].model : null
                }

                hasModelBeenAdded(t, s) {
                    return this.models[s] && this.models[s][t] !== void 0
                }

                getModelURIs(t) {
                    return this.modelUris[t] || {}
                }

                addModel(t, s, h) {
                    this.models[h] || (this.models[h] = {}), this.modelUris[h] || (this.modelUris[h] = {});
                    const m = this.requestManager.normalizeModelURL(s);
                    if ((this.hasModel(t, h, {exactIdMatch: !0}) || this.hasModelBeenAdded(t, h)) && this.modelUris[h][t] === m) this.models[h][t].numReferences++; else if (this.hasURLBeenRequested(m)) {
                        const {scope: g, modelId: v} = this.modelByURL[m];
                        this.models[g][v].numReferences++
                    } else this.modelUris[h][t] = m, this.load({[t]: this.modelUris[h][t]}, h)
                }

                addModelURLs(t, s) {
                    this.models[s] || (this.models[s] = {}), this.modelUris[s] || (this.modelUris[s] = {});
                    const h = this.modelUris[s];
                    for (const m in t) h[m] = this.requestManager.normalizeModelURL(t[m])
                }

                reloadModels(t) {
                    this.load(this.modelUris[t], t, {forceReload: !0})
                }

                addModelsFromBucket(t, s) {
                    this.models[s] || (this.models[s] = {}), this.modelUris[s] || (this.modelUris[s] = {});
                    const h = {};
                    for (const m of t) this.hasModel(m, s, {exactIdMatch: !0}) || this.hasURLBeenRequested(m) ? this.models[s][m].numReferences++ : this.modelUris[s][m] && !this.hasURLBeenRequested(m) ? h[m] = this.modelUris[s][m] : !this.hasURLBeenRequested(m) && o.d9(m, !1) && (this.modelUris[s][m] = this.requestManager.normalizeModelURL(m), h[m] = this.modelUris[s][m]);
                    this.load(h, s)
                }

                hasURLBeenRequested(t) {
                    return this.modelByURL[t] !== void 0
                }

                removeModel(t, s, h = !1, m = !1) {
                    if (this.models[s] && this.models[s][t] && (this.models[s][t].numReferences--, this.models[s][t].numReferences === 0 || m)) {
                        const g = this.modelUris[s][t];
                        h || delete this.modelUris[s][t], delete this.modelByURL[g];
                        const v = this.models[s][t].model;
                        if (!v) return;
                        delete this.models[s][t], v.destroy()
                    }
                }

                destroy() {
                    for (const t of Object.keys(this.models)) for (const s of Object.keys(this.models[t])) {
                        const h = this.models[t][s].model;
                        delete this.models[t][s], h && h.destroy()
                    }
                    this.models = {"": {}}, this.modelUris = {"": {}}, this.modelByURL = {}, this.numModelsLoading = {}
                }

                listModels(t) {
                    return this.models[t] || (this.models[t] = {}), Object.keys(this.models[t])
                }

                upload(t, s) {
                    this.models[s] || (this.models[s] = {});
                    for (const h in this.models[s]) this.models[s][h].model && this.models[s][h].model.upload(t.context)
                }
            }

            const vd = new o.a7({data: new o.a8(o.a5.colorTheme.data)});

            class Fp {
                constructor(t) {
                    this._scope = t, this._buildingQueryParams = {
                        target: {
                            featuresetId: "building-outline",
                            importId: this._scope
                        }
                    }, this._floorQueryParams = {target: {featuresetId: "floor-outline", importId: this._scope}}
                }

                execute(t) {
                    const s = this._makeBuildingsQueryArea(t), h = this._makeFloorsQueryArea(t),
                        m = t.queryRenderedFeatures(s, this._buildingQueryParams).filter(b => b.properties.shape_type === "building").reduce((b, S) => {
                            const P = S.properties.id;
                            return S.properties.shape_type !== "building" || b.some(M => M.properties.id === P) || b.push(S), b
                        }, []),
                        g = t.queryRenderedFeatures(h, this._floorQueryParams).filter(b => b.properties.shape_type === "floor").reduce((b, S) => {
                            const P = S.properties.id;
                            return S.properties.shape_type !== "floor" || b.some(M => M.properties.id === P) || b.push(S), b
                        }, []), v = [t.getCenter().lng, t.getCenter().lat];
                    return {floors: g, building: this._findBuildingAtCenter(v, m) || (m.length > 0 ? m[0] : null)}
                }

                _makeBuildingsQueryArea(t) {
                    const s = t.transform.width, h = t.transform.height, m = Math.min(s, h), g = m * (1 / 8),
                        v = m * (1 / 8), b = .5 * (s - g), S = .5 * (h - v);
                    return [new o.P(b, S), new o.P(b + g, S + v)]
                }

                _makeFloorsQueryArea(t) {
                    const s = t.transform.width, h = t.transform.height, m = s * (2 / 3), g = h * (2 / 3),
                        v = .5 * (s - m), b = .5 * (h - g);
                    return [new o.P(v, b), new o.P(v + m, b + g)]
                }

                _findBuildingAtCenter(t, s) {
                    for (const h of s) if (h.geometry.type === "Polygon" && this._pointInPolygon(t, h.geometry.coordinates[0])) return h;
                    return null
                }

                _pointInPolygon(t, s) {
                    let h = !1;
                    for (let m = 0, g = s.length - 1; m < s.length; g = m++) {
                        const v = s[m][0], b = s[m][1], S = s[g][1];
                        b > t[1] != S > t[1] && t[0] < (s[g][0] - v) * (t[1] - b) / (S - b) + v && (h = !h)
                    }
                    return h
                }
            }

            class Ka {
                constructor() {
                    this._selectedFloorId = null, this._selectedBuildingId = null, this._floors = []
                }

                setBuildingId(t) {
                    this._selectedBuildingId = t
                }

                setFloors(t) {
                    if (this._floors = t.filter(s => s.properties.building_id === this._selectedBuildingId), !this._selectedFloorId || !this._floors.map(s => s.properties.id).includes(this._selectedFloorId)) {
                        const s = this._floors.map(h => ({
                            id: h.properties.id,
                            level: h.properties.floor_level
                        })).reduce((h, m) => {
                            const g = Math.abs(h.level - 1), v = Math.abs(m.level - 1);
                            return v < g || v === g && m.level > h.level ? m : h
                        });
                        this._selectedFloorId = s.id
                    }
                }

                setFloorId(t) {
                    this._selectedFloorId = t
                }

                getSelectedFloorId() {
                    return this._selectedFloorId
                }

                getCurrentBuildingFloors() {
                    return this._floors
                }

                reset() {
                    this._selectedFloorId = null, this._selectedBuildingId = null, this._floors = []
                }
            }

            const Gx = {"mbx-indoor-level-selected": {default: ["literal", []]}};

            function G_(u) {
                return u = u || {}, Object.assign(u, Gx)
            }

            class $x extends o.E {
                constructor(t) {
                    super(), o.aV(["_onLoad", "_onMove"], this), this._map = t, this._floorSelectionState = new Ka, this._queryIndoor(), this._map.on("load", this._onLoad), this._map.on("move", this._onMove)
                }

                destroy() {
                    this._map.indoor.off("load", this._onLoad), this._map.indoor.off("move", this._onMove), this._map = null, this._floorSelectionState = null
                }

                _onLoad() {
                    this._map.style.forEachFragmentStyle(t => {
                        t.stylesheet.indoor && (this._indoorDataQuery ? this.fire(new o.z(new Error("Multiple indoor map styles detected, simultaneous usage is not allowed currently."))) : (this._scope = t.scope, this._indoorDataQuery = new Fp(this._scope)))
                    }), this._map._addIndoorControl(), this._queryIndoor()
                }

                _onMove() {
                    this._queryIndoor()
                }

                _queryIndoor() {
                    if (!this._indoorDataQuery || !this._map.isStyleLoaded()) return;
                    if (this._map.transform.zoom < 16) return void this._clearIndoorData();
                    const t = this._indoorDataQuery.execute(this._map);
                    t && t.floors.length !== 0 ? (this._floorSelectionState.getSelectedFloorId() || this._map._addIndoorControl(), this._selectFloors(t)) : this._clearIndoorData()
                }

                _selectFloors(t) {
                    if (t.building) this._floorSelectionState.setBuildingId(t.building.properties.id), this._floorSelectionState.setFloors(t.floors), this._updateUI(); else {
                        const s = this._floorSelectionState.getSelectedFloorId();
                        if (s && t.floors.some(h => h.properties.id === s)) return;
                        this._clearIndoorData()
                    }
                }

                _clearIndoorData() {
                    this._floorSelectionState.reset(), this._map._removeIndoorControl(), this._map.setConfigProperty(this._scope, "mbx-indoor-level-selected", ["literal", []])
                }

                _updateUI() {
                    const t = this._floorSelectionState.getCurrentBuildingFloors().map(h => ({
                        id: h.properties.id,
                        name: h.properties.name,
                        shortName: h.properties.floor_level,
                        levelOrder: h.properties.floor_level
                    })), s = this._floorSelectionState.getSelectedFloorId();
                    s ? (this._updateIndoorConfig(), this.fire(new o.A("indoorupdate", {
                        selectedFloorId: s,
                        floors: t
                    }))) : console.warn("IndoorManager: Selected floor is not set")
                }

                _updateIndoorConfig() {
                    const t = this._floorSelectionState.getSelectedFloorId();
                    t ? this._map.setConfigProperty(this._scope, "mbx-indoor-level-selected", ["literal", [t]]) : console.warn("IndoorManager: Selected floor is not set")
                }

                selectFloor(t) {
                    this._floorSelectionState.setFloorId(t), this._updateIndoorConfig()
                }
            }

            function $_(u) {
                if (!u.metadata || !u.metadata.content_area) return;
                const t = o.q.devicePixelRatio, {left: s, top: h, width: m, height: g} = u.metadata.content_area,
                    v = s * t, b = h * t;
                return [v, b, v + m * t, b + g * t]
            }

            function H_(u) {
                if (u) return u.map(([t, s]) => [t * o.q.devicePixelRatio, s * o.q.devicePixelRatio])
            }

            class Bp {
                constructor(t, s, h) {
                    this.id = t, this.scope = s, this.sourceCache = h, this.pendingRequests = new Set, this.missingRequests = new Set
                }

                addPendingRequest(t) {
                    this.missingRequests.has(t.name) || this.pendingRequests.has(t.name) || this.pendingRequests.add(t.name)
                }

                hasPendingRequests() {
                    return this.pendingRequests.size > 0
                }

                resolvePendingRequests() {
                    const t = new Map;
                    if (!this.sourceCache.loaded()) return t;
                    const s = this.sourceCache.getVisibleCoordinates();
                    if (s.length === 0) return t;
                    const h = this.sourceCache.getSource();
                    if (!(h instanceof qa)) return t;
                    const m = s.map(v => this.sourceCache.getTile(v)),
                        g = h.getImages(m, Array.from(this.pendingRequests));
                    for (const [v, b] of g) t.set(o.I.from({
                        name: v,
                        iconsetId: this.id
                    }), b), this.pendingRequests.delete(v);
                    for (const v of this.pendingRequests) this.missingRequests.add(v);
                    return this.pendingRequests.clear(), t
                }
            }

            const Qa = (u, t) => se(u, t && t.filter(s => s.identifier !== "source.canvas")),
                q_ = o.aF(Vi, ["addLayer", "removeLayer", "setLights", "setPaintProperty", "setLayoutProperty", "setSlot", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setSnow", "setRain", "setProjection", "setCamera", "addImport", "removeImport", "updateImport", "addIconset", "removeIconset"]),
                W_ = o.aF(Vi, ["setCenter", "setZoom", "setBearing", "setPitch"]),
                xd = new Set(["background", "sky", "slot", "custom"]), Ja = {version: 8, layers: [], sources: {}},
                uh = {duration: 300, delay: 0};

            class xs extends o.E {
                constructor(t, s = {}) {
                    super(), this.map = t, this.scope = s.scope || "", this.globalId = null, this.fragments = [], this.importDepth = s.importDepth || 0, this.importsCache = s.importsCache || new Map, this.resolvedImports = s.resolvedImports || new Set, this.transition = o.h({}, uh), this._buildingIndex = new L_(this), this.crossTileSymbolIndex = new Ao, this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._clipLayerPresent = !1, this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this._changes = s.styleChanges || new Do, this.dispatcher = s.dispatcher ? s.dispatcher : new o.D(o.db(), this), s.imageManager ? this.imageManager = s.imageManager : (this.imageManager = new Nn(this.map._spriteFormat), this.imageManager.setEventedParent(this)), this.imageManager.addScope(this.scope), this.glyphManager = s.glyphManager ? s.glyphManager : new o.dc(t._requestManager, s.localFontFamily ? o.dd.all : s.localIdeographFontFamily ? o.dd.ideographs : o.dd.none, s.localFontFamily || s.localIdeographFontFamily), s.modelManager ? this.modelManager = s.modelManager : (this.modelManager = new U_(t._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = !1, this._precompileDone = !1, this._shouldPrecompile = !1, this._availableImages = [], this._availableModels = {}, this._order = [], this._markersNeedUpdate = !1, this.options = s.configOptions ? s.configOptions : new Map, this._configDependentLayers = s.configDependentLayers ? s.configDependentLayers : new Set, this._config = s.config, this._styleColorTheme = {
                        lut: null,
                        lutLoading: !1,
                        lutLoadingCorrelationID: 0,
                        colorTheme: null,
                        colorThemeOverride: s.colorThemeOverride
                    }, this._styleColorThemeForScope = {}, this._initialConfig = s.initialConfig, this.dispatcher.broadcast("setReferrer", o.de());
                    const h = this;
                    this._rtlTextPluginCallback = xs.registerForPluginStateChange(m => {
                        h.dispatcher.broadcast("syncRTLPluginState", {
                            pluginStatus: m.pluginStatus,
                            pluginURL: m.pluginURL
                        }, (g, v) => {
                            if (o.df(g), v && v.every(b => b)) for (const b in h._sourceCaches) {
                                const S = h._sourceCaches[b], P = S.getSource().type;
                                P !== "vector" && P !== "geojson" || S.reload()
                            }
                        })
                    }), this.on("data", m => {
                        if (m.dataType !== "source" || m.sourceDataType !== "metadata") return;
                        const g = this.getOwnSource(m.sourceId);
                        if (g && g.vectorLayerIds) for (const v in this._layers) {
                            const b = this._layers[v];
                            b.source === g.id && this._validateLayer(b)
                        }
                    })
                }

                load(t) {
                    return t ? (typeof t == "string" ? this.loadURL(t) : this.loadJSON(t), this) : this
                }

                _getGlobalId(t) {
                    if (!t) return null;
                    if (typeof t == "string") {
                        if (o.j(t)) return t;
                        const s = o.dg(t);
                        if (!s.startsWith("http")) try {
                            return new URL(s, location.href).toString()
                        } catch {
                            return s
                        }
                        return s
                    }
                    return `json://${o.dh(JSON.stringify(t))}`
                }

                _diffStyle(t, s, h) {
                    this.globalId = this._getGlobalId(t);
                    const m = (g, v) => {
                        try {
                            v(null, this.setState(g, h))
                        } catch (b) {
                            v(b, !1)
                        }
                    };
                    if (typeof t == "string") {
                        const g = this.map._requestManager.normalizeStyleURL(t),
                            v = this.map._requestManager.transformRequest(g, o.R.Style);
                        o.n(v, (b, S) => {
                            b ? this.fire(new o.z(b)) : S && m(S, s)
                        })
                    } else typeof t == "object" && m(t, s)
                }

                loadURL(t, s = {}) {
                    this.fire(new o.A("dataloading", {dataType: "style"}));
                    const h = typeof s.validate == "boolean" ? s.validate : !o.j(t);
                    this.globalId = this._getGlobalId(t), t = this.map._requestManager.normalizeStyleURL(t, s.accessToken), this.resolvedImports.add(t);
                    const m = this.importsCache.get(t);
                    if (m) return this._load(m, h);
                    const g = this.map._requestManager.transformRequest(t, o.R.Style);
                    this._request = o.n(g, (v, b) => {
                        if (this._request = null, v) this.fire(new o.z(v)); else if (b) return this.importsCache.set(t, b), this._load(b, h)
                    })
                }

                loadJSON(t, s = {}) {
                    this.fire(new o.A("dataloading", {dataType: "style"})), this.globalId = this._getGlobalId(t), this._request = o.q.frame(() => {
                        this._request = null, this._load(t, s.validate !== !1)
                    })
                }

                loadEmpty() {
                    this.fire(new o.A("dataloading", {dataType: "style"})), this._load(Ja, !1)
                }

                _loadImports(t, s, h) {
                    if (this.importDepth >= 4) return o.w("Style doesn't support nesting deeper than 5"), Promise.resolve();
                    const m = [];
                    for (const g of t) {
                        const v = this._createFragmentStyle(g), b = new Promise(M => {
                            v.once("style.import.load", M), v.once("error", M)
                        }).then(() => this.mergeAll());
                        if (m.push(b), this.resolvedImports.has(g.url)) {
                            v.loadEmpty();
                            continue
                        }
                        const S = g.data || this.importsCache.get(g.url);
                        S ? (v.loadJSON(S, {validate: s}), this._isInternalStyle(S) && (v.globalId = null)) : g.url ? v.loadURL(g.url, {validate: s}) : v.loadEmpty();
                        const P = {style: v, id: g.id, config: g.config};
                        if (h) {
                            const M = this.fragments.findIndex(({id: k}) => k === h);
                            this.fragments = this.fragments.slice(0, M).concat(P).concat(this.fragments.slice(M))
                        } else this.fragments.push(P)
                    }
                    return Promise.allSettled(m)
                }

                getImportGlobalIds(t = this, s = new Set) {
                    for (const h of t.fragments) h.style.globalId && s.add(h.style.globalId), this.getImportGlobalIds(h.style, s);
                    return [...s.values()]
                }

                _createFragmentStyle(t) {
                    const s = this.scope ? o.C(t.id, this.scope) : t.id;
                    let h;
                    const m = this._initialConfig && this._initialConfig[s];
                    (t.config || m) && (h = o.h({}, t.config, m));
                    const g = new xs(this.map, {
                        scope: s,
                        styleChanges: this._changes,
                        importDepth: this.importDepth + 1,
                        importsCache: this.importsCache,
                        resolvedImports: new Set(this.resolvedImports),
                        dispatcher: this.dispatcher,
                        imageManager: this.imageManager,
                        glyphManager: this.glyphManager,
                        modelManager: this.modelManager,
                        config: h,
                        configOptions: this.options,
                        colorThemeOverride: t["color-theme"],
                        configDependentLayers: this._configDependentLayers
                    });
                    return g.setEventedParent(this.map, {style: g}), g
                }

                _reloadImports() {
                    this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast("setLayers", {
                        layers: this._serializeLayers(this._order),
                        scope: this.scope,
                        options: this.options
                    }), this._shouldPrecompile = this.map._precompilePrograms && this.isRootStyle()
                }

                _isInternalStyle(t) {
                    return this.isRootStyle() && (t.fragment || !!t.schema && t.fragment !== !1)
                }

                _load(t, s) {
                    const h = t.indoor ? G_(t.schema) : t.schema;
                    if (this._isInternalStyle(t)) {
                        const v = o.h({}, Ja, {imports: [{id: "basemap", data: t, url: ""}]});
                        return void this._load(v, s)
                    }
                    if (this.updateConfig(this._config, h), s && Qa(this, To(t))) return;
                    this._loaded = !0, this.stylesheet = o.di(t);
                    const m = () => {
                        for (const P in t.sources) this.addSource(P, t.sources[P], {validate: !1, isInitialLoad: !0});
                        if (t.iconsets) for (const P in t.iconsets) this.addIconset(P, t.iconsets[P]);
                        t.sprite ? this._loadIconset(t.sprite) : (this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast("spriteLoaded", {
                            scope: this.scope,
                            isLoaded: !0
                        })), !this.glyphManager.url && t.glyphs && this.glyphManager.setURL(t.glyphs);
                        const v = Yu(this.stylesheet.layers);
                        if (this._order = v.map(P => P.id), this.stylesheet.light && o.w("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."), this.stylesheet.lights) if (this.stylesheet.lights.length === 1 && this.stylesheet.lights[0].type === "flat") {
                            const P = this.stylesheet.lights[0];
                            this.light = new Ve(P.properties, P.id)
                        } else this.setLights(this.stylesheet.lights);
                        this.light || (this.light = new Ve(this.stylesheet.light)), this._layers = {};
                        for (const P of v) {
                            const M = o.dn(P, this.scope, this._styleColorTheme.lut, this.options);
                            M.configDependencies.size !== 0 && this._configDependentLayers.add(M.fqid), M.setEventedParent(this, {layer: {id: M.id}}), this._layers[M.id] = M;
                            const k = this.getOwnLayerSourceCache(M),
                                R = !!this.directionalLight && this.directionalLight.shadowsEnabled();
                            k && M.canCastShadows() && R && (k.castsShadows = !0)
                        }
                        this.stylesheet.featuresets && this.setFeaturesetSelectors(this.stylesheet.featuresets), this.stylesheet.models && this.addModelURLs(this.stylesheet.models);
                        const b = this.stylesheet.terrain;
                        b && (this.checkCanvasFingerprintNoise(), this.disableElevatedTerrain || this.terrainSetForDrapingOnly() || this._createTerrain(b, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.snow && this._createSnow(this.stylesheet.snow), this.stylesheet.rain && this._createRain(this.stylesheet.rain), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new o.A("data", {dataType: "style"}));
                        const S = this.isRootStyle();
                        t.imports ? this._loadImports(t.imports, s).then(() => {
                            this._reloadImports(), this.fire(new o.A(S ? "style.load" : "style.import.load"))
                        }).catch(P => {
                            this.fire(new o.z(new Error("Failed to load imports", P))), this.fire(new o.A(S ? "style.load" : "style.import.load"))
                        }) : (this._reloadImports(), this.fire(new o.A(S ? "style.load" : "style.import.load")))
                    };
                    this._styleColorTheme.colorTheme = this.stylesheet["color-theme"];
                    const g = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
                    if (g) {
                        const v = this._evaluateColorThemeData(g);
                        this._loadColorTheme(v).then(() => {
                            m()
                        }).catch(b => {
                            o.w(`Couldn't load color theme from the stylesheet: ${b}`), m()
                        })
                    } else this._styleColorTheme.lut = null, m()
                }

                isRootStyle() {
                    return this.importDepth === 0
                }

                mergeAll() {
                    let t, s, h, m, g, v, b, S, P, M;
                    const k = {};
                    this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle(R => {
                        if (R.stylesheet) {
                            if (R.light != null && (t = R.light), R.stylesheet.lights) for (const O of R.stylesheet.lights) O.type === "ambient" && R.ambientLight != null && (s = R.ambientLight), O.type === "directional" && R.directionalLight != null && (h = R.directionalLight);
                            m = this._prioritizeTerrain(m, R.terrain, R.stylesheet.terrain), R.stylesheet.fog && R.fog != null && (g = R.fog), R.stylesheet.snow && R.snow != null && (v = R.snow), R.stylesheet.rain && R.rain != null && (b = R.rain), R.stylesheet.camera != null && (M = R.stylesheet.camera), R.stylesheet.projection != null && (S = R.stylesheet.projection), R.stylesheet.transition != null && (P = R.stylesheet.transition), k[R.scope] = R._styleColorTheme
                        }
                    }), this.light = t, this.ambientLight = s, this.directionalLight = h, this.fog = g, this.snow = v, this.rain = b, this._styleColorThemeForScope = k, m === null ? delete this.terrain : this.terrain = m, this.camera = M || {"camera-projection": "perspective"}, this.projection = S || {name: "mercator"}, this.transition = o.h({}, uh, P), this.mergeSources(), this.mergeLayers()
                }

                forEachFragmentStyle(t) {
                    const s = h => {
                        for (const m of h.fragments) s(m.style);
                        t(h)
                    };
                    s(this)
                }

                _prioritizeTerrain(t, s, h) {
                    const m = t && t.drapeRenderMode === 0;
                    return h === null ? s && s.drapeRenderMode === 0 ? s : m ? t : null : s != null && (!t || m || s && s.drapeRenderMode === 1) ? s : t
                }

                mergeTerrain() {
                    let t;
                    this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle(s => {
                        t = this._prioritizeTerrain(t, s.terrain, s.stylesheet.terrain)
                    }), t === null ? delete this.terrain : this.terrain = t
                }

                mergeProjection() {
                    let t;
                    this.forEachFragmentStyle(s => {
                        s.stylesheet.projection != null && (t = s.stylesheet.projection)
                    }), this.projection = t || {name: "mercator"}
                }

                mergeSources() {
                    const t = {}, s = {}, h = {};
                    this.forEachFragmentStyle(m => {
                        for (const g in m._sourceCaches) {
                            const v = o.C(g, m.scope);
                            t[v] = m._sourceCaches[g]
                        }
                        for (const g in m._otherSourceCaches) {
                            const v = o.C(g, m.scope);
                            s[v] = m._otherSourceCaches[g]
                        }
                        for (const g in m._symbolSourceCaches) {
                            const v = o.C(g, m.scope);
                            h[v] = m._symbolSourceCaches[g]
                        }
                    }), this._mergedSourceCaches = t, this._mergedOtherSourceCaches = s, this._mergedSymbolSourceCaches = h
                }

                mergeLayers() {
                    const t = {}, s = [], h = {};
                    this._mergedSlots = [], this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this.forEachFragmentStyle(g => {
                        for (const v of g._order) {
                            const b = g._layers[v];
                            if (b.type === "slot") {
                                const S = o.dj(v);
                                if (t[S]) continue;
                                t[S] = []
                            }
                            b.slot && t[b.slot] ? t[b.slot].push(b) : s.push(b)
                        }
                    }), this._mergedOrder = [];
                    const m = (g = []) => {
                        for (const v of g) if (v.type === "slot") {
                            const b = o.dj(v.id);
                            t[b] && m(t[b]), this._mergedSlots.push(b)
                        } else {
                            const b = o.C(v.id, v.scope);
                            this._mergedOrder.push(b), h[b] = v, v.is3D(!!this.terrain) && (this._has3DLayers = !0), v.type === "circle" && (this._hasCircleLayers = !0), v.type === "symbol" && (this._hasSymbolLayers = !0), v.type === "clip" && (this._clipLayerPresent = !0)
                        }
                    };
                    m(s), this._mergedOrder.sort((g, v) => {
                        const b = h[g], S = h[v];
                        return b.hasInitialOcclusionOpacityProperties ? S.is3D(!!this.terrain) ? 1 : 0 : b.is3D(!!this.terrain) && S.hasInitialOcclusionOpacityProperties ? -1 : 0
                    }), this._mergedLayers = h, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged()
                }

                terrainSetForDrapingOnly() {
                    return !!this.terrain && this.terrain.drapeRenderMode === 0
                }

                getCamera() {
                    return this.stylesheet.camera
                }

                setCamera(t) {
                    return this.stylesheet.camera = o.h({}, this.stylesheet.camera, t), this.camera = this.stylesheet.camera, this
                }

                _evaluateColorThemeData(t) {
                    return t.data ? function (s, h, m, g) {
                        const v = o.h({}, h);
                        for (const S of Object.keys(o.a5.colorTheme)) v[S] === void 0 && (v[S] = o.a5.colorTheme[S].default);
                        const b = new o.a6(vd, s, new Map(m));
                        return b.setTransitionOrValue(v, m), b.untransitioned().possiblyEvaluate(new o.aa(0, {worldview: void 0}))
                    }(this.scope, t, this.options).get("data") : null
                }

                _loadColorTheme(t) {
                    this._styleColorTheme.lutLoading = !0, this._styleColorTheme.lutLoadingCorrelationID += 1;
                    const s = this._styleColorTheme.lutLoadingCorrelationID;
                    return new Promise((h, m) => {
                        const g = "data:image/png;base64,";
                        if (!t || t.length === 0) return this._styleColorTheme.lut = null, this._styleColorTheme.lutLoading = !1, void h();
                        let v = t;
                        v.startsWith(g) || (v = g + v);
                        const b = o.I.from("mapbox-reserved-lut"), S = new Image;
                        S.src = v, S.onerror = () => {
                            this._styleColorTheme.lutLoading = !1, m(new Error("Failed to load image data"))
                        }, S.onload = () => {
                            if (this._styleColorTheme.lutLoadingCorrelationID !== s) return void h();
                            this._styleColorTheme.lutLoading = !1;
                            const {width: P, height: M, data: k} = o.q.getImageData(S);
                            if (M > 32) return void m(new Error("The height of the image must be less than or equal to 32 pixels."));
                            if (P !== M * M) return void m(new Error("The width of the image must be equal to the height squared."));
                            this.getImage(b) && this.removeImage(b), this.addImage(b, {
                                data: new o.r({
                                    width: P,
                                    height: M
                                }, k), pixelRatio: 1, sdf: !1, usvg: !1, version: 0
                            });
                            const R = this.imageManager.getImage(b, this.scope);
                            R ? (this._styleColorTheme.lut = {
                                image: R.data,
                                data: t
                            }, h()) : m(new Error("Missing LUT image."))
                        }
                    })
                }

                getLut(t) {
                    const s = this._styleColorThemeForScope[t];
                    return s ? s.lut : null
                }

                setProjection(t) {
                    t ? this.stylesheet.projection = t : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection()
                }

                applyProjectionUpdate() {
                    this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0))
                }

                _updateMapProjection() {
                    this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection))
                }

                _loadSprite(t) {
                    this._spriteRequest = function (s, h, m) {
                        let g, v, b;
                        const S = o.q.devicePixelRatio > 1 ? "@2x" : "";
                        let P = o.n(h.transformRequest(h.normalizeSpriteURL(s, S, ".json"), o.R.SpriteJSON), (R, O) => {
                            P = null, b || (b = R, g = O, k())
                        }), M = o.o(h.transformRequest(h.normalizeSpriteURL(s, S, ".png"), o.R.SpriteImage), (R, O) => {
                            M = null, b || (b = R, v = O, k())
                        });

                        function k() {
                            if (b) m(b); else if (g && v) {
                                const R = o.q.getImageData(v), O = {};
                                for (const V in g) {
                                    const {
                                        width: B,
                                        height: G,
                                        x: U,
                                        y: Z,
                                        sdf: Q,
                                        pixelRatio: te,
                                        stretchX: ce,
                                        stretchY: _e,
                                        content: ve
                                    } = g[V], ue = new o.r({width: B, height: G});
                                    o.r.copy(R, ue, {x: U, y: Z}, {x: 0, y: 0}, {
                                        width: B,
                                        height: G
                                    }, null), O[V] = {
                                        data: ue,
                                        pixelRatio: te,
                                        sdf: Q,
                                        stretchX: ce,
                                        stretchY: _e,
                                        content: ve,
                                        usvg: !1
                                    }
                                }
                                m(null, O)
                            }
                        }

                        return {
                            cancel() {
                                P && (P.cancel(), P = null), M && (M.cancel(), M = null)
                            }
                        }
                    }(t, this.map._requestManager, (s, h) => {
                        if (this._spriteRequest = null, s) this.fire(new o.z(s)); else if (h) {
                            const m = new Map;
                            for (const g in h) m.set(o.I.from(g), h[g]);
                            this.addImages(m)
                        }
                        this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast("spriteLoaded", {
                            scope: this.scope,
                            isLoaded: !0
                        }), this.fire(new o.A("data", {dataType: "style"}))
                    })
                }

                addIconset(t, s) {
                    if (s.type === "sprite") return void this._loadSprite(s.url);
                    const h = this.getOwnSourceCache(s.source);
                    if (!h) return void this.fire(new o.z(new Error(`Source "${s.source}" as specified by iconset "${t}" does not exist and cannot be used as an iconset source`)));
                    const m = h.getSource();
                    if (m.type !== "raster-array") return void this.fire(new o.z(new Error(`Source "${s.source}" as specified by iconset "${t}" is not a "raster-array" source and cannot be used as an iconset source`)));
                    m.partial = !1;
                    const g = new Bp(t, this.scope, h);
                    this.imageManager.addImageProvider(g, this.scope)
                }

                removeIconset(t) {
                    this.imageManager.removeImageProvider(t, this.scope)
                }

                _loadIconset(t) {
                    if (!o.j(t) && this.map._spriteFormat !== "icon_set" || this.map._spriteFormat === "raster") return void this._loadSprite(t);
                    const s = this.map._spriteFormat === "auto";
                    var h, m;
                    this._spriteRequest = (m = (g, v) => {
                        if (this._spriteRequest = null, g) s ? this._loadSprite(t) : this.fire(new o.z(g)); else if (v) {
                            const b = new Map;
                            for (const S in v) b.set(o.I.from(S), v[S]);
                            this.addImages(b)
                        }
                        this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast("spriteLoaded", {
                            scope: this.scope,
                            isLoaded: !0
                        }), this.fire(new o.A("data", {dataType: "style"}))
                    }, o.br((h = this.map._requestManager).transformRequest(h.normalizeIconsetURL(t), o.R.Iconset), (g, v) => {
                        if (g) return void m(g);
                        const b = {}, S = o.da(new o.bq(v));
                        for (const P of S.icons) {
                            const M = {
                                version: 1,
                                pixelRatio: o.q.devicePixelRatio,
                                content: $_(P),
                                stretchX: P.metadata ? H_(P.metadata.stretch_x_areas) : void 0,
                                stretchY: P.metadata ? H_(P.metadata.stretch_y_areas) : void 0,
                                sdf: !1,
                                usvg: !0,
                                icon: P
                            };
                            b[P.name] = M
                        }
                        m(null, b)
                    }))
                }

                _validateLayer(t) {
                    const s = this.getOwnSource(t.source);
                    if (!s) return;
                    const h = t.sourceLayer;
                    h && (s.type === "geojson" || s.vectorLayerIds && s.vectorLayerIds.indexOf(h) === -1) && this.fire(new o.z(new Error(`Source layer "${h}" does not exist on source "${s.id}" as specified by style layer "${t.id}"`)))
                }

                loaded() {
                    if (!this._loaded || Object.keys(this._changes.getUpdatedSourceCaches()).length) return !1;
                    for (const t in this._sourceCaches) if (!this._sourceCaches[t].loaded()) return !1;
                    if (!this.imageManager.isLoaded() || this.imageManager.hasPatternsInFlight() || !this.modelManager.isLoaded() || this._styleColorTheme.lutLoading) return !1;
                    for (const {style: t} of this.fragments) if (!t.loaded()) return !1;
                    return !0
                }

                _serializeImports() {
                    if (this.stylesheet.imports) return this.stylesheet.imports.map((t, s) => {
                        const h = this.fragments[s];
                        return h && h.style && (t.data = h.style.serialize()), t
                    })
                }

                _serializeSources() {
                    const t = {};
                    for (const s in this._sourceCaches) {
                        const h = this._sourceCaches[s].getSource();
                        t[h.id] || (t[h.id] = h.serialize())
                    }
                    return t
                }

                _serializeLayers(t) {
                    const s = [];
                    for (const h of t) {
                        const m = this._layers[h];
                        m && m.type !== "custom" && s.push(m.serialize())
                    }
                    return s
                }

                hasLightTransitions() {
                    return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition())
                }

                hasFogTransition() {
                    return !!this.fog && this.fog.hasTransition()
                }

                hasSnowTransition() {
                    return !!this.snow && this.snow.hasTransition()
                }

                hasRainTransition() {
                    return !!this.rain && this.rain.hasTransition()
                }

                hasTransitions() {
                    if (this.hasLightTransitions() || this.hasFogTransition() || this.hasSnowTransition() || this.hasRainTransition()) return !0;
                    for (const t in this._sourceCaches) if (this._sourceCaches[t].hasTransition()) return !0;
                    for (const t in this._layers) if (this._layers[t].hasTransition()) return !0;
                    return !1
                }

                get order() {
                    return this.terrain ? this._drapedFirstOrder : this._mergedOrder
                }

                _getOrder(t) {
                    return t ? this.order : this._mergedOrder
                }

                isLayerDraped(t) {
                    return !!this.terrain && t.isDraped(this.getLayerSourceCache(t))
                }

                _checkLoaded() {
                    if (!this._loaded) throw new Error("Style is not done loading")
                }

                _checkLayer(t) {
                    const s = this.getOwnLayer(t);
                    if (s) return s;
                    this.fire(new o.z(new Error(`The layer '${t}' does not exist in the map's style.`)))
                }

                _checkSource(t) {
                    const s = this.getOwnSource(t);
                    if (s) return s;
                    this.fire(new o.z(new Error(`The source '${t}' does not exist in the map's style.`)))
                }

                precompilePrograms(t, s) {
                    const h = this.map.painter;
                    if (h) for (let m = t.minzoom || 0; m < (t.maxzoom || 25.5); m++) {
                        const g = t.getProgramIds();
                        if (g) for (const v of g) {
                            const b = t.getDefaultProgramParams(v, s.zoom, this._styleColorTheme.lut);
                            b && (h.style = this, this.fog && (h._fogVisible = !0, b.overrideFog = !0, h.getOrCreateProgram(v, b)), h._fogVisible = !1, b.overrideFog = !1, h.getOrCreateProgram(v, b), (this.stylesheet.terrain || this.stylesheet.projection && this.stylesheet.projection.name === "globe") && (b.overrideRtt = !0, h.getOrCreateProgram(v, b)))
                        }
                    }
                }

                update(t) {
                    if (!this._loaded) return;
                    this.ambientLight && this.ambientLight.recalculate(t), this.directionalLight && this.directionalLight.recalculate(t);
                    const s = this.calculateLightsBrightness();
                    t.brightness = s || 0, s !== this._brightness && (this._brightness = s, this.dispatcher.broadcast("setBrightness", s)), t.worldview !== this._worldview && (this._worldview = t.worldview, this.dispatcher.broadcast("setWorldview", this._worldview));
                    const h = this._changes.isDirty();
                    let m = !1;
                    if (this._changes.isDirty()) {
                        const b = this._changes.getLayerUpdatesByScope();
                        for (const S in b) {
                            const {updatedIds: P, removedIds: M} = b[S];
                            (P || M) && (this._updateWorkerLayers(S, P, M), m = !0)
                        }
                        this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t), this.light && this.light.updateTransitions(t), this.ambientLight && this.ambientLight.updateTransitions(t), this.directionalLight && this.directionalLight.updateTransitions(t), this.fog && this.fog.updateTransitions(t), this.snow && this.snow.updateTransitions(t), this.rain && this.rain.updateTransitions(t), this._changes.reset()
                    }
                    const g = {};
                    for (const b in this._mergedSourceCaches) {
                        const S = this._mergedSourceCaches[b];
                        g[b] = S.used, S.used = !1, S.tileCoverLift = 0
                    }
                    for (const b of this._mergedOrder) {
                        const S = this._mergedLayers[b];
                        if (S.recalculate(t, this._availableImages), !S.isHidden(t.zoom)) {
                            const P = this.getLayerSourceCache(S);
                            P && (P.used = !0, P.tileCoverLift = Math.max(P.tileCoverLift, S.tileCoverLift()))
                        }
                        !this._precompileDone && this._shouldPrecompile && ("requestIdleCallback" in window ? requestIdleCallback(() => {
                            this.precompilePrograms(S, t)
                        }) : this.precompilePrograms(S, t))
                    }
                    this._shouldPrecompile && (this._precompileDone = !0), this.terrain && m && this.mergeLayers();
                    const v = this.imageManager.getPendingImageProviders();
                    for (const b of v) b.sourceCache.used = !0;
                    for (const b in g) {
                        const S = this._mergedSourceCaches[b];
                        g[b] !== S.used && S.getSource().fire(new o.A("data", {
                            sourceDataType: "visibility",
                            dataType: "source",
                            sourceId: S.getSource().id
                        }))
                    }
                    this.light && this.light.recalculate(t), this.terrain && this.terrain.recalculate(t), this.fog && this.fog.recalculate(t), this.snow && this.snow.recalculate(t), this.rain && this.rain.recalculate(t), this.z = t.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), this.imageManager.clearUpdatedImages(this.scope), h && this.fire(new o.A("data", {dataType: "style"}))
                }

                updateImageProviders() {
                    const t = this.imageManager.getPendingImageProviders();
                    for (const s of t) {
                        const h = s.resolvePendingRequests(), m = this.getFragmentStyle(s.scope);
                        m && m.addImages(h)
                    }
                }

                _updateTilesForChangedImages() {
                    const t = {};
                    for (const s in this._mergedSourceCaches) {
                        const h = this._mergedSourceCaches[s].getSource().scope;
                        t[h] = t[h] || this._changes.getUpdatedImages(h), t[h].length !== 0 && this._mergedSourceCaches[s].reloadTilesForDependencies(["icons", "patterns"], t[h])
                    }
                    for (const s in t) this._changes.resetUpdatedImages(s)
                }

                _updateWorkerLayers(t, s, h) {
                    const m = this.getFragmentStyle(t);
                    m && this.dispatcher.broadcast("updateLayers", {
                        layers: s ? m._serializeLayers(s) : [],
                        scope: t,
                        removedIds: h || [],
                        options: m.options
                    })
                }

                setState(t, s) {
                    if (this._checkLoaded(), Qa(this, To(t))) return !1;
                    (t = o.di(t)).layers = Yu(t.layers);
                    const h = function (v, b) {
                        if (!v) return [{command: Vi.setStyle, args: [b]}];
                        let S = [];
                        try {
                            if (!o.bv(v.version, b.version)) return [{command: Vi.setStyle, args: [b]}];
                            if (o.bv(v.center, b.center) || S.push({
                                command: Vi.setCenter,
                                args: [b.center]
                            }), o.bv(v.zoom, b.zoom) || S.push({
                                command: Vi.setZoom,
                                args: [b.zoom]
                            }), o.bv(v.bearing, b.bearing) || S.push({
                                command: Vi.setBearing,
                                args: [b.bearing]
                            }), o.bv(v.pitch, b.pitch) || S.push({
                                command: Vi.setPitch,
                                args: [b.pitch]
                            }), o.bv(v.sprite, b.sprite) || S.push({
                                command: Vi.setSprite,
                                args: [b.sprite]
                            }), o.bv(v.glyphs, b.glyphs) || S.push({
                                command: Vi.setGlyphs,
                                args: [b.glyphs]
                            }), o.bv(v.imports, b.imports) || function (O = [], V = [], B) {
                                V = V || [];
                                const G = (O = O || []).map(Ll), U = V.map(Ll), Z = O.reduce(Wa, {}),
                                    Q = V.reduce(Wa, {}), te = G.slice();
                                let ce, _e, ve, ue;
                                for (ce = 0, _e = 0; ce < G.length; ce++) ve = G[ce], Q.hasOwnProperty(ve) ? _e++ : (B.push({
                                    command: Vi.removeImport,
                                    args: [ve]
                                }), te.splice(te.indexOf(ve, _e), 1));
                                for (ce = 0, _e = 0; ce < U.length; ce++) ve = U[U.length - 1 - ce], te[te.length - 1 - ce] !== ve && (Z.hasOwnProperty(ve) ? (B.push({
                                    command: Vi.removeImport,
                                    args: [ve]
                                }), te.splice(te.lastIndexOf(ve, te.length - _e), 1)) : _e++, ue = te[te.length - ce], B.push({
                                    command: Vi.addImport,
                                    args: [Q[ve], ue]
                                }), te.splice(te.length - ce, 0, ve));
                                for (const he of V) {
                                    const me = Z[he.id];
                                    me && (delete me.data, o.bv(me, he) || B.push({
                                        command: Vi.updateImport,
                                        args: [he.id, he]
                                    }))
                                }
                            }(v.imports, b.imports, S), o.bv(v.transition, b.transition) || S.push({
                                command: Vi.setTransition,
                                args: [b.transition]
                            }), o.bv(v.light, b.light) || S.push({
                                command: Vi.setLight,
                                args: [b.light]
                            }), o.bv(v.fog, b.fog) || S.push({
                                command: Vi.setFog,
                                args: [b.fog]
                            }), o.bv(v.snow, b.snow) || S.push({
                                command: Vi.setSnow,
                                args: [b.snow]
                            }), o.bv(v.rain, b.rain) || S.push({
                                command: Vi.setRain,
                                args: [b.rain]
                            }), o.bv(v.projection, b.projection) || S.push({
                                command: Vi.setProjection,
                                args: [b.projection]
                            }), o.bv(v.lights, b.lights) || S.push({
                                command: Vi.setLights,
                                args: [b.lights]
                            }), o.bv(v.camera, b.camera) || S.push({
                                command: Vi.setCamera,
                                args: [b.camera]
                            }), o.bv(v.iconsets, b.iconsets) || function (O, V, B) {
                                let G;
                                for (G in V = V || {}, O = O || {}) O.hasOwnProperty(G) && (V.hasOwnProperty(G) || B.push({
                                    command: Vi.removeIconset,
                                    args: [G]
                                }));
                                for (G in V) {
                                    if (!V.hasOwnProperty(G)) continue;
                                    const U = V[G];
                                    O.hasOwnProperty(G) ? o.bv(O[G], U) || (B.push({
                                        command: Vi.removeIconset,
                                        args: [G]
                                    }), B.push({
                                        command: Vi.addIconset,
                                        args: [G, U]
                                    })) : B.push({command: Vi.addIconset, args: [G, U]})
                                }
                            }(v.iconsets, b.iconsets, S), !o.bv(v["color-theme"], b["color-theme"])) return [{
                                command: Vi.setStyle,
                                args: [b]
                            }];
                            const P = {}, M = [];
                            (function (O, V, B, G) {
                                let U;
                                for (U in V = V || {}, O = O || {}) O.hasOwnProperty(U) && (V.hasOwnProperty(U) || yc(U, B, G));
                                for (U in V) {
                                    if (!V.hasOwnProperty(U)) continue;
                                    const Z = V[U];
                                    O.hasOwnProperty(U) ? o.bv(O[U], Z) || (O[U].type === "geojson" && Z.type === "geojson" && Nx(O, V, U) ? B.push({
                                        command: Vi.setGeoJSONSourceData,
                                        args: [U, Z.data]
                                    }) : Ku(U, V, B, G)) : fd(U, V, B)
                                }
                            })(v.sources, b.sources, M, P);
                            const k = [];
                            v.layers && v.layers.forEach(O => {
                                O.source && P[O.source] ? S.push({command: Vi.removeLayer, args: [O.id]}) : k.push(O)
                            });
                            let R = v.terrain;
                            R && P[R.source] && (S.push({
                                command: Vi.setTerrain,
                                args: [void 0]
                            }), R = void 0), S = S.concat(M), o.bv(R, b.terrain) || S.push({
                                command: Vi.setTerrain,
                                args: [b.terrain]
                            }), function (O, V, B) {
                                V = V || [];
                                const G = (O = O || []).map(Ll), U = V.map(Ll), Z = O.reduce(Wa, {}),
                                    Q = V.reduce(Wa, {}), te = G.slice(), ce = Object.create(null);
                                let _e, ve, ue, he, me, Oe, Se;
                                for (_e = 0, ve = 0; _e < G.length; _e++) ue = G[_e], Q.hasOwnProperty(ue) ? ve++ : (B.push({
                                    command: Vi.removeLayer,
                                    args: [ue]
                                }), te.splice(te.indexOf(ue, ve), 1));
                                for (_e = 0, ve = 0; _e < U.length; _e++) ue = U[U.length - 1 - _e], te[te.length - 1 - _e] !== ue && (Z.hasOwnProperty(ue) ? (B.push({
                                    command: Vi.removeLayer,
                                    args: [ue]
                                }), te.splice(te.lastIndexOf(ue, te.length - ve), 1)) : ve++, Oe = te[te.length - _e], B.push({
                                    command: Vi.addLayer,
                                    args: [Q[ue], Oe]
                                }), te.splice(te.length - _e, 0, ue), ce[ue] = !0);
                                for (_e = 0; _e < U.length; _e++) if (ue = U[_e], he = Z[ue], me = Q[ue], !ce[ue] && !o.bv(he, me)) if (o.bv(he.source, me.source) && o.bv(he["source-layer"], me["source-layer"]) && o.bv(he.type, me.type)) {
                                    for (Se in Qu(he.layout, me.layout, B, ue, null, Vi.setLayoutProperty), Qu(he.paint, me.paint, B, ue, null, Vi.setPaintProperty), o.bv(he.slot, me.slot) || B.push({
                                        command: Vi.setSlot,
                                        args: [ue, me.slot]
                                    }), o.bv(he.filter, me.filter) || B.push({
                                        command: Vi.setFilter,
                                        args: [ue, me.filter]
                                    }), o.bv(he.minzoom, me.minzoom) && o.bv(he.maxzoom, me.maxzoom) || B.push({
                                        command: Vi.setLayerZoomRange,
                                        args: [ue, me.minzoom, me.maxzoom]
                                    }), he) he.hasOwnProperty(Se) && Se !== "layout" && Se !== "paint" && Se !== "filter" && Se !== "metadata" && Se !== "minzoom" && Se !== "maxzoom" && Se !== "slot" && (Se.indexOf("paint.") === 0 ? Qu(he[Se], me[Se], B, ue, Se.slice(6), Vi.setPaintProperty) : o.bv(he[Se], me[Se]) || B.push({
                                        command: Vi.setLayerProperty,
                                        args: [ue, Se, me[Se]]
                                    }));
                                    for (Se in me) me.hasOwnProperty(Se) && !he.hasOwnProperty(Se) && Se !== "layout" && Se !== "paint" && Se !== "filter" && Se !== "metadata" && Se !== "minzoom" && Se !== "maxzoom" && Se !== "slot" && (Se.indexOf("paint.") === 0 ? Qu(he[Se], me[Se], B, ue, Se.slice(6), Vi.setPaintProperty) : o.bv(he[Se], me[Se]) || B.push({
                                        command: Vi.setLayerProperty,
                                        args: [ue, Se, me[Se]]
                                    }))
                                } else B.push({
                                    command: Vi.removeLayer,
                                    args: [ue]
                                }), Oe = te[te.lastIndexOf(ue) + 1], B.push({command: Vi.addLayer, args: [me, Oe]})
                            }(k, b.layers, S)
                        } catch (P) {
                            console.warn("Unable to compute style diff:", P), S = [{command: Vi.setStyle, args: [b]}]
                        }
                        return S
                    }(this.serialize(), t).filter(v => !(v.command in W_));
                    if (h.length === 0) return !1;
                    const m = h.filter(v => !(v.command in q_));
                    if (m.length > 0) throw new Error(`Unimplemented: ${m.map(v => v.command).join(", ")}.`);
                    const g = [];
                    return h.forEach(v => {
                        g.push(this[v.command](...v.args))
                    }), s && Promise.all(g).then(s).catch(s), this.stylesheet = t, this.mergeAll(), this.dispatcher.broadcast("setLayers", {
                        layers: this._serializeLayers(this._order),
                        scope: this.scope,
                        options: this.options
                    }), !0
                }

                _updateWorkerImages() {
                    this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", {
                        scope: this.scope,
                        images: this._availableImages
                    })
                }

                _updateWorkerModels() {
                    this._availableModels = this.modelManager.getModelURIs(this.scope), this.dispatcher.broadcast("setModels", {
                        scope: this.scope,
                        models: this._availableModels
                    })
                }

                addImages(t) {
                    if (t.size === 0) return this;
                    for (const [s, h] of t.entries()) {
                        if (this.getImage(s)) return this.fire(new o.z(new Error(`An image with the name "${s.name}" already exists.`)));
                        this.imageManager.addImage(s, this.scope, h), this._changes.updateImage(s, this.scope)
                    }
                    return this._updateWorkerImages(), this.fire(new o.A("data", {dataType: "style"})), this
                }

                addImage(t, s) {
                    return this.getImage(t) ? this.fire(new o.z(new Error(`An image with the name "${t.name}" already exists.`))) : (this.imageManager.addImage(t, this.scope, s), this._changes.updateImage(t, this.scope), this._updateWorkerImages(), this.fire(new o.A("data", {dataType: "style"})), this)
                }

                updateImage(t, s, h = !1) {
                    this.imageManager.updateImage(t, this.scope, s), h && (this._changes.updateImage(t, this.scope), this._updateWorkerImages(), this.fire(new o.A("data", {dataType: "style"})))
                }

                getImage(t) {
                    return this.imageManager.getImage(t, this.scope)
                }

                removeImage(t) {
                    return this.getImage(t) ? (this.imageManager.removeImage(t, this.scope), this._changes.updateImage(t, this.scope), this._updateWorkerImages(), this.fire(new o.A("data", {dataType: "style"})), this) : this.fire(new o.z(new Error("No image with this name exists.")))
                }

                listImages() {
                    return this._checkLoaded(), this._availableImages.slice()
                }

                addModelURLs(t) {
                    return this.modelManager.addModelURLs(t, this.scope), this._updateWorkerModels(), this.fire(new o.A("data", {dataType: "style"})), this
                }

                addModel(t, s, h = {}) {
                    return this._checkLoaded(), this._validate(ie, `models.${t}`, s, null, h) || (this.modelManager.addModel(t, s, this.scope), this.fire(new o.A("data", {dataType: "style"}))), this
                }

                hasModel(t) {
                    return this.modelManager.hasModel(t, this.scope)
                }

                removeModel(t) {
                    return this.hasModel(t) ? (this.modelManager.removeModel(t, this.scope, !1, !0), this.fire(new o.A("data", {dataType: "style"})), this) : this.fire(new o.z(new Error("No model with this ID exists.")))
                }

                listModels() {
                    return this._checkLoaded(), this.modelManager.listModels(this.scope)
                }

                addSource(t, s, h = {}) {
                    if (this._checkLoaded(), this.getOwnSource(t) !== void 0) throw new Error(`There is already a source with ID "${t}".`);
                    if (!s.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(s).join(", ")}.`);
                    if (["vector", "raster", "geojson", "video", "image"].indexOf(s.type) >= 0 && this._validate(pa, `sources.${t}`, s, null, h)) return;
                    this.map && this.map._collectResourceTiming && (s.collectResourceTiming = !0);
                    const m = $u(t, s, this.dispatcher, this);
                    m.scope = this.scope, m.setEventedParent(this, () => ({
                        isSourceLoaded: this._isSourceCacheLoaded(m.id),
                        source: m.serialize(),
                        sourceId: m.id
                    }));
                    const g = v => {
                        const b = (v ? "symbol:" : "other:") + m.id, S = o.C(b, this.scope),
                            P = this._sourceCaches[b] = new Eo(S, m, v);
                        (v ? this._symbolSourceCaches : this._otherSourceCaches)[m.id] = P, P.onAdd(this.map)
                    };
                    g(!1), s.type !== "vector" && s.type !== "geojson" || g(!0), m.onAdd && m.onAdd(this.map), h.isInitialLoad || (this.mergeSources(), this._changes.setDirty())
                }

                removeSource(t) {
                    this._checkLoaded();
                    const s = this.getOwnSource(t);
                    if (!s) throw new Error("There is no source with this ID");
                    for (const m in this._layers) if (this._layers[m].source === t) return this.fire(new o.z(new Error(`Source "${t}" cannot be removed while layer "${m}" is using it.`)));
                    if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t) return this.fire(new o.z(new Error(`Source "${t}" cannot be removed while terrain is using it.`)));
                    if (this.stylesheet.iconsets) {
                        const m = Object.entries(this.stylesheet.iconsets).find(([g, v]) => v.type === "source" && v.source === t);
                        if (m) return this.fire(new o.z(new Error(`Source "${t}" cannot be removed while iconset "${m[0]}" is using it.`)))
                    }
                    const h = this.getOwnSourceCaches(t);
                    for (const m of h) {
                        const g = o.dj(m.id);
                        delete this._sourceCaches[g], this._changes.discardSourceCacheUpdate(m.id), m.fire(new o.A("data", {
                            sourceDataType: "metadata",
                            dataType: "source",
                            sourceId: m.getSource().id
                        })), m.setEventedParent(null), m.clearTiles()
                    }
                    return delete this._otherSourceCaches[t], delete this._symbolSourceCaches[t], this.mergeSources(), s.setEventedParent(null), s.onRemove && s.onRemove(this.map), this._changes.setDirty(), this
                }

                setGeoJSONSourceData(t, s) {
                    this._checkLoaded(), this.getOwnSource(t).setData(s), this._changes.setDirty()
                }

                getOwnSource(t) {
                    const s = this.getOwnSourceCache(t);
                    return s && s.getSource()
                }

                getOwnSources() {
                    const t = [];
                    for (const s in this._otherSourceCaches) {
                        const h = this.getOwnSourceCache(s);
                        h && t.push(h.getSource())
                    }
                    return t
                }

                areTilesLoaded() {
                    const t = this._mergedSourceCaches;
                    for (const s in t) {
                        const h = t[s]._tiles;
                        for (const m in h) {
                            const g = h[m];
                            if (g.state !== "loaded" && g.state !== "errored") return !1
                        }
                    }
                    return !0
                }

                setLights(t) {
                    if (this._checkLoaded(), !t) return delete this.ambientLight, void delete this.directionalLight;
                    const s = this._getTransitionParameters();
                    for (const g of t) {
                        if (this._validate(Ha, "lights", g)) return;
                        switch (g.type) {
                            case"ambient":
                                if (this.ambientLight) {
                                    const v = this.ambientLight;
                                    v.set(g), v.updateTransitions(s)
                                } else this.ambientLight = new un(g, Li || (Li = new o.a7({
                                    color: new o.a8(o.a5.properties_light_ambient.color),
                                    "color-use-theme": new o.a8({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-constant"
                                    }),
                                    intensity: new o.a8(o.a5.properties_light_ambient.intensity)
                                })), this.scope, this.options);
                                break;
                            case"directional":
                                if (this.directionalLight) {
                                    const v = this.directionalLight;
                                    v.set(g), v.updateTransitions(s)
                                } else this.directionalLight = new un(g, Xn || (Xn = new o.a7({
                                    direction: new o.an(o.a5.properties_light_directional.direction),
                                    color: new o.a8(o.a5.properties_light_directional.color),
                                    "color-use-theme": new o.a8({
                                        type: "string",
                                        default: "default",
                                        "property-type": "data-constant"
                                    }),
                                    intensity: new o.a8(o.a5.properties_light_directional.intensity),
                                    "cast-shadows": new o.a8(o.a5.properties_light_directional["cast-shadows"]),
                                    "shadow-quality": new o.a8(o.a5.properties_light_directional["shadow-quality"]),
                                    "shadow-intensity": new o.a8(o.a5.properties_light_directional["shadow-intensity"])
                                })), this.scope, this.options)
                        }
                    }
                    const h = Object.assign(s, {worldview: this.map.getWorldview()}), m = new o.aa(this.z || 0, h);
                    this.ambientLight && this.ambientLight.recalculate(m), this.directionalLight && this.directionalLight.recalculate(m), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast("setBrightness", this._brightness)
                }

                calculateLightsBrightness() {
                    const t = this.directionalLight, s = this.ambientLight;
                    if (!t || !s) return;
                    const h = R => .2126 * (R[0] <= .03928 ? R[0] / 12.92 : Math.pow((R[0] + .055) / 1.055, 2.4)) + .7152 * (R[1] <= .03928 ? R[1] / 12.92 : Math.pow((R[1] + .055) / 1.055, 2.4)) + .0722 * (R[2] <= .03928 ? R[2] / 12.92 : Math.pow((R[2] + .055) / 1.055, 2.4)),
                        m = t.properties.get("color").toNonPremultipliedRenderColor(null).toArray01(),
                        g = t.properties.get("intensity"), v = t.properties.get("direction"),
                        b = 1 - o.d1(v.x, v.y, v.z)[2] / 90, S = h(m) * g * b,
                        P = s.properties.get("color").toNonPremultipliedRenderColor(null).toArray01(),
                        M = s.properties.get("intensity"), k = h(P) * M;
                    return Number(((S + k) / 2).toFixed(6))
                }

                getBrightness() {
                    return this._brightness
                }

                getLights() {
                    if (!this.enable3dLights()) return null;
                    const t = [];
                    return this.directionalLight && t.push(this.directionalLight.get()), this.ambientLight && t.push(this.ambientLight.get()), t
                }

                enable3dLights() {
                    return !!this.ambientLight && !!this.directionalLight
                }

                getFragmentStyle(t) {
                    if (t == null || t === "" && this.isRootStyle()) return this;
                    if (o.dk(t)) {
                        const s = o.dl(t), h = this.fragments.find(({id: g}) => g === s);
                        if (!h) return;
                        const m = o.dj(t);
                        return h.style.getFragmentStyle(m)
                    }
                    {
                        const s = this.fragments.find(({id: h}) => h === t);
                        return s ? s.style : void 0
                    }
                }

                setFeaturesetSelectors(t) {
                    if (!t) return;
                    const s = {}, h = (m, g = "") => `${m}::${g}`;
                    this._featuresetSelectors = {};
                    for (const m in t) {
                        const g = this._featuresetSelectors[m] = [];
                        for (const v of t[m].selectors) {
                            if (v.featureNamespace) {
                                const S = this.getOwnLayer(v.layer);
                                if (!S) {
                                    o.w(`Layer is undefined for selector: ${v.layer}`);
                                    continue
                                }
                                const P = h(S.source, S.sourceLayer);
                                if (P in s && s[P] !== v.featureNamespace) {
                                    o.w(`"featureNamespace ${v.featureNamespace} of featureset ${m}'s selector is not associated to the same source, skip this selector`);
                                    continue
                                }
                                s[P] = v.featureNamespace
                            }
                            let b;
                            if (v.properties) for (const S in v.properties) {
                                const P = o.X(v.properties[S]);
                                P.result === "success" && (b = b || {}, b[S] = P.value)
                            }
                            g.push({
                                layerId: v.layer,
                                namespace: v.featureNamespace,
                                properties: b,
                                uniqueFeatureID: v._uniqueFeatureID
                            })
                        }
                    }
                }

                getFeaturesetDescriptors(t) {
                    const s = this.getFragmentStyle(t);
                    if (!s || !s.stylesheet.featuresets) return [];
                    const h = [];
                    for (const m in s.stylesheet.featuresets) h.push({
                        featuresetId: m,
                        importId: s.scope ? s.scope : void 0
                    });
                    return h
                }

                getFeaturesetLayers(t, s) {
                    const h = this.getFragmentStyle(s), m = h.stylesheet.featuresets;
                    if (!m || !m[t]) return this.fire(new o.z(new Error(`The featureset '${t}' does not exist in the map's style and cannot be queried.`))), [];
                    const g = [];
                    for (const v of m[t].selectors) {
                        const b = h.getOwnLayer(v.layer);
                        b && g.push(b)
                    }
                    return g
                }

                getConfigProperty(t, s) {
                    const h = this.getFragmentStyle(t);
                    if (!h) return null;
                    const m = o.C(s, h.scope), g = h.options.get(m), v = g ? g.value || g.default : null;
                    return v ? v.serialize() : null
                }

                setConfigProperty(t, s, h) {
                    const m = this.getFragmentStyle(t);
                    if (!m) return;
                    const g = m.stylesheet.indoor ? G_(m.stylesheet.schema) : m.stylesheet.schema;
                    if (!g || !g[s]) return;
                    const v = o.X(h);
                    if (v.result !== "success") return void Qa(this, v.value);
                    const b = v.value.expression, S = o.C(s, m.scope), P = m.options.get(S);
                    if (!P) return;
                    let M;
                    const {minValue: k, maxValue: R, stepValue: O, type: V, values: B} = g[s], G = o.X(g[s].default);
                    G.result === "success" && (M = G.value.expression), M ? (this.options.set(S, Object.assign({}, P, {
                        value: b,
                        default: M,
                        minValue: k,
                        maxValue: R,
                        stepValue: O,
                        type: V,
                        values: B
                    })), this.updateConfigDependencies(s)) : this.fire(new o.z(new Error(`No schema defined for the config option "${s}" in the "${t}" fragment.`)))
                }

                getConfig(t) {
                    const s = this.getFragmentStyle(t);
                    if (!s) return null;
                    const h = s.stylesheet.schema;
                    if (!h) return null;
                    const m = {};
                    for (const g in h) {
                        const v = o.C(g, s.scope), b = s.options.get(v), S = b ? b.value || b.default : null;
                        m[g] = S ? S.serialize() : null
                    }
                    return m
                }

                setConfig(t, s) {
                    const h = this.getFragmentStyle(t);
                    h && (h.updateConfig(s, h.stylesheet.schema), this.updateConfigDependencies())
                }

                getSchema(t) {
                    const s = this.getFragmentStyle(t);
                    return s ? s.stylesheet.schema : null
                }

                setSchema(t, s) {
                    const h = this.getFragmentStyle(t);
                    h && (h.stylesheet.schema = s, h.updateConfig(h._config, s), this.updateConfigDependencies())
                }

                updateConfig(t, s) {
                    if (this._config = t, t || s) if (s) for (const h in s) {
                        let m, g;
                        const v = o.X(s[h].default);
                        if (v.result === "success" && (m = v.value.expression), t && t[h] !== void 0) {
                            const R = o.X(t[h]);
                            R.result === "success" && (g = R.value.expression)
                        }
                        const {minValue: b, maxValue: S, stepValue: P, type: M, values: k} = s[h];
                        if (m) {
                            const R = o.C(h, this.scope);
                            this.options.set(R, {
                                default: m,
                                value: g,
                                minValue: b,
                                maxValue: S,
                                stepValue: P,
                                type: M,
                                values: k
                            })
                        } else this.fire(new o.z(new Error(`No schema defined for config option "${h}".`)))
                    } else this.fire(new o.z(new Error("Attempting to set config for a style without schema.")))
                }

                updateConfigDependencies(t) {
                    for (const s of this._configDependentLayers) {
                        const h = this.getLayer(s);
                        if (h) {
                            if (t && !h.configDependencies.has(t)) continue;
                            h.possiblyEvaluateVisibility(), this._updateLayer(h)
                        }
                    }
                    this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this.fog && this.fog.updateConfig(this.options), this.snow && this.snow.updateConfig(this.options), this.rain && this.rain.updateConfig(this.options), this.forEachFragmentStyle(s => {
                        const h = s._styleColorTheme.colorThemeOverride ? s._styleColorTheme.colorThemeOverride : s._styleColorTheme.colorTheme;
                        if (h) {
                            const m = s._evaluateColorThemeData(h);
                            (!s._styleColorTheme.lut && m !== "" || s._styleColorTheme.lut && m !== s._styleColorTheme.lut.data) && s.setColorTheme(h)
                        }
                    }), this._changes.setDirty()
                }

                addLayer(t, s, h = {}) {
                    this._checkLoaded();
                    const m = t.id;
                    if (this._layers[m]) return void this.fire(new o.z(new Error(`Layer with id "${m}" already exists on this map`)));
                    let g;
                    if (t.type === "custom") {
                        if (Qa(this, o.dm(t))) return;
                        g = o.dn(t, this.scope, this._styleColorTheme.lut, this.options)
                    } else {
                        if (typeof t.source == "object" && (this.addSource(m, t.source), t = o.di(t), t = o.h(t, {source: m})), this._validate(Ai, `layers.${m}`, t, {arrayIndex: -1}, h)) return;
                        g = o.dn(t, this.scope, this._styleColorTheme.lut, this.options), this._validateLayer(g), g.setEventedParent(this, {layer: {id: m}})
                    }
                    g.configDependencies.size !== 0 && this._configDependentLayers.add(g.fqid);
                    let v = this._order.length;
                    if (s) {
                        const M = this._order.indexOf(s);
                        if (M === -1) return void this.fire(new o.z(new Error(`Layer with id "${s}" does not exist on this map.`)));
                        g.slot === this._layers[s].slot ? v = M : o.w(`Layer with id "${s}" has a different slot. Layers can only be rearranged within the same slot.`)
                    }
                    this._order.splice(v, 0, m), this._layerOrderChanged = !0, this._layers[m] = g;
                    const b = this.getOwnLayerSourceCache(g),
                        S = !!this.directionalLight && this.directionalLight.shadowsEnabled();
                    b && g.canCastShadows() && S && (b.castsShadows = !0);
                    const P = this._changes.getRemovedLayer(g);
                    if (P && g.source && b && g.type !== "custom") {
                        this._changes.discardLayerRemoval(g);
                        const M = o.C(g.source, g.scope);
                        P.type !== g.type ? this._changes.updateSourceCache(M, "clear") : (this._changes.updateSourceCache(M, "reload"), b.pause())
                    }
                    this._updateLayer(g), g.onAdd && g.onAdd(this.map), g.scope = this.scope, this.mergeLayers()
                }

                moveLayer(t, s) {
                    this._checkLoaded();
                    const h = this._checkLayer(t);
                    if (!h || t === s) return;
                    const m = this._order.indexOf(t);
                    this._order.splice(m, 1);
                    let g = this._order.length;
                    if (s) {
                        const v = this._order.indexOf(s);
                        if (v === -1) return void this.fire(new o.z(new Error(`Layer with id "${s}" does not exist on this map.`)));
                        h.slot === this._layers[s].slot ? g = v : o.w(`Layer with id "${s}" has a different slot. Layers can only be rearranged within the same slot.`)
                    }
                    this._order.splice(g, 0, t), this._changes.setDirty(), this._layerOrderChanged = !0, this.mergeLayers()
                }

                removeLayer(t) {
                    this._checkLoaded();
                    const s = this._checkLayer(t);
                    if (!s) return;
                    s.setEventedParent(null);
                    const h = this._order.indexOf(t);
                    this._order.splice(h, 1), delete this._layers[t], this._changes.setDirty(), this._layerOrderChanged = !0, this._configDependentLayers.delete(s.fqid), this._changes.removeLayer(s);
                    const m = this.getOwnLayerSourceCache(s);
                    if (m && m.castsShadows) {
                        let g = !1;
                        for (const v in this._layers) if (this._layers[v].source === s.source && this._layers[v].canCastShadows()) {
                            g = !0;
                            break
                        }
                        m.castsShadows = g
                    }
                    s.onRemove && s.onRemove(this.map), this.mergeLayers()
                }

                getOwnLayer(t) {
                    return this._layers[t]
                }

                hasLayer(t) {
                    return t in this._mergedLayers
                }

                hasLayerType(t) {
                    for (const s in this._layers) if (this._layers[s].type === t) return !0;
                    return !1
                }

                setLayerZoomRange(t, s, h) {
                    this._checkLoaded();
                    const m = this._checkLayer(t);
                    m && (m.minzoom === s && m.maxzoom === h || (s != null && (m.minzoom = s), h != null && (m.maxzoom = h), this._updateLayer(m)))
                }

                getSlots() {
                    return this._checkLoaded(), this._mergedSlots
                }

                setSlot(t, s) {
                    this._checkLoaded();
                    const h = this._checkLayer(t);
                    h && h.slot !== s && (h.slot = s, this._updateLayer(h))
                }

                setFilter(t, s, h = {}) {
                    this._checkLoaded();
                    const m = this._checkLayer(t);
                    if (m && !o.bv(m.filter, s)) return s == null ? (m.filter = void 0, void this._updateLayer(m)) : void (this._validate(Le, `layers.${m.id}.filter`, s, {layerType: m.type}, h) || (m.filter = o.di(s), this._updateLayer(m)))
                }

                getFilter(t) {
                    const s = this._checkLayer(t);
                    if (s) return o.di(s.filter)
                }

                setLayoutProperty(t, s, h, m = {}) {
                    this._checkLoaded();
                    const g = this._checkLayer(t);
                    if (g && !o.bv(g.getLayoutProperty(s), h)) {
                        if (h != null && (!m || m.validate !== !1) && Qa(g, W.call(To, {
                            key: `layers.${t}.layout.${s}`,
                            layerType: g.type,
                            objectKey: s,
                            value: h,
                            styleSpec: o.a5,
                            style: {glyphs: !0, sprite: !0}
                        }))) return;
                        g.setLayoutProperty(s, h), g.configDependencies.size !== 0 && this._configDependentLayers.add(g.fqid), this._updateLayer(g)
                    }
                }

                getLayoutProperty(t, s) {
                    const h = this._checkLayer(t);
                    if (h) return h.getLayoutProperty(s)
                }

                setPaintProperty(t, s, h, m = {}) {
                    this._checkLoaded();
                    const g = this._checkLayer(t);
                    if (!g || o.bv(g.getPaintProperty(s), h) || h != null && (!m || m.validate !== !1) && Qa(g, $.call(To, {
                        key: `layers.${t}.paint.${s}`,
                        layerType: g.type,
                        objectKey: s,
                        value: h,
                        styleSpec: o.a5
                    }))) return;
                    const v = g.setPaintProperty(s, h);
                    g.configDependencies.size !== 0 && this._configDependentLayers.add(g.fqid), v && this._updateLayer(g), this._changes.updatePaintProperties(g)
                }

                getPaintProperty(t, s) {
                    const h = this._checkLayer(t);
                    if (h) return h.getPaintProperty(s)
                }

                setFeatureState(t, s) {
                    if (this._checkLoaded(), "target" in t) {
                        if ("featuresetId" in t.target) {
                            const {featuresetId: S, importId: P} = t.target, M = this.getFragmentStyle(P),
                                k = M.getFeaturesetLayers(S);
                            for (const {source: R, sourceLayer: O} of k) M.setFeatureState({
                                id: t.id,
                                source: R,
                                sourceLayer: O
                            }, s)
                        } else if ("layerId" in t.target) {
                            const {layerId: S} = t.target, P = this.getLayer(S);
                            this.setFeatureState({id: t.id, source: P.source, sourceLayer: P.sourceLayer}, s)
                        }
                        return
                    }
                    const h = t.source, m = t.sourceLayer, g = this._checkSource(h);
                    if (!g) return;
                    const v = g.type;
                    if (v === "geojson" && m) return void this.fire(new o.z(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
                    if (v === "vector" && !m) return void this.fire(new o.z(new Error("The sourceLayer parameter must be provided for vector source types.")));
                    t.id === void 0 && this.fire(new o.z(new Error("The feature id parameter must be provided.")));
                    const b = this.getOwnSourceCaches(h);
                    for (const S of b) S.setFeatureState(m, t.id, s)
                }

                removeFeatureState(t, s) {
                    if (this._checkLoaded(), "target" in t) {
                        if ("featuresetId" in t.target) {
                            const {featuresetId: S, importId: P} = t.target, M = this.getFragmentStyle(P),
                                k = M.getFeaturesetLayers(S);
                            for (const {source: R, sourceLayer: O} of k) M.removeFeatureState({
                                id: t.id,
                                source: R,
                                sourceLayer: O
                            }, s)
                        } else if ("layerId" in t.target) {
                            const {layerId: S} = t.target, P = this.getLayer(S);
                            this.removeFeatureState({id: t.id, source: P.source, sourceLayer: P.sourceLayer}, s)
                        }
                        return
                    }
                    const h = t.source, m = this._checkSource(h);
                    if (!m) return;
                    const g = m.type, v = g === "vector" ? t.sourceLayer : void 0;
                    if (g === "vector" && !v) return void this.fire(new o.z(new Error("The sourceLayer parameter must be provided for vector source types.")));
                    if (s && typeof t.id != "string" && typeof t.id != "number") return void this.fire(new o.z(new Error("A feature id is required to remove its specific state property.")));
                    const b = this.getOwnSourceCaches(h);
                    for (const S of b) S.removeFeatureState(v, t.id, s)
                }

                getFeatureState(t) {
                    if (this._checkLoaded(), "target" in t) {
                        let g;
                        if ("featuresetId" in t.target) {
                            const {featuresetId: v, importId: b} = t.target, S = this.getFragmentStyle(b),
                                P = S.getFeaturesetLayers(v);
                            for (const {source: M, sourceLayer: k} of P) {
                                const R = S.getFeatureState({id: t.id, source: M, sourceLayer: k});
                                if (R && !g) g = R; else if (!o.bv(g, R)) return void this.fire(new o.z(new Error("The same feature id exists in multiple sources in the featureset, but their feature states are not consistent through the sources.")))
                            }
                        } else if ("layerId" in t.target) {
                            const {layerId: v} = t.target, b = this.getLayer(v);
                            g = this.getFeatureState({id: t.id, source: b.source, sourceLayer: b.sourceLayer})
                        }
                        return g
                    }
                    const s = t.source, h = t.sourceLayer, m = this._checkSource(s);
                    if (m) {
                        if (m.type !== "vector" || h) return t.id === void 0 && this.fire(new o.z(new Error("The feature id parameter must be provided."))), this.getOwnSourceCaches(s)[0].getFeatureState(h, t.id);
                        this.fire(new o.z(new Error("The sourceLayer parameter must be provided for vector source types.")))
                    }
                }

                setTransition(t) {
                    return this.stylesheet.transition = o.h({}, this.stylesheet.transition, t), this.transition = this.stylesheet.transition, this
                }

                getTransition() {
                    return o.h({}, this.stylesheet.transition)
                }

                serialize() {
                    this._checkLoaded();
                    const t = this.getTerrain(),
                        s = t && this.terrain && this.terrain.scope === this.scope ? t : this.stylesheet.terrain;
                    return o.dp({
                        version: this.stylesheet.version,
                        name: this.stylesheet.name,
                        metadata: this.stylesheet.metadata,
                        fragment: this.stylesheet.fragment,
                        iconsets: this.stylesheet.iconsets,
                        imports: this._serializeImports(),
                        schema: this.stylesheet.schema,
                        camera: this.stylesheet.camera,
                        light: this.stylesheet.light,
                        lights: this.stylesheet.lights,
                        terrain: s,
                        fog: this.stylesheet.fog,
                        snow: this.stylesheet.snow,
                        rain: this.stylesheet.rain,
                        center: this.stylesheet.center,
                        "color-theme": this.stylesheet["color-theme"],
                        zoom: this.stylesheet.zoom,
                        bearing: this.stylesheet.bearing,
                        pitch: this.stylesheet.pitch,
                        sprite: this.stylesheet.sprite,
                        glyphs: this.stylesheet.glyphs,
                        transition: this.stylesheet.transition,
                        projection: this.stylesheet.projection,
                        sources: this._serializeSources(),
                        layers: this._serializeLayers(this._order)
                    }, h => h !== void 0)
                }

                _updateFilteredLayers(t) {
                    for (const s of Object.values(this._mergedLayers)) t(s) && this._updateLayer(s)
                }

                _updateLayer(t) {
                    this._changes.updateLayer(t);
                    const s = this.getLayerSourceCache(t), h = o.C(t.source, t.scope),
                        m = this._changes.getUpdatedSourceCaches();
                    t.source && !m[h] && s && s.getSource().type !== "raster" && (this._changes.updateSourceCache(h, "reload"), s.pause()), t.invalidateCompiledFilter()
                }

                _flattenAndSortRenderedFeatures(t) {
                    const s = b => this._mergedLayers[b].is3D(!!this.terrain), h = this.order, m = {}, g = [];
                    for (let b = h.length - 1; b >= 0; b--) {
                        const S = h[b];
                        if (s(S)) {
                            m[S] = b;
                            for (const P of t) {
                                const M = P[S];
                                if (M) for (const k of M) g.push(k)
                            }
                        }
                    }
                    g.sort((b, S) => S.intersectionZ - b.intersectionZ);
                    const v = [];
                    for (let b = h.length - 1; b >= 0; b--) {
                        const S = h[b];
                        if (s(S)) for (let P = g.length - 1; P >= 0; P--) {
                            const M = g[P].feature;
                            if (M.layer && m[M.layer.id] < b) break;
                            v.push(M), g.pop()
                        } else for (const P of t) {
                            const M = P[S];
                            if (M) for (const k of M) v.push(k.feature)
                        }
                    }
                    return v
                }

                queryRenderedFeatures(t, s, h) {
                    let m;
                    s && !Array.isArray(s) && s.filter && (this._validate(Le, "queryRenderedFeatures.filter", s.filter, null, s), m = o.b3(s.filter));
                    const g = {}, v = M => {
                        if (xd.has(M.type)) return;
                        const k = this.getOwnLayerSourceCache(M),
                            R = g[k.id] = g[k.id] || {sourceCache: k, layers: {}, has3DLayers: !1};
                        M.is3D(!!this.terrain) && (R.has3DLayers = !0), R.layers[M.fqid] = R.layers[M.fqid] || {
                            styleLayer: M,
                            targets: []
                        }, R.layers[M.fqid].targets.push({filter: m})
                    };
                    if (s && s.layers) {
                        if (!Array.isArray(s.layers)) return this.fire(new o.z(new Error("parameters.layers must be an Array."))), [];
                        for (const M of s.layers) {
                            const k = this._layers[M];
                            if (!k) return this.fire(new o.z(new Error(`The layer '${M}' does not exist in the map's style and cannot be queried for features.`))), [];
                            v(k)
                        }
                    } else for (const M in this._layers) v(this._layers[M]);
                    const b = this._queryRenderedFeatures(t, g, h), S = this._flattenAndSortRenderedFeatures(b), P = [];
                    for (const M of S) o.dq(M.layer.id) === this.scope && P.push(M);
                    return P
                }

                queryRenderedFeatureset(t, s, h) {
                    let m;
                    s && !Array.isArray(s) && s.filter && (this._validate(Le, "queryRenderedFeatures.filter", s.filter, null, s), m = o.b3(s.filter));
                    const g = "mock", v = [];
                    if (s && s.target) v.push(Object.assign({}, s, {targetId: g, filter: m})); else {
                        const M = this.getFeaturesetDescriptors();
                        for (const k of M) v.push({targetId: g, filter: m, target: k});
                        for (const {style: k} of this.fragments) {
                            const R = k.getFeaturesetDescriptors();
                            for (const O of R) v.push({targetId: g, filter: m, target: O})
                        }
                    }
                    const b = this.queryRenderedTargets(t, v, h), S = [], P = new Set;
                    for (const M of b) for (const k of M.variants[g]) ud(k, M, P) || S.push(new o.dr(M, k));
                    return S
                }

                queryRenderedTargets(t, s, h) {
                    const m = {}, g = (b, S, P, M) => {
                        const k = m[S.id] = m[S.id] || {sourceCache: S, layers: {}, has3DLayers: !1};
                        if (k.layers[b.fqid] = k.layers[b.fqid] || {
                            styleLayer: b,
                            targets: []
                        }, b.is3D(!!this.terrain) && (k.has3DLayers = !0), !M) return P.uniqueFeatureID = !1, void k.layers[b.fqid].targets.push(P);
                        k.layers[b.fqid].targets.push(Object.assign({}, P, {
                            namespace: M.namespace,
                            properties: M.properties,
                            uniqueFeatureID: M.uniqueFeatureID
                        }))
                    };
                    for (const b of s) if ("featuresetId" in b.target) {
                        const {featuresetId: S, importId: P} = b.target, M = this.getFragmentStyle(P);
                        if (!M || !M._featuresetSelectors) continue;
                        const k = M._featuresetSelectors[S];
                        if (!k) {
                            this.fire(new o.z(new Error(`The featureset '${S}' does not exist in the map's style and cannot be queried for features.`)));
                            continue
                        }
                        for (const R of k) {
                            const O = M.getOwnLayer(R.layerId);
                            O && !xd.has(O.type) && g(O, M.getOwnLayerSourceCache(O), b, R)
                        }
                    } else if ("layerId" in b.target) {
                        const {layerId: S} = b.target, P = this.getLayer(S);
                        if (!P || xd.has(P.type)) continue;
                        g(P, this.getLayerSourceCache(P), b)
                    }
                    const v = this._queryRenderedFeatures(t, m, h);
                    return this._flattenAndSortRenderedFeatures(v)
                }

                _queryRenderedFeatures(t, s, h) {
                    const m = [], g = !!this.map._showQueryGeometry, v = Zi.createFromScreenPoints(t, h);
                    for (const b in s) {
                        const S = hd(v, s[b], this._availableImages, h, g);
                        Object.keys(S).length && m.push(S)
                    }
                    if (this.placement) for (const b in s) {
                        if (!s[b].sourceCache._onlySymbols) continue;
                        const S = Rl(v.screenGeometry, s[b], this._availableImages, this.placement.collisionIndex, this.placement.retainedQueryData, this.map.getWorldview());
                        Object.keys(S).length && m.push(S)
                    }
                    return m
                }

                querySourceFeatures(t, s) {
                    const h = s && s.filter;
                    h && this._validate(Le, "querySourceFeatures.filter", h, null, s);
                    let m = [];
                    const g = this.getOwnSourceCaches(t);
                    for (const v of g) m = m.concat(qu(v, s));
                    return m
                }

                addSourceType(t, s, h) {
                    return xs.getSourceType(t) ? h(new Error(`A source type called "${t}" already exists.`)) : (xs.setSourceType(t, s), s.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {
                        name: t,
                        url: s.workerSourceURL
                    }, h) : h(null, null))
                }

                getFlatLight() {
                    return this.light.getLight()
                }

                setFlatLight(t, s, h = {}) {
                    this._checkLoaded();
                    const m = this.light.getLight();
                    let g = !1;
                    for (const b in t) if (!o.bv(t[b], m[b])) {
                        g = !0;
                        break
                    }
                    if (!g) return;
                    const v = this._getTransitionParameters();
                    this.light.setLight(t, s, h), this.light.updateTransitions(v)
                }

                getTerrain() {
                    return this.terrain && this.terrain.drapeRenderMode === 1 ? this.terrain.get() : null
                }

                setTerrainForDraping() {
                    this.setTerrain({source: "", exaggeration: 0}, 0)
                }

                checkCanvasFingerprintNoise() {
                    this.disableElevatedTerrain === void 0 && (this.disableElevatedTerrain = o.q.hasCanvasFingerprintNoise(), this.disableElevatedTerrain && o.w("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode)."))
                }

                setTerrain(t, s = 1) {
                    if (this._checkLoaded(), !t) return this.terrainSetForDrapingOnly() || (delete this.terrain, this.map.transform.projection.requiresDraping && this.setTerrainForDraping()), s === 0 && delete this.terrain, t === null ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);
                    this.checkCanvasFingerprintNoise();
                    let h = t;
                    const m = t.source == null;
                    if (s === 1) {
                        if (this.disableElevatedTerrain) return;
                        if (typeof h.source == "object") {
                            const b = "terrain-dem-src";
                            this.addSource(b, h.source), h = o.di(h), h = o.h(h, {source: b})
                        }
                        const g = o.h({}, h), v = {};
                        if (this.terrain && m) {
                            g.source = this.terrain.get().source;
                            const b = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
                            b && (v.style = b.serialize())
                        }
                        if (this._validate(Ze, "terrain", g, v)) return
                    }
                    if (!this.terrain || this.terrain.scope !== this.scope && !m || this.terrain && s !== this.terrain.drapeRenderMode) {
                        if (!h) return;
                        this._createTerrain(h, s), this.fire(new o.A("data", {dataType: "style"}))
                    } else {
                        const g = this.terrain, v = g.get();
                        for (const b of Object.keys(o.a5.terrain)) !h.hasOwnProperty(b) && o.a5.terrain[b].default && (h[b] = o.a5.terrain[b].default);
                        for (const b in t) if (!o.bv(t[b], v[b])) {
                            g.set(t, this.options), this.stylesheet.terrain = t;
                            const S = this._getTransitionParameters({duration: 0});
                            g.updateTransitions(S), this.fire(new o.A("data", {dataType: "style"}));
                            break
                        }
                    }
                    this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = !0
                }

                _createFog(t) {
                    const s = this.fog = new Ti(t, this.map.transform, this.scope, this.options);
                    this.stylesheet.fog = s.get();
                    const h = this._getTransitionParameters({duration: 0});
                    s.updateTransitions(h)
                }

                _createSnow(t) {
                    const s = this.snow = new mr(t, this.map.transform, this.scope, this.options);
                    this.stylesheet.snow = s.get();
                    const h = this._getTransitionParameters({duration: 0});
                    s.updateTransitions(h)
                }

                _createRain(t) {
                    const s = this.rain = new lr(t, this.map.transform, this.scope, this.options);
                    this.stylesheet.rain = s.get();
                    const h = this._getTransitionParameters({duration: 0});
                    s.updateTransitions(h)
                }

                _updateMarkersOpacity() {
                    this.map._markers.length !== 0 && this.map._requestDomTask(() => {
                        for (const t of this.map._markers) t._evaluateOpacity()
                    })
                }

                getFog() {
                    return this.fog ? this.fog.get() : null
                }

                setFog(t) {
                    if (this._checkLoaded(), !t) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);
                    if (this.fog) {
                        const s = this.fog;
                        if (!o.bv(s.get(), t)) {
                            s.set(t, this.options), this.stylesheet.fog = s.get();
                            const h = this._getTransitionParameters({duration: 0});
                            s.updateTransitions(h)
                        }
                    } else this._createFog(t);
                    this._markersNeedUpdate = !0
                }

                getSnow() {
                    return this.snow ? this.snow.get() : null
                }

                setSnow(t) {
                    if (this._checkLoaded(), !t) return delete this.snow, void delete this.stylesheet.snow;
                    if (this.snow) {
                        const s = this.snow;
                        if (!o.bv(s.get(), t)) {
                            s.set(t, this.options), this.stylesheet.snow = s.get();
                            const h = this._getTransitionParameters({duration: 0});
                            s.updateTransitions(h)
                        }
                    } else this._createSnow(t);
                    this._markersNeedUpdate = !0
                }

                getRain() {
                    return this.rain ? this.rain.get() : null
                }

                setRain(t) {
                    if (this._checkLoaded(), !t) return delete this.rain, void delete this.stylesheet.rain;
                    if (this.rain) {
                        const s = this.rain;
                        if (!o.bv(s.get(), t)) {
                            s.set(t, this.options), this.stylesheet.rain = s.get();
                            const h = this._getTransitionParameters({duration: 0});
                            s.updateTransitions(h)
                        }
                    } else this._createRain(t);
                    this._markersNeedUpdate = !0
                }

                _reloadColorTheme() {
                    const t = () => {
                            for (const m in this._layers) this._layers[m].lut = this._styleColorTheme.lut;
                            for (const m in this._sourceCaches) this._sourceCaches[m].clearTiles()
                        },
                        s = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
                    if (!s) return this._styleColorTheme.lut = null, void t();
                    const h = this._evaluateColorThemeData(s);
                    this._loadColorTheme(h).then(() => {
                        this.fire(new o.A("colorthemeset")), t()
                    }).catch(m => {
                        o.w(`Couldn't set color theme: ${m}`)
                    })
                }

                setColorTheme(t) {
                    this._checkLoaded(), this._styleColorTheme.colorThemeOverride && o.w("Note: setColorTheme is called on a style with a color-theme override, the passed color-theme won't be visible."), this._styleColorTheme.colorTheme = t, this._reloadColorTheme()
                }

                setImportColorTheme(t, s) {
                    const h = this.getFragmentStyle(t);
                    h && (h._styleColorTheme.colorThemeOverride = s, h._reloadColorTheme())
                }

                _getTransitionParameters(t) {
                    return {now: o.q.now(), transition: o.h(this.transition, t)}
                }

                updateDrapeFirstLayers() {
                    if (!this.terrain) return;
                    const t = [], s = [];
                    for (const h of this._mergedOrder) this.isLayerDraped(this._mergedLayers[h]) ? t.push(h) : s.push(h);
                    this._drapedFirstOrder = [], this._drapedFirstOrder.push(...t), this._drapedFirstOrder.push(...s)
                }

                _createTerrain(t, s) {
                    const h = this.terrain = new Pe(t, s, this.scope, this.options, this.map.getWorldview());
                    s === 1 && (this.stylesheet.terrain = t), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();
                    const m = this._getTransitionParameters({duration: 0});
                    h.updateTransitions(m)
                }

                _force3DLayerUpdate() {
                    for (const t in this._layers) {
                        const s = this._layers[t];
                        s.type === "fill-extrusion" && this._updateLayer(s)
                    }
                }

                _forceSymbolLayerUpdate() {
                    for (const t in this._layers) {
                        const s = this._layers[t];
                        s.type === "symbol" && this._updateLayer(s)
                    }
                }

                _validate(t, s, h, m, g = {}) {
                    if (g && g.validate === !1) return !1;
                    const v = o.h({}, this.serialize());
                    return Qa(this, t.call(To, o.h({key: s, style: v, value: h, styleSpec: o.a5}, m)))
                }

                _remove() {
                    this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), o.ds.off("pluginStateChange", this._rtlTextPluginCallback);
                    for (const t in this._mergedLayers) this._mergedLayers[t].setEventedParent(null);
                    for (const t in this._mergedSourceCaches) this._mergedSourceCaches[t].clearTiles(), this._mergedSourceCaches[t].setEventedParent(null);
                    this.imageManager.removeScope(this.scope), this.setEventedParent(null), delete this.fog, delete this.snow, delete this.rain, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.imageManager.destroy(), this.modelManager.setEventedParent(null), this.modelManager.destroy(), this.dispatcher.remove())
                }

                clearSource(t) {
                    const s = this.getSourceCaches(t);
                    for (const h of s) h.clearTiles()
                }

                clearSources() {
                    for (const t in this._mergedSourceCaches) this._mergedSourceCaches[t].clearTiles()
                }

                clearLayers() {
                    for (const t in this._mergedLayers) {
                        const s = this._mergedLayers[t];
                        s._clear && s._clear()
                    }
                }

                reloadSource(t) {
                    const s = this.getSourceCaches(t);
                    for (const h of s) h.resume(), h.reload()
                }

                reloadSources() {
                    for (const t of this.getSources()) t.reload && t.reload()
                }

                reloadModels() {
                    this.modelManager.reloadModels(""), this.forEachFragmentStyle(t => {
                        t.modelManager.reloadModels(t.scope)
                    })
                }

                updateSources(t) {
                    let s;
                    this.directionalLight && (s = Ac(this.directionalLight));
                    const h = new Set;
                    for (const m in this._mergedLayers) {
                        const g = this._mergedLayers[m];
                        g.hasElevation() && !h.has(g.source) && h.add(g.source)
                    }
                    for (const m in this._mergedSourceCaches) {
                        const g = this._mergedSourceCaches[m], v = h.has(g._source.id);
                        g.update(t, void 0, void 0, s, v)
                    }
                }

                _generateCollisionBoxes() {
                    for (const t in this._sourceCaches) {
                        const s = this._sourceCaches[t];
                        s.resume(), s.reload()
                    }
                }

                _updatePlacement(t, s, h, m, g, v, b = !1) {
                    let S = !1, P = !1;
                    const M = {}, k = {};
                    for (const R of this._mergedOrder) {
                        const O = this._mergedLayers[R];
                        if (O.type !== "symbol") continue;
                        const V = o.C(O.source, O.scope);
                        let B = M[V];
                        if (!B) {
                            const U = this.getLayerSourceCache(O);
                            if (!U) continue;
                            const Z = U.getRenderableIds(!0).map(Q => U.getTileByID(Q));
                            k[V] = Z.slice(), B = M[V] = Z.sort((Q, te) => te.tileID.overscaledZ - Q.tileID.overscaledZ || (Q.tileID.isLessThan(te.tileID) ? -1 : 1))
                        }
                        const G = this.crossTileSymbolIndex.addLayer(O, B, s.center.lng, s.projection);
                        S = S || G
                    }
                    if (this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), b = b || this._layerOrderChanged || m === 0, this._layerOrderChanged && this.fire(new o.A("neworder")), (b || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(o.q.now(), s.zoom)) && (this.pauseablePlacement = new _d(s, this._mergedOrder, b, h, m, g, this.placement, this.fog && s.projection.supportsFog ? this.fog.state : null, this._buildingIndex), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, M, k, this.map.painter.scaleFactor), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(o.q.now()), P = !0), S && this.pauseablePlacement.placement.setStale()), P || S) {
                        this._buildingIndex.onNewFrame(s.zoom);
                        for (let R = 0; R < this._mergedOrder.length; R++) {
                            const O = this._mergedLayers[this._mergedOrder[R]];
                            if (O.type !== "symbol") continue;
                            const V = this.isLayerClipped(O);
                            this.placement.updateLayerOpacities(O, M[o.C(O.source, O.scope)], R, V ? v : null)
                        }
                    }
                    return {needsRerender: !this.pauseablePlacement.isDone() || this.placement.hasTransitions(o.q.now())}
                }

                _releaseSymbolFadeTiles() {
                    for (const t in this._sourceCaches) this._sourceCaches[t].releaseSymbolFadeTiles()
                }

                addImport(t, s) {
                    this._checkLoaded();
                    const h = this.stylesheet.imports = this.stylesheet.imports || [];
                    if (h.findIndex(({id: g}) => g === t.id) !== -1) return void this.fire(new o.z(new Error(`Import with id '${t.id}' already exists in the map's style.`)));
                    if (!s) return h.push(t), this._loadImports([t], !0);
                    const m = h.findIndex(({id: g}) => g === s);
                    return m === -1 && this.fire(new o.z(new Error(`Import with id "${s}" does not exist on this map.`))), this.stylesheet.imports = h.slice(0, m).concat(t).concat(h.slice(m)), this._loadImports([t], !0, s)
                }

                updateImport(t, s) {
                    this._checkLoaded();
                    const h = this.stylesheet.imports || [], m = this.getImportIndex(t);
                    return m === -1 ? this : typeof s == "string" ? (this.setImportUrl(t, s), this) : (s.url && s.url !== h[m].url && this.setImportUrl(t, s.url), o.bv(s.config, h[m].config) || this.setImportConfig(t, s.config, s.data.schema), o.bv(s.data, h[m].data) || this.setImportData(t, s.data), this)
                }

                moveImport(t, s) {
                    this._checkLoaded();
                    let h = this.stylesheet.imports || [];
                    const m = this.getImportIndex(t);
                    if (m === -1) return this;
                    const g = this.getImportIndex(s);
                    if (g === -1) return this;
                    const v = h[m], b = this.fragments[m];
                    return h = h.filter(({id: S}) => S !== t), this.fragments = this.fragments.filter(({id: S}) => S !== t), this.stylesheet.imports = h.slice(0, g).concat(v).concat(h.slice(g)), this.fragments = this.fragments.slice(0, g).concat(b).concat(this.fragments.slice(g)), this.mergeLayers(), this
                }

                setImportUrl(t, s) {
                    this._checkLoaded();
                    const h = this.stylesheet.imports || [], m = this.getImportIndex(t);
                    if (m === -1) return this;
                    h[m].url = s;
                    const g = this.fragments[m];
                    return g.style = this._createFragmentStyle(h[m]), g.style.on("style.import.load", () => this.mergeAll()), g.style.loadURL(s), this
                }

                setImportData(t, s) {
                    this._checkLoaded();
                    const h = this.getImportIndex(t), m = this.stylesheet.imports || [];
                    return h === -1 ? this : s ? (this.fragments[h].style.setState(s), this._reloadImports(), this) : (delete m[h].data, this.setImportUrl(t, m[h].url))
                }

                setImportConfig(t, s, h) {
                    this._checkLoaded();
                    const m = this.getImportIndex(t), g = this.stylesheet.imports || [];
                    if (m === -1) return this;
                    s ? g[m].config = s : delete g[m].config;
                    const v = this.fragments[m];
                    h && v.style.stylesheet && (v.style.stylesheet.schema = h);
                    const b = v.style.stylesheet && v.style.stylesheet.schema;
                    return v.config = s, v.style.updateConfig(s, b), this.updateConfigDependencies(), this
                }

                removeImport(t) {
                    this._checkLoaded();
                    const s = this.stylesheet.imports || [], h = this.getImportIndex(t);
                    h !== -1 && (s.splice(h, 1), this.fragments[h].style._remove(), this.fragments.splice(h, 1), this._reloadImports())
                }

                getImportIndex(t) {
                    const s = (this.stylesheet.imports || []).findIndex(h => h.id === t);
                    return s === -1 && this.fire(new o.z(new Error(`Import '${t}' does not exist in the map's style and cannot be updated.`))), s
                }

                getLayer(t) {
                    return this._mergedLayers[t]
                }

                getSources() {
                    const t = [];
                    for (const s in this._mergedOtherSourceCaches) {
                        const h = this._mergedOtherSourceCaches[s];
                        h && t.push(h.getSource())
                    }
                    return t
                }

                getSource(t, s) {
                    const h = this.getSourceCache(t, s);
                    return h && h.getSource()
                }

                getLayerSource(t) {
                    const s = this.getLayerSourceCache(t);
                    return s && s.getSource()
                }

                getSourceCache(t, s) {
                    const h = o.C(t, s);
                    return this._mergedOtherSourceCaches[h]
                }

                getLayerSourceCache(t) {
                    const s = o.C(t.source, t.scope);
                    return t.type === "symbol" ? this._mergedSymbolSourceCaches[s] : this._mergedOtherSourceCaches[s]
                }

                getSourceCaches(t) {
                    if (t == null) return Object.values(this._mergedSourceCaches);
                    const s = [];
                    return this._mergedOtherSourceCaches[t] && s.push(this._mergedOtherSourceCaches[t]), this._mergedSymbolSourceCaches[t] && s.push(this._mergedSymbolSourceCaches[t]), s
                }

                updateSourceCaches() {
                    const t = this._changes.getUpdatedSourceCaches();
                    for (const s in t) {
                        const h = t[s];
                        h === "reload" ? this.reloadSource(s) : h === "clear" && this.clearSource(s)
                    }
                }

                updateLayers(t) {
                    const s = this._changes.getUpdatedPaintProperties();
                    for (const h of s) {
                        const m = this.getLayer(h);
                        m && m.updateTransitions(t)
                    }
                }

                getGlyphsUrl() {
                    return this.stylesheet.glyphs
                }

                setGlyphsUrl(t) {
                    this.stylesheet.glyphs = t, this.glyphManager.setURL(t)
                }

                getImages(t, s, h) {
                    this.imageManager.getImages(s.images, s.scope, h), this._updateTilesForChangedImages();
                    const m = v => {
                        if (v) {
                            const b = s.images.map(S => o.I.toString(S));
                            v.setDependencies(s.tileID.key, s.type, b)
                        }
                    }, g = o.C(s.source, s.scope);
                    m(this._mergedOtherSourceCaches[g]), m(this._mergedSymbolSourceCaches[g]), s.images.some(v => v.iconsetId) && this.fire(new o.A("data", {dataType: "style"}))
                }

                rasterizeImages(t, s, h) {
                    this.imageManager.rasterizeImages(s, h)
                }

                getGlyphs(t, s, h) {
                    this.glyphManager.getGlyphs(s.stacks, h)
                }

                getResource(t, s, h) {
                    return o.dt(s, h)
                }

                getOwnSourceCache(t) {
                    return this._otherSourceCaches[t]
                }

                getOwnLayerSourceCache(t) {
                    return t.type === "symbol" ? this._symbolSourceCaches[t.source] : this._otherSourceCaches[t.source]
                }

                getOwnSourceCaches(t) {
                    const s = [];
                    return this._otherSourceCaches[t] && s.push(this._otherSourceCaches[t]), this._symbolSourceCaches[t] && s.push(this._symbolSourceCaches[t]), s
                }

                _isSourceCacheLoaded(t) {
                    const s = this.getOwnSourceCaches(t);
                    return s.length === 0 ? (this.fire(new o.z(new Error(`There is no source with ID '${t}'`))), !1) : s.every(h => h.loaded())
                }

                has3DLayers() {
                    return this._has3DLayers
                }

                hasSymbolLayers() {
                    return this._hasSymbolLayers
                }

                hasCircleLayers() {
                    return this._hasCircleLayers
                }

                isLayerClipped(t, s) {
                    if (!this._clipLayerPresent && t.type !== "fill-extrusion" && t.type !== "building") return !1;
                    const h = t.type === "fill-extrusion" && (t.sourceLayer === "building" || t.sourceLayer === "procedural_buildings"),
                        m = t.type === "building";
                    if (t.is3D(!!this.terrain)) {
                        if (h || m || s && s.type === "batched-model" || t.type === "model") return !0
                    } else if (t.type === "symbol") return !0;
                    return !1
                }

                _clearWorkerCaches() {
                    this.dispatcher.broadcast("clearCaches")
                }

                destroy() {
                    this._clearWorkerCaches(), this.fragments.forEach(t => {
                        t.style._remove()
                    }), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain)
                }
            }

            xs.getSourceType = function (u) {
                return cd[u]
            }, xs.setSourceType = function (u, t) {
                cd[u] = t
            }, xs.registerForPluginStateChange = o.du;
            var Np = `
#define EPSILON 0.0000001
#define PI 3.141592653589793
#ifdef RENDER_CUTOFF
float cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}
#endif`, Cc = `
out vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}
#ifdef INDICATOR_CUTOUT
uniform vec3 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;
#endif
vec4 applyCutout(vec4 color,float height) {
#ifdef INDICATOR_CUTOUT
float verticalFadeRange=u_indicator_cutout_centers.z*0.25;float holeMinOpacity=mix(1.0,u_indicator_cutout_params.x,smoothstep(u_indicator_cutout_centers.z,u_indicator_cutout_centers.z+verticalFadeRange,height));float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);
#else
return color;
#endif
}
#ifdef DEBUG_WIREFRAME
#define HANDLE_WIREFRAME_DEBUG \\
glFragColor=vec4(0.7,0.0,0.0,0.7); \\
gl_FragDepth=gl_FragCoord.z-0.0001;
#else
#define HANDLE_WIREFRAME_DEBUG
#endif
#ifdef RENDER_CUTOFF
uniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;
#endif
vec4 textureLodCustom(sampler2D image,highp vec2 pos,highp vec2 lod_coord) {highp vec2 size=vec2(textureSize(image,0));highp vec2 dx=dFdx(lod_coord.xy*size);highp vec2 dy=dFdy(lod_coord.xy*size);highp float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));highp float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}vec4 applyLUT(highp sampler3D lut,vec4 col) {vec3 size=vec3(textureSize(lut,0));vec3 uvw=(col.rbg*float(size-1.0)+0.5)/size;return vec4(texture(lut,uvw).rgb,col.a);}vec3 applyLUT(highp sampler3D lut,vec3 col) {return applyLUT(lut,vec4(col,1.0)).rgb;}`,
                Pc = `
#define EXTENT 8192.0
#define RAD_TO_DEG 180.0/PI
#define DEG_TO_RAD PI/180.0
#define GLOBE_RADIUS EXTENT/PI/2.0
float wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}
#ifdef PROJECTION_GLOBE_VIEW
vec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {
#ifndef PROJECTED_POS_ON_VIEWPORT
float tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;
#else
return vec3(0.0);
#endif
}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(
unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const vec2 units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (units_to_pixels*pos+offset)/pattern_size;}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {return get_pattern_pos(pixel_coord_upper,pixel_coord_lower,pattern_size,vec2(tile_units_to_pixels),pos);}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}
#ifdef RENDER_CUTOFF
uniform vec4 u_cutoff_params;out float v_cutoff_opacity;
#endif
const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)
{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}`,
                jp = "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}",
                wd = `
#define ELEVATION_SCALE 7.0
#define ELEVATION_OFFSET 450.0
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(
mix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}
#else
vec3 elevationVector(vec2 pos) { return vec3(0,0,1); }
#endif
#ifdef TERRAIN
uniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
vec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;
#else
float dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);
#endif
}float prevElevation(vec2 apos) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
vec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;
#else
float dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);
#endif
}
#ifdef TERRAIN_VERTEX_MORPHING
float elevation(vec2 apos) {
#ifdef ZERO_EXAGGERATION
return 0.0;
#endif
float nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}
#else
float elevation(vec2 apos) {
#ifdef ZERO_EXAGGERATION
return 0.0;
#endif
return currentElevation(apos);}
#endif
vec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}
#else
float elevation(vec2 pos) { return 0.0; }
#endif
#ifdef DEPTH_OCCLUSION
uniform highp sampler2D u_depth;uniform highp vec2 u_depth_size_inv;uniform highp vec2 u_depth_range_unpack;uniform highp float u_occluder_half_size;uniform highp float u_occlusion_depth_offset;
#ifdef DEPTH_D24
float unpack_depth(float depth) {return depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}vec4 unpack_depth4(vec4 depth) {return depth*u_depth_range_unpack.x+vec4(u_depth_range_unpack.y);}
#else
highp float unpack_depth_rgba(vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}
#endif
bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;
#ifdef DEPTH_D24
float depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5).r);
#else
float depth=unpack_depth_rgba(texture(u_depth,(coord.xy+1.0)*0.5));
#endif
return coord.z+u_occlusion_depth_offset > depth;}highp vec4 getCornerDepths(vec2 coord) {highp vec3 df=vec3(u_occluder_half_size*u_depth_size_inv,0.0);highp vec2 uv=0.5*coord.xy+0.5;
#ifdef DEPTH_D24
highp vec4 depth=vec4(
texture(u_depth,uv-df.xz).r,texture(u_depth,uv+df.xz).r,texture(u_depth,uv-df.zy).r,texture(u_depth,uv+df.zy).r
);depth=unpack_depth4(depth);
#else
highp vec4 depth=vec4(
unpack_depth_rgba(texture(u_depth,uv-df.xz)),unpack_depth_rgba(texture(u_depth,uv+df.xz)),unpack_depth_rgba(texture(u_depth,uv-df.zy)),unpack_depth_rgba(texture(u_depth,uv+df.zy))
);
#endif
return depth;}highp float occlusionFadeMultiSample(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec2 uv=0.5*coord.xy+0.5;int NX=3;int NY=4;highp vec2 df=u_occluder_half_size*u_depth_size_inv;highp vec2 oneStep=2.0*u_occluder_half_size*u_depth_size_inv/vec2(NX-1,NY-1);highp float res=0.0;for (int y=0; y < NY;++y) {for (int x=0; x < NX;++x) {
#ifdef DEPTH_D24
highp float depth=unpack_depth(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)).r);
#else
highp float depth=unpack_depth_rgba(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)));
#endif
res+=1.0-clamp(300.0*(coord.z+u_occlusion_depth_offset-depth),0.0,1.0);}}res=clamp(2.0*res/float(NX*NY)-0.5,0.0,1.0);return res;}highp float occlusionFade(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec4 depth=getCornerDepths(coord.xy);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z+u_occlusion_depth_offset)-depth),0.0,1.0));}
#else
bool isOccluded(vec4 frag) { return false; }highp float occlusionFade(vec4 frag) { return 1.0; }highp float occlusionFadeMultiSample(vec4 frag) { return 1.0; }
#endif//DEPTH_OCCLUSION`, Ko = `#ifdef FOG
uniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}
#endif`, bd = `#ifdef FOG
uniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;
#ifdef FLIP_Y
uv.y=1.0-uv.y;
#endif
highp vec3 ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {return color;}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}
#endif`, yt = `#ifdef RASTER_ARRAY
uniform highp sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)
);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)
);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}
#endif`, Vp = `#ifdef RASTER_ARRAY
uniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec2 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=u_data_offset+vec2(dot(t.rg,u_data_scale),dot(t.ba,u_data_scale));velocity.y=-velocity.y;velocity/=max(u_max_speed,length(velocity));return velocity;}
#endif
uniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}`,
                Td = `#ifdef RENDER_SHADOWS
uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {vec3 transformed_normal=vec3(-normal.xy,normal.z);float NDotL=dot(normalize(transformed_normal),u_shadow_direction);float dotScale=min(1.0-NDotL,1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}
#endif//RENDER_SHADOWS`, Sd = `#ifdef RENDER_SHADOWS
precision highp sampler2DShadow;uniform sampler2DShadow u_shadowmap_0;uniform sampler2DShadow u_shadowmap_1;uniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;float shadow_sample(sampler2DShadow shadowmap,highp vec3 pos,highp float bias) {
#ifdef CLIP_ZERO_TO_ONE
highp vec3 coord=vec3(pos.xy*0.5+0.5,pos.z-bias);
#else
highp vec3 coord=vec3(pos.xy*0.5+0.5,pos.z*0.5+0.5-bias);
#endif
return texture(shadowmap,coord);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {light_view_pos0.xyz/=light_view_pos0.w;
#ifdef SHADOWS_SINGLE_CASCADE
vec2 abs_bounds=abs(light_view_pos0.xy);if (abs_bounds.x >=1.0 || abs_bounds.y >=1.0) {return 0.0;}return shadow_sample(u_shadowmap_0,light_view_pos0.xyz,bias);
#else
light_view_pos1.xyz/=light_view_pos1.w;vec4 abs_bounds=abs(vec4(light_view_pos0.xy,light_view_pos1.xy));if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {return shadow_sample(u_shadowmap_0,light_view_pos0.xyz,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}float occlusion1=shadow_sample(u_shadowmap_1,light_view_pos1.xyz,bias);return clamp(mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth)),0.0,1.0);
#endif
}highp float calculate_shadow_bias(float NDotL) {
#ifdef NORMAL_OFFSET
return 0.5*u_shadow_bias.x;
#else
return 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));
#endif
}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_opacity(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,float shadow_opacity) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias)*shadow_opacity;return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}highp vec2 compute_receiver_plane_depth_bias(highp vec3 pos_dx,highp vec3 pos_dy)
{highp vec2 biasUV=vec2(
pos_dy.y*pos_dx.z-pos_dx.y*pos_dy.z,pos_dx.x*pos_dy.z-pos_dy.x*pos_dx.z);biasUV*=1.0/((pos_dx.x*pos_dy.y)-(pos_dx.y*pos_dy.x));return biasUV;}float shadowed_light_factor_plane_bias(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {highp vec3 light_view_pos0_xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;highp vec3 light_view_pos0_ddx=dFdx(light_view_pos0_xyz);highp vec3 light_view_pos0_ddy=dFdy(light_view_pos0_xyz);highp vec2 plane_depth_bias=compute_receiver_plane_depth_bias(light_view_pos0_ddx,light_view_pos0_ddy);highp float bias=dot(vec2(u_shadow_texel_size,u_shadow_texel_size),plane_depth_bias)+0.0001;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}
#endif`;
            const hh = [];
            Fs(Np, hh), Fs(Pc, hh), Fs(Cc, hh);
            const jl = {
                "_prelude_fog.vertex.glsl": Ko,
                "_prelude_terrain.vertex.glsl": wd,
                "_prelude_shadow.vertex.glsl": Td,
                "_prelude_fog.fragment.glsl": bd,
                "_prelude_shadow.fragment.glsl": Sd,
                "_prelude_lighting.glsl": `
#ifdef LIGHTING_3D_MODE
uniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}
#endif//LIGHTING_3D_MODE`,
                "_prelude_raster_array.glsl": yt,
                "_prelude_raster_particle.glsl": Vp
            }, ws = {};
            Oi("", wd), Oi(bd, Ko), Oi(Sd, Td), Oi(yt, ""), Oi(Vp, "");
            const Ed = Oi(Cc, Pc), el = Np;
            var dh = {
                background: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec4 u_color;uniform float u_opacity;
#ifdef LIGHTING_3D_MODE
in vec4 v_color;
#endif
void main() {vec4 out_color;
#ifdef LIGHTING_3D_MODE
out_color=v_color;
#else
out_color=u_color;
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_lighting.glsl"
in vec2 a_pos;uniform mat4 u_matrix;
#ifdef LIGHTING_3D_MODE
uniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;
#endif
void main() {gl_Position=u_matrix*vec4(a_pos,0,1);
#ifdef LIGHTING_3D_MODE
v_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`),
                backgroundPattern: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in highp vec2 v_pos;void main() {highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec2 u_pattern_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_pattern_units_to_pixels,a_pos);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`),
                building: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
const float window_depth=0.5;const float ao_radius=0.2;in vec4 v_color;in highp vec3 v_normal;in highp vec3 v_pos;
#ifdef BUILDING_FAUX_FACADE
in lowp float v_faux_facade;in highp float v_faux_facade_ed;in highp vec2 v_faux_facade_window;in highp vec2 v_faux_facade_floor;in highp vec2 v_faux_facade_range;in highp float v_aspect;in highp vec3 v_tbn_0;in highp vec3 v_tbn_1;in highp vec3 v_tbn_2;in highp vec4 v_faux_color_emissive;uniform float u_faux_facade_ao_intensity;
#endif
#ifdef RENDER_SHADOWS
in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;
#endif
uniform lowp float u_opacity;uniform vec3 u_camera_pos;uniform highp float u_tile_to_meter;uniform float u_facade_emissive_chance;vec3 linearTosRGB(in vec3 color) {return pow(color,vec3(1./2.2));}
#ifdef BUILDING_FAUX_FACADE
float hash12(in vec2 p) {vec3 p3 =fract(vec3(p.xyx)*0.1031);p3+=dot(p3,p3.yzx+33.33);return fract((p3.x+p3.y)*p3.z);}float min3(in vec3 v) {return min(min(v.x,v.y),v.z);}vec2 get_uv_mask_id(in vec2 q,out float mask,out vec2 id) {vec2 p=q;mask=step(v_faux_facade_range.x,p.y)*step(p.y,v_faux_facade_range.y);p.y=p.y-v_faux_facade_range.x;vec2 uv=modf(p/v_faux_facade_floor,id);vec4 d=(v_faux_facade_floor.xyxy+vec4(-v_faux_facade_window,v_faux_facade_window))*0.5;vec4 edge=d/v_faux_facade_floor.xyxy;vec2 m=step(edge.xy,uv)*step(uv,edge.zw);mask*=m.x*m.y;uv-=vec2(0.5);uv*=vec2(0.5)/(vec2(0.5)-edge.xy);uv+=vec2(0.5);return uv;}float ray_unit_box(in vec3 ray_o,in vec3 ray_d,in vec3 bmin,in vec3 bmax) {vec3 planes=mix(bmin,bmax,step(0.0,ray_d));vec3 t=(planes-ray_o)/ray_d;return min3(t);}float get_emissive(in vec2 id) {if (u_facade_emissive_chance > 0.0) {return (step(hash12(id),u_facade_emissive_chance)+0.05)*v_faux_color_emissive.a;}return 0.0;}vec3 get_shade_info(in vec3 v,in vec3 v_normalized,in vec3 color,in vec2 id,in mat3 tbn,inout vec3 out_normal,inout float out_emissive) {vec3 out_color=color;vec3 abs_v=abs(v_normalized);bool x_major=abs_v.x >=abs_v.y && abs_v.x >=abs_v.z;bool y_major=abs_v.y >=abs_v.x && abs_v.y >=abs_v.z;bool z_major=abs_v.z >=abs_v.x && abs_v.z >=abs_v.y;
#if 0
if (x_major) {out_color=v.x > 0.0 ? vec3(1.0,0.0,0.0) : vec3(0.0,1.0,1.0);} else if (y_major) {out_color=v.y > 0.0 ? vec3(0.0,1.0,0.0) : vec3(1.0,0.0,1.0);} else if (z_major) {out_color=v.z > 0.0 ? vec3(0.0,0.0,1.0) : vec3(1.0,1.0,0.0);}out_emissive=1.0;
#else
if (x_major) {out_normal=sign(v.x)*tbn[0];} else if (y_major) {out_normal=vec3(0.0,0.0,-sign(v.y));} else if (z_major) {out_color=v_faux_color_emissive.rgb;out_emissive=v.z <=0.0 ? get_emissive(id) : out_emissive;}float ao=1.0;if (u_faux_facade_ao_intensity > 0.0) {vec4 ao_range=v_faux_facade_window.xxyy*0.5-vec4(0,ao_radius,0,ao_radius);vec2 ao_range_z=vec2(window_depth*0.5)-vec2(0.0,ao_radius);if (x_major || y_major) {ao*=smoothstep(-ao_range_z.x,-ao_range_z.y,v.z);} else if (z_major) {ao*=smoothstep(-ao_range.x,-ao_range.y,v.x)*(1.0-smoothstep(ao_range.y,ao_range.x,v.x));ao*=smoothstep(-ao_range.z,-ao_range.w,v.y)*(1.0-smoothstep(ao_range.w,ao_range.z,v.y));}ao=mix(1.0,min(1.0,ao+0.25),u_faux_facade_ao_intensity);}out_color*=ao;
#endif
return out_color;}
#endif
vec3 apply_lighting_linear(in vec3 color,in vec3 normal,in float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return color*(ambient_contrib+directional_contrib);}void main() {vec3 normal=normalize(v_normal);vec3 base_color=v_color.rgb;float emissive=v_color.a;
#ifdef BUILDING_FAUX_FACADE
if (v_faux_facade > 0.0) {mat3 tbn=mat3(v_tbn_0,v_tbn_1,v_tbn_2);vec3 v=vec3(v_pos.xy,v_pos.z/u_tile_to_meter)-u_camera_pos;vec3 view_tangent=transpose(tbn)*v;vec2 q=vec2(v_faux_facade_ed,v_pos.z);float mask=0.0;vec2 id=vec2(0.0);vec2 uv=get_uv_mask_id(q,mask,id);uv*=v_faux_facade_window;vec3 bmin=vec3(0.0,0.0,-window_depth);vec3 bmax=bmin+vec3(v_faux_facade_window,window_depth);vec3 ray_o=vec3(uv,0.0);vec3 ray_d=normalize(view_tangent);float t_min=ray_unit_box(ray_o,ray_d,bmin,bmax);vec3 hit=ray_o+t_min*ray_d;vec3 r=vec3(v_faux_facade_window,-window_depth);hit-=r*0.5;vec3 normalized=hit/r;vec3 out_normal=normal;float out_emissive=emissive;vec3 room_color=get_shade_info(hit,normalized,base_color,id,tbn,out_normal,out_emissive);base_color=mix(base_color,room_color,mask);normal=mix(normal,out_normal,mask);emissive=mix(emissive,out_emissive,mask);}
#endif
vec4 color=vec4(base_color,1.0);vec3 xy_flipped_normal=vec3(-normal.xy,normal.z);float shadowed_lighting_factor=0.0;
#ifdef RENDER_SHADOWS
shadowed_lighting_factor=shadowed_light_factor_normal(xy_flipped_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);
#else
shadowed_lighting_factor=dot(normal,u_lighting_directional_dir);
#endif
color.rgb=apply_lighting_linear(color.rgb,xy_flipped_normal,shadowed_lighting_factor);color.rgb=mix(color.rgb,base_color.rgb,emissive);
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos,v_pos.z));
#endif
color.rgb=linearTosRGB(color.rgb);color*=u_opacity;
#ifdef INDICATOR_CUTOUT
color=applyCutout(color,v_pos.z);
#endif
glFragColor=color; 
#ifdef DEBUG_SHOW_NORMALS
color.rgb=xy_flipped_normal*0.5+vec3(0.5,0.5,0.5);color.a=1.0;glFragColor=color;
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec3 a_pos_3f;in vec3 a_normal_3;in vec3 a_centroid_3;in vec4 a_faux_facade_data;in vec2 a_faux_facade_vertical_range;uniform mat4 u_matrix;uniform mat4 u_normal_matrix;uniform highp float u_tile_to_meter;out vec4 v_color;out vec3 v_normal;out highp vec3 v_pos;
#ifdef BUILDING_FAUX_FACADE
out lowp float v_faux_facade;out highp float v_faux_facade_ed;out highp vec2 v_faux_facade_window;out highp vec2 v_faux_facade_floor;out highp vec2 v_faux_facade_range;out highp float v_aspect;out highp vec3 v_tbn_0;out highp vec3 v_tbn_1;out highp vec3 v_tbn_2;out highp vec4 v_faux_color_emissive;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;
#endif
const float MAX_UINT_16=65535.0;const float MAX_INT_16=32767.0;const float MAX_UINT_8=255.0;const float TWO_POW_8=256.0;vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}
#ifdef BUILDING_FAUX_FACADE
mat3 get_tbn(in vec3 normal) {const vec3 bitangent=vec3(0.0,0.0,1.0);vec3 tangent=normalize(vec3(normal.y,-normal.x,0.0));return mat3(tangent,bitangent,normal);}
#endif
#pragma mapbox: define-attribute-vertex-shader-only highp vec2 part_color_emissive
#pragma mapbox: define-attribute-vertex-shader-only highp vec2 faux_facade_color_emissive
void main() {
#pragma mapbox: initialize-attribute-custom highp vec2 part_color_emissive
#pragma mapbox: initialize-attribute-custom highp vec2 faux_facade_color_emissive
vec4 color_emissive=decode_color(part_color_emissive);v_color=vec4(sRGBToLinear(color_emissive.rgb),color_emissive.a);vec3 a_normal_3f=a_normal_3/MAX_INT_16;v_normal=vec3(u_normal_matrix*vec4(a_normal_3f,0.0));float hidden=0.0;
#ifdef BUILDING_FAUX_FACADE
v_faux_facade=a_faux_facade_data.x;if (v_faux_facade > 0.0) {v_faux_facade_ed=a_faux_facade_data.x *u_tile_to_meter;float window_x_perc=floor(a_faux_facade_data.y/TWO_POW_8);float window_y_perc=a_faux_facade_data.y-TWO_POW_8*window_x_perc;vec2 window_perc=vec2(window_x_perc,window_y_perc)/MAX_UINT_8;v_faux_facade_floor=(a_faux_facade_data.zw/MAX_UINT_16*EXTENT)*u_tile_to_meter;v_faux_facade_window=window_perc*v_faux_facade_floor;v_faux_facade_range=(a_faux_facade_vertical_range/MAX_UINT_16*EXTENT)*u_tile_to_meter;v_aspect=v_faux_facade_window.x/v_faux_facade_window.y;mat3 tbn=get_tbn(normalize(v_normal));v_tbn_0=tbn[0];v_tbn_1=tbn[1];v_tbn_2=tbn[2];v_faux_color_emissive=decode_color(faux_facade_color_emissive);v_faux_color_emissive.rgb=sRGBToLinear(v_faux_color_emissive.rgb);}
#endif
v_pos=a_pos_3f;
#ifdef RENDER_CUTOFF
vec4 ground=u_matrix*vec4(a_centroid_3,1.0);v_cutoff_opacity=cutoff_opacity(u_cutoff_params,ground.z);hidden=float(v_cutoff_opacity==0.0);v_pos.z*=v_cutoff_opacity;
#endif
#ifdef RENDER_SHADOWS
vec3 shadow_pos=v_pos;
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset_model(v_normal);shadow_pos+=offset*shadow_normal_offset_multiplier0();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shadow_pos,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(shadow_pos,1.0);v_depth_shadows=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(v_pos);
#endif
gl_Position=mix(u_matrix*vec4(v_pos,1),AWAY,hidden);}`),
                buildingBloom: Oi(`in vec4 v_color_emissive;
#pragma mapbox: define-attribute highp vec4 bloom_attenuation
#pragma mapbox: initialize-attribute highp vec4 bloom_attenuation
float saturate(float val) {return clamp(val,0.0,1.0);}void main() {float emission=v_color_emissive.a;float opacity=1.0;
#ifdef HAS_ATTRIBUTE_a_bloom_attenuation
float distance=length(vec2(1.3*max(0.0,abs(bloom_attenuation.x)-bloom_attenuation.z),bloom_attenuation.y));distance+= mix(0.5,0.0,clamp(emission-1.0,0.0,1.0));opacity*=saturate(1.0-distance*distance);
#endif
glFragColor=vec4(v_color_emissive.rgb,1.0)*opacity;}`, `in vec3 a_pos_3f;
#pragma mapbox: define-attribute-vertex-shader-only highp vec2 part_color_emissive
#pragma mapbox: define-attribute highp vec4 bloom_attenuation
out vec4 v_color_emissive;uniform mat4 u_matrix;vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {
#pragma mapbox: initialize-attribute-custom highp vec2 part_color_emissive
#pragma mapbox: initialize-attribute highp vec4 bloom_attenuation
#ifdef HAS_ATTRIBUTE_a_part_color_emissive
vec4 color_emissive=decode_color(part_color_emissive);float part_emissive=color_emissive.a*5.0;v_color_emissive=vec4(sRGBToLinear(color_emissive.rgb),part_emissive);
#else
v_color_emissive=vec4(1.0);
#endif
gl_Position=u_matrix*vec4(a_pos_3f,1.0);}`),
                buildingDepth: Oi(`in highp float v_depth;void main() {
#ifndef DEPTH_TEXTURE
glFragColor=pack_depth(v_depth);
#endif
}`, "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;void main() {gl_Position=u_matrix*vec4(a_pos_3f,1.0);v_depth=gl_Position.z/gl_Position.w;}"),
                circle: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
uniform float u_emissive_strength;void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float blur_positive=blur < 0.0 ? 0.0 : 1.0;lowp float antialiasblur=v_data.z;float extrude_length=length(extrude)+antialiasblur*(1.0-blur_positive);float antialiased_blur=-max(abs(blur),antialiasblur);float antialiase_blur_opacity=smoothstep(0.0,antialiasblur,extrude_length-1.0);float opacity_t=blur_positive==1.0 ? 
smoothstep(0.0,-antialiased_blur,1.0-extrude_length) : 
smoothstep(antialiased_blur,0.0,extrude_length-1.0)-antialiase_blur_opacity;float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(
antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)
);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#endif
#ifdef FOG
out_color=fog_apply_premultiplied(out_color,v_fog_pos);
#endif
glFragColor=out_color*(v_visibility*opacity_t);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define NUM_VISIBILITY_RINGS 2
#define INV_SQRT2 0.70710678
#define ELEVATION_BIAS 0.0001
#define NUM_SAMPLES_PER_RING 16
uniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;
#endif
#ifdef ELEVATED_ROADS
in float a_circle_z_offset;
#endif
out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
vec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {
#if defined(TERRAIN)
return elevation(pos)+ELEVATION_BIAS;
#else
return 0.0;
#endif
}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);
#ifdef PITCH_WITH_MAP
#ifdef PROJECTION_GLOBE_VIEW
return u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );
#else
return u_matrix*( world_center+vec4(sample_offset,0,0) );
#endif
#else
return projected_center+vec4(sample_offset,0,0);
#endif
}float get_sample_step() {
#ifdef PITCH_WITH_MAP
return 2.0*PI/float(NUM_SAMPLES_PER_RING);
#else
return PI/float(NUM_SAMPLES_PER_RING);
#endif
}void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;
#ifdef PROJECTION_GLOBE_VIEW
vec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);
#else 
surface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);
#endif
#ifdef ELEVATED_ROADS
world_center.z+=a_circle_z_offset+ELEVATION_BIAS;
#endif
vec4 projected_center=u_matrix*world_center;float view_scale=0.0;
#ifdef PITCH_WITH_MAP
#ifdef SCALE_WITH_MAP
view_scale=1.0;
#else
view_scale=projected_center.w/u_camera_to_center_distance;
#endif
#else
#ifdef SCALE_WITH_MAP
view_scale=u_camera_to_center_distance;
#else
view_scale=projected_center.w;
#endif
#endif
gl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;
#ifdef TERRAIN
float step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;
#ifdef PITCH_WITH_MAP
float cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;
#else
occlusion_world_center=world_center;occlusion_projected_center=projected_center;
#endif
for(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);
#else
visibility=1.0;
#endif
#ifdef PROJECTION_GLOBE_VIEW
visibility=1.0;
#endif
v_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);
#ifdef FOG
v_fog_pos=fog_position(world_center.xyz);
#endif
}`),
                clippingMask: Oi("void main() {glFragColor=vec4(1.0);}", "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
                heatmap: Oi(`#include "_prelude_fog.fragment.glsl"
uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);
#ifdef FOG
if (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_terrain.vertex.glsl"
#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;
#endif
out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#else
pos=vec3(tilePos+extrude,elevation(tilePos));
#endif
gl_Position=u_matrix*vec4(pos,1);
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`),
                heatmapTexture: Oi(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(0.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"),
                collisionBox: Oi("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", `#include "_prelude_terrain.vertex.glsl"
in vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in vec2 a_elevation_from_sea;in float a_size_scale;in vec2 a_padding;in float a_auto_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform float u_zoom_transition;
#endif
out float v_placed;out float v_notUsed;void main() {float feature_elevation=a_elevation_from_sea.x+a_auto_z_offset;float terrain_elevation=(a_elevation_from_sea.y==1.0 ? 0.0 : elevation(a_anchor_pos));vec3 proj_pos=a_pos+elevationVector(a_anchor_pos)*(feature_elevation+terrain_elevation);
#ifdef PROJECTION_GLOBE_VIEW
#ifndef PROJECTED_POS_ON_VIEWPORT
vec3 globe_pos=proj_pos;vec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,a_anchor_pos,u_tile_id,u_merc_center);proj_pos=mix_globe_mercator(globe_pos,mercator_pos,u_zoom_transition);
#endif
#endif
vec4 projectedPoint=u_matrix*vec4(proj_pos,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(
0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}`),
                collisionCircle: Oi("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}", `in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(
mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(
0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}`),
                debug: Oi("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}", `#include "_prelude_terrain.vertex.glsl"
in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;
#endif
out vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;
#ifdef PROJECTION_GLOBE_VIEW
gl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);
#else
gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);
#endif
}`),
                elevatedStructuresDepth: Oi(`void main() {
#ifndef DEPTH_TEXTURE
glFragColor=vec4(0.);
#endif
}`, "in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform float u_depth_bias;void main() {gl_Position=u_matrix*vec4(a_pos,a_height,1);gl_Position.z=gl_Position.z+u_depth_bias;}"),
                elevatedStructuresDepthReconstruct: Oi(`#ifdef DEPTH_RECONSTRUCTION
in float v_height;
#endif
void main() {
#ifdef DEPTH_RECONSTRUCTION
if (v_height >=0.0)
discard;
#endif
glFragColor=vec4(1.0,0.0,0.0,1.0);}`, `in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform vec3 u_camera_pos;uniform highp float u_depth_bias;uniform lowp float u_height_scale;uniform lowp float u_reset_depth;
#ifdef DEPTH_RECONSTRUCTION
out float v_height;
#endif
void main() {vec3 vpos=vec3(a_pos,a_height*u_height_scale);
#ifdef DEPTH_RECONSTRUCTION
if (u_camera_pos.z > vpos.z) {vpos-=(u_camera_pos-vpos)*(vpos.z/(u_camera_pos.z-vpos.z));}v_height=a_height;
#endif
gl_Position=u_matrix*vec4(vpos,1);gl_Position.z=u_reset_depth==1.0 ? gl_Position.w : gl_Position.z+u_depth_bias;}`),
                elevatedStructures: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
in vec3 v_normal;in float v_height;
#ifdef RENDER_SHADOWS
in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth;
#endif
vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}vec3 compute_view_dependent_emissive_color(float ndotl,float emissive_strength,vec3 color)
{color=sRGBToLinear(color);color=color*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);color=linearTosRGB(color.rgb);return color;}uniform float u_emissive_strength;
#pragma mapbox: define highp vec4 structure_color
void main() {
#pragma mapbox: initialize highp vec4 structure_color
vec3 color=structure_color.xyz;
#ifdef LIGHTING_3D_MODE
vec3 normal=normalize(v_normal);vec3 transformed_normal=vec3(-normal.xy,normal.z);float ndotl=calculate_NdotL(transformed_normal);float emissive_strength=u_emissive_strength;emissive_strength=0.0;vec3 emissive_color=compute_view_dependent_emissive_color(ndotl,emissive_strength,color.xyz);
#ifdef RENDER_SHADOWS
float shadowed_lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth);color.rgb=apply_lighting(color.rgb,transformed_normal,shadowed_lighting_factor);
#else
color=apply_lighting(color,transformed_normal);
#endif
color=mix(color,emissive_color,emissive_strength);if (v_height < 0.0) {float penetration=max(v_height+7.5,0.0);float occlusion=1.0-1.0/PI*acos(1.0-penetration/4.0);color=color*(1.0-pow(occlusion,2.0)*0.3);}
#endif
#ifdef FOG
color=fog_apply(color,v_fog_pos);
#endif
vec4 out_color=vec4(color,1.0);
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,v_height);
#endif
#ifdef FEATURE_CUTOUT
out_color=apply_feature_cutout(out_color,gl_FragCoord);
#endif
glFragColor=out_color;HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec2 a_pos;in float a_height;in vec3 a_pos_normal_3;uniform mat4 u_matrix;out vec3 v_normal;out float v_height;
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth;
#endif
#pragma mapbox: define highp vec4 structure_color
void main() {
#pragma mapbox: initialize highp vec4 structure_color
v_normal=a_pos_normal_3/16384.0;v_height=a_height;vec3 pos=vec3(a_pos,a_height);gl_Position=u_matrix*vec4(pos,1);
#ifdef RENDER_SHADOWS
vec3 shd_pos0=pos;vec3 shd_pos1=pos;
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(-v_normal.xy,v_normal.z));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`),
                fill: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#ifdef ELEVATED_ROADS
in highp float v_road_z_offset;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
vec4 out_color=color;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
out_color*=opacity;
#ifdef INDICATOR_CUTOUT
if (v_z_offset >=0.0) {out_color=applyCutout(out_color,v_z_offset);}
#endif
#ifdef FEATURE_CUTOUT
out_color=apply_feature_cutout(out_color,gl_FragCoord);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;out highp float v_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp float z_offset
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;v_road_z_offset=z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=z_offset;
#endif
}`),
                fillOutline: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
in highp vec2 v_pos;uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
#ifdef FEATURE_CUTOUT
out_color=apply_feature_cutout(out_color,gl_FragCoord);
#endif
glFragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
uniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp float z_offset
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);
#ifdef FLIP_Y
v_pos=(vec2(gl_Position.x,-gl_Position.y)/gl_Position.w+1.0)/2.0*u_world;
#else
v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#endif
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`),
                fillOutlinePattern: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;
#ifdef FILL_PATTERN_TRANSITION
uniform float u_pattern_transition;
#endif
uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
in highp vec2 v_pos;in highp vec2 v_pos_world;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);
#ifdef FILL_PATTERN_TRANSITION
vec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;
#endif
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FEATURE_CUTOUT
out_color=apply_feature_cutout(out_color,gl_FragCoord);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
out highp vec2 v_pos;out highp vec2 v_pos_world;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
#pragma mapbox: define lowp float pixel_ratio
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
#pragma mapbox: initialize lowp float pixel_ratio
#pragma mapbox: initialize highp float z_offset
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);
#ifdef FLIP_Y
v_pos_world=(vec2(gl_Position.x,-gl_Position.y)/gl_Position.w+1.0)/2.0*u_world;
#else
v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#endif
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`),
                fillPattern: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;
#ifdef FILL_PATTERN_TRANSITION
uniform float u_pattern_transition;
#endif
in highp vec2 v_pos;uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#ifdef ELEVATED_ROADS
in highp float v_road_z_offset;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);
#ifdef FILL_PATTERN_TRANSITION
vec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;
#endif
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);
#ifdef ELEVATED_ROADS
out_color.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);
#else
out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#endif
#ifdef FEATURE_CUTOUT
out_color=apply_feature_cutout(out_color,gl_FragCoord);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;out highp float v_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
out highp vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
#pragma mapbox: define lowp float pixel_ratio
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
#pragma mapbox: initialize highp float z_offset
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;v_road_z_offset=z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`),
                fillExtrusion: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
in vec4 v_color;in vec4 v_flat;
#ifdef RENDER_SHADOWS
in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;
#endif
uniform lowp float u_opacity;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;in vec2 v_ao;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
in vec4 v_roof_color;
#endif
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
in highp vec3 v_normal;
#endif
uniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;
#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)
in float v_flood_radius;in float v_has_floodlight;
#endif
in float v_height;
#pragma mapbox: define highp float emissive_strength
void main() {
#pragma mapbox: initialize highp float emissive_strength
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
vec3 normal=normalize(v_normal);
#endif
float z;vec4 color=v_color;
#ifdef ZERO_ROOF_RADIUS
z=float(normal.z > 0.00001);
#ifdef LIGHTING_3D_MODE
normal=mix(normal,vec3(0.0,0.0,1.0),z);
#else
color=mix(v_color,v_roof_color,z);
#endif
#endif
float h=max(0.0,v_height);float ao_shade=1.0;
#ifdef FAUX_AO
float intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;
#ifdef ZERO_ROOF_RADIUS
concave*=(1.0-z);
#endif
float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);
#ifdef LIGHTING_3D_MODE
#ifdef FLOOD_LIGHT
color.rgb*=mix(ao_shade,1.0,v_has_floodlight);
#else
color.rgb*=ao_shade;
#endif
#else
color.rgb*=ao_shade;
#endif
#endif
#ifdef LIGHTING_3D_MODE
float flood_radiance=0.0;
#ifdef FLOOD_LIGHT
flood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;
#endif
#ifdef RENDER_SHADOWS
#ifdef FLOOD_LIGHT
float ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);
#else
float shadowed_lighting_factor;
#ifdef RENDER_CUTOFF
shadowed_lighting_factor=shadowed_light_factor_normal_opacity(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}
#else
shadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);
#endif
color.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);
#endif
#else
color.rgb=apply_lighting(color.rgb,normal);
#ifdef FLOOD_LIGHT
color.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);
#endif
#endif
color.rgb=mix(color.rgb,v_flat.rgb,emissive_strength);color*=u_opacity;
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));
#endif
#ifdef INDICATOR_CUTOUT
color=applyCutout(color,h);
#endif
#ifdef FEATURE_CUTOUT
color=apply_feature_cutout(color,gl_FragCoord);
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_lighting.glsl"
uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;uniform float u_width_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef RENDER_WALL_MODE
in vec3 a_join_normal_inside;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;
#endif
#ifdef TERRAIN
uniform int u_height_type;uniform int u_base_type;
#endif
uniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
out vec4 v_roof_color;
#endif
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
out highp vec3 v_normal;
#endif
#ifdef FAUX_AO
uniform lowp vec2 u_ao;out vec2 v_ao;
#endif
#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)
out float v_flood_radius;out float v_has_floodlight;
#endif
out float v_height;vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
#pragma mapbox: define highp float flood_light_wall_radius
#pragma mapbox: define highp float line_width
#pragma mapbox: define highp float emissive_strength
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize highp float flood_light_wall_radius
#pragma mapbox: initialize highp float line_width
#pragma mapbox: initialize highp float emissive_strength
base*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
v_normal=normal;
#endif
base=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
float ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;
#ifdef TERRAIN
bool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);
#else
h=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);
#endif
#ifdef PROJECTION_GLOBE_VIEW
float lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#endif
float cutoff=1.0;vec3 scaled_pos=pos;
#ifdef RENDER_CUTOFF
vec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);
#ifdef CLIP_ZERO_TO_ONE
cutoff=cutoff_opacity(u_cutoff_params,ground.z*2.0-ground.w);
#else
cutoff=cutoff_opacity(u_cutoff_params,ground.z);
#endif
if (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;v_cutoff_opacity=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);
#endif
float hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff==0.0 && centroid_pos.x !=0.0) || (color.a==0.0));
#ifdef RENDER_WALL_MODE
vec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);scaled_pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;scaled_pos.xy-=a_join_normal_inside.z*wall_offset*0.5;
#endif
gl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;
#ifdef RENDER_SHADOWS
vec3 shd_pos0=pos;vec3 shd_pos1=pos;
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);
#endif
float NdotL=0.0;float colorvalue=0.0;
#ifndef LIGHTING_3D_MODE
colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(
(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}
#endif
#ifdef FAUX_AO
float concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;
#ifdef TERRAIN
top_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);
#endif
v_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);
#ifdef PROJECTION_GLOBE_VIEW
top_height+=u_height_lift;
#endif
gl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;
#endif
#ifdef LIGHTING_3D_MODE
#ifdef FLOOD_LIGHT
float is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;
#endif
v_color=vec4(color.rgb,1.0);float ndotl=calculate_NdotL(normal);v_flat.rgb=sRGBToLinear(color.rgb);v_flat.rgb=v_flat.rgb*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);v_flat=vec4(linearTosRGB(v_flat.rgb),1.0);
#else
v_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
float roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;
#endif
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`),
                fillExtrusionDepth: Oi(`in highp float v_depth;void main() {
#ifndef DEPTH_TEXTURE
glFragColor=pack_depth(v_depth);
#endif
}`, `#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_width_scale;uniform float u_vertical_scale;
#ifdef TERRAIN
uniform int u_height_type;uniform int u_base_type;
#endif
in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef RENDER_WALL_MODE
in vec3 a_join_normal_inside;
#endif
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp float line_width
#pragma mapbox: define highp vec4 color
out highp float v_depth;void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp float line_width
#pragma mapbox: initialize highp vec4 color
base*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
vec3 pos;
#ifdef TERRAIN
bool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;float ele=elevation(pos_nx.xy);float c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);float h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);
#else
pos=vec3(pos_nx.xy,t > 0.0 ? height : base);
#endif
#ifdef RENDER_WALL_MODE
vec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;pos.xy-=a_join_normal_inside.z*wall_offset*0.5;
#endif
float hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}`),
                fillExtrusionPattern: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;
#ifdef FILL_EXTRUSION_PATTERN_TRANSITION
uniform float u_pattern_transition;
#endif
#ifdef FAUX_AO
uniform lowp vec2 u_ao;in vec3 v_ao;
#endif
#ifdef LIGHTING_3D_MODE
in vec3 v_normal;
#endif
in highp vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define mediump vec4 pattern
#ifdef FILL_EXTRUSION_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
#pragma mapbox: define highp float pixel_ratio
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize mediump vec4 pattern
#ifdef FILL_EXTRUSION_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
#pragma mapbox: initialize highp float pixel_ratio
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);
#ifdef FILL_EXTRUSION_PATTERN_TRANSITION
vec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;
#endif
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;
#else
out_color=out_color*v_lighting;
#endif
#ifdef FAUX_AO
float intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,height);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#include "_prelude_lighting.glsl"
uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_width_scale;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef RENDER_WALL_MODE
in vec3 a_join_normal_inside;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;
#endif
#ifdef TERRAIN
uniform int u_height_type;uniform int u_base_type;
#endif
out highp vec2 v_pos;out vec4 v_lighting;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;out vec3 v_ao;
#endif
#ifdef LIGHTING_3D_MODE
out vec3 v_normal;
#endif
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump vec4 pattern
#ifdef FILL_EXTRUSION_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
#pragma mapbox: define highp float pixel_ratio
#pragma mapbox: define highp float line_width
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump vec4 pattern
#ifdef FILL_EXTRUSION_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
#pragma mapbox: initialize highp float pixel_ratio
#pragma mapbox: initialize highp float line_width
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
float ele=0.0;float h=z;vec3 p;float c_ele;
#ifdef TERRAIN
bool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;p=vec3(pos_nx.xy,h);
#else
p=vec3(pos_nx.xy,z);
#endif
#ifdef PROJECTION_GLOBE_VIEW
float lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#endif
#ifdef RENDER_WALL_MODE
vec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);p.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;p.xy-=a_join_normal_inside.z*wall_offset*0.5;
#endif
float hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0
? pos_nx.xy
: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;
#ifdef LIGHTING_3D_MODE
NdotL=calculate_NdotL(normal);
#else
NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);
#endif
if (normal.y !=0.0) {float r=0.84;
#ifndef LIGHTING_3D_MODE
r=mix(0.7,0.98,1.0-u_lightintensity);
#endif
NdotL*=(
(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}
#ifdef FAUX_AO
float concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;
#ifdef TERRAIN
top_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);
#endif
v_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);
#ifdef PROJECTION_GLOBE_VIEW
top_height+=u_height_lift;
#endif
gl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;
#endif
#ifdef LIGHTING_3D_MODE
v_normal=normal;
#else
v_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;
#endif
#ifdef FOG
v_fog_pos=fog_position(p);
#endif
}`),
                groundShadow: Oi(`#include "_prelude_shadow.fragment.glsl"
precision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;
#ifdef FOG
in float v_fog_opacity;
#endif
void main() {float light=shadowed_light_factor_plane_bias(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);
#ifdef RENDER_CUTOFF
shadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));
#endif
#ifdef FOG
shadow=mix(shadow,vec3(1.0),v_fog_opacity);
#endif
#ifdef INDICATOR_CUTOUT
shadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0),0.0).r);
#endif
glFragColor=vec4(shadow,1.0);}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;
#ifdef FOG
out float v_fog_opacity;
#endif
void main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);
#ifdef FOG
v_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);
#endif
}`),
                fillExtrusionGroundEffect: Oi(`uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;
#ifdef SDF_SUBPASS
in highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}
#ifdef FOG
in highp float v_fog;
#endif
#endif
void main() {
#ifdef CLEAR_SUBPASS
vec4 color=vec4(1.0);
#ifdef CLEAR_FROM_TEXTURE
color=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));
#endif
glFragColor=color;
#else
#ifdef SDF_SUBPASS
highp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;
#ifdef FOG
fog=v_fog;
#endif
#ifdef RENDER_CUTOFF
fog*=v_cutoff_opacity;
#endif
glFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));
#else
vec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);
#ifdef OVERDRAW_INSPECTOR
color=vec4(1.0);
#endif
glFragColor=color;
#endif
HANDLE_WIREFRAME_DEBUG;
#endif
}`, `#include "_prelude_fog.vertex.glsl"
in highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;
#ifdef SDF_SUBPASS
out highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;
#ifdef FOG
out highp float v_fog;
#endif
#endif
uniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp float u_dynamic_offset;uniform highp vec2 u_ao;
#pragma mapbox: define highp float flood_light_ground_radius
const float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {
#pragma mapbox: initialize highp float flood_light_ground_radius
vec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(u_dynamic_offset,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;
#ifdef SDF_SUBPASS
v_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);
#ifdef FOG
v_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);
#endif
#endif
float hidden_by_landmark=0.0;
#ifdef HAS_CENTROID
hidden_by_landmark=a_hidden_by_landmark;
#endif
float isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));
#ifdef RENDER_CUTOFF
v_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);
#endif
}`),
                hillshadePrepare: Oi(`precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(
(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)
)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(
deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
                hillshade: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef LIGHTING_3D_MODE
glFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);
#endif
#ifdef FOG
glFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`),
                line: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform lowp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_floor_width_scale;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec3 v_uv;
#ifdef ELEVATED_ROADS
in highp float v_road_z_offset;
#endif
#ifdef RENDER_LINE_DASH
uniform sampler2D u_dash_image;in vec2 v_tex;
#endif
#ifdef RENDER_LINE_GRADIENT
uniform sampler2D u_gradient_image;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 dash
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float border_width
#pragma mapbox: define lowp vec4 border_color
float linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize lowp vec4 dash
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float border_width
#pragma mapbox: initialize lowp vec4 border_color
float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);
#ifdef RENDER_LINE_DASH
float sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;float scaled_floorwidth=(floorwidth*u_floor_width_scale);alpha*=linearstep(0.5-sdfgamma/scaled_floorwidth,0.5+sdfgamma/scaled_floorwidth,sdfdist);
#endif
highp vec4 out_color;
#ifdef RENDER_LINE_GRADIENT
out_color=texture(u_gradient_image,v_uv.xy);
#else
out_color=color;
#endif
float trim_alpha=1.0;
#ifdef RENDER_LINE_TRIM_OFFSET
highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);out_color=mix(out_color,u_trim_color,transition_factor);trim_alpha=1.0-transition_factor;}
#endif
if (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}
#ifdef RENDER_LINE_BORDER
float edgeBlur=((border_width*u_width_scale)+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color=mix(border_color*trim_alpha,out_color,smoothAlpha);}}
#endif
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);
#ifdef ELEVATED_ROADS
out_color.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);
#else
out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
out_color*=(alpha*opacity);
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,v_z_offset);
#endif
#ifdef FEATURE_CUTOUT
out_color=apply_feature_cutout(out_color,gl_FragCoord);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define EXTRUDE_SCALE 0.015873016
in vec2 a_pos_normal;in vec4 a_data;
#if defined(ELEVATED) || defined(ELEVATED_ROADS) || defined(VARIABLE_LINE_WIDTH)
in vec3 a_z_offset_width;
#endif
#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)
in highp vec3 a_packed;
#endif
#ifdef RENDER_LINE_DASH
in float a_linesofar;
#endif
uniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;uniform float u_width_scale;uniform highp float u_floor_width_scale;
#ifdef ELEVATED
uniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {
#ifdef ELEVATION_REFERENCE_SEA
return 0.0;
#else
return elevation(apos);
#endif
}
#endif
out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec3 v_uv;
#ifdef ELEVATED_ROADS
out highp float v_road_z_offset;
#endif
#ifdef RENDER_LINE_DASH
uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;
#endif
#ifdef RENDER_LINE_GRADIENT
uniform float u_image_height;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 dash
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float border_width
#pragma mapbox: define lowp vec4 border_color
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize lowp vec4 dash
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float border_width
#pragma mapbox: initialize lowp vec4 border_color
float a_z_offset;
#if defined(ELEVATED) || defined(ELEVATED_ROADS)
a_z_offset=a_z_offset_width.x;
#endif
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth;
#ifdef VARIABLE_LINE_WIDTH
float left=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);halfwidth=(u_width_scale*(left==1.0 ? a_z_offset_width.y : a_z_offset_width.z))/2.0;
#else
halfwidth=(u_width_scale*width)/2.0;
#endif
offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;
#ifdef ELEVATED_ROADS
v_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;
#else
#ifdef ELEVATED
vec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;
#ifdef CROSS_SLOPE_VERTICAL
float top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);
#else
#ifdef CROSS_SLOPE_HORIZONTAL
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;
#else
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;
#endif
#endif
gl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);
#else
gl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);
#endif
#endif
#ifdef ELEVATED_ROADS
#ifdef RENDER_SHADOWS
vec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;
#ifdef NORMAL_OFFSET
vec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#endif
#ifndef RENDER_TO_TEXTURE
float epsilon=0.0001;float extrude_length_without_perspective=max(length(dist),epsilon);float extrude_length_with_perspective=max(length(projected_extrude_xy/gl_Position.w*u_units_to_pixels),epsilon);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));
#else
v_gamma_scale=1.0;
#endif
#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)
highp float a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float line_progress=a_packed[2];
#ifdef RENDER_LINE_GRADIENT
highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec3(a_uv_x,a_split_index*texel_height-half_texel_height,line_progress);
#else
v_uv=vec3(a_uv_x,0.0,line_progress);
#endif
#endif
#ifdef RENDER_LINE_DASH
float scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/(floorwidth*u_floor_width_scale),(-normal.y*height+dash.x+0.5)/u_texsize.y);
#endif
v_width2=vec2(outset,inset);
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=a_z_offset;
#endif
}`),
                linePattern: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform highp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_alpha_discard_threshold;uniform highp vec2 u_texsize;uniform highp float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;uniform sampler2D u_image;
#ifdef LINE_PATTERN_TRANSITION
uniform float u_pattern_transition;
#endif
in vec2 v_normal;in vec2 v_width2;in highp float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef RENDER_LINE_TRIM_OFFSET
in highp vec3 v_uv;
#endif
#ifdef ELEVATED_ROADS
in highp float v_road_z_offset;
#endif
#ifdef LINE_JOIN_NONE
in vec2 v_pattern_data;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
uniform float u_emissive_strength;
#pragma mapbox: define mediump vec4 pattern
#ifdef LINE_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
#pragma mapbox: define mediump float pixel_ratio
#pragma mapbox: define mediump float blur
#pragma mapbox: define mediump float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern
#ifdef LINE_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
#pragma mapbox: initialize mediump float pixel_ratio
#pragma mapbox: initialize mediump float blur
#pragma mapbox: initialize mediump float opacity
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;highp float pattern_size=display_size.x/u_tile_units_to_pixels;float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);highp float pattern_x=v_linesofar/pattern_size*aspect;highp float x=mod(pattern_x,1.0);highp float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;highp vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));highp vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);
#ifdef LINE_PATTERN_TRANSITION
vec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl*texel_size-texel_size,pattern_b_br*texel_size+texel_size,vec2(x,y));vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);color=color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;
#endif
#ifdef RENDER_LINE_TRIM_OFFSET
highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);color=mix(color,color.a*u_trim_color,transition_factor);}
#endif
#ifdef LINE_JOIN_NONE
highp float pattern_len=pattern_size/aspect;highp float segment_phase=pattern_len-mod(v_linesofar-v_pattern_data.x+pattern_len,pattern_len);highp float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;highp float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}
#endif
#ifdef LIGHTING_3D_MODE
color=apply_lighting_with_emission_ground(color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);
#ifdef ELEVATED_ROADS
color.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);
#else
color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
color*=(alpha*opacity);if (u_alpha_discard_threshold !=0.0) {if (color.a < u_alpha_discard_threshold) {discard;}}
#ifdef INDICATOR_CUTOUT
color=applyCutout(color,v_z_offset);
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;
#if defined(ELEVATED) || defined(ELEVATED_ROADS)
in vec3 a_z_offset_width;
#endif
#ifdef RENDER_LINE_TRIM_OFFSET
in highp vec3 a_packed;
#endif
in highp float a_linesofar;
#ifdef LINE_JOIN_NONE
in highp vec3 a_pattern_data;out vec2 v_pattern_data;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
uniform mat4 u_matrix;uniform float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform float u_device_pixel_ratio;uniform float u_width_scale;uniform float u_floor_width_scale;
#ifdef ELEVATED
uniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {
#ifdef ELEVATION_REFERENCE_SEA
return 0.0;
#else
return elevation(apos);
#endif
}
#endif
out vec2 v_normal;out vec2 v_width2;out highp float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef RENDER_LINE_TRIM_OFFSET
out highp vec3 v_uv;
#endif
#ifdef ELEVATED_ROADS
out highp float v_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#pragma mapbox: define mediump float blur
#pragma mapbox: define mediump float opacity
#pragma mapbox: define mediump float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define mediump float floorwidth
#pragma mapbox: define mediump vec4 pattern
#ifdef LINE_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
#pragma mapbox: define mediump float pixel_ratio
void main() {
#pragma mapbox: initialize mediump float blur
#pragma mapbox: initialize mediump float opacity
#pragma mapbox: initialize mediump float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize mediump float floorwidth
#pragma mapbox: initialize mediump vec4 pattern
#ifdef LINE_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
#pragma mapbox: initialize mediump float pixel_ratio
float a_z_offset;
#if defined(ELEVATED) || defined(ELEVATED_ROADS)
a_z_offset=a_z_offset_width.x;
#endif
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=(u_width_scale*width)/2.0;offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);vec2 dist=outset*a_extrude*scale;float u=0.5*a_direction;float t=1.0-abs(u);vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;
#ifdef ELEVATED_ROADS
v_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;
#else
#ifdef ELEVATED
vec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;
#ifdef CROSS_SLOPE_VERTICAL
float top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);
#else
#ifdef CROSS_SLOPE_HORIZONTAL
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;
#else
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;
#endif
#endif
gl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);
#else
gl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);
#endif
#endif
#ifdef ELEVATED_ROADS
#ifdef RENDER_SHADOWS
vec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;
#ifdef NORMAL_OFFSET
vec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#endif
#ifndef RENDER_TO_TEXTURE
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));
#else
v_gamma_scale=1.0;
#endif
#ifdef RENDER_LINE_TRIM_OFFSET
highp float a_uv_x=a_packed[0];highp float line_progress=a_packed[2];v_uv=vec3(a_uv_x,0.0,line_progress);
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=(floorwidth*u_floor_width_scale);
#ifdef LINE_JOIN_NONE
v_width=(floorwidth*u_floor_width_scale)+ANTIALIASING;mediump float pixels_to_tile_units=1.0/u_tile_units_to_pixels;mediump float pixel_ratio_inverse=1.0/pixel_ratio;mediump float aspect=v_width/((pattern.w-pattern.y)*pixel_ratio_inverse);highp float subt_multiple=(pattern.z-pattern.x)*pixel_ratio_inverse*pixels_to_tile_units*aspect*32.0;highp float subt=floor(a_pattern_data.z/subt_multiple)*subt_multiple;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5*pixels_to_tile_units;v_linesofar=(a_pattern_data.z-subt)+a_linesofar+line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);
#endif
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=a_z_offset;
#endif
}`),
                raster: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_raster_array.glsl"
uniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;
#ifdef PROJECTION_GLOBE_VIEW
in float v_split_fade;
#endif
uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;
#ifndef RASTER_ARRAY
uniform highp sampler2D u_image0;uniform sampler2D u_image1;
#endif
#ifdef RASTER_COLOR
uniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;
#endif
void main() {vec4 color0,color1,color;vec2 value;
#ifdef RASTER_COLOR
#ifdef RASTER_ARRAY
#ifdef RASTER_ARRAY_LINEAR
value=mix(
raTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t
);
#else
value=mix(
raTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t
);
#endif
if (value.y > 0.0) value.x/=value.y;
#else
color=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);
#endif
color=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;
#else
color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);
#endif
color.a*=u_opacity;
#ifdef GLOBE_POLES
color.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);
#endif
vec3 rgb=color.rgb;rgb=vec3(
dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;
#endif
#ifdef FOG
highp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));
#endif
glFragColor=vec4(out_color*color.a,color.a);
#ifdef PROJECTION_GLOBE_VIEW
glFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));
#endif
#ifdef RENDER_CUTOFF
glFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;
#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8
#ifdef GLOBE_POLES
in vec3 a_globe_pos;in vec2 a_uv;
#else
in vec2 a_pos;in vec2 a_texture_pos;
#endif
out vec2 v_pos0;out vec2 v_pos1;out float v_depth;
#ifdef PROJECTION_GLOBE_VIEW
out float v_split_fade;
#endif
void main() {vec2 uv;
#ifdef GLOBE_POLES
vec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);
#endif
#else
float w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;
#ifdef PROJECTION_GLOBE_VIEW
vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    
v_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
#else
gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
#endif
#endif
v_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;
#ifdef RENDER_CUTOFF
v_depth=gl_Position.z;
#endif
}`),
                rasterParticle: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),0.0).rgb;
#endif
#ifdef FOG
highp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));
#endif
glFragColor=vec4(out_color*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;
#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8
in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;
#ifdef PROJECTION_GLOBE_VIEW
vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
#else
uv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
#endif
v_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`),
                rasterParticleDraw: Oi("uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}", `#include "_prelude_raster_particle.glsl"
in float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(
mod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-1.0,0,1);v_particle_speed=length(velocity);}gl_PointSize=1.0;}`),
                rasterParticleTexture: Oi("uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}", "in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}"),
                rasterParticleUpdate: Oi(`#include "_prelude_raster_particle.glsl"
uniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;vec2 linearstep(vec2 edge0,vec2 edge1,vec2 x) {return  clamp((x-edge0)/(edge1-edge0),vec2(0),vec2(1));}const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp vec2 persist_rate=pow(
linearstep(vec2(-u_particle_pos_offset),vec2(0),pos)*linearstep(vec2(1.0+u_particle_pos_offset),vec2(1),pos),vec2(4)
);highp vec2 per_frame_persist=pow(persist_rate,abs(dp)/u_particle_pos_offset);highp float drop_rate=1.0-per_frame_persist.x*per_frame_persist.y;drop_rate=any(greaterThanEqual(abs(pos-0.5),vec2(0.5+u_particle_pos_offset))) ? 1.0 : drop_rate;highp float drop=step(1.0-drop_rate-u_reset_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}`, "in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}"),
                symbol: Oi(`#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;uniform lowp float u_scale_factor;
#ifdef ICON_TRANSITION
uniform float u_icon_transition;
#endif
#ifdef COLOR_ADJUSTMENT
uniform mat4 u_color_adj_mat;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#else
#ifdef RENDER_SHADOWS
in highp float v_z_offset;
#endif
#endif
in vec2 v_tex_a;
#ifdef ICON_TRANSITION
in vec2 v_tex_b;
#endif
in float v_draw_halo;in vec3 v_gamma_scale_size_fade_opacity;
#ifdef RENDER_TEXT_AND_SYMBOL
in float is_sdf;in vec2 v_tex_a_icon;
#endif
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
#pragma mapbox: define lowp float emissive_strength
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
#pragma mapbox: initialize lowp float emissive_strength
vec4 out_color;float fade_opacity=v_gamma_scale_size_fade_opacity[2];
#ifdef RENDER_TEXT_AND_SYMBOL
if (is_sdf==ICON) {vec2 tex_icon=v_tex_a_icon;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
return;}
#endif
#ifdef RENDER_SDF
float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_gamma_scale_size_fade_opacity.x;float size=v_gamma_scale_size_fade_opacity.y;float fontScale=u_is_text ? size/24.0 : size;out_color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {out_color=halo_color;gamma=(halo_blur*u_scale_factor*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width*u_scale_factor/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,v_tex_a).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);out_color*=alpha;
#else
#ifdef ICON_TRANSITION
vec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);
#else
out_color=texture(u_texture,v_tex_a);
#endif
#ifdef COLOR_ADJUSTMENT
out_color=u_color_adj_mat*out_color;
#endif
#endif
out_color*=opacity*fade_opacity;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);
#ifdef TERRAIN
out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#else
out_color.rgb*=mix(v_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);
#endif
#endif
#endif
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,v_z_offset);
#endif
#ifdef FEATURE_CUTOUT
out_color=apply_feature_cutout(out_color,gl_FragCoord);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_terrain.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;
#ifdef Z_OFFSET
in float a_auto_z_offset;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_globe_anchor;in vec3 a_globe_normal;
#endif
#ifdef ICON_TRANSITION
in vec2 a_texb;
#endif
#ifdef OCCLUSION_QUERIES
in float a_occlusion_query_opacity;
#endif
#ifdef ELEVATED_ROADS
in vec3 a_x_axis;in vec3 a_y_axis;uniform float u_normal_scale;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#else
#ifdef RENDER_SHADOWS
out highp float v_z_offset;
#endif
#endif
uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_elevation_from_sea;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;
#endif
out vec2 v_tex_a;
#ifdef ICON_TRANSITION
out vec2 v_tex_b;
#endif
out float v_draw_halo;out vec3 v_gamma_scale_size_fade_opacity;
#ifdef RENDER_TEXT_AND_SYMBOL
out float is_sdf;out vec2 v_tex_a_icon;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
#pragma mapbox: define lowp float emissive_strength
#pragma mapbox: define lowp float occlusion_opacity
#pragma mapbox: define lowp float z_offset
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
#pragma mapbox: initialize lowp float emissive_strength
#pragma mapbox: initialize lowp float occlusion_opacity
#pragma mapbox: initialize lowp float z_offset
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=u_elevation_from_sea ? z_offset : z_offset+elevation(tile_anchor);
#ifdef Z_OFFSET
e+=a_auto_z_offset;
#endif
vec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;vec3 world_pos_globe;
#ifdef PROJECTION_GLOBE_VIEW
mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos_globe=a_globe_anchor+h;world_pos=mix_globe_mercator(world_pos_globe,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;
#else
world_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(
0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;vec2 a;
#ifdef PROJECTION_GLOBE_VIEW
vec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);vec4 projected_point_globe=u_matrix*vec4(world_pos_globe,1);a=projected_point_globe.xy/projected_point_globe.w;
#else
offsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);a=projected_point.xy/projected_point.w;
#endif
vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;
#ifdef PROJECTION_GLOBE_VIEW
#ifdef PROJECTED_POS_ON_VIEWPORT
projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xyz+h,1.0);
#else
vec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz,mercator_pos,u_zoom_transition)+h;projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);    
#endif
#else
projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);
#endif
highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);
#ifdef TERRAIN
#ifdef PITCH_WITH_MAP_TERRAIN
vec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);
#endif
#endif
#ifdef Z_OFFSET
z+=u_pitch_with_map ? a_auto_z_offset+z_offset : 0.0;
#else
z+=u_pitch_with_map ? z_offset : 0.0;
#endif
float occlusion_fade=globe_occlusion_fade;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));
#ifdef DEPTH_OCCLUSION
float depth_occlusion=occlusionFadeMultiSample(projected_point);float depth_occlusion_multplier=mix(occlusion_opacity,1.0,depth_occlusion);out_fade_opacity*=depth_occlusion_multplier;
#endif
#ifdef OCCLUSION_QUERIES
float occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);out_fade_opacity*=occludedFadeMultiplier;
#endif
float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);vec3 pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);pos=projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y;
#else
#ifdef ELEVATED_ROADS
vec3 xAxis=vec3(a_x_axis.xy,a_x_axis.z*u_normal_scale);vec3 yAxis=vec3(a_y_axis.xy,a_y_axis.z*u_normal_scale);pos=projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y;
#else
pos=vec3(projected_pos.xy/projected_pos.w+offset,z);
#endif
#endif
gl_Position=mix(u_coord_matrix*vec4(pos,1.0),AWAY,hidden);float gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_gamma_scale_size_fade_opacity=vec3(gamma_scale,size,out_fade_opacity);v_tex_a=a_tex/u_texsize;
#ifdef RENDER_TEXT_AND_SYMBOL
is_sdf=a_size[0]-2.0*a_size_min;v_tex_a_icon=a_tex/u_texsize_icon;
#endif
#ifdef ICON_TRANSITION
v_tex_b=a_texb/u_texsize;
#endif
#ifdef RENDER_SHADOWS
vec4 shd_pos=u_inv_matrix*vec4(pos,1.0);vec3 shd_pos0=shd_pos.xyz;vec3 shd_pos1=shd_pos.xyz;
#ifdef NORMAL_OFFSET
vec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=e;
#else
#ifdef RENDER_SHADOWS
v_z_offset=e;
#endif
#endif
}`),
                terrainRaster: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image0;in vec2 v_pos0;
#ifdef FOG
in float v_fog_opacity;
#endif
#ifdef RENDER_SHADOWS
in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;
#endif
uniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;
#ifdef LIGHTING_3D_MODE
const vec3 normal=vec3(0.0,0.0,1.0);
#ifdef RENDER_SHADOWS
float cutoffOpacity=1.0;
#ifdef RENDER_CUTOFF
cutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);
#endif
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
vec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;
#else
float lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));
#endif
#else
float lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
color.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;
#endif
#endif
#else
color=image_color;
#endif
#ifdef FOG
#ifdef ZERO_EXAGGERATION
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#else
color=fog_dither(fog_apply_from_vert(color,v_fog_opacity));
#endif
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;
#ifdef FOG
out float v_fog_opacity;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;
#endif
void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);
#ifdef FOG
#ifdef ZERO_EXAGGERATION
v_fog_pos=fog_position(decodedPos);
#else
v_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));
#endif
#endif
#ifdef RENDER_SHADOWS
vec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);
#endif
}`),
                terrainDepth: Oi("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}", `#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}`),
                skybox: Oi(`#include "_prelude_fog.fragment.glsl"
in lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(
cos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;
#ifdef FOG
sky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);
#endif
sky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`, jp),
                skyboxGradient: Oi(`#include "_prelude_fog.fragment.glsl"
in highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));
#ifdef FOG
color.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;
#endif
color*=u_opacity;glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`, jp),
                skyboxCapture: Oi(`
in highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;
#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)
#define BETA_M                  vec3(21e-6,21e-6,21e-6)
#define MIE_G                   0.76
#define DENSITY_HEIGHT_SCALE_R  8000.0
#define DENSITY_HEIGHT_SCALE_M  1200.0
#define PLANET_RADIUS           6360e3
#define ATMOSPHERE_RADIUS       6420e3
#define SAMPLE_STEPS            10
#define DENSITY_STEPS           4
float ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}`, "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"),
                globeRaster: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image0;uniform float u_far_z_cutoff;in vec2 v_pos0;
#ifndef FOG
uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;
#endif
void main() {vec4 color;
#ifdef CUSTOM_ANTIALIASING
highp vec2 uv=gl_FragCoord.xy/u_viewport;
#ifdef FLIP_Y
uv.y=1.0-uv.y;
#endif
highp vec3 ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;highp float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);highp float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);
#ifdef LIGHTING_3D_MODE
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
raster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(clamp(raster.rgb,vec3(0),vec3(1))*antialias,antialias);
#else
raster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);
#endif
#else
color=vec4(raster.rgb*antialias,raster.a*antialias);
#endif
#else
color=texture(u_image0,v_pos0);
#ifdef LIGHTING_3D_MODE
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
color=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;
#else
color=apply_lighting_ground(color);
#endif
#endif
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
color*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;
#ifdef GLOBE_POLES
in vec3 a_globe_pos;in vec2 a_uv;
#else
in vec2 a_pos;
#endif
out vec2 v_pos0;void main() {
#ifdef GLOBE_POLES
vec3 globe_pos=a_globe_pos;vec2 uv=a_uv;
#else
float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);
#endif
v_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;
#ifdef GLOBE_POLES
vec3 up_vector=globe_derived_up_vector;
#else
vec3 up_vector=elevationVector(tile_pos);
#endif
float height=elevation(tile_pos);globe_pos+=up_vector*height;
#ifndef GLOBE_POLES
globe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;
#endif
#ifdef GLOBE_POLES
vec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);
#else
vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);
#endif
gl_Position=u_proj_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
}`),
                globeAtmosphere: Oi(`#include "_prelude_fog.fragment.glsl"
uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;
#ifdef PROJECTION_GLOBE_VIEW
globe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {
#ifdef ALPHA_PASS
glFragColor=vec4(0,0,0,0);return;
#else
#ifdef NATIVE
glFragColor=vec4(1,1,1,1);
#else
glFragColor=vec4(0,0,0,1);
#endif
return;
#endif
}
#endif
highp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?
0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;
#ifdef PROJECTION_GLOBE_VIEW
highp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?
PI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);
#else
horizon_angle=horizon_angle_mercator;
#endif
horizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;
#ifdef ALPHA_PASS
float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);
#else
vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;glFragColor=vec4(c*t,t);
#endif
}`, `in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(
mix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}`),
                model: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;
#ifdef RENDER_SHADOWS
in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;
#endif
#ifdef OCCLUSION_TEXTURE_TRANSFORM
uniform vec4 u_occlusionTextureTransform;
#endif
#pragma mapbox: define-attribute highp vec3 normal_3f
#pragma mapbox: define-attribute highp vec3 color_3f
#pragma mapbox: define-attribute highp vec4 color_4f
#pragma mapbox: define-attribute highp vec2 uv_2f
#pragma mapbox: initialize-attribute highp vec3 normal_3f
#pragma mapbox: initialize-attribute highp vec3 color_3f
#pragma mapbox: initialize-attribute highp vec4 color_4f
#pragma mapbox: initialize-attribute highp vec2 uv_2f
#ifdef HAS_ATTRIBUTE_a_pbr
in lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;
#endif
#ifdef HAS_TEXTURE_u_baseColorTexture
uniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;
#endif
#ifdef HAS_TEXTURE_u_metallicRoughnessTexture
uniform sampler2D u_metallicRoughnessTexture;
#endif
#ifdef HAS_TEXTURE_u_occlusionTexture
uniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;
#endif
#ifdef HAS_TEXTURE_u_normalTexture
uniform sampler2D u_normalTexture;
#endif
#ifdef HAS_TEXTURE_u_emissionTexture
uniform sampler2D u_emissionTexture;
#endif
#ifdef APPLY_LUT_ON_GPU
uniform highp sampler3D u_lutTexture;
#endif
#ifdef TERRAIN_FRAGMENT_OCCLUSION
in highp float v_depth;uniform highp sampler2D u_depthTexture;uniform highp vec2 u_inv_depth_size;uniform highp vec2 u_depth_range_unpack;
#ifdef DEPTH_D24
highp float unpack_depth(highp float depth) {return  depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}
#else
highp float unpack_depth_rgba(highp vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}
#endif
bool isOccluded() {highp vec2 coord=gl_FragCoord.xy*u_inv_depth_size;
#ifdef DEPTH_D24
highp float depth=unpack_depth(texture(u_depthTexture,coord).r);
#else
highp float depth=unpack_depth_rgba(texture(u_depthTexture,coord));
#endif
return v_depth > depth+0.0005;}
#endif
#define saturate(_x) clamp(_x,0.,1.)
vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)
{
#ifdef LIGHTING_3D_MODE
vec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;
#ifdef RENDER_SHADOWS
lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);
#else
lighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));
#endif
return apply_lighting(albedo,transformed_normal,lighting_factor);
#else
vec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;
#endif
}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;
#ifdef HAS_ATTRIBUTE_a_color_3f
albedo*=vec4(color_3f,1.0);
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
#else
#ifdef HAS_ATTRIBUTE_a_color_4f
albedo*=color_4f;
#endif
#endif
#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)
vec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}
#ifdef UNPREMULT_TEXTURE_IN_SHADER
if(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;
#endif
if(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}
#endif
vec4 color=vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);
#ifdef APPLY_LUT_ON_GPU
color=applyLUT(u_lutTexture,color);
#endif
return color;}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {
#ifdef HAS_TEXTURE_u_normalTexture
highp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;
#ifdef FLIP_Y
T=-T;B=-B;
#endif
highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;
#else
return mat3(1.0);
#endif
}highp vec3 getNormal(){highp vec3 n;
#ifdef HAS_ATTRIBUTE_a_normal_3f
n=normalize(normal_3f);
#else
highp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));
#ifdef FLIP_Y
n=normalize(cross(fdx,fdy));
#else
n=normalize(cross(fdx,fdy))*-1.0;
#endif
#endif
#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
vec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);
#endif
return n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;
#ifdef HAS_ATTRIBUTE_a_pbr
mat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;
#endif
#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) 
vec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;
#endif
const float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)
{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)
{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)
{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)
{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)
{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)
{
#ifdef LIGHTING_3D_MODE
return mat.diffuseColor;
#else
return mat.diffuseColor/PI;
#endif
}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)
{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)
{vec3 env_light=vec3(0.65,0.65,0.65);
#ifdef LIGHTING_3D_MODE
float ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;
#endif
vec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)
{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;
#ifdef RENDER_SHADOWS
lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);
#else
lighting_factor=NdotL;
#endif
vec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;
#if !defined(LIGHTING_3D_MODE)
const vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);
#endif
color*=intensityFactor;return color;}void main() {
#ifdef TERRAIN_FRAGMENT_OCCLUSION
if (isOccluded()) {discard;}
#endif
vec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;
#ifdef LIGHTING_3D_MODE
lightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;
#endif
vec4 finalColor;
#ifdef DIFFUSE_SHADED
vec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);
#ifdef HAS_TEXTURE_u_occlusionTexture
float ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;
#endif
finalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;
#else
Material mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;
#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
#ifdef OCCLUSION_TEXTURE_TRANSFORM
vec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;
#else
vec2 uv=uv_2f;
#endif
ao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;
#endif
vec4 emissive=u_emissiveFactor;
#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
emissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);
#endif
#ifdef APPLY_LUT_ON_GPU
float emissiveFactorLength=max(length(u_emissiveFactor.rgb),0.001);emissive.rgb=sRGBToLinear(applyLUT(u_lutTexture,linearTosRGB(emissive.rgb/emissiveFactorLength).rbg))*emissiveFactorLength;
#endif
color+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;
#ifdef HAS_ATTRIBUTE_a_pbr
float resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);vec3 color_mix=v_color_mix.rgb;
#ifdef APPLY_LUT_ON_GPU
color_mix=applyLUT(u_lutTexture,color_mix);
#endif
color=mix(color,color_mix,min(1.0,resEmission));
#ifdef HAS_ATTRIBUTE_a_color_4f
float distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);
#endif
#endif
vec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);
#endif
#ifdef FOG
finalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));
#endif
#ifdef RENDER_CUTOFF
finalColor*=v_cutoff_opacity;
#endif
#ifdef INDICATOR_CUTOUT
finalColor=applyCutout(finalColor,v_position_height.w);
#endif
#ifdef FEATURE_CUTOUT
finalColor=apply_feature_cutout(finalColor,gl_FragCoord);
#endif
glFragColor=finalColor;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec3 a_pos_3f;
#pragma mapbox: define-attribute highp vec3 normal_3f
#pragma mapbox: define-attribute highp vec2 uv_2f
#pragma mapbox: define-attribute highp vec3 color_3f
#pragma mapbox: define-attribute highp vec4 color_4f
#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr
#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength
uniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;
#ifdef INSTANCED_ARRAYS
in vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;
#else
uniform highp mat4 u_normal_matrix;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;
#endif
out vec4 v_position_height;out lowp vec4 v_color_mix;
#ifdef TERRAIN_FRAGMENT_OCCLUSION
out highp float v_depth;
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
out lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;
#endif
vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {
#pragma mapbox: initialize-attribute highp vec3 normal_3f
#pragma mapbox: initialize-attribute highp vec2 uv_2f
#pragma mapbox: initialize-attribute highp vec3 color_3f
#pragma mapbox: initialize-attribute highp vec4 color_4f
#pragma mapbox: initialize-attribute-custom highp vec4 pbr
#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength
highp mat4 normal_matrix;
#ifdef INSTANCED_ARRAYS
normal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);
#else
normal_matrix=u_normal_matrix;
#endif
vec3 local_pos;mat3 rs;
#ifdef MODEL_POSITION_ON_GPU
vec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float hidden=float(pos_a.x > EXTENT);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=mix(u_matrix*pos,AWAY,hidden);pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;
#else
local_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);
#endif
v_position_height.w=a_pos_3f.z;
#ifdef HAS_ATTRIBUTE_a_pbr
vec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;
#endif
#ifdef FOG
v_fog_pos=fog_position(local_pos);
#endif
#ifdef RENDER_CUTOFF
v_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);
#endif
#ifdef TERRAIN_FRAGMENT_OCCLUSION
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef HAS_ATTRIBUTE_a_normal_3f
#ifdef MODEL_POSITION_ON_GPU
float x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);
#else
normal_3f=vec3(normal_matrix*vec4(normal_3f,0));
#endif
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
#ifdef HAS_ATTRIBUTE_a_color_4f
v_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);
#endif
#endif
#ifdef RENDER_SHADOWS
vec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);
#ifdef NORMAL_OFFSET
#ifdef HAS_ATTRIBUTE_a_normal_3f
#ifdef MODEL_POSITION_ON_GPU
vec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();
#else
vec3 offset=shadow_normal_offset_model(normal_3f);shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();
#endif
#endif
#endif
v_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;
#endif
}`),
                modelDepth: Oi(`in highp float v_depth;void main() {
#ifndef DEPTH_TEXTURE
glFragColor=pack_depth(v_depth);
#endif
}`, `in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;
#ifdef MODEL_POSITION_ON_GPU
#ifdef INSTANCED_ARRAYS
in vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;
#else
uniform highp mat4 u_instance;
#endif
uniform highp mat4 u_node_matrix;
#endif
void main() {
#ifdef MODEL_POSITION_ON_GPU
highp mat4 instance;
#ifdef INSTANCED_ARRAYS
instance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);
#else
instance=u_instance;
#endif
vec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float hidden=float(pos_a.x > EXTENT);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=mix(u_matrix*pos,AWAY,hidden);
#else
gl_Position=u_matrix*vec4(a_pos_3f,1);
#endif
v_depth=gl_Position.z/gl_Position.w;}`),
                stars: Oi(`in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)
{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}`, `
in vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}`),
                snowParticle: Oi("in highp vec2 uv;in highp float alphaMultiplier;uniform vec4 u_particleColor;uniform vec2 u_simpleShapeParameters;void main() {float t=clamp((length(uv)-u_simpleShapeParameters.x)/(1.0-u_simpleShapeParameters.x),0.0,1.0);float alpha=1.0-pow(t,pow(10.0,u_simpleShapeParameters.y));alpha*=alphaMultiplier;alpha*=u_particleColor.a;vec3 color=u_particleColor.rgb*alpha;glFragColor=vec4(color,alpha) ;HANDLE_WIREFRAME_DEBUG;}", `
in highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_snowParticleData;in highp vec4 a_snowParticleDataHorizontalOscillation;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform vec2 u_screenSize;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; 
uniform float u_velocity;uniform vec3 u_direction;uniform float u_horizontalOscillationRadius; 
uniform float u_horizontalOscillationRate; 
uniform float u_billboardSize;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;out highp vec2 uv;out highp float alphaMultiplier;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos.xyz*=halfBoxSize;pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_snowParticleData.z;float coneAngleHeadingRad=a_snowParticleData.w*radians(360.0);vec3 localZ=normalize(u_direction);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 direction;direction.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.z=cos(coneAnglePichRad);direction=normalize(direction);vec3 simPosLocal=vec3(0,0,0);float velocityScale=(1.0+3.0*a_snowParticleData.y)*u_velocity;simPosLocal+=direction*velocityScale*u_time;float horizontalOscillationRadius=u_horizontalOscillationRadius*a_snowParticleDataHorizontalOscillation.x;float horizontalOscillationAngle=u_horizontalOscillationRate*u_time*(-1.0+2.0*a_snowParticleDataHorizontalOscillation.y);simPosLocal.xy+=horizontalOscillationRadius*vec2(cos(horizontalOscillationAngle),sin(horizontalOscillationAngle));vec3 simPos=localX*simPosLocal.x+
localY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);float clipZ=-u_cam_pos.z+pos.z;vec4 posView=u_modelview*vec4(pos,1.0);float size=u_billboardSize;alphaMultiplier=1.0;vec4 posScreen=u_projection*posView;posScreen/=posScreen.w;posScreen.xy=vec2(0.5)+posScreen.xy*0.5;posScreen.xy*=u_screenSize;vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=u_screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-posScreen.xy)/(0.5*u_screenSize));screenDist+=a_snowParticleData.x*u_thinningParticleOffset;float scaleFactorMode=0.0;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);if (a_snowParticleData.x < u_thinningAffectedRatio) {scaleFactorMode=1.0-thinningFadeRatio;alphaMultiplier=thinningFadeRatio;}}vec4 posScreen1=u_projection*vec4(posView.x-size,posView.yzw);posScreen1/=posScreen1.w;vec4 posScreen2=u_projection*vec4(posView.x+size,posView.yzw);posScreen2/=posScreen2.w;posScreen1.xy=vec2(0.5)+posScreen1.xy*0.5;posScreen1.xy*=u_screenSize;posScreen2.xy=vec2(0.5)+posScreen2.xy*0.5;posScreen2.xy*=u_screenSize;float screenLength=length(posScreen1.xy-posScreen2.xy);float screenEpsilon=3.0;float scaleFactor=1.0;if (screenLength < screenEpsilon) {scaleFactor=screenEpsilon/max(screenLength,0.01);scaleFactor=mix(scaleFactor,1.0,scaleFactorMode);}float screenEpsilon2=15.0;if (screenLength > screenEpsilon2) {scaleFactor=screenEpsilon2/max(screenLength,0.01);}size*=scaleFactor;vec2 right=size*vec2(1,0);vec2 up=size*vec2(0,1);posView.xy+=right*a_uv.x;posView.xy+=up*a_uv.y;uv=a_uv;gl_Position=u_projection*posView;}`),
                rainParticle: Oi("in highp vec2 uv;in highp float particleRandomValue;uniform sampler2D u_texScreen;uniform float u_distortionStrength;uniform vec4 u_color;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;uniform float u_shapeDirectionalPower;uniform float u_mode;void main() {vec2 st=uv*0.5+vec2(0.5);vec2 uvm=uv;uvm.y=-1.0+2.0*pow(st.y,u_shapeDirectionalPower);float shape=clamp(1.0-length(uvm),0.0,1.0);float alpha=abs(shape)*u_color.a;vec2 screenSize=vec2(textureSize(u_texScreen,0));vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-gl_FragCoord.xy)/(0.5*screenSize));screenDist+=(0.5+0.5*particleRandomValue)*u_thinningParticleOffset;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;float thinningAlpha=1.0;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);thinningAlpha*=thinningFadeRatio;}vec2 offsetXY=normalize(uvm)*abs(shape);vec2 stScreen=(gl_FragCoord.xy+offsetXY*u_distortionStrength*thinningAlpha)/screenSize;vec3 colorScreen=texture(u_texScreen,stScreen).rgb;alpha*=thinningAlpha;glFragColor=mix(vec4(colorScreen,1.0),vec4(u_color.rgb*alpha,alpha),u_mode);HANDLE_WIREFRAME_DEBUG;}", `
in highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_rainParticleData;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; 
uniform float u_velocity; 
uniform vec2 u_rainDropletSize;uniform vec3 u_rainDirection;out highp vec2 uv;out highp float particleRandomValue;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos*=halfBoxSize; 
pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_rainParticleData.z;float coneAngleHeadingRad=a_rainParticleData.w*radians(360.0);vec3 localZ=normalize(u_rainDirection);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 directionLocal;directionLocal.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.z=cos(coneAnglePichRad);directionLocal=normalize(directionLocal);vec3 directionWorld=localX*directionLocal.x+localY*directionLocal.y+localZ*directionLocal.z;float velocityScale=(1.0+3.0*a_rainParticleData.y)*u_velocity;vec3 simPosLocal=vec3(0,0,0);simPosLocal+=directionLocal*velocityScale*u_time;vec3 simPos=localX*simPosLocal.x+
localY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);vec4 posView=u_modelview*vec4(pos,1.0);vec3 directionView=normalize((u_modelview*vec4(directionWorld,0.0)).xyz);vec3 side=cross(directionView,normalize(posView.xyz));posView.xyz+=side*a_uv.x*u_rainDropletSize.x;posView.xyz+=directionView*a_uv.y*u_rainDropletSize.y;uv=a_uv;particleRandomValue=a_rainParticleData.x;gl_Position=u_projection*posView;}`),
                vignette: Oi("uniform vec3 u_vignetteShape;uniform vec4 u_vignetteColor;in vec2 st;void main() {float screenDist=length(st);float alpha=clamp((screenDist-u_vignetteShape.x)/u_vignetteShape.y,0.0,1.0);alpha=pow(alpha,u_vignetteShape.z)*u_vignetteColor.a;vec3 color=u_vignetteColor.rgb;glFragColor=vec4(color*alpha,alpha) ;}", "in vec2 a_pos_2f;out vec2 st;void main() {st=a_pos_2f;gl_Position=vec4(a_pos_2f,0,1);}"),
                occlusion: Oi("uniform vec4 u_color;void main() {glFragColor=u_color;}", `#include "_prelude_terrain.vertex.glsl"
in highp vec2 a_offset_xy;uniform highp vec3 u_anchorPos;uniform mat4 u_matrix;uniform vec2 u_screenSizePx;uniform vec2 u_occluderSizePx;void main() {vec3 world_pos=u_anchorPos;
#ifdef TERRAIN
float e=elevation(world_pos.xy);world_pos.z+=e;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1.0);projected_point.xy+=projected_point.w*a_offset_xy*0.5*u_occluderSizePx/u_screenSizePx;gl_Position=projected_point;}`)
            };

            function Fs(u, t) {
                const s = u.replace(/\s*\/\/[^\n]*\n/g, `
`).split(`
`);
                for (let h of s) if (h = h.trim(), h[0] === "#" && h.includes("if") && !h.includes("endif")) {
                    h = h.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
                    const m = h.split(" ");
                    for (const g of m) t.includes(g) || t.push(g)
                }
            }

            function Oi(u, t) {
                const s = /#include\s+"([^"]+)"/g, h = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
                let m = t.match(/(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm);
                m && (m = m.map(P => {
                    const M = P.split(" ");
                    return M[M.length - 1]
                }), m = [...new Set(m)]);
                const g = {}, v = [], b = [];
                if (u = u.replace(s, (P, M) => (b.push(M), "")), (t = t.replace(s, (P, M) => (v.push(M), ""))).includes("flat out")) return void console.error('The usage of "flat" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071');
                let S = [...hh];
                Fs(u, S), Fs(t, S);
                for (const P of [...v, ...b]) jl[P] || console.error(`Undefined include: ${P}`), ws[P] || (ws[P] = [], Fs(jl[P], ws[P])), S = [...S, ...ws[P]];
                return {
                    fragmentSource: u = u.replace(h, (P, M, k, R, O) => (g[O] = !0, M === "define" ? `
#ifndef HAS_UNIFORM_u_${O}
in ${k} ${R} ${O};
#else
uniform ${k} ${R} u_${O};
#endif
` : M === "initialize" ? `
#ifdef HAS_UNIFORM_u_${O}
    ${k} ${R} ${O} = u_${O};
#endif
` : M === "define-attribute" ? `
#ifdef HAS_ATTRIBUTE_a_${O}
    in ${k} ${R} ${O};
#endif
` : M === "initialize-attribute" ? "" : void 0)), vertexSource: t = t.replace(h, (P, M, k, R, O) => {
                        const V = R === "float" ? "vec2" : R, B = O.match(/color/) ? "color" : V;
                        return M === "define-attribute-vertex-shader-only" ? `
#ifdef HAS_ATTRIBUTE_a_${O}
in ${k} ${R} a_${O};
#endif
` : g[O] ? M === "define" ? `
#ifndef HAS_UNIFORM_u_${O}
uniform lowp float u_${O}_t;
in ${k} ${V} a_${O};
out ${k} ${R} ${O};
#else
uniform ${k} ${R} u_${O};
#endif
` : M === "initialize" ? B === "vec4" ? `
#ifndef HAS_UNIFORM_u_${O}
    ${O} = a_${O};
#else
    ${k} ${R} ${O} = u_${O};
#endif
` : `
#ifndef HAS_UNIFORM_u_${O}
    ${O} = unpack_mix_${B}(a_${O}, u_${O}_t);
#else
    ${k} ${R} ${O} = u_${O};
#endif
` : M === "define-attribute" ? `
#ifdef HAS_ATTRIBUTE_a_${O}
    in ${k} ${R} a_${O};
    out ${k} ${R} ${O};
#endif
` : M === "initialize-attribute" ? `
#ifdef HAS_ATTRIBUTE_a_${O}
    ${O} = a_${O};
#endif
` : void 0 : M === "define" ? `
#ifndef HAS_UNIFORM_u_${O}
uniform lowp float u_${O}_t;
in ${k} ${V} a_${O};
#else
uniform ${k} ${R} u_${O};
#endif
` : M === "define-instanced" ? B === "mat4" ? `
#ifdef INSTANCED_ARRAYS
in vec4 a_${O}0;
in vec4 a_${O}1;
in vec4 a_${O}2;
in vec4 a_${O}3;
#else
uniform ${k} ${R} u_${O};
#endif
` : `
#ifdef INSTANCED_ARRAYS
in ${k} ${V} a_${O};
#else
uniform ${k} ${R} u_${O};
#endif
` : M === "initialize-attribute-custom" ? `
#ifdef HAS_ATTRIBUTE_a_${O}
    ${k} ${R} ${O} = a_${O};
#endif
` : B === "vec4" ? `
#ifndef HAS_UNIFORM_u_${O}
    ${k} ${R} ${O} = a_${O};
#else
    ${k} ${R} ${O} = u_${O};
#endif
` : `
#ifndef HAS_UNIFORM_u_${O}
    ${k} ${R} ${O} = unpack_mix_${B}(a_${O}, u_${O}_t);
#else
    ${k} ${R} ${O} = u_${O};
#endif
`
                    }), staticAttributes: m, usedDefines: S, vertexIncludes: v, fragmentIncludes: b
                }
            }

            class Hx {
                constructor() {
                    this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null
                }

                bind(t, s, h, m, g, v, b, S) {
                    this.context = t;
                    let P = this.boundPaintVertexBuffers.length !== m.length;
                    for (let k = 0; !P && k < m.length; k++) this.boundPaintVertexBuffers[k] !== m[k] && (P = !0);
                    let M = this.boundDynamicVertexBuffers.length !== b.length;
                    for (let k = 0; !M && k < b.length; k++) this.boundDynamicVertexBuffers[k] !== b[k] && (M = !0);
                    if (!this.vao || this.boundProgram !== s || this.boundLayoutVertexBuffer !== h || P || M || this.boundIndexBuffer !== g || this.boundVertexOffset !== v) this.freshBind(s, h, m, g, v, b, S); else {
                        t.bindVertexArrayOES.set(this.vao);
                        for (const k of b) k && (k.bind(), S && k.instanceCount && k.setVertexAttribDivisor(t.gl, s, S));
                        g && g.dynamicDraw && g.bind()
                    }
                }

                freshBind(t, s, h, m, g, v, b) {
                    const S = t.numAttributes, P = this.context, M = P.gl;
                    this.vao && this.destroy(), this.vao = P.gl.createVertexArray(), P.bindVertexArrayOES.set(this.vao), this.boundProgram = t, this.boundLayoutVertexBuffer = s, this.boundPaintVertexBuffers = h, this.boundIndexBuffer = m, this.boundVertexOffset = g, this.boundDynamicVertexBuffers = v, s.enableAttributes(M, t), s.bind(), s.setVertexAttribPointers(M, t, g);
                    for (const k of h) k.enableAttributes(M, t), k.bind(), k.setVertexAttribPointers(M, t, g);
                    for (const k of v) k && (k.enableAttributes(M, t), k.bind(), k.setVertexAttribPointers(M, t, g), b && k.instanceCount && k.setVertexAttribDivisor(M, t, b));
                    m && m.bind(), P.currentNumAttributes = S
                }

                destroy() {
                    this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null)
                }
            }

            function Up(u, t) {
                const s = Math.pow(2, t.canonical.z), h = t.canonical.y;
                return [new o.ac(0, h / s).toLngLat().lat, new o.ac(0, (h + 1) / s).toLngLat().lat]
            }

            function qx(u, t, s, h, m, g, v) {
                const b = u.context, S = b.gl, P = s.hillshadeFBO;
                if (!P) return;
                u.prepareDrawTile();
                const M = u.isTileAffectedByFog(t), k = u.getOrCreateProgram("hillshade", {overrideFog: M});
                b.activeTexture.set(S.TEXTURE0), S.bindTexture(S.TEXTURE_2D, P.colorAttachment.get());
                const R = ((G, U, Z, Q) => {
                    const te = Z.paint.get("hillshade-shadow-color"),
                        ce = Z.paint.get("hillshade-shadow-color-use-theme").constantOr("default") === "none",
                        _e = Z.paint.get("hillshade-highlight-color"),
                        ve = Z.paint.get("hillshade-highlight-color-use-theme").constantOr("default") === "none",
                        ue = Z.paint.get("hillshade-accent-color"),
                        he = Z.paint.get("hillshade-accent-color-use-theme").constantOr("default") === "none",
                        me = Z.paint.get("hillshade-emissive-strength");
                    let Oe = o.al(Z.paint.get("hillshade-illumination-direction"));
                    if (Z.paint.get("hillshade-illumination-anchor") === "viewport") Oe -= G.transform.angle; else if (G.style && G.style.enable3dLights() && G.style.directionalLight) {
                        const Xe = G.style.directionalLight.properties.get("direction"), je = o.d1(Xe.x, Xe.y, Xe.z);
                        Oe = o.al(je[1])
                    }
                    const Se = !G.options.moving;
                    return {
                        u_matrix: Q || G.transform.calculateProjMatrix(U.tileID.toUnwrapped(), Se),
                        u_image: 0,
                        u_latrange: Up(0, U.tileID),
                        u_light: [Z.paint.get("hillshade-exaggeration"), Oe],
                        u_shadow: te.toPremultipliedRenderColor(ce ? null : Z.lut),
                        u_highlight: _e.toPremultipliedRenderColor(ve ? null : Z.lut),
                        u_emissive_strength: me,
                        u_accent: ue.toPremultipliedRenderColor(he ? null : Z.lut)
                    }
                })(u, s, h, u.terrain ? t.projMatrix : null);
                u.uploadCommonUniforms(b, k, t.toUnwrapped());
                const {
                    tileBoundsBuffer: O,
                    tileBoundsIndexBuffer: V,
                    tileBoundsSegments: B
                } = u.getTileBoundsBuffers(s);
                k.draw(u, S.TRIANGLES, m, g, v, Yt.disabled, R, h.id, O, V, B)
            }

            function Gp(u, t, s) {
                if (!t.needsDEMTextureUpload) return;
                const h = u.context, m = h.gl;
                h.pixelStoreUnpackPremultiplyAlpha.set(!1), t.demTexture = t.demTexture || u.getTileTexture(s.stride);
                const g = s.getPixels();
                t.demTexture ? t.demTexture.update(g, {premultiply: !1}) : t.demTexture = new o.T(h, g, m.R32F, {premultiply: !1}), t.needsDEMTextureUpload = !1
            }

            function Z_(u, t, s) {
                const h = u.context, m = h.gl;
                if (!t.dem) return;
                const g = t.dem;
                if (h.activeTexture.set(m.TEXTURE1), Gp(u, t, g), !t.demTexture) return;
                t.demTexture.bind(m.NEAREST, m.CLAMP_TO_EDGE);
                const v = g.dim;
                h.activeTexture.set(m.TEXTURE0);
                let b = t.hillshadeFBO;
                if (!b) {
                    const R = new o.T(h, {width: v, height: v, data: null}, m.RGBA8);
                    R.bind(m.LINEAR, m.CLAMP_TO_EDGE), b = t.hillshadeFBO = h.createFramebuffer(v, v, !0, "renderbuffer"), b.colorAttachment.set(R.texture)
                }
                h.bindFramebuffer.set(b.framebuffer), h.viewport.set([0, 0, v, v]);
                const {
                    tileBoundsBuffer: S,
                    tileBoundsIndexBuffer: P,
                    tileBoundsSegments: M
                } = u.getMercatorTileBoundsBuffers(), k = [];
                u.linearFloatFilteringSupported() && k.push("TERRAIN_DEM_FLOAT_FORMAT"), u.getOrCreateProgram("hillshadePrepare", {defines: k}).draw(u, m.TRIANGLES, It.disabled, ei.disabled, gi.unblended, Yt.disabled, ((R, O) => {
                    const V = O.stride, B = o.bz();
                    return o.ca(B, 0, o.aj, -o.aj, 0, 0, 1), o.bo(B, B, [0, -o.aj, 0]), {
                        u_matrix: B,
                        u_image: 1,
                        u_dimension: [V, V],
                        u_zoom: R.overscaledZ
                    }
                })(t.tileID, g), s.id, S, P, M), t.needsHillshadePrepare = !1
            }

            class zn {
                constructor(t) {
                    this.gl = t.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1
                }

                get() {
                    return this.current
                }

                set(t) {
                }

                getDefault() {
                    return this.default
                }

                setDefault() {
                    this.set(this.default)
                }
            }

            class Wx extends zn {
                getDefault() {
                    return o.am.transparent.toNonPremultipliedRenderColor(null)
                }

                set(t) {
                    const s = this.current;
                    (t.r !== s.r || t.g !== s.g || t.b !== s.b || t.a !== s.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1)
                }
            }

            class Zx extends zn {
                getDefault() {
                    return 1
                }

                set(t) {
                    (t !== this.current || this.dirty) && (this.gl.clearDepth(t), this.current = t, this.dirty = !1)
                }
            }

            class Xx extends zn {
                getDefault() {
                    return 0
                }

                set(t) {
                    (t !== this.current || this.dirty) && (this.gl.clearStencil(t), this.current = t, this.dirty = !1)
                }
            }

            class Yx extends zn {
                getDefault() {
                    return [!0, !0, !0, !0]
                }

                set(t) {
                    const s = this.current;
                    (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || t[3] !== s[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1)
                }
            }

            class X_ extends zn {
                getDefault() {
                    return !0
                }

                set(t) {
                    (t !== this.current || this.dirty) && (this.gl.depthMask(t), this.current = t, this.dirty = !1)
                }
            }

            class Kx extends zn {
                getDefault() {
                    return 255
                }

                set(t) {
                    (t !== this.current || this.dirty) && (this.gl.stencilMask(t), this.current = t, this.dirty = !1)
                }
            }

            class Ad extends zn {
                getDefault() {
                    return {func: this.gl.ALWAYS, ref: 0, mask: 255}
                }

                set(t) {
                    const s = this.current;
                    (t.func !== s.func || t.ref !== s.ref || t.mask !== s.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask), this.current = t, this.dirty = !1)
                }
            }

            class Qx extends zn {
                getDefault() {
                    const t = this.gl;
                    return [t.KEEP, t.KEEP, t.KEEP]
                }

                set(t) {
                    const s = this.current;
                    (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]), this.current = t, this.dirty = !1)
                }
            }

            class Y_ extends zn {
                getDefault() {
                    return !1
                }

                set(t) {
                    if (t === this.current && !this.dirty) return;
                    const s = this.gl;
                    t ? s.enable(s.STENCIL_TEST) : s.disable(s.STENCIL_TEST), this.current = t, this.dirty = !1
                }
            }

            class $p extends zn {
                getDefault() {
                    return [0, 1]
                }

                set(t) {
                    const s = this.current;
                    (t[0] !== s[0] || t[1] !== s[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]), this.current = t, this.dirty = !1)
                }
            }

            class Id extends zn {
                getDefault() {
                    return !1
                }

                set(t) {
                    if (t === this.current && !this.dirty) return;
                    const s = this.gl;
                    t ? s.enable(s.DEPTH_TEST) : s.disable(s.DEPTH_TEST), this.current = t, this.dirty = !1
                }
            }

            class Hp extends zn {
                getDefault() {
                    return this.gl.LESS
                }

                set(t) {
                    (t !== this.current || this.dirty) && (this.gl.depthFunc(t), this.current = t, this.dirty = !1)
                }
            }

            class Vl extends zn {
                getDefault() {
                    return !1
                }

                set(t) {
                    if (t === this.current && !this.dirty) return;
                    const s = this.gl;
                    t ? s.enable(s.BLEND) : s.disable(s.BLEND), this.current = t, this.dirty = !1
                }
            }

            class Mc extends zn {
                getDefault() {
                    const t = this.gl;
                    return [t.ONE, t.ZERO, t.ONE, t.ZERO]
                }

                set(t) {
                    const s = this.current;
                    (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || t[3] !== s[3] || this.dirty) && (this.gl.blendFuncSeparate(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1)
                }
            }

            class Cd extends zn {
                getDefault() {
                    return o.am.transparent.toNonPremultipliedRenderColor(null)
                }

                set(t) {
                    const s = this.current;
                    (t.r !== s.r || t.g !== s.g || t.b !== s.b || t.a !== s.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1)
                }
            }

            class Pd extends zn {
                getDefault() {
                    return this.gl.FUNC_ADD
                }

                set(t) {
                    (t !== this.current || this.dirty) && (this.gl.blendEquationSeparate(t, t), this.current = t, this.dirty = !1)
                }
            }

            class Rc extends zn {
                getDefault() {
                    return !1
                }

                set(t) {
                    if (t === this.current && !this.dirty) return;
                    const s = this.gl;
                    t ? s.enable(s.CULL_FACE) : s.disable(s.CULL_FACE), this.current = t, this.dirty = !1
                }
            }

            class K_ extends zn {
                getDefault() {
                    return this.gl.BACK
                }

                set(t) {
                    (t !== this.current || this.dirty) && (this.gl.cullFace(t), this.current = t, this.dirty = !1)
                }
            }

            class qp extends zn {
                getDefault() {
                    return this.gl.CCW
                }

                set(t) {
                    (t !== this.current || this.dirty) && (this.gl.frontFace(t), this.current = t, this.dirty = !1)
                }
            }

            let Q_ = class extends zn {
                getDefault() {
                    return null
                }

                set(u) {
                    (u !== this.current || this.dirty) && (this.gl.useProgram(u), this.current = u, this.dirty = !1)
                }
            };

            class zc extends zn {
                getDefault() {
                    return this.gl.TEXTURE0
                }

                set(t) {
                    (t !== this.current || this.dirty) && (this.gl.activeTexture(t), this.current = t, this.dirty = !1)
                }
            }

            class Md extends zn {
                getDefault() {
                    const t = this.gl;
                    return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight]
                }

                set(t) {
                    const s = this.current;
                    (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || t[3] !== s[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1)
                }
            }

            class Rd extends zn {
                getDefault() {
                    return null
                }

                set(t) {
                    if (t === this.current && !this.dirty) return;
                    const s = this.gl;
                    s.bindFramebuffer(s.FRAMEBUFFER, t), this.current = t, this.dirty = !1
                }
            }

            class Wp extends zn {
                getDefault() {
                    return null
                }

                set(t) {
                    if (t === this.current && !this.dirty) return;
                    const s = this.gl;
                    s.bindRenderbuffer(s.RENDERBUFFER, t), this.current = t, this.dirty = !1
                }
            }

            class zd extends zn {
                getDefault() {
                    return null
                }

                set(t) {
                    if (t === this.current && !this.dirty) return;
                    const s = this.gl;
                    s.bindTexture(s.TEXTURE_2D, t), this.current = t, this.dirty = !1
                }
            }

            class fh extends zn {
                getDefault() {
                    return null
                }

                set(t) {
                    if (t === this.current && !this.dirty) return;
                    const s = this.gl;
                    s.bindBuffer(s.ARRAY_BUFFER, t), this.current = t, this.dirty = !1
                }
            }

            class J_ extends zn {
                getDefault() {
                    return null
                }

                set(t) {
                    const s = this.gl;
                    s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, t), this.current = t, this.dirty = !1
                }
            }

            class ey extends zn {
                getDefault() {
                    return null
                }

                set(t) {
                    this.gl && (t !== this.current || this.dirty) && (this.gl.bindVertexArray(t), this.current = t, this.dirty = !1)
                }
            }

            class ty extends zn {
                getDefault() {
                    return 4
                }

                set(t) {
                    if (t === this.current && !this.dirty) return;
                    const s = this.gl;
                    s.pixelStorei(s.UNPACK_ALIGNMENT, t), this.current = t, this.dirty = !1
                }
            }

            class Dc extends zn {
                getDefault() {
                    return !1
                }

                set(t) {
                    if (t === this.current && !this.dirty) return;
                    const s = this.gl;
                    s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t), this.current = t, this.dirty = !1
                }
            }

            class iy extends zn {
                getDefault() {
                    return !1
                }

                set(t) {
                    if (t === this.current && !this.dirty) return;
                    const s = this.gl;
                    s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, t), this.current = t, this.dirty = !1
                }
            }

            class Zp extends zn {
                constructor(t, s) {
                    super(t), this.context = t, this.parent = s
                }

                getDefault() {
                    return null
                }
            }

            class Jx extends Zp {
                setDirty() {
                    this.dirty = !0
                }

                set(t) {
                    if (t === this.current && !this.dirty) return;
                    this.context.bindFramebuffer.set(this.parent);
                    const s = this.gl;
                    s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1
                }
            }

            class ny extends Zp {
                attachment() {
                    return this.gl.DEPTH_ATTACHMENT
                }

                set(t) {
                    if (t === this.current && !this.dirty) return;
                    this.context.bindFramebuffer.set(this.parent);
                    const s = this.gl;
                    s.framebufferRenderbuffer(s.FRAMEBUFFER, this.attachment(), s.RENDERBUFFER, t), this.current = t, this.dirty = !1
                }
            }

            class Xp extends Zp {
                attachment() {
                    return this.gl.DEPTH_ATTACHMENT
                }

                set(t) {
                    if (t === this.current && !this.dirty) return;
                    this.context.bindFramebuffer.set(this.parent);
                    const s = this.gl;
                    s.framebufferTexture2D(s.FRAMEBUFFER, this.attachment(), s.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1
                }
            }

            class Yp extends ny {
                attachment() {
                    return this.gl.DEPTH_STENCIL_ATTACHMENT
                }
            }

            const Kp = (u, t, s) => ({u_matrix: u, u_image0: 0, u_skirt_height: t, u_ground_shadow_factor: s}),
                Dd = (u, t, s, h, m, g, v, b, S, P, M, k, R, O, V, B) => ({
                    u_proj_matrix: Float32Array.from(u),
                    u_globe_matrix: t,
                    u_normalize_matrix: Float32Array.from(h),
                    u_merc_matrix: s,
                    u_zoom_transition: m,
                    u_merc_center: g,
                    u_image0: 0,
                    u_frustum_tl: v,
                    u_frustum_tr: b,
                    u_frustum_br: S,
                    u_frustum_bl: P,
                    u_globe_pos: M,
                    u_globe_radius: k,
                    u_viewport: R,
                    u_grid_matrix: B ? Float32Array.from(B) : new Float32Array(9),
                    u_skirt_height: O,
                    u_far_z_cutoff: V
                });

            function Qp(u, t) {
                return u != null && t != null && !(!u.hasData() || !t.hasData()) && u.demTexture != null && t.demTexture != null && u.tileID.key !== t.tileID.key
            }

            const Ul = new class {
                constructor() {
                    this.operations = {}
                }

                newMorphing(u, t, s, h, m) {
                    if (u in this.operations) {
                        const g = this.operations[u];
                        g.to.tileID.key !== s.tileID.key && (g.queued = s)
                    } else this.operations[u] = {startTime: h, phase: 0, duration: m, from: t, to: s, queued: null}
                }

                getMorphValuesForProxy(u) {
                    if (!(u in this.operations)) return null;
                    const t = this.operations[u];
                    return {from: t.from, to: t.to, phase: t.phase}
                }

                update(u) {
                    for (const t in this.operations) {
                        const s = this.operations[t];
                        for (s.phase = (u - s.startTime) / s.duration; s.phase >= 1 || !this._validOp(s);) if (!this._nextOp(s, u)) {
                            delete this.operations[t];
                            break
                        }
                    }
                }

                _nextOp(u, t) {
                    return !!u.queued && (u.from = u.to, u.to = u.queued, u.queued = null, u.phase = 0, u.startTime = t, !0)
                }

                _validOp(u) {
                    return u.from.hasData() && u.to.hasData()
                }
            }, ry = {0: null, 1: "TERRAIN_VERTEX_MORPHING"};

            function Lc(u, t, s) {
                if (t === 0) return 0;
                const h = t < 1 && s === 514 ? .25 / t : 1;
                return 6 * Math.pow(1.5, 22 - u) * Math.max(t, 1) * h
            }

            function ph(u, t) {
                const s = 1 << u.z;
                return !t && (u.x === 0 || u.x === s - 1) || u.y === 0 || u.y === s - 1
            }

            const Ld = u => ({u_matrix: u});

            function Io(u, t, s, h, m) {
                if (m > 0) {
                    const g = o.q.now(), v = (g - u.timeAdded) / m, b = t ? (g - t.timeAdded) / m : -1,
                        S = s.getSource(), P = h.coveringZoomLevel({tileSize: S.tileSize, roundZoom: S.roundZoom}),
                        M = !t || Math.abs(t.tileID.overscaledZ - P) > Math.abs(u.tileID.overscaledZ - P),
                        k = M && u.refreshedUponExpiration ? 1 : o.ay(M ? v : 1 - b, 0, 1);
                    return u.refreshedUponExpiration && v >= 1 && (u.refreshedUponExpiration = !1), t ? {
                        opacity: 1,
                        mix: 1 - k
                    } : {opacity: k, mix: 0}
                }
                return {opacity: 1, mix: 0}
            }

            class Jp extends Eo {
                constructor(t) {
                    const s = $u("mock-dem", {
                        type: "raster-dem",
                        maxzoom: t.transform.maxZoom
                    }, t.style.dispatcher, t.style);
                    super("mock-dem", s, !1), s.setEventedParent(this), this._sourceLoaded = !0
                }

                _loadTile(t, s) {
                    t.state = "loaded", s(null)
                }
            }

            class kd extends Eo {
                constructor(t) {
                    const s = $u("proxy", {type: "geojson", maxzoom: t.transform.maxZoom}, t.style.dispatcher, t.style);
                    super("proxy", s, !1), s.setEventedParent(this), this.map = this.getSource().map = t, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {}
                }

                update(t, s, h) {
                    if (t.freezeTileCoverage) return;
                    this.transform = t;
                    const m = t.coveringTiles({
                        tileSize: this._source.tileSize,
                        minzoom: this._source.minzoom,
                        maxzoom: this._source.maxzoom,
                        roundZoom: this._source.roundZoom,
                        reparseOverscaled: this._source.reparseOverscaled
                    }).reduce((g, v) => {
                        if (g[v.key] = "", !this._tiles[v.key]) {
                            const b = new zl(v, this._source.tileSize * v.overscaleFactor(), t.tileZoom, void 0, void 0, this._source.worldview);
                            b.state = "loaded", this._tiles[v.key] = b
                        }
                        return g
                    }, {});
                    for (const g in this._tiles) g in m || (this.freeFBO(g), this._tiles[g].unloadVectorData(), delete this._tiles[g])
                }

                freeFBO(t) {
                    const s = this.proxyCachedFBO[t];
                    if (s !== void 0) {
                        const h = Object.values(s);
                        this.renderCachePool.push(...h), delete this.proxyCachedFBO[t]
                    }
                }

                deallocRenderCache() {
                    this.renderCache.forEach(t => t.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {}
                }
            }

            class mh extends o.aM {
                constructor(t, s, h) {
                    super(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y), this.proxyTileKey = s, this.projMatrix = h
                }
            }

            class Od extends o.dF {
                constructor(t, s) {
                    super(), this._debugParams = {
                        sortTilesHiZFirst: !0,
                        disableRenderCache: !1
                    }, t.tp.registerParameter(this._debugParams, ["Terrain"], "sortTilesHiZFirst", {}, () => {
                        this._style.map.triggerRepaint()
                    }), t.tp.registerParameter(this._debugParams, ["Terrain"], "disableRenderCache", {}, () => {
                        this._style.map.triggerRepaint()
                    }), t.tp.registerButton(["Terrain"], "Invalidate Render Cache", () => {
                        this.invalidateRenderCache = !0, this._style.map.triggerRepaint()
                    }), this.painter = t, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
                    const [h, m, g] = function (S) {
                        const P = new o.ba, M = new o.a_, k = 131;
                        P.reserve(17161), M.reserve(33800);
                        const R = o.aj / 128, O = o.aj + R / 2, V = O + R;
                        for (let G = -R; G < V; G += R) for (let U = -R; U < V; U += R) {
                            const Z = U < 0 || U > O || G < 0 || G > O ? 24575 : 0, Q = o.ay(Math.round(U), 0, o.aj),
                                te = o.ay(Math.round(G), 0, o.aj);
                            P.emplaceBack(Q + Z, te)
                        }
                        const B = (G, U) => {
                            const Z = U * k + G;
                            M.emplaceBack(Z + 1, Z, Z + k), M.emplaceBack(Z + k, Z + k + 1, Z + 1)
                        };
                        for (let G = 1; G < 129; G++) for (let U = 1; U < 129; U++) B(U, G);
                        return [0, 129].forEach(G => {
                            for (let U = 0; U < 130; U++) B(U, G), B(G, U)
                        }), [P, M, 32768]
                    }(), v = t.context;
                    this.gridBuffer = v.createVertexBuffer(h, o.bc.members), this.gridIndexBuffer = v.createIndexBuffer(m), this.gridSegments = o.bd.simpleSegment(0, 0, h.length, m.length), this.gridNoSkirtSegments = o.bd.simpleSegment(0, 0, h.length, g), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new kd(s.map), this.orthoMatrix = o.bz(), o.ca(this.orthoMatrix, this.painter.transform.projection.name === "globe" ? .015 : 0, o.aj, 0, o.aj, 0, 1);
                    const b = v.gl;
                    this._overlapStencilMode = new ei({
                        func: b.GEQUAL,
                        mask: 255
                    }, 0, 255, b.KEEP, b.KEEP, b.REPLACE), this._previousZoom = t.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = s, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new Jp(s.map), this._pendingGroundEffectLayers = []
                }

                set style(t) {
                    t.on("data", this._onStyleDataEvent.bind(this)), this._style = t, this._style.map.on("moveend", () => {
                        this._clearLineLayersFromRenderCache()
                    })
                }

                update(t, s, h) {
                    if (t && t.terrain) {
                        this._style !== t && (this.style = t, this._evaluationZoom = void 0);
                        const m = t.terrain.properties, g = t.terrain.drapeRenderMode === 0,
                            v = t.terrain.isZoomDependent();
                        this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = o.q.now();
                        const b = t.terrain && t.terrain.scope, S = m.get("source"),
                            P = g ? this._mockSourceCache : t.getSourceCache(S, b);
                        if (!P) return void o.w(`Couldn't find terrain source "${S}".`);
                        if (this.sourceCache = P, this._attenuationRange = t.terrain.getAttenuationRange(), this._exaggeration = v ? this.calculateExaggeration(s) : m.get("exaggeration"), !s.projection.requiresDraping && v && this._exaggeration === 0) return void this._disable();
                        this.enabled = !0;
                        const M = () => {
                            this.sourceCache.used && o.w(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                            const k = this.getScaledDemTileSize();
                            this.sourceCache.update(s, k, !0), this.resetTileLookupCache(this.sourceCache.id)
                        };
                        this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, M(), this._initializing = !0), M(), s.updateElevation(!0, h), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(s), this._emptyDEMTextureDirty = !0, this._previousZoom = s.zoom
                    } else this._disable()
                }

                calculateExaggeration(t) {
                    if (this._attenuationRange && t.zoom >= Math.ceil(this._attenuationRange[1])) return this._style.terrain.getExaggeration(t.zoom);
                    const s = this._previousCameraAltitude,
                        h = t.getFreeCameraOptions().position.z / t.pixelsPerMeter * t.worldSize;
                    this._previousCameraAltitude = h;
                    const m = s != null ? h - s : Number.MAX_VALUE;
                    if (Math.abs(m) < 2) return this._exaggeration;
                    const g = t.zoom, v = this._style.terrain;
                    if (!this._previousUpdateTimestamp) return v.getExaggeration(g);
                    let b = g - this._previousZoom;
                    const S = this._previousUpdateTimestamp;
                    let P = g;
                    this._evaluationZoom != null && (P = this._evaluationZoom, Math.abs(g - P) > .5 && (b = .5 * (g - P + b)), b * m < 0 && (P += b)), this._evaluationZoom = P;
                    const M = v.getExaggeration(P), k = M === v.getExaggeration(Math.max(0, P - .1));
                    if (k && Math.abs(M - this._exaggeration) < .01) return M;
                    let R = Math.min(.1, .00375 * (this._updateTimestamp - S));
                    return (k || M < .1 || Math.abs(b) < 1e-4) && (R = Math.min(.2, 4 * R)), o.ai(this._exaggeration, M, R)
                }

                resetTileLookupCache(t) {
                    this._findCoveringTileCache[t] = {}
                }

                attenuationRange() {
                    return this._attenuationRange
                }

                getDemUpscale() {
                    return this.proxySourceCache.getSource().tileSize / 128
                }

                getScaledDemTileSize() {
                    return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize
                }

                _onStyleDataEvent(t) {
                    t.coord && t.dataType === "source" ? this._clearRenderCacheForTile(t.sourceCacheId, t.coord) : t.dataType === "style" && (this.invalidateRenderCache = !0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0)
                }

                _disable() {
                    if (this.enabled && (this.enabled = !1, this._emptyDEMTextureDirty = !0, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for (const t in this._style._mergedSourceCaches) this._style._mergedSourceCaches[t].usedForTerrain = !1
                }

                destroy() {
                    this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this.pool.forEach(t => t.fb.destroy()), this.pool = [], this.framebufferCopyTexture && this.framebufferCopyTexture.destroy()
                }

                _source() {
                    return this.enabled ? this.sourceCache : null
                }

                isUsingMockSource() {
                    return this.sourceCache === this._mockSourceCache
                }

                exaggeration() {
                    return this.enabled ? this._exaggeration : 0
                }

                get visibleDemTiles() {
                    return this._visibleDemTiles
                }

                get drapeBufferSize() {
                    const t = 2 * this.proxySourceCache.getSource().tileSize;
                    return [t, t]
                }

                set useVertexMorphing(t) {
                    this._useVertexMorphing = t
                }

                updateTileBinding(t) {
                    if (!this.enabled) return;
                    this.prevTerrainTileForTile = this.terrainTileForTile;
                    const s = this.proxySourceCache, h = this.painter.transform;
                    this._initializing && (this._initializing = h._centerAltitude === 0 && this.getAtPointOrZero(o.ac.fromLngLat(h.center), -1) === -1, this._emptyDEMTextureDirty = !this._initializing);
                    const m = this.proxyCoords = s.getIds().map(S => {
                        const P = s.getTileByID(S).tileID;
                        return P.projMatrix = h.calculateProjMatrix(P.toUnwrapped()), P
                    });
                    (function (S, P) {
                        const M = P.transform.pointCoordinate(P.transform.getCameraPoint()), k = new o.P(M.x, M.y);
                        S.sort((R, O) => {
                            if (O.overscaledZ - R.overscaledZ) return O.overscaledZ - R.overscaledZ;
                            const V = new o.P(R.canonical.x + (1 << R.canonical.z) * R.wrap, R.canonical.y),
                                B = new o.P(O.canonical.x + (1 << O.canonical.z) * O.wrap, O.canonical.y),
                                G = k.mult(1 << R.canonical.z);
                            return G.x -= .5, G.y -= .5, G.distSqr(V) - G.distSqr(B)
                        })
                    })(m, this.painter);
                    const g = this.proxyToSource || {};
                    this.proxyToSource = {}, m.forEach(S => {
                        this.proxyToSource[S.key] = {}
                    }), this.terrainTileForTile = {};
                    const v = this._style._mergedSourceCaches;
                    for (const S in v) {
                        const P = v[S];
                        if (!P.used || (P !== this.sourceCache && this.resetTileLookupCache(P.id), this._setupProxiedCoordsForOrtho(P, t[S], g), P.usedForTerrain)) continue;
                        const M = t[S];
                        P.getSource().reparseOverscaled && this._assignTerrainTiles(M)
                    }
                    this.proxiedCoords[s.id] = m.map(S => new mh(S, S.key, this.orthoMatrix)), this._assignTerrainTiles(m), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(g), this.renderingToTexture = !1;
                    const b = {};
                    this._visibleDemTiles = [];
                    for (const S of this.proxyCoords) {
                        const P = this.terrainTileForTile[S.key];
                        if (!P) continue;
                        const M = P.tileID.key;
                        M in b || (this._visibleDemTiles.push(P), b[M] = M)
                    }
                }

                _assignTerrainTiles(t) {
                    this._initializing || t.forEach(s => {
                        if (this.terrainTileForTile[s.key]) return;
                        const h = this._findTileCoveringTileID(s, this.sourceCache);
                        h && (this.terrainTileForTile[s.key] = h)
                    })
                }

                _prepareDEMTextures() {
                    const t = this.painter.context, s = t.gl;
                    for (const h in this.terrainTileForTile) {
                        const m = this.terrainTileForTile[h], g = m.dem;
                        !g || m.demTexture && !m.needsDEMTextureUpload || (t.activeTexture.set(s.TEXTURE1), Gp(this.painter, m, g))
                    }
                }

                _prepareDemTileUniforms(t, s, h, m) {
                    if (!s || s.demTexture == null) return !1;
                    const g = t.tileID.canonical, v = Math.pow(2, s.tileID.canonical.z - g.z), b = m || "";
                    return h[`u_dem_tl${b}`] = [g.x * v % 1, g.y * v % 1], h[`u_dem_scale${b}`] = v, !0
                }

                get emptyDEMTexture() {
                    return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture()
                }

                _getLoadedAreaMinimum() {
                    if (!this.enabled) return 0;
                    let t = 0;
                    const s = this._visibleDemTiles.reduce((h, m) => {
                        if (!m.dem) return h;
                        const g = m.dem.tree.minimums[0];
                        return g > 0 && t++, h + g
                    }, 0);
                    return t ? s / t : 0
                }

                _updateEmptyDEMTexture() {
                    const t = this.painter.context, s = t.gl;
                    t.activeTexture.set(s.TEXTURE2);
                    const h = this._getLoadedAreaMinimum(), m = new o.dG({width: 1, height: 1}, new Float32Array([h]));
                    this._emptyDEMTextureDirty = !1;
                    let g = this._emptyDEMTexture;
                    return g ? g.update(m, {premultiply: !1}) : g = this._emptyDEMTexture = new o.T(t, m, s.R32F, {premultiply: !1}), g
                }

                setupElevationDraw(t, s, h) {
                    const m = this.painter.context, g = m.gl, v = {
                        u_dem: 2,
                        u_dem_prev: 4,
                        u_dem_tl: [0, 0],
                        u_dem_tl_prev: [0, 0],
                        u_dem_scale: 0,
                        u_dem_scale_prev: 0,
                        u_dem_size: 0,
                        u_dem_lerp: 1,
                        u_depth: 3,
                        u_depth_size_inv: [0, 0],
                        u_depth_range_unpack: [0, 1],
                        u_occluder_half_size: 16,
                        u_occlusion_depth_offset: -1e-4,
                        u_exaggeration: 0
                    };
                    v.u_exaggeration = this.exaggeration();
                    let b = null, S = null, P = 1;
                    if (h && h.morphing && this._useVertexMorphing) {
                        const O = h.morphing.srcDemTile, V = h.morphing.dstDemTile;
                        P = h.morphing.phase, O && V && (this._prepareDemTileUniforms(t, O, v, "_prev") && (S = O), this._prepareDemTileUniforms(t, V, v) && (b = V))
                    }
                    const M = O => O && O.demTexture && this.painter.linearFloatFilteringSupported() ? g.LINEAR : g.NEAREST;
                    let k = null;
                    var R;
                    if (this.enabled ? S && b ? (k = b.demTexture, m.activeTexture.set(g.TEXTURE4), S.demTexture.bind(M(S), g.CLAMP_TO_EDGE), v.u_dem_lerp = P) : (b = this.terrainTileForTile[t.tileID.key], k = this._prepareDemTileUniforms(t, b, v) ? b.demTexture : this.emptyDEMTexture) : k = this.emptyDEMTexture, m.activeTexture.set(g.TEXTURE2), k && (v.u_dem_size = (R = k).size[0] === 1 ? 1 : R.size[0] - 2, k.bind(M(b), g.CLAMP_TO_EDGE)), this.painter.setupDepthForOcclusion(h && h.useDepthForOcclusion, s, v), h && h.useMeterToDem && b) {
                        const O = (1 << b.tileID.canonical.z) * o.cb(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
                        v.u_meter_to_dem = O
                    }
                    if (h && h.labelPlaneMatrixInv && (v.u_label_plane_matrix_inv = h.labelPlaneMatrixInv), s.setTerrainUniformValues(m, v), this.painter.transform.projection.name === "globe") {
                        const O = this.globeUniformValues(this.painter.transform, t.tileID.canonical, h && h.useDenormalizedUpVectorScale);
                        s.setGlobeUniformValues(m, O)
                    }
                }

                globeUniformValues(t, s, h) {
                    const m = t.projection;
                    return {
                        u_tile_tl_up: m.upVector(s, 0, 0),
                        u_tile_tr_up: m.upVector(s, o.aj, 0),
                        u_tile_br_up: m.upVector(s, o.aj, o.aj),
                        u_tile_bl_up: m.upVector(s, 0, o.aj),
                        u_tile_up_scale: h ? o.dH(1) : m.upVectorScale(s, t.center.lat, t.worldSize).metersToTile
                    }
                }

                renderToBackBuffer(t) {
                    const s = this.painter, h = this.painter.context;
                    t.length !== 0 && (h.bindFramebuffer.set(null), h.viewport.set([0, 0, s.width, s.height]), s.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, function (m, g, v, b, S) {
                        if (m.transform.projection.name === "globe") (function (P, M, k, R, O) {
                            const V = P.context, B = V.gl;
                            let G, U;
                            const Z = P.transform, Q = o.dy(P, V, Z), te = (Xe, je) => {
                                if (U === je) return;
                                const Ke = [ry[je], "PROJECTION_GLOBE_VIEW"];
                                Q && Ke.push("CUSTOM_ANTIALIASING");
                                const ut = P.isTileAffectedByFog(Xe);
                                G = P.getOrCreateProgram("globeRaster", {defines: Ke, overrideFog: ut}), U = je
                            }, ce = P.colorModeForRenderPass(), _e = new It(B.LEQUAL, It.ReadWrite, P.depthRangeFor3D);
                            Ul.update(O);
                            const ve = o.dz(Z), ue = [o.aD(Z.center.lng), o.aH(Z.center.lat)],
                                he = P.globeSharedBuffers,
                                me = [Z.width * o.q.devicePixelRatio, Z.height * o.q.devicePixelRatio],
                                Oe = Float32Array.from(Z.globeMatrix), Se = {useDenormalizedUpVectorScale: !0};
                            {
                                const Xe = P.transform,
                                    je = Lc(Xe.zoom, M.exaggeration(), M.sourceCache._source.tileSize);
                                U = -1;
                                const Ke = B.TRIANGLES;
                                for (const ut of R) {
                                    const Fe = k.getTile(ut), Te = ei.disabled, $e = M.prevTerrainTileForTile[ut.key],
                                        Be = M.terrainTileForTile[ut.key];
                                    Qp($e, Be) && Ul.newMorphing(ut.key, $e, Be, O, 250), V.activeTexture.set(B.TEXTURE0), Fe.texture && Fe.texture.bind(B.LINEAR, B.CLAMP_TO_EDGE);
                                    const tt = Ul.getMorphValuesForProxy(ut.key), it = tt ? 1 : 0;
                                    tt && o.L(Se, {
                                        morphing: {
                                            srcDemTile: tt.from,
                                            dstDemTile: tt.to,
                                            phase: o.dx(tt.phase)
                                        }
                                    });
                                    const rt = o.dA(ut.canonical), gt = o.dB(rt.getCenter().lat),
                                        Ot = o.dC(ut.canonical, rt, gt, Xe.worldSize / Xe._pixelsPerMercatorPixel),
                                        Ut = o.bh(o.dD(ut.canonical)),
                                        St = Dd(Xe.expandedFarZProjMatrix, Oe, ve, Ut, o.ah(Xe.zoom), ue, Xe.frustumCorners.TL, Xe.frustumCorners.TR, Xe.frustumCorners.BR, Xe.frustumCorners.BL, Xe.globeCenterInViewSpace, Xe.globeRadius, me, je, Xe._farZ, Ot);
                                    if (te(ut, it), G && (M.setupElevationDraw(Fe, G, Se), P.uploadCommonUniforms(V, G, ut.toUnwrapped()), he)) {
                                        const [Nt, Ft, ri] = he.getGridBuffers(gt, je !== 0);
                                        G.draw(P, Ke, _e, Te, ce, Yt.backCCW, St, "globe_raster", Nt, Ft, ri)
                                    }
                                }
                            }
                            if (he && (P.renderDefaultNorthPole || P.renderDefaultSouthPole)) {
                                const Xe = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                                Q && Xe.push("CUSTOM_ANTIALIASING"), G = P.getOrCreateProgram("globeRaster", {defines: Xe});
                                for (const je of R) {
                                    const {x: Ke, y: ut, z: Fe} = je.canonical, Te = ut === 0,
                                        $e = ut === (1 << Fe) - 1, [Be, tt, it, rt] = he.getPoleBuffers(Fe, !1);
                                    if (rt && (Te || $e)) {
                                        const gt = k.getTile(je);
                                        V.activeTexture.set(B.TEXTURE0), gt.texture && gt.texture.bind(B.LINEAR, B.CLAMP_TO_EDGE);
                                        let Ot = o.dE(Fe, Ke, Z);
                                        const Ut = o.bh(o.dD(je.canonical)),
                                            St = (Nt, Ft) => Nt.draw(P, B.TRIANGLES, _e, ei.disabled, ce, Yt.disabled, Dd(Z.expandedFarZProjMatrix, Ot, Ot, Ut, 0, ue, Z.frustumCorners.TL, Z.frustumCorners.TR, Z.frustumCorners.BR, Z.frustumCorners.BL, Z.globeCenterInViewSpace, Z.globeRadius, me, 0, Z._farZ), "globe_pole_raster", Ft, it, rt);
                                        M.setupElevationDraw(gt, G, Se), P.uploadCommonUniforms(V, G, je.toUnwrapped()), Te && P.renderDefaultNorthPole && St(G, Be), $e && P.renderDefaultSouthPole && (Ot = o.cP(o.bz(), Ot, [1, -1, 1]), St(G, tt))
                                    }
                                }
                            }
                        })(m, g, v, b, S); else {
                            const P = m.context, M = P.gl;
                            let k, R;
                            const O = m.shadowRenderer, V = Ks(m, m.longestCutoffRange), B = ce => {
                                if (R === ce) return;
                                const _e = [];
                                _e.push(ry[ce]), V.shouldRenderCutoff && _e.push("RENDER_CUTOFF"), O && (_e.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), O.useNormalOffset && _e.push("NORMAL_OFFSET")), k = m.getOrCreateProgram("terrainRaster", {defines: _e}), R = ce
                            }, G = m.colorModeForRenderPass(), U = new It(M.LEQUAL, It.ReadWrite, m.depthRangeFor3D);
                            Ul.update(S);
                            const Z = m.transform, Q = Lc(Z.zoom, g.exaggeration(), g.sourceCache._source.tileSize);
                            let te = [0, 0, 0];
                            if (O) {
                                const ce = m.style.directionalLight, _e = m.style.ambientLight;
                                ce && _e && (te = Nl(m.style, ce, _e))
                            }
                            {
                                R = -1;
                                const ce = M.TRIANGLES, [_e, ve] = [g.gridIndexBuffer, g.gridSegments];
                                for (const ue of b) {
                                    const he = v.getTile(ue), me = ei.disabled, Oe = g.prevTerrainTileForTile[ue.key],
                                        Se = g.terrainTileForTile[ue.key];
                                    Qp(Oe, Se) && Ul.newMorphing(ue.key, Oe, Se, S, 250), P.activeTexture.set(M.TEXTURE0), he.texture && he.texture.bind(M.LINEAR, M.CLAMP_TO_EDGE);
                                    const Xe = Ul.getMorphValuesForProxy(ue.key), je = Xe ? 1 : 0;
                                    let Ke;
                                    Xe && (Ke = {
                                        morphing: {
                                            srcDemTile: Xe.from,
                                            dstDemTile: Xe.to,
                                            phase: o.dx(Xe.phase)
                                        }
                                    });
                                    const ut = Kp(ue.projMatrix, ph(ue.canonical, Z.renderWorldCopies) ? Q / 10 : Q, te);
                                    if (B(je), !k) continue;
                                    g.setupElevationDraw(he, k, Ke);
                                    const Fe = ue.toUnwrapped();
                                    O && O.setupShadows(Fe, k), m.uploadCommonUniforms(P, k, Fe, null, V), k.draw(m, ce, U, me, G, Yt.backCCW, ut, "terrain_raster", g.gridBuffer, _e, ve)
                                }
                            }
                        }
                    }(s, this, this.proxySourceCache, t, this._updateTimestamp), this.renderingToTexture = !0, s.gpuTimingDeferredRenderEnd(), t.splice(0, t.length))
                }

                renderBatch(t) {
                    if (this._drapedRenderBatches.length === 0) return t + 1;
                    this.renderingToTexture = !0;
                    const s = this.painter, h = this.painter.context, m = this.proxySourceCache,
                        g = this.proxiedCoords[m.id], v = this._drapedRenderBatches.shift(), b = s.style.order, S = [];
                    let P = 0;
                    for (const M of g) {
                        const k = m.getTileByID(M.proxyTileKey),
                            R = m.proxyCachedFBO[M.key] ? m.proxyCachedFBO[M.key][t] : void 0,
                            O = R !== void 0 ? m.renderCache[R] : this.pool[P++], V = R !== void 0;
                        if (k.texture = O.tex, V && !O.dirty) {
                            S.push(k.tileID);
                            continue
                        }
                        let B;
                        h.bindFramebuffer.set(O.fb.framebuffer), this.renderedToTile = !1, O.dirty && (h.clear({
                            color: o.am.transparent,
                            stencil: 0
                        }), O.dirty = !1);
                        for (let G = v.start; G <= v.end; ++G) {
                            const U = s.style._mergedLayers[b[G]];
                            if (U.isHidden(s.transform.zoom)) continue;
                            const Z = s.style.getLayerSourceCache(U), Q = Z ? this.proxyToSource[M.key][Z.id] : [M];
                            if (!Q) continue;
                            const te = Q;
                            h.viewport.set([0, 0, O.fb.width, O.fb.height]), B !== (Z ? Z.id : null) && (this._setupStencil(O, Q, U, Z), B = Z ? Z.id : null), s.renderLayer(s, Z, U, te)
                        }
                        if (this._drapedRenderBatches.length === 0) for (const G of this._pendingGroundEffectLayers) {
                            const U = s.style._mergedLayers[b[G]];
                            if (U.isHidden(s.transform.zoom)) continue;
                            const Z = s.style.getLayerSourceCache(U), Q = Z ? this.proxyToSource[M.key][Z.id] : [M];
                            if (!Q) continue;
                            const te = Q;
                            h.viewport.set([0, 0, O.fb.width, O.fb.height]), B !== (Z ? Z.id : null) && (this._setupStencil(O, Q, U, Z), B = Z ? Z.id : null), s.renderLayer(s, Z, U, te)
                        }
                        this.renderedToTile ? (O.dirty = !0, S.push(k.tileID)) : V || --P, P === 5 && (P = 0, this.renderToBackBuffer(S))
                    }
                    return this.renderToBackBuffer(S), this.renderingToTexture = !1, h.bindFramebuffer.set(null), h.viewport.set([0, 0, s.width, s.height]), v.end + 1
                }

                postRender() {
                }

                isLayerOrderingCorrect(t) {
                    const s = t.order.length;
                    let h = -1, m = s;
                    for (let g = 0; g < s; ++g) this._style.isLayerDraped(t._mergedLayers[t.order[g]]) ? h = Math.max(h, g) : m = Math.min(m, g);
                    return m > h
                }

                getMinElevationBelowMSL() {
                    let t = 0;
                    return this._visibleDemTiles.filter(s => s.dem).forEach(s => {
                        t = Math.min(t, s.dem.tree.minimums[0])
                    }), t === 0 ? t : (t - 30) * this._exaggeration
                }

                raycast(t, s, h) {
                    if (!this._visibleDemTiles) return null;
                    const m = this._visibleDemTiles.filter(g => g.dem).map(g => {
                        const v = g.tileID, b = 1 << v.overscaledZ, {x: S, y: P} = v.canonical, M = S / b,
                            k = (S + 1) / b, R = P / b, O = (P + 1) / b;
                        return {
                            minx: M,
                            miny: R,
                            maxx: k,
                            maxy: O,
                            t: g.dem.tree.raycastRoot(M, R, k, O, t, s, h),
                            tile: g
                        }
                    });
                    m.sort((g, v) => (g.t !== null ? g.t : Number.MAX_VALUE) - (v.t !== null ? v.t : Number.MAX_VALUE));
                    for (const g of m) {
                        if (g.t == null) return null;
                        const v = g.tile.dem.tree.raycast(g.minx, g.miny, g.maxx, g.maxy, t, s, h);
                        if (v != null) return v
                    }
                    return null
                }

                _createFBO() {
                    const t = this.painter.context, s = t.gl, h = this.drapeBufferSize;
                    t.activeTexture.set(s.TEXTURE0);
                    const m = new o.T(t, {width: h[0], height: h[1], data: null}, s.RGBA8);
                    m.bind(s.LINEAR, s.CLAMP_TO_EDGE);
                    const g = t.createFramebuffer(h[0], h[1], !0, null);
                    return g.colorAttachment.set(m.texture), g.depthAttachment = new Yp(t, g.framebuffer), this._sharedDepthStencil === void 0 ? (this._sharedDepthStencil = t.createRenderbuffer(t.gl.DEPTH_STENCIL, h[0], h[1]), this._stencilRef = 0, g.depthAttachment.set(this._sharedDepthStencil), t.clear({stencil: 0})) : g.depthAttachment.set(this._sharedDepthStencil), t.extTextureFilterAnisotropic && s.texParameterf(s.TEXTURE_2D, t.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t.extTextureFilterAnisotropicMax), {
                        fb: g,
                        tex: m,
                        dirty: !1
                    }
                }

                _initFBOPool() {
                    for (; this.pool.length < Math.min(5, this.proxyCoords.length);) this.pool.push(this._createFBO())
                }

                _shouldDisableRenderCache() {
                    if (this._debugParams.disableRenderCache || this._style.hasLightTransitions()) return !0;
                    for (const t in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[t].hasTransition()) return !0;
                    return this._style.order.some(t => {
                        const s = this._style._mergedLayers[t], h = s.isHidden(this.painter.transform.zoom);
                        return s.type === "hillshade" || s.type === "custom" ? !h && s.shouldRedrape() : !h && s.hasTransition()
                    })
                }

                _clearLineLayersFromRenderCache() {
                    let t = !1;
                    for (const h of this._style.getSources()) if (h instanceof Gu) {
                        t = !0;
                        break
                    }
                    if (!t) return;
                    const s = {};
                    for (let h = 0; h < this._style.order.length; ++h) {
                        const m = this._style._mergedLayers[this._style.order[h]],
                            g = this._style.getLayerSourceCache(m);
                        if (g && !s[g.id] && !m.isHidden(this.painter.transform.zoom) && m.type === "line" && m.widthExpression() instanceof o.ab) {
                            s[g.id] = !0;
                            for (const v of this.proxyCoords) {
                                const b = this.proxyToSource[v.key][g.id];
                                if (b) for (const S of b) this._clearRenderCacheForTile(g.id, S)
                            }
                        }
                    }
                }

                _clearRasterLayersFromRenderCache() {
                    let t = !1;
                    for (const h in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[h]._source instanceof Br) {
                        t = !0;
                        break
                    }
                    if (!t) return;
                    const s = {};
                    for (let h = 0; h < this._style.order.length; ++h) {
                        const m = this._style._mergedLayers[this._style.order[h]],
                            g = this._style.getLayerSourceCache(m);
                        if (!g || s[g.id] || m.isHidden(this.painter.transform.zoom) || m.type !== "raster") continue;
                        const v = m.paint.get("raster-fade-duration");
                        for (const b of this.proxyCoords) {
                            const S = this.proxyToSource[b.key][g.id];
                            if (S) for (const P of S) {
                                const M = Io(g.getTile(P), g.findLoadedParent(P, 0), g, this.painter.transform, v);
                                (M.opacity !== 1 || M.mix !== 0) && this._clearRenderCacheForTile(g.id, P)
                            }
                        }
                    }
                }

                _setupDrapedRenderBatches() {
                    this._style.updateDrapeFirstLayers();
                    const t = this._style.order, s = t.length;
                    if (s === 0) return;
                    const h = [];
                    this._pendingGroundEffectLayers = [];
                    let m, g = 0, v = this._style._mergedLayers[t[g]];
                    for (; !this._style.isLayerDraped(v) && v.isHidden(this.painter.transform.zoom) && ++g < s;) v = this._style._mergedLayers[t[g]];
                    for (; g < s; ++g) {
                        const b = this._style._mergedLayers[t[g]];
                        b.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(b) ? m === void 0 && (m = g) : (b.type === "fill-extrusion" && this._pendingGroundEffectLayers.push(g), m !== void 0 && (h.push({
                            start: m,
                            end: g - 1
                        }), m = void 0)))
                    }
                    if (m !== void 0 && h.push({start: m, end: g - 1}), h.length !== 0) {
                        const b = h[h.length - 1];
                        this._pendingGroundEffectLayers.every(S => S > b.end) || o.w("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.")
                    }
                    this._drapedRenderBatches = h
                }

                _setupRenderCache(t) {
                    const s = this.proxySourceCache;
                    if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
                        if (this.invalidateRenderCache = !1, s.renderCache.length > s.renderCachePool.length) {
                            const v = Object.values(s.proxyCachedFBO);
                            s.proxyCachedFBO = {};
                            for (let b = 0; b < v.length; ++b) {
                                const S = Object.values(v[b]);
                                s.renderCachePool.push(...S)
                            }
                        }
                        return
                    }
                    this._clearRasterLayersFromRenderCache();
                    const h = this.proxyCoords, m = this._tilesDirty;
                    for (let v = h.length - 1; v >= 0; v--) {
                        const b = h[v];
                        if (s.getTileByID(b.key), s.proxyCachedFBO[b.key] !== void 0) {
                            const S = t[b.key], P = this.proxyToSource[b.key];
                            let M = 0;
                            for (const k in P) {
                                const R = P[k], O = S[k];
                                if (!O || O.length !== R.length || R.some((V, B) => V !== O[B] || m[k] && m[k].hasOwnProperty(V.key))) {
                                    M = -1;
                                    break
                                }
                                ++M
                            }
                            for (const k in s.proxyCachedFBO[b.key]) s.renderCache[s.proxyCachedFBO[b.key][k]].dirty = M < 0 || M !== Object.values(S).length
                        }
                    }
                    const g = [...this._drapedRenderBatches];
                    g.sort((v, b) => b.end - b.start - (v.end - v.start));
                    for (const v of g) for (const b of h) {
                        if (s.proxyCachedFBO[b.key]) continue;
                        let S = s.renderCachePool.pop();
                        S === void 0 && s.renderCache.length < 50 && (S = s.renderCache.length, s.renderCache.push(this._createFBO())), S !== void 0 && (s.proxyCachedFBO[b.key] = {}, s.proxyCachedFBO[b.key][v.start] = S, s.renderCache[S].dirty = !0)
                    }
                    this._tilesDirty = {}
                }

                _setupStencil(t, s, h, m) {
                    if (!m || !this._sourceTilesOverlap[m.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));
                    const g = this.painter.context, v = g.gl;
                    if (s.length <= 1) return void (this._overlapStencilType = !1);
                    let b;
                    if (h.isTileClipped()) b = s.length, this._overlapStencilMode.test = {
                        func: v.EQUAL,
                        mask: 255
                    }, this._overlapStencilType = "Clip"; else {
                        if (!(s[0].overscaledZ > s[s.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);
                        b = 1, this._overlapStencilMode.test = {
                            func: v.GREATER,
                            mask: 255
                        }, this._overlapStencilType = "Mask"
                    }
                    this._stencilRef + b > 255 && (g.clear({stencil: 0}), this._stencilRef = 0), this._stencilRef += b, this._overlapStencilMode.ref = this._stencilRef, h.isTileClipped() && this._renderTileClippingMasks(s, this._overlapStencilMode.ref)
                }

                clipOrMaskOverlapStencilType() {
                    return this._overlapStencilType === "Clip" || this._overlapStencilType === "Mask"
                }

                stencilModeForRTTOverlap(t) {
                    return this.renderingToTexture && this._overlapStencilType ? (this._overlapStencilType === "Clip" && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t.key]), this._overlapStencilMode) : ei.disabled
                }

                _renderTileClippingMasks(t, s) {
                    const h = this.painter, m = this.painter.context, g = m.gl;
                    h._tileClippingMaskIDs = {}, m.setColorMode(gi.disabled), m.setDepthMode(It.disabled);
                    const v = h.getOrCreateProgram("clippingMask");
                    for (const b of t) {
                        const S = h._tileClippingMaskIDs[b.key] = --s;
                        v.draw(h, g.TRIANGLES, It.disabled, new ei({
                            func: g.ALWAYS,
                            mask: 0
                        }, S, 255, g.KEEP, g.KEEP, g.REPLACE), gi.disabled, Yt.disabled, Ld(b.projMatrix), "$clipping", h.tileExtentBuffer, h.quadTriangleIndexBuffer, h.tileExtentSegments)
                    }
                }

                pointCoordinate(t) {
                    const s = this.painter.transform;
                    if (t.x < 0 || t.x > s.width || t.y < 0 || t.y > s.height) return null;
                    const h = [t.x, t.y, 1, 1];
                    o.aA(h, h, s.pixelMatrixInverse), o.cH(h, h, 1 / h[3]), h[0] /= s.worldSize, h[1] /= s.worldSize;
                    const m = s._camera.position, g = o.cb(1, s.center.lat), v = [m[0], m[1], m[2] / g, 0],
                        b = o.d7([], h.slice(0, 3), v);
                    o.au(b, b);
                    const S = this.raycast(v, b, this._exaggeration);
                    return S !== null && S ? (o.bE(v, v, b, S), v[3] = v[2], v[2] *= g, v) : null
                }

                _setupProxiedCoordsForOrtho(t, s, h) {
                    if (t.getSource() instanceof o.aP) return this._setupProxiedCoordsForImageSource(t, s, h);
                    this._findCoveringTileCache[t.id] = this._findCoveringTileCache[t.id] || {};
                    const m = this.proxiedCoords[t.id] = [], g = this.proxyCoords;
                    for (let S = 0; S < g.length; S++) {
                        const P = g[S], M = this._findTileCoveringTileID(P, t);
                        if (M) {
                            const k = this._createProxiedId(P, M, h[P.key] && h[P.key][t.id]);
                            m.push(k), this.proxyToSource[P.key][t.id] = [k]
                        }
                    }
                    let v = !1;
                    const b = new Set;
                    for (let S = 0; S < s.length; S++) {
                        const P = t.getTile(s[S]);
                        if (!P || !P.hasData()) continue;
                        const M = this._findTileCoveringTileID(P.tileID, this.proxySourceCache);
                        if (M && M.tileID.canonical.z !== P.tileID.canonical.z) {
                            const k = this.proxyToSource[M.tileID.key][t.id],
                                R = this._createProxiedId(M.tileID, P, h[M.tileID.key] && h[M.tileID.key][t.id]);
                            k ? k.splice(k.length - 1, 0, R) : this.proxyToSource[M.tileID.key][t.id] = [R];
                            const O = this.proxyToSource[M.tileID.key][t.id];
                            b.has(O) || b.add(O), m.push(R), v = !0
                        }
                    }
                    if (this._sourceTilesOverlap[t.id] = v, v && this._debugParams.sortTilesHiZFirst) for (const S of b) S.sort((P, M) => M.overscaledZ - P.overscaledZ)
                }

                _setupProxiedCoordsForImageSource(t, s, h) {
                    if (!t.getSource().loaded()) return;
                    const m = this.proxiedCoords[t.id] = [], g = this.proxyCoords, v = t.getSource(), b = v.tileID;
                    if (!b) return;
                    const S = new o.P(b.x, b.y)._div(1 << b.z),
                        P = v.coordinates.map(o.ac.fromLngLat).reduce((k, R) => (k.min.x = Math.min(k.min.x, R.x - S.x), k.min.y = Math.min(k.min.y, R.y - S.y), k.max.x = Math.max(k.max.x, R.x - S.x), k.max.y = Math.max(k.max.y, R.y - S.y), k), {
                            min: new o.P(Number.MAX_VALUE, Number.MAX_VALUE),
                            max: new o.P(-Number.MAX_VALUE, -Number.MAX_VALUE)
                        }), M = (k, R) => {
                            const O = k.wrap + k.canonical.x / (1 << k.canonical.z),
                                V = k.canonical.y / (1 << k.canonical.z), B = o.aj / (1 << k.canonical.z),
                                G = R.wrap + R.canonical.x / (1 << R.canonical.z), U = R.canonical.y / (1 << R.canonical.z);
                            return O + B < G + P.min.x || O > G + P.max.x || V + B < U + P.min.y || V > U + P.max.y
                        };
                    for (let k = 0; k < g.length; k++) {
                        const R = g[k];
                        for (let O = 0; O < s.length; O++) {
                            const V = t.getTile(s[O]);
                            if (!V || !V.hasData() || M(R, V.tileID)) continue;
                            const B = this._createProxiedId(R, V, h[R.key] && h[R.key][t.id]),
                                G = this.proxyToSource[R.key][t.id];
                            G ? G.push(B) : this.proxyToSource[R.key][t.id] = [B], m.push(B)
                        }
                    }
                }

                _createProxiedId(t, s, h) {
                    let m = this.orthoMatrix;
                    if (h) {
                        const g = h.find(v => v.key === s.tileID.key);
                        if (g) return g
                    }
                    if (s.tileID.key !== t.key) {
                        const g = t.canonical.z - s.tileID.canonical.z;
                        let v, b, S;
                        m = o.bz();
                        const P = s.tileID.wrap - t.wrap << t.overscaledZ;
                        g > 0 ? (v = o.aj >> g, b = v * ((s.tileID.canonical.x << g) - t.canonical.x + P), S = v * ((s.tileID.canonical.y << g) - t.canonical.y)) : (v = o.aj << -g, b = o.aj * (s.tileID.canonical.x - (t.canonical.x + P << -g)), S = o.aj * (s.tileID.canonical.y - (t.canonical.y << -g))), o.ca(m, 0, v, 0, v, 0, 1), o.bo(m, m, [b, S, 0])
                    }
                    return new mh(s.tileID, t.key, m)
                }

                _findTileCoveringTileID(t, s) {
                    let h = s.getTile(t);
                    if (h && h.hasData()) return h;
                    const m = this._findCoveringTileCache[s.id], g = m[t.key];
                    if (h = g ? s.getTileByID(g) : null, h && h.hasData() || g === null) return h;
                    let v = h ? h.tileID : t, b = v.overscaledZ;
                    const S = s.getSource().minzoom, P = [];
                    if (!g) {
                        const k = s.getSource().maxzoom;
                        if (t.canonical.z >= k) {
                            const R = t.canonical.z - k;
                            s.getSource().reparseOverscaled ? (b = Math.max(t.canonical.z + 2, s.transform.tileZoom), v = new o.aM(b, t.wrap, k, t.canonical.x >> R, t.canonical.y >> R)) : R !== 0 && (b = k, v = new o.aM(b, t.wrap, k, t.canonical.x >> R, t.canonical.y >> R))
                        }
                        v.key !== t.key && (P.push(v.key), h = s.getTile(v))
                    }
                    const M = k => {
                        P.forEach(R => {
                            m[R] = k
                        }), P.length = 0
                    };
                    for (b -= 1; b >= S && (!h || !h.hasData()); b--) {
                        h && M(h.tileID.key);
                        const k = v.calculateScaledKey(b);
                        if (h = s.getTileByID(k), h && h.hasData()) break;
                        const R = m[k];
                        if (R === null) break;
                        R === void 0 ? P.push(k) : h = s.getTileByID(R)
                    }
                    return M(h ? h.tileID.key : null), h && h.hasData() ? h : null
                }

                findDEMTileFor(t) {
                    return this.enabled ? this._findTileCoveringTileID(t, this.sourceCache) : null
                }

                prepareDrawTile() {
                    this.renderedToTile = !0
                }

                _clearRenderCacheForTile(t, s) {
                    let h = this._tilesDirty[t];
                    h || (h = this._tilesDirty[t] = {}), h[s.key] = !0
                }
            }

            function em(u, t, s) {
                const h = function (b, S, P) {
                    const M = o.bG(S, b), k = o.bG(P, [.2126, .7152, .0722]), R = (V, B, G) => (1 - G) * V + G * B,
                        O = R(1 - .3 * Math.min(k, 1), 1, Math.min(M + 1, 1));
                    return R(.92, 1, Math.asin(o.ay(S[2], -1, 1)) / Math.PI + .5) * O
                }(u, [0, 0, 1], t), m = [0, 0, 0];
                o.c1(m, s.slice(0, 3), h);
                const g = [0, 0, 0];
                o.c1(g, t.slice(0, 3), u[2]);
                const v = [0, 0, 0];
                return o.d5(v, m, g), o.d8(v)
            }

            const tm = ["fill", "fillOutline", "fillPattern", "line", "linePattern", "background", "backgroundPattern", "hillshade", "raster"],
                Fd = ["stars", "rainParticle", "snowParticle", "fillExtrusion", "fillExtrusionGroundEffect", "elevatedStructures", "model", "symbol"];

            class Bd {
                static cacheKey(t, s, h, m) {
                    let g = `${s}${m ? m.cacheKey : ""}`;
                    for (const v of h) t.usedDefines.includes(v) && (g += `/${v}`);
                    return g
                }

                constructor(t, s, h, m, g, v) {
                    const b = t.gl;
                    this.program = b.createProgram(), this.configuration = m, this.name = s, this.fixedDefines = [...v];
                    const S = m ? m.getBinderAttributes() : [], P = (h.staticAttributes || []).concat(S);
                    let M = m ? m.defines() : [];
                    M = M.concat(v.map(G => `#define ${G}`));
                    const k = `#version 300 es
`;
                    let R = k + M.concat("precision mediump float;", el, Ed.fragmentSource).join(`
`);
                    for (const G of h.fragmentIncludes) R += `
${jl[G]}`;
                    R += `
${h.fragmentSource}`;
                    let O = k + M.concat("precision highp float;", el, Ed.vertexSource).join(`
`);
                    for (const G of h.vertexIncludes) O += `
${jl[G]}`;
                    this.forceManualRenderingForInstanceIDShaders = t.forceManualRenderingForInstanceIDShaders && h.vertexSource.indexOf("gl_InstanceID") !== -1, this.forceManualRenderingForInstanceIDShaders && (O += `
uniform int u_instanceID;
`), O += `
${h.vertexSource}`, this.forceManualRenderingForInstanceIDShaders && (O = O.replaceAll("gl_InstanceID", "u_instanceID"));
                    const V = b.createShader(b.FRAGMENT_SHADER);
                    if (b.isContextLost()) return void (this.failedToCreate = !0);
                    b.shaderSource(V, R), b.compileShader(V), b.attachShader(this.program, V);
                    const B = b.createShader(b.VERTEX_SHADER);
                    if (b.isContextLost()) this.failedToCreate = !0; else {
                        b.shaderSource(B, O), b.compileShader(B), b.attachShader(this.program, B), this.attributes = {}, this.numAttributes = P.length;
                        for (let G = 0; G < this.numAttributes; G++) if (P[G]) {
                            const U = P[G].startsWith("a_") ? P[G] : `a_${P[G]}`;
                            b.bindAttribLocation(this.program, G, U), this.attributes[U] = G
                        }
                        b.linkProgram(this.program), b.deleteShader(B), b.deleteShader(V), this.fixedUniforms = g(t), this.binderUniforms = m ? m.getUniforms(t) : [], this.forceManualRenderingForInstanceIDShaders && (this.instancingUniforms = (G => ({u_instanceID: new o.cd(G)}))(t)), (v.includes("TERRAIN") || s.indexOf("symbol") !== -1 || s.indexOf("circle") !== -1) && (this.terrainUniforms = (G => ({
                            u_dem: new o.cd(G),
                            u_dem_prev: new o.cd(G),
                            u_dem_tl: new o.cg(G),
                            u_dem_scale: new o.cf(G),
                            u_dem_tl_prev: new o.cg(G),
                            u_dem_scale_prev: new o.cf(G),
                            u_dem_size: new o.cf(G),
                            u_dem_lerp: new o.cf(G),
                            u_exaggeration: new o.cf(G),
                            u_depth: new o.cd(G),
                            u_depth_size_inv: new o.cg(G),
                            u_depth_range_unpack: new o.cg(G),
                            u_occluder_half_size: new o.cf(G),
                            u_occlusion_depth_offset: new o.cf(G),
                            u_meter_to_dem: new o.cf(G),
                            u_label_plane_matrix_inv: new o.ch(G)
                        }))(t)), v.includes("GLOBE") && (this.globeUniforms = (G => ({
                            u_tile_tl_up: new o.ce(G),
                            u_tile_tr_up: new o.ce(G),
                            u_tile_br_up: new o.ce(G),
                            u_tile_bl_up: new o.ce(G),
                            u_tile_up_scale: new o.cf(G)
                        }))(t)), v.includes("FOG") && (this.fogUniforms = (G => ({
                            u_fog_matrix: new o.ch(G),
                            u_fog_range: new o.cg(G),
                            u_fog_color: new o.d0(G),
                            u_fog_horizon_blend: new o.cf(G),
                            u_fog_vertical_limit: new o.cg(G),
                            u_fog_temporal_offset: new o.cf(G),
                            u_frustum_tl: new o.ce(G),
                            u_frustum_tr: new o.ce(G),
                            u_frustum_br: new o.ce(G),
                            u_frustum_bl: new o.ce(G),
                            u_globe_pos: new o.ce(G),
                            u_globe_radius: new o.cf(G),
                            u_globe_transition: new o.cf(G),
                            u_is_globe: new o.cd(G),
                            u_viewport: new o.cg(G)
                        }))(t)), v.includes("RENDER_CUTOFF") && (this.cutoffUniforms = (G => ({u_cutoff_params: new o.d0(G)}))(t)), v.includes("LIGHTING_3D_MODE") && (this.lightsUniforms = (G => ({
                            u_lighting_ambient_color: new o.ce(G),
                            u_lighting_directional_dir: new o.ce(G),
                            u_lighting_directional_color: new o.ce(G),
                            u_ground_radiance: new o.ce(G)
                        }))(t)), v.includes("RENDER_SHADOWS") && (this.shadowUniforms = (G => ({
                            u_light_matrix_0: new o.ch(G),
                            u_light_matrix_1: new o.ch(G),
                            u_fade_range: new o.cg(G),
                            u_shadow_normal_offset: new o.ce(G),
                            u_shadow_intensity: new o.cf(G),
                            u_shadow_texel_size: new o.cf(G),
                            u_shadow_map_resolution: new o.cf(G),
                            u_shadow_direction: new o.ce(G),
                            u_shadow_bias: new o.ce(G),
                            u_shadowmap_0: new o.cd(G),
                            u_shadowmap_1: new o.cd(G)
                        }))(t))
                    }
                }

                setTerrainUniformValues(t, s) {
                    if (!this.terrainUniforms) return;
                    const h = this.terrainUniforms;
                    if (!this.failedToCreate) {
                        t.program.set(this.program);
                        for (const m in s) h[m] && h[m].set(this.program, m, s[m])
                    }
                }

                setGlobeUniformValues(t, s) {
                    if (!this.globeUniforms) return;
                    const h = this.globeUniforms;
                    if (!this.failedToCreate) {
                        t.program.set(this.program);
                        for (const m in s) h[m] && h[m].set(this.program, m, s[m])
                    }
                }

                setFogUniformValues(t, s) {
                    if (!this.fogUniforms) return;
                    const h = this.fogUniforms;
                    if (!this.failedToCreate) {
                        t.program.set(this.program);
                        for (const m in s) h[m].set(this.program, m, s[m])
                    }
                }

                setCutoffUniformValues(t, s) {
                    if (!this.cutoffUniforms) return;
                    const h = this.cutoffUniforms;
                    if (!this.failedToCreate) {
                        t.program.set(this.program);
                        for (const m in s) h[m].set(this.program, m, s[m])
                    }
                }

                setLightsUniformValues(t, s) {
                    if (!this.lightsUniforms) return;
                    const h = this.lightsUniforms;
                    if (!this.failedToCreate) {
                        t.program.set(this.program);
                        for (const m in s) h[m].set(this.program, m, s[m])
                    }
                }

                setShadowUniformValues(t, s) {
                    if (this.failedToCreate || !this.shadowUniforms) return;
                    const h = this.shadowUniforms;
                    t.program.set(this.program);
                    for (const m in s) h[m].set(this.program, m, s[m])
                }

                _drawDebugWireframe(t, s, h, m, g, v, b, S, P, M) {
                    const k = t.options.wireframe;
                    if (k.terrain === !1 && k.layers2D === !1 && k.layers3D === !1) return;
                    const R = t.context;
                    if (!(!(!k.terrain || this.name !== "terrainRaster" && this.name !== "globeRaster") || !(!k.layers2D || t._terrain && t._terrain.renderingToTexture || !tm.includes(this.name)) || !(!k.layers3D || !Fd.includes(this.name)))) return;
                    const O = R.gl, V = t.wireframeDebugCache.getLinesFromTrianglesBuffer(t.frameCounter, g, R);
                    if (!V) return;
                    const B = [...this.fixedDefines];
                    B.push("DEBUG_WIREFRAME");
                    const G = t.getOrCreateProgram(this.name, {config: this.configuration, defines: B});
                    R.program.set(G.program);
                    const U = (te, ce, _e) => {
                        if (ce[te] && _e[te]) for (const ve in ce[te]) _e[te][ve] && _e[te][ve].set(_e.program, ve, ce[te][ve].current)
                    };
                    P && P.setUniforms(G.program, R, G.binderUniforms, b, {zoom: S}), U("fixedUniforms", this, G), U("terrainUniforms", this, G), U("globeUniforms", this, G), U("fogUniforms", this, G), U("lightsUniforms", this, G), U("shadowUniforms", this, G), V.bind(), R.setColorMode(new gi([O.ONE, O.ONE_MINUS_SRC_ALPHA, O.ZERO, O.ONE], o.am.transparent, [!0, !0, !0, !1])), R.setDepthMode(new It(s.func === O.LESS ? O.LEQUAL : s.func, It.ReadOnly, s.range)), R.setStencilMode(ei.disabled);
                    const Z = 3 * v.primitiveLength * 2, Q = 3 * v.primitiveOffset * 2 * 2;
                    if (this.forceManualRenderingForInstanceIDShaders) {
                        const te = M || 1;
                        for (let ce = 0; ce < te; ++ce) G.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", ce), O.drawElements(O.LINES, Z, O.UNSIGNED_SHORT, Q)
                    } else M && M > 1 ? O.drawElementsInstanced(O.LINES, Z, O.UNSIGNED_SHORT, Q, M) : O.drawElements(O.LINES, Z, O.UNSIGNED_SHORT, Q);
                    g.bind(), R.program.set(this.program), R.setDepthMode(s), R.setStencilMode(h), R.setColorMode(m)
                }

                checkUniforms(t, s, h) {
                    if (this.fixedDefines.includes(s)) {
                        for (const m of Object.keys(h)) if (!h[m].initialized) throw new Error(`Program '${this.name}', from draw '${t}': uniform ${m} not set but required by ${s} being defined`)
                    }
                }

                draw(t, s, h, m, g, v, b, S, P, M, k, R, O, V, B, G) {
                    const U = t.context, Z = U.gl;
                    if (this.failedToCreate) return;
                    U.program.set(this.program), U.setDepthMode(h), U.setStencilMode(m), U.setColorMode(g), U.setCullFace(v);
                    for (const ce of Object.keys(this.fixedUniforms)) this.fixedUniforms[ce].set(this.program, ce, b[ce]);
                    V && V.setUniforms(this.program, U, this.binderUniforms, R, {zoom: O});
                    const Q = {[Z.POINTS]: 1, [Z.LINES]: 2, [Z.TRIANGLES]: 3, [Z.LINE_STRIP]: 1}[s];
                    this.checkUniforms(S, "RENDER_SHADOWS", this.shadowUniforms);
                    const te = G && G > 0 ? 1 : void 0;
                    for (const ce of k.get()) {
                        const _e = ce.vaos || (ce.vaos = {});
                        if ((_e[S] || (_e[S] = new Hx)).bind(U, this, P, V ? V.getPaintVertexBuffers() : [], M, ce.vertexOffset, B || [], te), this.forceManualRenderingForInstanceIDShaders) {
                            const ve = G || 1;
                            for (let ue = 0; ue < ve; ++ue) this.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", ue), M ? Z.drawElements(s, ce.primitiveLength * Q, Z.UNSIGNED_SHORT, ce.primitiveOffset * Q * 2) : Z.drawArrays(s, ce.vertexOffset, ce.vertexLength)
                        } else G && G > 1 ? Z.drawElementsInstanced(s, ce.primitiveLength * Q, Z.UNSIGNED_SHORT, ce.primitiveOffset * Q * 2, G) : M ? Z.drawElements(s, ce.primitiveLength * Q, Z.UNSIGNED_SHORT, ce.primitiveOffset * Q * 2) : Z.drawArrays(s, ce.vertexOffset, ce.vertexLength);
                        s === Z.TRIANGLES && M && this._drawDebugWireframe(t, h, m, g, M, ce, R, O, V, G)
                    }
                }
            }

            function Nd(u, t, s = 0) {
                const h = Math.pow(2, t.tileID.overscaledZ), m = t.tileSize * Math.pow(2, u.transform.tileZoom) / h,
                    g = m * (t.tileID.canonical.x + t.tileID.wrap * h), v = m * t.tileID.canonical.y;
                return {
                    u_image: 0,
                    u_texsize: t.imageAtlasTexture ? t.imageAtlasTexture.size : [0, 0],
                    u_tile_units_to_pixels: 1 / o.aw(t, 1, u.transform.tileZoom),
                    u_pixel_coord_upper: [g >> 16, v >> 16],
                    u_pixel_coord_lower: [65535 & g, 65535 & v],
                    u_pattern_transition: s
                }
            }

            const Gl = {terrain: 0, flat: 1}, im = o.bz(),
                nm = (u, t, s, h, m, g, v, b, S, P, M, k, R, O, V, B, G, U) => {
                    const Z = t.style.light, Q = Z.properties.get("position"), te = [Q.x, Q.y, Q.z], ce = o.dJ();
                    Z.properties.get("anchor") === "viewport" && (o.dK(ce, -t.transform.angle), o.dL(te, te, ce));
                    const _e = Z.properties.get("color").toPremultipliedRenderColor(null), ve = t.transform, ue = {
                        u_matrix: u,
                        u_lightpos: te,
                        u_lightintensity: Z.properties.get("intensity"),
                        u_lightcolor: [_e.r, _e.g, _e.b],
                        u_vertical_gradient: +s,
                        u_opacity: h,
                        u_tile_id: [0, 0, 0],
                        u_zoom_transition: 0,
                        u_inv_rot_matrix: im,
                        u_merc_center: [0, 0],
                        u_up_dir: [0, 0, 0],
                        u_height_lift: 0,
                        u_height_type: Gl[P],
                        u_base_type: Gl[M],
                        u_ao: m,
                        u_edge_radius: g,
                        u_width_scale: v,
                        u_flood_light_color: V,
                        u_vertical_scale: B,
                        u_flood_light_intensity: G,
                        u_ground_shadow_factor: U
                    };
                    return ve.projection.name === "globe" && (ue.u_tile_id = [b.canonical.x, b.canonical.y, 1 << b.canonical.z], ue.u_zoom_transition = k, ue.u_inv_rot_matrix = O, ue.u_merc_center = R, ue.u_up_dir = ve.projection.upVector(new o.cA(0, 0, 0), R[0] * o.aj, R[1] * o.aj), ue.u_height_lift = S), ue
                }, oy = (u, t, s, h, m, g) => ({
                    u_matrix: u,
                    u_edge_radius: t,
                    u_width_scale: s,
                    u_vertical_scale: h,
                    u_height_type: Gl[m],
                    u_base_type: Gl[g]
                }), kc = (u, t, s, h, m, g, v, b, S, P, M, k, R, O, V, B, G, U) => {
                    const Z = nm(u, t, s, h, m, g, v, b, P, M, k, R, O, V, B, G, 1, [0, 0, 0]),
                        Q = {u_height_factor: -Math.pow(2, b.overscaledZ) / S.tileSize / 8};
                    return o.h(Z, Nd(t, S, U), Q)
                }, sy = (u, t, s) => ({u_matrix: u, u_emissive_strength: t, u_ground_shadow_factor: s}),
                ay = (u, t, s, h, m, g = 0) => o.h(sy(u, t, m), Nd(s, h, g)),
                e1 = (u, t, s, h) => ({u_matrix: u, u_world: s, u_emissive_strength: t, u_ground_shadow_factor: h}),
                t1 = (u, t, s, h, m, g, v = 0) => o.h(ay(u, t, s, h, g, v), {u_world: m}),
                i1 = (u, t) => ({u_matrix: u, u_ground_shadow_factor: t}), jd = (u, t, s, h, m) => ({
                    u_matrix: u,
                    u_camera_pos: [t[0], t[1], t[2]],
                    u_depth_bias: s,
                    u_height_scale: h,
                    u_reset_depth: m
                }), rm = (u, t) => ({u_matrix: u, u_normal_matrix: t, u_opacity: 1}), om = u => ({u_matrix: u}),
                ly = u => ({u_matrix: u}), Oc = (u, t, s, h, m, g, v, b) => {
                    const S = o.aj / g.tileSize;
                    return {
                        u_matrix: u,
                        u_inv_rot_matrix: t,
                        u_camera_to_center_distance: s.getCameraToCenterDistance(b),
                        u_extrude_scale: [s.pixelsToGLUnits[0] / S, s.pixelsToGLUnits[1] / S],
                        u_zoom_transition: h,
                        u_tile_id: v,
                        u_merc_center: m
                    }
                }, sm = (u, t, s = 1) => ({u_matrix: u, u_color: t, u_overlay: 0, u_overlay_scale: s}), cy = o.bz(),
                uy = (u, t, s, h, m, g, v) => {
                    const b = u.transform, S = b.projection.name === "globe",
                        P = S ? o.dM(b.zoom, t.canonical) * b._pixelsPerMercatorPixel : o.aw(s, 1, g), M = {
                            u_matrix: t.projMatrix,
                            u_extrude_scale: P,
                            u_intensity: v,
                            u_inv_rot_matrix: cy,
                            u_merc_center: [0, 0],
                            u_tile_id: [0, 0, 0],
                            u_zoom_transition: 0,
                            u_up_dir: [0, 0, 0]
                        };
                    if (S) {
                        M.u_inv_rot_matrix = h, M.u_merc_center = m, M.u_tile_id = [t.canonical.x, t.canonical.y, 1 << t.canonical.z], M.u_zoom_transition = o.ah(b.zoom);
                        const k = m[0] * o.aj, R = m[1] * o.aj;
                        M.u_up_dir = b.projection.upVector(new o.cA(0, 0, 0), k, R)
                    }
                    return M
                };

            function Vd(u, [t, s, h, m], [g, v]) {
                if (g === v) return [0, 0, 0, 0];
                const b = 255 * (u - 1) / (u * (v - g));
                return [t * b, s * b, h * b, m * b]
            }

            function tl(u, t, [s, h]) {
                return s === h ? 0 : .5 / u + (t - s) * (u - 1) / (u * (h - s))
            }

            const am = (u, t, s, h, m, g, v, b, S, P, M, k, R, O, V, B, G, U, Z, Q, te) => ({
                u_matrix: u,
                u_normalize_matrix: t,
                u_globe_matrix: s,
                u_merc_matrix: h,
                u_grid_matrix: m,
                u_tl_parent: g,
                u_scale_parent: P,
                u_fade_t: M.mix,
                u_opacity: M.opacity * k.paint.get("raster-opacity"),
                u_image0: 0,
                u_image1: 1,
                u_brightness_low: k.paint.get("raster-brightness-min"),
                u_brightness_high: k.paint.get("raster-brightness-max"),
                u_saturation_factor: o.dO(k.paint.get("raster-saturation")),
                u_contrast_factor: o.dN(k.paint.get("raster-contrast")),
                u_spin_weights: il(k.paint.get("raster-hue-rotate")),
                u_perspective_transform: R,
                u_raster_elevation: O,
                u_zoom_transition: v,
                u_merc_center: b,
                u_cutoff_params: S,
                u_colorization_mix: Vd(o.dP, B, U),
                u_colorization_offset: tl(o.dP, G, U),
                u_color_ramp: V,
                u_texture_offset: [Q / (Z + 2 * Q), Z / (Z + 2 * Q)],
                u_texture_res: [Z + 2 * Q, Z + 2 * Q],
                u_emissive_strength: te
            });

            function il(u) {
                u *= Math.PI / 180;
                const t = Math.sin(u), s = Math.cos(u);
                return [(2 * s + 1) / 3, (-Math.sqrt(3) * t - s + 1) / 3, (Math.sqrt(3) * t - s + 1) / 3]
            }

            const nl = .05, Ud = (u, t, s, h, m, g, v, b, S, P, M, k) => ({
                    u_matrix: u,
                    u_normalize_matrix: t,
                    u_globe_matrix: s,
                    u_merc_matrix: h,
                    u_grid_matrix: m,
                    u_tl_parent: g,
                    u_scale_parent: P,
                    u_fade_t: M.mix,
                    u_opacity: M.opacity,
                    u_image0: 0,
                    u_image1: 1,
                    u_raster_elevation: k,
                    u_zoom_transition: v,
                    u_merc_center: b,
                    u_cutoff_params: S
                }), hy = (u, t, s, h, m, g, v, b, S, P) => ({
                    u_particle_texture: u,
                    u_particle_texture_side_len: t,
                    u_tile_offset: s,
                    u_velocity: h,
                    u_color_ramp: g,
                    u_velocity_res: m,
                    u_max_speed: v,
                    u_uv_offset: b,
                    u_data_scale: [255 * S[0], 255 * S[1]],
                    u_data_offset: P,
                    u_particle_pos_scale: 1.1,
                    u_particle_pos_offset: [nl, nl]
                }), dy = (u, t, s, h, m, g, v, b, S, P) => ({
                    u_particle_texture: u,
                    u_particle_texture_side_len: t,
                    u_velocity: s,
                    u_velocity_res: h,
                    u_max_speed: m,
                    u_speed_factor: g,
                    u_reset_rate: v,
                    u_rand_seed: Math.random(),
                    u_uv_offset: b,
                    u_data_scale: [255 * S[0], 255 * S[1]],
                    u_data_offset: P,
                    u_particle_pos_scale: 1.1,
                    u_particle_pos_offset: [nl, nl]
                }), Gd = o.bz(), $d = (u, t, s, h, m, g, v, b, S, P, M, k, R, O, V, B, G, U, Z, Q, te, ce, _e, ve) => {
                    const ue = m.transform, he = {
                        u_is_size_zoom_constant: +(u === "constant" || u === "source"),
                        u_is_size_feature_constant: +(u === "constant" || u === "camera"),
                        u_size_t: t ? t.uSizeT : 0,
                        u_size: t ? t.uSize : 0,
                        u_camera_to_center_distance: ue.getCameraToCenterDistance(Z),
                        u_rotate_symbol: +s,
                        u_aspect_ratio: ue.width / ue.height,
                        u_fade_change: m.options.fadeDuration ? m.symbolFadeChange : 1,
                        u_matrix: g,
                        u_label_plane_matrix: v,
                        u_coord_matrix: b,
                        u_is_text: +P,
                        u_elevation_from_sea: S ? 1 : 0,
                        u_pitch_with_map: +h,
                        u_texsize: M,
                        u_texsize_icon: k,
                        u_texture: 0,
                        u_texture_icon: 1,
                        u_tile_id: [0, 0, 0],
                        u_zoom_transition: 0,
                        u_inv_rot_matrix: Gd,
                        u_merc_center: [0, 0],
                        u_camera_forward: [0, 0, 0],
                        u_ecef_origin: [0, 0, 0],
                        u_tile_matrix: Gd,
                        u_up_vector: [0, -1, 0],
                        u_color_adj_mat: ce,
                        u_icon_transition: _e || 0,
                        u_gamma_scale: h ? m.transform.getCameraToCenterDistance(Z) * Math.cos(m.terrain ? 0 : m.transform._pitch) : 1,
                        u_device_pixel_ratio: o.q.devicePixelRatio,
                        u_is_halo: 1,
                        u_scale_factor: ve || 1,
                        u_ground_shadow_factor: Q,
                        u_inv_matrix: o.bi(o.bz(), v),
                        u_normal_scale: te
                    };
                    return Z.name === "globe" && (he.u_tile_id = [O.canonical.x, O.canonical.y, 1 << O.canonical.z], he.u_zoom_transition = V, he.u_inv_rot_matrix = G, he.u_merc_center = B, he.u_camera_forward = ue._camera.forward(), he.u_ecef_origin = o.dQ(ue.globeMatrix, O.toUnwrapped()), he.u_tile_matrix = Float32Array.from(ue.globeMatrix), he.u_up_vector = U), he
                }, fy = (u, t, s, h) => ({u_matrix: u, u_emissive_strength: t, u_opacity: s, u_color: h}),
                lm = (u, t, s, h, m, g, v, b, S) => o.h(function (P, M, k, R, O, V) {
                    const {width: B, height: G} = R.imageManager.getPixelSize(M), U = Math.pow(2, V.tileID.overscaledZ),
                        Z = V.tileSize * Math.pow(2, R.transform.tileZoom) / U,
                        Q = Z * (V.tileID.canonical.x + V.tileID.wrap * U), te = Z * V.tileID.canonical.y;
                    return {
                        u_image: 0,
                        u_pattern_tl: k.tl,
                        u_pattern_br: k.br,
                        u_texsize: [B, G],
                        u_pattern_size: k.displaySize,
                        u_pattern_units_to_pixels: O ? [R.transform.width, -1 * R.transform.height] : [1 / o.aw(V, 1, R.transform.tileZoom), 1 / o.aw(V, 1, R.transform.tileZoom)],
                        u_pixel_coord_upper: [Q >> 16, te >> 16],
                        u_pixel_coord_lower: [65535 & Q, 65535 & te]
                    }
                }(0, g, v, h, b, S), {u_matrix: u, u_emissive_strength: t, u_opacity: s}),
                $l = new Float32Array(o.bx([])), cm = (u, t, s, h, m, g, v, b, S, P, M, k, R, O = [0, 0, 0], V) => {
                    const B = m.style.light, G = B.properties.get("position"), U = [-G.x, -G.y, G.z], Z = o.dJ();
                    B.properties.get("anchor") === "viewport" && (o.dK(Z, -m.transform.angle), o.dL(U, U, Z));
                    const Q = M.alphaMode === "MASK", te = B.properties.get("color").toNonPremultipliedRenderColor(null),
                        ce = R.paint.get("model-ambient-occlusion-intensity"),
                        _e = R.paint.get("model-color").constantOr(o.am.white).toNonPremultipliedRenderColor(null);
                    return _e.a = R.paint.get("model-color-mix-intensity").constantOr(0), {
                        u_matrix: u,
                        u_lighting_matrix: t,
                        u_normal_matrix: s,
                        u_node_matrix: h || $l,
                        u_lightpos: U,
                        u_lightintensity: B.properties.get("intensity"),
                        u_lightcolor: [te.r, te.g, te.b],
                        u_camera_pos: O,
                        u_opacity: g,
                        u_baseTextureIsAlpha: 0,
                        u_alphaMask: +Q,
                        u_alphaCutoff: M.alphaCutoff,
                        u_baseColorFactor: v.toNonPremultipliedRenderColor(null).toArray01(),
                        u_emissiveFactor: b.toNonPremultipliedRenderColor(null).toArray01(),
                        u_metallicFactor: S,
                        u_roughnessFactor: P,
                        u_baseColorTexture: po.BaseColor,
                        u_metallicRoughnessTexture: po.MetallicRoughness,
                        u_normalTexture: po.Normal,
                        u_occlusionTexture: po.Occlusion,
                        u_emissionTexture: po.Emission,
                        u_lutTexture: po.LUT,
                        u_color_mix: _e.toArray01(),
                        u_aoIntensity: ce,
                        u_emissive_strength: k,
                        u_occlusionTextureTransform: V || [0, 0, 0, 0]
                    }
                }, py = (u, t = $l, s = $l) => ({u_matrix: u, u_instance: t, u_node_matrix: s}), my = {
                    fillExtrusion: u => ({
                        u_matrix: new o.ch(u),
                        u_lightpos: new o.ce(u),
                        u_lightintensity: new o.cf(u),
                        u_lightcolor: new o.ce(u),
                        u_vertical_gradient: new o.cf(u),
                        u_opacity: new o.cf(u),
                        u_edge_radius: new o.cf(u),
                        u_width_scale: new o.cf(u),
                        u_ao: new o.cg(u),
                        u_height_type: new o.cd(u),
                        u_base_type: new o.cd(u),
                        u_tile_id: new o.ce(u),
                        u_zoom_transition: new o.cf(u),
                        u_inv_rot_matrix: new o.ch(u),
                        u_merc_center: new o.cg(u),
                        u_up_dir: new o.ce(u),
                        u_height_lift: new o.cf(u),
                        u_flood_light_color: new o.ce(u),
                        u_vertical_scale: new o.cf(u),
                        u_flood_light_intensity: new o.cf(u),
                        u_ground_shadow_factor: new o.ce(u)
                    }),
                    fillExtrusionDepth: u => ({
                        u_matrix: new o.ch(u),
                        u_edge_radius: new o.cf(u),
                        u_width_scale: new o.cf(u),
                        u_vertical_scale: new o.cf(u),
                        u_height_type: new o.cd(u),
                        u_base_type: new o.cd(u)
                    }),
                    fillExtrusionPattern: u => ({
                        u_matrix: new o.ch(u),
                        u_lightpos: new o.ce(u),
                        u_lightintensity: new o.cf(u),
                        u_lightcolor: new o.ce(u),
                        u_vertical_gradient: new o.cf(u),
                        u_height_factor: new o.cf(u),
                        u_edge_radius: new o.cf(u),
                        u_width_scale: new o.cf(u),
                        u_ao: new o.cg(u),
                        u_height_type: new o.cd(u),
                        u_base_type: new o.cd(u),
                        u_tile_id: new o.ce(u),
                        u_zoom_transition: new o.cf(u),
                        u_inv_rot_matrix: new o.ch(u),
                        u_merc_center: new o.cg(u),
                        u_up_dir: new o.ce(u),
                        u_height_lift: new o.cf(u),
                        u_image: new o.cd(u),
                        u_texsize: new o.cg(u),
                        u_pixel_coord_upper: new o.cg(u),
                        u_pixel_coord_lower: new o.cg(u),
                        u_tile_units_to_pixels: new o.cf(u),
                        u_opacity: new o.cf(u),
                        u_pattern_transition: new o.cf(u)
                    }),
                    fillExtrusionGroundEffect: u => ({
                        u_matrix: new o.ch(u),
                        u_opacity: new o.cf(u),
                        u_ao_pass: new o.cf(u),
                        u_meter_to_tile: new o.cf(u),
                        u_ao: new o.cg(u),
                        u_flood_light_intensity: new o.cf(u),
                        u_flood_light_color: new o.ce(u),
                        u_attenuation: new o.cf(u),
                        u_edge_radius: new o.cf(u),
                        u_fb: new o.cd(u),
                        u_fb_size: new o.cf(u),
                        u_dynamic_offset: new o.cf(u)
                    }),
                    fill: u => ({
                        u_matrix: new o.ch(u),
                        u_emissive_strength: new o.cf(u),
                        u_ground_shadow_factor: new o.ce(u)
                    }),
                    fillPattern: u => ({
                        u_matrix: new o.ch(u),
                        u_emissive_strength: new o.cf(u),
                        u_image: new o.cd(u),
                        u_texsize: new o.cg(u),
                        u_pixel_coord_upper: new o.cg(u),
                        u_pixel_coord_lower: new o.cg(u),
                        u_tile_units_to_pixels: new o.cf(u),
                        u_ground_shadow_factor: new o.ce(u),
                        u_pattern_transition: new o.cf(u)
                    }),
                    fillOutline: u => ({
                        u_matrix: new o.ch(u),
                        u_emissive_strength: new o.cf(u),
                        u_world: new o.cg(u),
                        u_ground_shadow_factor: new o.ce(u)
                    }),
                    fillOutlinePattern: u => ({
                        u_matrix: new o.ch(u),
                        u_emissive_strength: new o.cf(u),
                        u_world: new o.cg(u),
                        u_image: new o.cd(u),
                        u_texsize: new o.cg(u),
                        u_pixel_coord_upper: new o.cg(u),
                        u_pixel_coord_lower: new o.cg(u),
                        u_tile_units_to_pixels: new o.cf(u),
                        u_ground_shadow_factor: new o.ce(u),
                        u_pattern_transition: new o.cf(u)
                    }),
                    building: u => ({u_matrix: new o.ch(u), u_normal_matrix: new o.ch(u), u_opacity: new o.cf(u)}),
                    buildingBloom: u => ({u_matrix: new o.ch(u)}),
                    buildingDepth: u => ({u_matrix: new o.ch(u)}),
                    elevatedStructuresDepth: u => ({u_matrix: new o.ch(u), u_depth_bias: new o.cf(u)}),
                    elevatedStructures: u => ({u_matrix: new o.ch(u), u_ground_shadow_factor: new o.ce(u)}),
                    elevatedStructuresDepthReconstruct: u => ({
                        u_matrix: new o.ch(u),
                        u_camera_pos: new o.ce(u),
                        u_depth_bias: new o.cf(u),
                        u_height_scale: new o.cf(u),
                        u_reset_depth: new o.cf(u)
                    }),
                    circle: o.dT,
                    collisionBox: u => ({
                        u_matrix: new o.ch(u),
                        u_inv_rot_matrix: new o.ch(u),
                        u_camera_to_center_distance: new o.cf(u),
                        u_extrude_scale: new o.cg(u),
                        u_zoom_transition: new o.cf(u),
                        u_merc_center: new o.cg(u),
                        u_tile_id: new o.ce(u)
                    }),
                    collisionCircle: u => ({
                        u_matrix: new o.ch(u),
                        u_inv_matrix: new o.ch(u),
                        u_camera_to_center_distance: new o.cf(u),
                        u_viewport_size: new o.cg(u)
                    }),
                    debug: u => ({
                        u_color: new o.dv(u),
                        u_matrix: new o.ch(u),
                        u_overlay: new o.cd(u),
                        u_overlay_scale: new o.cf(u)
                    }),
                    clippingMask: u => ({u_matrix: new o.ch(u)}),
                    heatmap: u => ({
                        u_extrude_scale: new o.cf(u),
                        u_intensity: new o.cf(u),
                        u_matrix: new o.ch(u),
                        u_inv_rot_matrix: new o.ch(u),
                        u_merc_center: new o.cg(u),
                        u_tile_id: new o.ce(u),
                        u_zoom_transition: new o.cf(u),
                        u_up_dir: new o.ce(u)
                    }),
                    heatmapTexture: u => ({u_image: new o.cd(u), u_color_ramp: new o.cd(u), u_opacity: new o.cf(u)}),
                    hillshade: u => ({
                        u_matrix: new o.ch(u),
                        u_image: new o.cd(u),
                        u_latrange: new o.cg(u),
                        u_light: new o.cg(u),
                        u_shadow: new o.dv(u),
                        u_highlight: new o.dv(u),
                        u_emissive_strength: new o.cf(u),
                        u_accent: new o.dv(u)
                    }),
                    hillshadePrepare: u => ({
                        u_matrix: new o.ch(u),
                        u_image: new o.cd(u),
                        u_dimension: new o.cg(u),
                        u_zoom: new o.cf(u)
                    }),
                    line: o.dS,
                    linePattern: o.dR,
                    raster: u => ({
                        u_matrix: new o.ch(u),
                        u_normalize_matrix: new o.ch(u),
                        u_globe_matrix: new o.ch(u),
                        u_merc_matrix: new o.ch(u),
                        u_grid_matrix: new o.dw(u),
                        u_tl_parent: new o.cg(u),
                        u_scale_parent: new o.cf(u),
                        u_fade_t: new o.cf(u),
                        u_opacity: new o.cf(u),
                        u_image0: new o.cd(u),
                        u_image1: new o.cd(u),
                        u_brightness_low: new o.cf(u),
                        u_brightness_high: new o.cf(u),
                        u_saturation_factor: new o.cf(u),
                        u_contrast_factor: new o.cf(u),
                        u_spin_weights: new o.ce(u),
                        u_perspective_transform: new o.cg(u),
                        u_raster_elevation: new o.cf(u),
                        u_zoom_transition: new o.cf(u),
                        u_merc_center: new o.cg(u),
                        u_cutoff_params: new o.d0(u),
                        u_colorization_mix: new o.d0(u),
                        u_colorization_offset: new o.cf(u),
                        u_color_ramp: new o.cd(u),
                        u_texture_offset: new o.cg(u),
                        u_texture_res: new o.cg(u),
                        u_emissive_strength: new o.cf(u)
                    }),
                    rasterParticle: u => ({
                        u_matrix: new o.ch(u),
                        u_normalize_matrix: new o.ch(u),
                        u_globe_matrix: new o.ch(u),
                        u_merc_matrix: new o.ch(u),
                        u_grid_matrix: new o.dw(u),
                        u_tl_parent: new o.cg(u),
                        u_scale_parent: new o.cf(u),
                        u_fade_t: new o.cf(u),
                        u_opacity: new o.cf(u),
                        u_image0: new o.cd(u),
                        u_image1: new o.cd(u),
                        u_raster_elevation: new o.cf(u),
                        u_zoom_transition: new o.cf(u),
                        u_merc_center: new o.cg(u),
                        u_cutoff_params: new o.d0(u)
                    }),
                    rasterParticleTexture: u => ({u_texture: new o.cd(u), u_opacity: new o.cf(u)}),
                    rasterParticleDraw: u => ({
                        u_particle_texture: new o.cd(u),
                        u_particle_texture_side_len: new o.cf(u),
                        u_tile_offset: new o.cg(u),
                        u_velocity: new o.cd(u),
                        u_color_ramp: new o.cd(u),
                        u_velocity_res: new o.cg(u),
                        u_max_speed: new o.cf(u),
                        u_uv_offset: new o.cg(u),
                        u_data_scale: new o.cg(u),
                        u_data_offset: new o.cf(u),
                        u_particle_pos_scale: new o.cf(u),
                        u_particle_pos_offset: new o.cg(u)
                    }),
                    rasterParticleUpdate: u => ({
                        u_particle_texture: new o.cd(u),
                        u_particle_texture_side_len: new o.cf(u),
                        u_velocity: new o.cd(u),
                        u_velocity_res: new o.cg(u),
                        u_max_speed: new o.cf(u),
                        u_speed_factor: new o.cf(u),
                        u_reset_rate: new o.cf(u),
                        u_rand_seed: new o.cf(u),
                        u_uv_offset: new o.cg(u),
                        u_data_scale: new o.cg(u),
                        u_data_offset: new o.cf(u),
                        u_particle_pos_scale: new o.cf(u),
                        u_particle_pos_offset: new o.cg(u)
                    }),
                    symbol: u => ({
                        u_is_size_zoom_constant: new o.cd(u),
                        u_is_size_feature_constant: new o.cd(u),
                        u_size_t: new o.cf(u),
                        u_size: new o.cf(u),
                        u_camera_to_center_distance: new o.cf(u),
                        u_rotate_symbol: new o.cd(u),
                        u_aspect_ratio: new o.cf(u),
                        u_fade_change: new o.cf(u),
                        u_matrix: new o.ch(u),
                        u_label_plane_matrix: new o.ch(u),
                        u_coord_matrix: new o.ch(u),
                        u_is_text: new o.cd(u),
                        u_elevation_from_sea: new o.cd(u),
                        u_pitch_with_map: new o.cd(u),
                        u_texsize: new o.cg(u),
                        u_texsize_icon: new o.cg(u),
                        u_texture: new o.cd(u),
                        u_texture_icon: new o.cd(u),
                        u_gamma_scale: new o.cf(u),
                        u_device_pixel_ratio: new o.cf(u),
                        u_tile_id: new o.ce(u),
                        u_zoom_transition: new o.cf(u),
                        u_inv_rot_matrix: new o.ch(u),
                        u_merc_center: new o.cg(u),
                        u_camera_forward: new o.ce(u),
                        u_tile_matrix: new o.ch(u),
                        u_up_vector: new o.ce(u),
                        u_ecef_origin: new o.ce(u),
                        u_is_halo: new o.cd(u),
                        u_icon_transition: new o.cf(u),
                        u_color_adj_mat: new o.ch(u),
                        u_scale_factor: new o.cf(u),
                        u_ground_shadow_factor: new o.ce(u),
                        u_inv_matrix: new o.ch(u),
                        u_normal_scale: new o.cf(u)
                    }),
                    background: u => ({
                        u_matrix: new o.ch(u),
                        u_emissive_strength: new o.cf(u),
                        u_opacity: new o.cf(u),
                        u_color: new o.dv(u)
                    }),
                    backgroundPattern: u => ({
                        u_matrix: new o.ch(u),
                        u_emissive_strength: new o.cf(u),
                        u_opacity: new o.cf(u),
                        u_image: new o.cd(u),
                        u_pattern_tl: new o.cg(u),
                        u_pattern_br: new o.cg(u),
                        u_texsize: new o.cg(u),
                        u_pattern_size: new o.cg(u),
                        u_pixel_coord_upper: new o.cg(u),
                        u_pixel_coord_lower: new o.cg(u),
                        u_pattern_units_to_pixels: new o.cg(u)
                    }),
                    terrainRaster: u => ({
                        u_matrix: new o.ch(u),
                        u_image0: new o.cd(u),
                        u_skirt_height: new o.cf(u),
                        u_ground_shadow_factor: new o.ce(u)
                    }),
                    skybox: u => ({
                        u_matrix: new o.ch(u),
                        u_sun_direction: new o.ce(u),
                        u_cubemap: new o.cd(u),
                        u_opacity: new o.cf(u),
                        u_temporal_offset: new o.cf(u)
                    }),
                    skyboxGradient: u => ({
                        u_matrix: new o.ch(u),
                        u_color_ramp: new o.cd(u),
                        u_center_direction: new o.ce(u),
                        u_radius: new o.cf(u),
                        u_opacity: new o.cf(u),
                        u_temporal_offset: new o.cf(u)
                    }),
                    skyboxCapture: u => ({
                        u_matrix_3f: new o.dw(u),
                        u_sun_direction: new o.ce(u),
                        u_sun_intensity: new o.cf(u),
                        u_color_tint_r: new o.d0(u),
                        u_color_tint_m: new o.d0(u),
                        u_luminance: new o.cf(u)
                    }),
                    globeRaster: u => ({
                        u_proj_matrix: new o.ch(u),
                        u_globe_matrix: new o.ch(u),
                        u_normalize_matrix: new o.ch(u),
                        u_merc_matrix: new o.ch(u),
                        u_zoom_transition: new o.cf(u),
                        u_merc_center: new o.cg(u),
                        u_image0: new o.cd(u),
                        u_grid_matrix: new o.dw(u),
                        u_skirt_height: new o.cf(u),
                        u_far_z_cutoff: new o.cf(u),
                        u_frustum_tl: new o.ce(u),
                        u_frustum_tr: new o.ce(u),
                        u_frustum_br: new o.ce(u),
                        u_frustum_bl: new o.ce(u),
                        u_globe_pos: new o.ce(u),
                        u_globe_radius: new o.cf(u),
                        u_viewport: new o.cg(u)
                    }),
                    globeAtmosphere: u => ({
                        u_frustum_tl: new o.ce(u),
                        u_frustum_tr: new o.ce(u),
                        u_frustum_br: new o.ce(u),
                        u_frustum_bl: new o.ce(u),
                        u_horizon: new o.cf(u),
                        u_transition: new o.cf(u),
                        u_fadeout_range: new o.cf(u),
                        u_color: new o.d0(u),
                        u_high_color: new o.d0(u),
                        u_space_color: new o.d0(u),
                        u_temporal_offset: new o.cf(u),
                        u_horizon_angle: new o.cf(u)
                    }),
                    model: u => ({
                        u_matrix: new o.ch(u),
                        u_lighting_matrix: new o.ch(u),
                        u_normal_matrix: new o.ch(u),
                        u_node_matrix: new o.ch(u),
                        u_lightpos: new o.ce(u),
                        u_lightintensity: new o.cf(u),
                        u_lightcolor: new o.ce(u),
                        u_camera_pos: new o.ce(u),
                        u_opacity: new o.cf(u),
                        u_baseColorFactor: new o.d0(u),
                        u_emissiveFactor: new o.d0(u),
                        u_metallicFactor: new o.cf(u),
                        u_roughnessFactor: new o.cf(u),
                        u_baseTextureIsAlpha: new o.cd(u),
                        u_alphaMask: new o.cd(u),
                        u_alphaCutoff: new o.cf(u),
                        u_baseColorTexture: new o.cd(u),
                        u_metallicRoughnessTexture: new o.cd(u),
                        u_normalTexture: new o.cd(u),
                        u_occlusionTexture: new o.cd(u),
                        u_emissionTexture: new o.cd(u),
                        u_lutTexture: new o.cd(u),
                        u_color_mix: new o.d0(u),
                        u_aoIntensity: new o.cf(u),
                        u_emissive_strength: new o.cf(u),
                        u_occlusionTextureTransform: new o.d0(u)
                    }),
                    modelDepth: u => ({u_matrix: new o.ch(u), u_instance: new o.ch(u), u_node_matrix: new o.ch(u)}),
                    groundShadow: u => ({u_matrix: new o.ch(u), u_ground_shadow_factor: new o.ce(u)}),
                    stars: u => ({
                        u_matrix: new o.ch(u),
                        u_up: new o.ce(u),
                        u_right: new o.ce(u),
                        u_intensity_multiplier: new o.cf(u)
                    }),
                    snowParticle: u => ({
                        u_modelview: new o.ch(u),
                        u_projection: new o.ch(u),
                        u_time: new o.cf(u),
                        u_cam_pos: new o.ce(u),
                        u_velocityConeAperture: new o.cf(u),
                        u_velocity: new o.cf(u),
                        u_horizontalOscillationRadius: new o.cf(u),
                        u_horizontalOscillationRate: new o.cf(u),
                        u_boxSize: new o.cf(u),
                        u_billboardSize: new o.cf(u),
                        u_simpleShapeParameters: new o.cg(u),
                        u_screenSize: new o.cg(u),
                        u_thinningCenterPos: new o.cg(u),
                        u_thinningShape: new o.ce(u),
                        u_thinningAffectedRatio: new o.cf(u),
                        u_thinningParticleOffset: new o.cf(u),
                        u_particleColor: new o.d0(u),
                        u_direction: new o.ce(u)
                    }),
                    rainParticle: u => ({
                        u_modelview: new o.ch(u),
                        u_projection: new o.ch(u),
                        u_time: new o.cf(u),
                        u_cam_pos: new o.ce(u),
                        u_texScreen: new o.cd(u),
                        u_velocityConeAperture: new o.cf(u),
                        u_velocity: new o.cf(u),
                        u_boxSize: new o.cf(u),
                        u_rainDropletSize: new o.cg(u),
                        u_distortionStrength: new o.cf(u),
                        u_rainDirection: new o.ce(u),
                        u_color: new o.d0(u),
                        u_screenSize: new o.cg(u),
                        u_thinningCenterPos: new o.cg(u),
                        u_thinningShape: new o.ce(u),
                        u_thinningAffectedRatio: new o.cf(u),
                        u_thinningParticleOffset: new o.cf(u),
                        u_shapeDirectionalPower: new o.cf(u),
                        u_shapeNormalPower: new o.cf(u),
                        u_mode: new o.cf(u)
                    }),
                    vignette: u => ({u_vignetteShape: new o.ce(u), u_vignetteColor: new o.d0(u)}),
                    occlusion: u => ({
                        u_matrix: new o.ch(u),
                        u_anchorPos: new o.ce(u),
                        u_screenSizePx: new o.cg(u),
                        u_occluderSizePx: new o.cg(u),
                        u_color: new o.d0(u)
                    })
                };

            class rl {
                constructor(t, s, h, m) {
                    this.id = rl.uniqueIdxCounter, rl.uniqueIdxCounter++, this.context = t;
                    const g = t.gl;
                    this.buffer = g.createBuffer(), this.dynamicDraw = !!h, this.context.unbindVAO(), t.bindElementBuffer.set(this.buffer), g.bufferData(g.ELEMENT_ARRAY_BUFFER, s.arrayBuffer, this.dynamicDraw ? g.DYNAMIC_DRAW : g.STATIC_DRAW), this.dynamicDraw || m || s.destroy()
                }

                bind() {
                    this.context.bindElementBuffer.set(this.buffer)
                }

                updateData(t) {
                    this.id = rl.uniqueIdxCounter, rl.uniqueIdxCounter++;
                    const s = this.context.gl;
                    this.context.unbindVAO(), this.bind(), s.bufferSubData(s.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer)
                }

                destroy() {
                    this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
                }
            }

            rl.uniqueIdxCounter = 0;
            const um = {
                Int8: "BYTE",
                Uint8: "UNSIGNED_BYTE",
                Int16: "SHORT",
                Uint16: "UNSIGNED_SHORT",
                Int32: "INT",
                Uint32: "UNSIGNED_INT",
                Float32: "FLOAT"
            };

            class hm {
                constructor(t, s, h, m, g, v) {
                    this.length = s.length, this.attributes = h, this.itemSize = s.bytesPerElement, this.dynamicDraw = m, this.instanceCount = v, this.context = t;
                    const b = t.gl;
                    this.buffer = b.createBuffer(), t.bindVertexBuffer.set(this.buffer), b.bufferData(b.ARRAY_BUFFER, s.arrayBuffer, this.dynamicDraw ? b.DYNAMIC_DRAW : b.STATIC_DRAW), this.dynamicDraw || g || s.destroy()
                }

                bind() {
                    this.context.bindVertexBuffer.set(this.buffer)
                }

                updateData(t) {
                    const s = this.context.gl;
                    this.bind(), s.bufferSubData(s.ARRAY_BUFFER, 0, t.arrayBuffer)
                }

                enableAttributes(t, s) {
                    for (let h = 0; h < this.attributes.length; h++) {
                        const m = s.attributes[this.attributes[h].name];
                        m !== void 0 && t.enableVertexAttribArray(m)
                    }
                }

                setVertexAttribPointers(t, s, h) {
                    for (let m = 0; m < this.attributes.length; m++) {
                        const g = this.attributes[m], v = s.attributes[g.name];
                        v !== void 0 && t.vertexAttribPointer(v, g.components, t[um[g.type]], !1, this.itemSize, g.offset + this.itemSize * (h || 0))
                    }
                }

                setVertexAttribDivisor(t, s, h) {
                    for (let m = 0; m < this.attributes.length; m++) {
                        const g = s.attributes[this.attributes[m].name];
                        g !== void 0 && this.instanceCount && this.instanceCount > 0 && t.vertexAttribDivisor(g, h)
                    }
                }

                destroy() {
                    this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer)
                }
            }

            class Hl {
                constructor(t, s, h, m, g) {
                    this.context = t, this.width = s, this.height = h;
                    const v = this.framebuffer = t.gl.createFramebuffer();
                    m && (this.colorAttachment = new Jx(t, v)), g && (this.depthAttachmentType = g, this.depthAttachment = g === "renderbuffer" ? new ny(t, v) : new Xp(t, v))
                }

                destroy() {
                    const t = this.context.gl;
                    if (this.colorAttachment) {
                        const s = this.colorAttachment.get();
                        s && t.deleteTexture(s)
                    }
                    if (this.depthAttachment && this.depthAttachmentType) if (this.depthAttachmentType === "renderbuffer") {
                        const s = this.depthAttachment.get();
                        s && t.deleteRenderbuffer(s)
                    } else {
                        const s = this.depthAttachment.get();
                        s && t.deleteTexture(s)
                    }
                    t.deleteFramebuffer(this.framebuffer)
                }
            }

            class Hd {
                constructor(t, s) {
                    this.gl = t, this.clearColor = new Wx(this), this.clearDepth = new Zx(this), this.clearStencil = new Xx(this), this.colorMask = new Yx(this), this.depthMask = new X_(this), this.stencilMask = new Kx(this), this.stencilFunc = new Ad(this), this.stencilOp = new Qx(this), this.stencilTest = new Y_(this), this.depthRange = new $p(this), this.depthTest = new Id(this), this.depthFunc = new Hp(this), this.blend = new Vl(this), this.blendFunc = new Mc(this), this.blendColor = new Cd(this), this.blendEquation = new Pd(this), this.cullFace = new Rc(this), this.cullFaceSide = new K_(this), this.frontFace = new qp(this), this.program = new Q_(this), this.activeTexture = new zc(this), this.viewport = new Md(this), this.bindFramebuffer = new Rd(this), this.bindRenderbuffer = new Wp(this), this.bindTexture = new zd(this), this.bindVertexBuffer = new fh(this), this.bindElementBuffer = new J_(this), this.bindVertexArrayOES = new ey(this), this.pixelStoreUnpack = new ty(this), this.pixelStoreUnpackPremultiplyAlpha = new Dc(this), this.pixelStoreUnpackFlipY = new iy(this), this.options = s ? Object.assign({}, s) : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = t.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = t.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = t.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.forceManualRenderingForInstanceIDShaders = s && !!s.forceManualRenderingForInstanceIDShaders || this.renderer && this.renderer.indexOf("PowerVR") !== -1, this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = t.getExtension("OES_texture_float_linear")), this.extRenderToTextureHalfFloat = t.getExtension("EXT_color_buffer_half_float"), this.extTimerQuery = t.getExtension("EXT_disjoint_timer_query_webgl2"), this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), this.maxPointSize = t.getParameter(t.ALIASED_POINT_SIZE_RANGE)[1]
                }

                setDefault() {
                    this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault()
                }

                setDirty() {
                    this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArrayOES.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0
                }

                createIndexBuffer(t, s, h) {
                    return new rl(this, t, s, h)
                }

                createVertexBuffer(t, s, h, m, g) {
                    return new hm(this, t, s, h, m, g)
                }

                createRenderbuffer(t, s, h) {
                    const m = this.gl, g = m.createRenderbuffer();
                    return this.bindRenderbuffer.set(g), m.renderbufferStorage(m.RENDERBUFFER, t, s, h), this.bindRenderbuffer.set(null), g
                }

                createFramebuffer(t, s, h, m) {
                    return new Hl(this, t, s, h, m)
                }

                clear({color: t, depth: s, stencil: h, colorMask: m}) {
                    const g = this.gl;
                    let v = 0;
                    t && (v |= g.COLOR_BUFFER_BIT, this.clearColor.set(t.toNonPremultipliedRenderColor(null)), this.colorMask.set(m || [!0, !0, !0, !0])), s !== void 0 && (v |= g.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(s), this.depthMask.set(!0)), h !== void 0 && (v |= g.STENCIL_BUFFER_BIT, this.clearStencil.set(h), this.stencilMask.set(255)), g.clear(v)
                }

                setCullFace(t) {
                    t.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(t.mode), this.frontFace.set(t.frontFace))
                }

                setDepthMode(t) {
                    t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0), this.depthFunc.set(t.func), this.depthMask.set(t.mask), this.depthRange.set(t.range)) : this.depthTest.set(!1)
                }

                setStencilMode(t) {
                    t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0), this.stencilMask.set(t.mask), this.stencilOp.set([t.fail, t.depthFail, t.pass]), this.stencilFunc.set({
                        func: t.test.func,
                        ref: t.ref,
                        mask: t.test.mask
                    })) : this.stencilTest.set(!1)
                }

                setColorMode(t) {
                    o.bv(t.blendFunction, gi.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t.blendFunction), this.blendColor.set(t.blendColor), t.blendEquation ? this.blendEquation.set(t.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(t.mask)
                }

                unbindVAO() {
                    this.bindVertexArrayOES.set(null)
                }
            }

            let ol;

            function dm(u, t, s, h, m, g, v) {
                const b = u.context, S = b.gl, P = u.transform, M = [o.aD(P.center.lng), o.aH(P.center.lat)],
                    k = s.layout.get("symbol-placement"), R = s.layout.get("text-variable-anchor"),
                    O = s.layout.get("icon-rotation-alignment") === "map",
                    V = s.layout.get("text-rotation-alignment") === "map", B = k !== "point", G = [];
                let U = 0, Z = 0;
                for (let he = 0; he < h.length; he++) {
                    const me = h[he], Oe = t.getTile(me), Se = Oe.getBucket(s);
                    if (!Se) continue;
                    const Xe = Se.getProjection().createInversionMatrix(P, me.canonical), je = [], Ke = O_(me, Se, P),
                        ut = !v && O && B, Fe = v && V && B, Te = R && Se.hasTextData(),
                        $e = Se.hasIconTextFit() && Te && Se.hasIconData(), Be = ut || Fe || v && Te || $e,
                        tt = Se.projection.name === "globe", it = tt ? o.ah(P.zoom) : 0;
                    tt && (je.push("PROJECTION_GLOBE_VIEW"), Be && je.push("PROJECTED_POS_ON_VIEWPORT"));
                    const rt = u.getOrCreateProgram("collisionBox", {defines: je});
                    let gt = Ke;
                    m[0] === 0 && m[1] === 0 || (gt = u.translatePosMatrix(Ke, Oe, m, g));
                    const Ot = v ? Se.textCollisionBox : Se.iconCollisionBox, Ut = Se.collisionCircleArray;
                    if (Ut.length > 0) {
                        const Nt = o.bz(), Ft = gt;
                        o.cM(Nt, Se.placementInvProjMatrix, P.glCoordMatrix), o.cM(Nt, Nt, Se.placementViewportMatrix), G.push({
                            circleArray: Ut,
                            circleOffset: Z,
                            transform: Ft,
                            invTransform: Nt,
                            projection: Se.getProjection()
                        }), U += Ut.length / 4, Z = U
                    }
                    if (!Ot) continue;
                    u.terrain && u.terrain.setupElevationDraw(Oe, rt);
                    const St = tt ? [me.canonical.x, me.canonical.y, 1 << me.canonical.z] : [0, 0, 0];
                    rt.draw(u, S.LINES, It.disabled, ei.disabled, u.colorModeForRenderPass(), Yt.disabled, Oc(gt, Xe, P, it, M, Oe, St, Se.getProjection()), s.id, Ot.layoutVertexBuffer, Ot.indexBuffer, Ot.segments, null, P.zoom, null, [Ot.collisionVertexBuffer, Ot.collisionVertexBufferExt])
                }
                if (!v || !G.length) return;
                const Q = u.getOrCreateProgram("collisionCircle"), te = new o.dU;
                te.resize(4 * U), te._trim();
                let ce = 0;
                for (const he of G) for (let me = 0; me < he.circleArray.length / 4; me++) {
                    const Oe = 4 * me, Se = he.circleArray[Oe + 0], Xe = he.circleArray[Oe + 1],
                        je = he.circleArray[Oe + 2], Ke = he.circleArray[Oe + 3];
                    te.emplace(ce++, Se, Xe, je, Ke, 0), te.emplace(ce++, Se, Xe, je, Ke, 1), te.emplace(ce++, Se, Xe, je, Ke, 2), te.emplace(ce++, Se, Xe, je, Ke, 3)
                }
                (!ol || ol.length < 2 * U) && (ol = function (he) {
                    const me = 2 * he, Oe = new o.a_;
                    Oe.resize(me), Oe._trim();
                    for (let Se = 0; Se < me; Se++) {
                        const Xe = 6 * Se;
                        Oe.uint16[Xe + 0] = 4 * Se + 0, Oe.uint16[Xe + 1] = 4 * Se + 1, Oe.uint16[Xe + 2] = 4 * Se + 2, Oe.uint16[Xe + 3] = 4 * Se + 2, Oe.uint16[Xe + 4] = 4 * Se + 3, Oe.uint16[Xe + 5] = 4 * Se + 0
                    }
                    return Oe
                }(U));
                const _e = b.createIndexBuffer(ol, !0), ve = b.createVertexBuffer(te, o.dV.members, !0);
                for (const he of G) {
                    const me = {
                        u_matrix: he.transform,
                        u_inv_matrix: he.invTransform,
                        u_camera_to_center_distance: (ue = P).getCameraToCenterDistance(he.projection),
                        u_viewport_size: [ue.width, ue.height]
                    };
                    Q.draw(u, S.TRIANGLES, It.disabled, ei.disabled, u.colorModeForRenderPass(), Yt.disabled, me, s.id, ve, _e, o.bd.simpleSegment(0, 2 * he.circleOffset, he.circleArray.length, he.circleArray.length / 2), null, P.zoom)
                }
                var ue;
                ve.destroy(), _e.destroy()
            }

            const ql = o.bz();

            function gh(u) {
                const t = u._camera.getWorldToCamera(u.worldSize, 1), s = o.az([], t, u.globeMatrix);
                o.bi(s, s);
                const h = [0, 0, 0], m = [0, 1, 0, 0];
                return o.aA(m, m, s), h[0] = m[0], h[1] = m[1], h[2] = m[2], o.au(h, h), h
            }

            function fm({width: u, height: t, anchor: s, textOffset: h, textScale: m}, g) {
                const {horizontalAlign: v, verticalAlign: b} = o.bZ(s), S = -(v - .5) * u, P = -(b - .5) * t,
                    M = o.b_(s, h);
                return new o.P((S / m + M[0]) * g, (P / m + M[1]) * g)
            }

            function gy(u, t, s, h, m, g, v, b, S, P) {
                const M = u.text.placedSymbolArray, k = u.text.dynamicLayoutVertexArray,
                    R = u.icon.dynamicLayoutVertexArray, O = {}, V = u.getProjection(), B = pd(v, V, m),
                    G = m.elevation, U = V.upVectorScale(v.canonical, m.center.lat, m.worldSize).metersToTile;
                k.clear();
                for (let Z = 0; Z < M.length; Z++) {
                    const Q = M.get(Z), {tileAnchorX: te, tileAnchorY: ce, numGlyphs: _e} = Q,
                        ve = Q.hidden || !Q.crossTileID || u.allowVerticalPlacement && !Q.placedOrientation ? null : h[Q.crossTileID];
                    if (ve) {
                        let ue = 0, he = 0, me = 0;
                        if (G) {
                            const $e = G ? G.getAtTileOffset(v, te, ce) : 0, [Be, tt, it] = V.upVector(v.canonical, te, ce);
                            ue = $e * Be * U, he = $e * tt * U, me = $e * it * U
                        }
                        let [Oe, Se, Xe, je] = Xo(Q.projectedAnchorX + ue, Q.projectedAnchorY + he, Q.projectedAnchorZ + me, s ? B : g);
                        const Ke = Rp(m.getCameraToCenterDistance(V), je);
                        let ut = o.bJ(u.textSizeData, S, Q) * Ke / o.bU;
                        s && (ut *= u.tilePixelRatio / b);
                        const Fe = fm(ve, ut);
                        s ? ({
                            x: Oe,
                            y: Se,
                            z: Xe
                        } = V.projectTilePoint(te + Fe.x, ce + Fe.y, v.canonical), [Oe, Se, Xe] = Xo(Oe + ue, Se + he, Xe + me, g)) : (t && Fe._rotate(-m.angle), Oe += Fe.x, Se += Fe.y, Xe = 0);
                        const Te = u.allowVerticalPlacement && Q.placedOrientation === o.bI.vertical ? Math.PI / 2 : 0;
                        for (let $e = 0; $e < _e; $e++) o.bL(k, Oe, Se, Xe, Te);
                        P && Q.associatedIconIndex >= 0 && (O[Q.associatedIconIndex] = {x: Oe, y: Se, z: Xe, angle: Te})
                    } else wc(_e, k)
                }
                if (P) {
                    R.clear();
                    const Z = u.icon.placedSymbolArray;
                    for (let Q = 0; Q < Z.length; Q++) {
                        const te = Z.get(Q), {numGlyphs: ce} = te, _e = O[Q];
                        if (te.hidden || !_e) wc(ce, R); else {
                            const {x: ve, y: ue, z: he, angle: me} = _e;
                            for (let Oe = 0; Oe < ce; Oe++) o.bL(R, ve, ue, he, me)
                        }
                    }
                    u.icon.dynamicLayoutVertexBuffer.updateData(R)
                }
                u.text.dynamicLayoutVertexBuffer.updateData(k)
            }

            function pm(u, t, s, h, m, g, v = {}) {
                const b = s.paint.get("icon-translate"), S = s.paint.get("text-translate"),
                    P = s.paint.get("icon-translate-anchor"), M = s.paint.get("text-translate-anchor"),
                    k = s.layout.get("icon-rotation-alignment"), R = s.layout.get("text-rotation-alignment"),
                    O = s.layout.get("icon-pitch-alignment"), V = s.layout.get("text-pitch-alignment"),
                    B = s.layout.get("icon-keep-upright"), G = s.layout.get("text-keep-upright"),
                    U = s.paint.get("icon-color-saturation"), Z = s.paint.get("icon-color-contrast"),
                    Q = s.paint.get("icon-color-brightness-min"), te = s.paint.get("icon-color-brightness-max"),
                    ce = s.layout.get("symbol-elevation-reference") === "sea", _e = u.context, ve = _e.gl,
                    ue = u.transform, he = k === "map", me = R === "map", Oe = O === "map", Se = V === "map",
                    Xe = s.layout.get("symbol-sort-key").constantOr(1) !== void 0;
                let je = !1;
                const Ke = u.depthModeForSublayer(0, It.ReadOnly),
                    ut = new It(u.context.gl.LEQUAL, It.ReadOnly, u.depthRangeFor3D),
                    Fe = [o.aD(ue.center.lng), o.aH(ue.center.lat)], Te = s.layout.get("text-variable-anchor"),
                    $e = ue.projection.name === "globe", Be = [], tt = [0, -1, 0];
                for (const it of h) {
                    const rt = t.getTile(it), gt = rt.getBucket(s);
                    if (!gt || gt.projection.name === "mercator" && $e || gt.fullyClipped) continue;
                    const Ot = gt.projection.name === "globe", Ut = Ot ? o.ah(ue.zoom) : 0,
                        St = pd(it, gt.getProjection(), ue), Nt = ue.calculatePixelsToTileUnitsMatrix(rt),
                        Ft = Te && gt.hasTextData(), ri = gt.hasIconTextFit() && Ft && gt.hasIconData(),
                        di = gt.getProjection().createInversionMatrix(ue, it.canonical),
                        Si = (1 << rt.tileID.canonical.z) * o.aj / u.transform.worldSize, Ui = rn => {
                            let Wi = [0, 0, 0];
                            if (rn) {
                                const kn = u.style.directionalLight, ji = u.style.ambientLight;
                                kn && ji && (Wi = Nl(u.style, kn, ji))
                            }
                            return Wi
                        }, ci = rn => {
                            ue.depthOcclusionForSymbolsAndCircles && (s.hasInitialOcclusionOpacityProperties || u.terrain) && (rn.push("DEPTH_D24"), rn.push("DEPTH_OCCLUSION"))
                        }, Gi = () => {
                            const rn = he && s.layout.get("symbol-placement") !== "point", Wi = [];
                            ci(Wi);
                            const kn = rn || ri, ji = gt.elevationType === "road", Yi = u.shadowRenderer,
                                hn = ji && Oe && !!Yi && Yi.enabled, ir = Ui(hn), er = ji && Oe && !u.terrain ? ut : Ke,
                                rr = s.paint.get("icon-image-cross-fade");
                            u.terrainRenderModeElevated() && Oe && Wi.push("PITCH_WITH_MAP_TERRAIN"), Ot && (Wi.push("PROJECTION_GLOBE_VIEW"), kn && Wi.push("PROJECTED_POS_ON_VIEWPORT")), rr > 0 && gt.hasAnySecondaryIcon && Wi.push("ICON_TRANSITION"), !gt.icon.zOffsetVertexBuffer || ji && u.terrain || Wi.push("Z_OFFSET"), U === 0 && Z === 0 && Q === 0 && te === 1 || Wi.push("COLOR_ADJUSTMENT"), gt.sdfIcons && Wi.push("RENDER_SDF"), hn && Wi.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"), ji && Oe && !u.terrain && gt.icon.orientationVertexBuffer && Wi.push("ELEVATED_ROADS");
                            const Rr = gt.icon.programConfigurations.get(s.id),
                                Ns = u.getOrCreateProgram("symbol", {config: Rr, defines: Wi}),
                                _o = rt.imageAtlasTexture ? rt.imageAtlasTexture.size : [0, 0], Fo = gt.iconSizeData,
                                Ur = o.bH(Fo, ue.zoom), ts = Oe || !ue.isOrthographic,
                                Ss = eh(St, rt.tileID.canonical, Oe, he, ue, gt.getProjection(), Nt),
                                Gr = _a(St, rt.tileID.canonical, Oe, he, ue, gt.getProjection(), Nt),
                                Yn = u.translatePosMatrix(Gr, rt, b, P, !0), Un = u.translatePosMatrix(St, rt, b, P),
                                gn = kn ? ql : Ss, ur = he && !Oe && !rn;
                            let zr = tt;
                            !$e && !ue.mercatorFromTransition || he || (zr = gh(ue));
                            const Kn = Ot ? zr : tt, is = s.getColorAdjustmentMatrix(U, Z, Q, te),
                                Yl = $d(Fo.kind, Ur, ur, Oe, u, Un, gn, Yn, ce, !1, _o, [0, 0], 0, it, Ut, Fe, di, Kn, gt.getProjection(), ir, Si, is, rr, null),
                                dl = rt.imageAtlasTexture ? rt.imageAtlasTexture : null,
                                Kc = s.layout.get("icon-size").constantOr(0) !== 1 || gt.iconsNeedLinear,
                                Qc = gt.sdfIcons || u.options.rotating || u.options.zooming || Kc || ts ? ve.LINEAR : ve.NEAREST,
                                ns = gt.sdfIcons && s.paint.get("icon-halo-width").constantOr(1) !== 0,
                                ia = u.terrain && Oe && rn ? o.bi(o.bz(), Ss) : ql;
                            if (rn && gt.icon) {
                                const hr = ue.elevation,
                                    rs = hr ? hr.getAtTileOffsetFunc(it, ue.center.lat, ue.worldSize, gt.getProjection()) : null,
                                    Kl = xc(St, rt.tileID.canonical, Oe, he, ue, gt.getProjection(), Nt);
                                Ol(gt, St, u, !1, Kl, Gr, Oe, B, rs, it)
                            }
                            return {
                                program: Ns,
                                buffers: gt.icon,
                                uniformValues: Yl,
                                atlasTexture: dl,
                                atlasTextureIcon: null,
                                atlasInterpolation: Qc,
                                atlasInterpolationIcon: null,
                                isSDF: gt.sdfIcons,
                                hasHalo: ns,
                                depthMode: er,
                                tile: rt,
                                renderWithShadows: hn,
                                labelPlaneMatrixInv: ia
                            }
                        }, qi = () => {
                            const rn = me && s.layout.get("symbol-placement") !== "point", Wi = [], kn = rn || Te || ri,
                                ji = gt.elevationType === "road", Yi = u.shadowRenderer,
                                hn = ji && Se && !!Yi && Yi.enabled, ir = Ui(hn), er = ji && Se && !u.terrain ? ut : Ke;
                            u.terrainRenderModeElevated() && Se && Wi.push("PITCH_WITH_MAP_TERRAIN"), Ot && (Wi.push("PROJECTION_GLOBE_VIEW"), kn && Wi.push("PROJECTED_POS_ON_VIEWPORT")), !gt.text.zOffsetVertexBuffer || ji && u.terrain || Wi.push("Z_OFFSET"), gt.iconsInText && Wi.push("RENDER_TEXT_AND_SYMBOL"), Wi.push("RENDER_SDF"), hn && Wi.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"), ji && Se && !u.terrain && gt.text.orientationVertexBuffer && Wi.push("ELEVATED_ROADS"), ci(Wi);
                            const rr = gt.text.programConfigurations.get(s.id),
                                Rr = u.getOrCreateProgram("symbol", {config: rr, defines: Wi});
                            let Ns, _o = [0, 0], Fo = null;
                            const Ur = gt.textSizeData;
                            gt.iconsInText && (_o = rt.imageAtlasTexture ? rt.imageAtlasTexture.size : [0, 0], Fo = rt.imageAtlasTexture ? rt.imageAtlasTexture : null, Ns = Se || !ue.isOrthographic || u.options.rotating || u.options.zooming || Ur.kind === "composite" || Ur.kind === "camera" ? ve.LINEAR : ve.NEAREST);
                            const ts = rt.glyphAtlasTexture ? rt.glyphAtlasTexture.size : [0, 0],
                                Ss = s.layout.get("text-size-scale-range"), Gr = o.ay(u.scaleFactor, Ss[0], Ss[1]),
                                Yn = o.bH(Ur, ue.zoom, Gr),
                                Un = eh(St, rt.tileID.canonical, Se, me, ue, gt.getProjection(), Nt),
                                gn = _a(St, rt.tileID.canonical, Se, me, ue, gt.getProjection(), Nt),
                                ur = u.translatePosMatrix(gn, rt, S, M, !0), zr = u.translatePosMatrix(St, rt, S, M),
                                Kn = kn ? ql : Un, is = me && !Se && !rn;
                            let Yl = tt;
                            !$e && !ue.mercatorFromTransition || me || (Yl = gh(ue));
                            const dl = $d(Ur.kind, Yn, is, Se, u, zr, Kn, ur, ce, !0, ts, _o, 0, it, Ut, Fe, di, Ot ? Yl : tt, gt.getProjection(), ir, Si, null, null, Gr),
                                Kc = rt.glyphAtlasTexture ? rt.glyphAtlasTexture : null, Qc = ve.LINEAR,
                                ns = s.paint.get("text-halo-width").constantOr(1) !== 0,
                                ia = u.terrain && Se && rn ? o.bi(o.bz(), Un) : ql;
                            if (rn && gt.text) {
                                const hr = ue.elevation,
                                    rs = hr ? hr.getAtTileOffsetFunc(it, ue.center.lat, ue.worldSize, gt.getProjection()) : null,
                                    Kl = xc(St, rt.tileID.canonical, Se, me, ue, gt.getProjection(), Nt);
                                Ol(gt, St, u, !0, Kl, gn, Se, G, rs, it)
                            }
                            return {
                                program: Rr,
                                buffers: gt.text,
                                uniformValues: dl,
                                atlasTexture: Kc,
                                atlasTextureIcon: Fo,
                                atlasInterpolation: Qc,
                                atlasInterpolationIcon: Ns,
                                isSDF: !0,
                                hasHalo: ns,
                                depthMode: er,
                                tile: rt,
                                renderWithShadows: hn,
                                labelPlaneMatrixInv: ia
                            }
                        }, pn = gt.icon.segments.get().length, wi = gt.text.segments.get().length,
                        $i = pn && !v.onlyText ? Gi() : null, Hi = wi && !v.onlyIcons ? qi() : null,
                        Xi = s.paint.get("icon-opacity").constantOr(1), Ei = s.paint.get("text-opacity").constantOr(1);
                    if (Xe && gt.canOverlap) {
                        je = !0;
                        const rn = Xi && !v.onlyText ? gt.icon.segments.get() : [],
                            Wi = Ei && !v.onlyIcons ? gt.text.segments.get() : [];
                        for (const kn of rn) Be.push({segments: new o.bd([kn]), sortKey: kn.sortKey, state: $i});
                        for (const kn of Wi) Be.push({segments: new o.bd([kn]), sortKey: kn.sortKey, state: Hi})
                    } else v.onlyText || Be.push({
                        segments: Xi ? gt.icon.segments : new o.bd([]),
                        sortKey: 0,
                        state: $i
                    }), v.onlyIcons || Be.push({segments: Ei ? gt.text.segments : new o.bd([]), sortKey: 0, state: Hi})
                }
                je && Be.sort((it, rt) => it.sortKey - rt.sortKey);
                for (const it of Be) {
                    const rt = it.state;
                    if (rt) if (u.terrain ? u.terrain.setupElevationDraw(rt.tile, rt.program, {
                        useDepthForOcclusion: ue.depthOcclusionForSymbolsAndCircles,
                        labelPlaneMatrixInv: rt.labelPlaneMatrixInv
                    }) : u.setupDepthForOcclusion(ue.depthOcclusionForSymbolsAndCircles, rt.program), _e.activeTexture.set(ve.TEXTURE0), rt.atlasTexture && rt.atlasTexture.bind(rt.atlasInterpolation, ve.CLAMP_TO_EDGE, !0), rt.atlasTextureIcon && (_e.activeTexture.set(ve.TEXTURE1), rt.atlasTextureIcon && rt.atlasTextureIcon.bind(rt.atlasInterpolationIcon, ve.CLAMP_TO_EDGE, !0)), rt.renderWithShadows && u.shadowRenderer.setupShadows(rt.tile.tileID.toUnwrapped(), rt.program, "vector-tile"), u.uploadCommonLightUniforms(u.context, rt.program), rt.hasHalo) {
                        const gt = rt.uniformValues;
                        gt.u_is_halo = 1, sl(rt.buffers, it.segments, s, u, rt.program, rt.depthMode, m, g, gt, 2), gt.u_is_halo = 0
                    } else {
                        if (rt.isSDF) {
                            const gt = rt.uniformValues;
                            rt.hasHalo && (gt.u_is_halo = 1, sl(rt.buffers, it.segments, s, u, rt.program, rt.depthMode, m, g, gt, 1)), gt.u_is_halo = 0
                        }
                        sl(rt.buffers, it.segments, s, u, rt.program, rt.depthMode, m, g, rt.uniformValues, 1)
                    }
                }
            }

            function sl(u, t, s, h, m, g, v, b, S, P) {
                const M = [u.dynamicLayoutVertexBuffer, u.opacityVertexBuffer, u.iconTransitioningVertexBuffer, u.globeExtVertexBuffer, u.zOffsetVertexBuffer, u.orientationVertexBuffer];
                m.draw(h, h.context.gl.TRIANGLES, g, v, b, Yt.disabled, S, s.id, u.layoutVertexBuffer, u.indexBuffer, t, s.paint, h.transform.zoom, u.programConfigurations.get(s.id), M, P)
            }

            function _h(u, t) {
                const s = 1 << u.canonical.z, h = (t.x * s - u.canonical.x - u.wrap * s) * o.aj,
                    m = (t.y * s - u.canonical.y) * o.aj, g = o.e2(t.z, t.y);
                return o.d2(h, m, g)
            }

            function Pt(u, t, s, h, m) {
                if (!s.layout || s.layout.get("fill-elevation-reference") === "none") return;
                const g = u.context.gl, v = new It(u.context.gl.LEQUAL, It.ReadWrite, u.depthRangeFor3D),
                    b = new It(u.context.gl.GREATER, It.ReadWrite, u.depthRangeFor3D), S = function (O) {
                        const V = o.cU(O.pitch);
                        let B = .01;
                        return O.isOrthographic && (B = o.ai(1e-4, B, o.cZ(V >= Mr ? 1 : V / Mr))), 2 * B
                    }(u.transform), P = u.transform.getFreeCameraOptions().position,
                    M = "elevatedStructuresDepthReconstruct",
                    k = u.getOrCreateProgram(M, {defines: ["DEPTH_RECONSTRUCTION"]}), R = u.getOrCreateProgram(M);
                for (const O of h) {
                    const V = t.getTile(O), B = V.getBucket(s);
                    if (!B) continue;
                    const G = B.elevatedStructures;
                    if (!G) continue;
                    const U = B.elevationBufferData.heightRange, Z = _h(O.toUnwrapped(), P),
                        Q = u.translatePosMatrix(O.projMatrix, V, s.paint.get("fill-translate"), s.paint.get("fill-translate-anchor"));
                    let te, ce, _e, ve;
                    if (m === "initialize") {
                        if (!U || U.min >= 1 || G.depthSegments.segments[0].primitiveLength === 0) continue;
                        te = jd(Q, Z, S, 1, 0), ce = v, _e = G.depthSegments, ve = k
                    } else if (m === "reset") {
                        if (!U || U.min >= 0 || G.maskSegments.segments[0].primitiveLength === 0) continue;
                        te = jd(Q, Z, 0, 0, 1), ce = b, _e = G.maskSegments, ve = k
                    } else if (m === "geometry") {
                        if (G.depthSegments.segments[0].primitiveLength === 0) continue;
                        te = jd(Q, Z, S, 1, 0), ce = v, _e = G.depthSegments, ve = R
                    }
                    ve.draw(u, g.TRIANGLES, ce, ei.disabled, gi.disabled, Yt.disabled, te, s.id, G.vertexBuffer, G.indexBuffer, _e, s.paint, u.transform.zoom)
                }
            }

            function qd(u, t, s) {
                const {
                        painter: h,
                        sourceCache: m,
                        layer: g,
                        coords: v,
                        colorMode: b,
                        elevationType: S,
                        terrainEnabled: P,
                        pass: M
                    } = u, k = h.context.gl, R = g.paint.get("fill-pattern"), O = g.paint.get("fill-pattern-cross-fade"),
                    V = R.constantOr(null);
                let B = S;
                S !== "road" || t && !P || (B = "none");
                const G = B === "road", U = u.painter.shadowRenderer, Z = G && !!U && U.enabled,
                    Q = new It(h.context.gl.LEQUAL, It.ReadOnly, h.depthRangeFor3D);
                let te = [0, 0, 0];
                if (Z) {
                    const ve = h.style.directionalLight, ue = h.style.ambientLight;
                    ve && ue && (te = Nl(h.style, ve, ue))
                }
                const ce = R && R.constantOr(1), _e = (ve, ue) => {
                    let he, me, Oe, Se, Xe;
                    ue ? (he = ce && !g.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", Oe = k.LINES) : (he = ce ? "fillPattern" : "fill", Oe = k.TRIANGLES);
                    for (const je of v) {
                        const Ke = m.getTile(je);
                        if (ce && !Ke.patternsLoaded()) continue;
                        const ut = Ke.getBucket(g);
                        if (!ut) continue;
                        const Fe = t ? ut.elevationBufferData : ut.bufferData;
                        if (Fe.isEmpty()) continue;
                        h.prepareDrawTile();
                        const Te = Fe.programConfigurations.get(g.id), $e = h.isTileAffectedByFog(je), Be = [], tt = [];
                        G && (Be.push("ELEVATED_ROADS"), tt.push(Fe.elevatedLayoutVertexBuffer)), Z && Be.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"), ce && (h.context.activeTexture.set(k.TEXTURE0), Ke.imageAtlasTexture && Ke.imageAtlasTexture.bind(k.LINEAR, k.CLAMP_TO_EDGE), Te.updatePaintBuffers());
                        let it = !1;
                        if (V && Ke.imageAtlas) {
                            const St = Ke.imageAtlas, Nt = o.dZ.from(V),
                                Ft = Nt.getPrimary().scaleSelf(o.q.devicePixelRatio).toString(), ri = Nt.getSecondary(),
                                di = St.patternPositions.get(Ft),
                                Si = ri ? St.patternPositions.get(ri.scaleSelf(o.q.devicePixelRatio).toString()) : null;
                            it = !!di && !!Si, di && Te.setConstantPatternPositions(di, Si)
                        }
                        O > 0 && (it || Te.getPatternTransitionVertexBuffer("fill-pattern")) && Be.push("FILL_PATTERN_TRANSITION");
                        const rt = h.getOrCreateProgram(he, {config: Te, overrideFog: $e, defines: Be}),
                            gt = h.translatePosMatrix(je.projMatrix, Ke, g.paint.get("fill-translate"), g.paint.get("fill-translate-anchor"));
                        Z && U.setupShadows(Ke.tileID.toUnwrapped(), rt, "vector-tile");
                        const Ot = g.paint.get("fill-emissive-strength");
                        if (ue) {
                            Se = Fe.lineIndexBuffer, Xe = Fe.lineSegments;
                            const St = h.terrain && h.terrain.renderingToTexture ? h.terrain.drapeBufferSize : [k.drawingBufferWidth, k.drawingBufferHeight];
                            me = he === "fillOutlinePattern" && ce ? t1(gt, Ot, h, Ke, St, te, O) : e1(gt, Ot, St, te)
                        } else Se = Fe.indexBuffer, Xe = Fe.triangleSegments, me = ce ? ay(gt, Ot, h, Ke, te, O) : sy(gt, Ot, te);
                        h.uploadCommonUniforms(h.context, rt, je.toUnwrapped());
                        let Ut = ve;
                        (S === "road" && !P || S === "offset") && (Ut = Q), rt.draw(h, Oe, Ut, s || h.stencilModeForClipping(je), b, Yt.disabled, me, g.id, Fe.layoutVertexBuffer, Se, Xe, g.paint, h.transform.zoom, Te, tt)
                    }
                };
                h.renderPass === M && _e(h.depthModeForSublayer(1, h.renderPass === "opaque" ? It.ReadWrite : It.ReadOnly), !1), B === "none" && h.renderPass === "translucent" && g.paint.get("fill-antialias") && _e(h.depthModeForSublayer(g.getPaintProperty("fill-outline-color") ? 2 : 0, It.ReadOnly), !0)
            }

            function yh(u, t, s, h, m, g, v, b) {
                s.resetLayerRenderingStats(u);
                const S = u.context, P = S.gl, M = u.transform, k = s.paint.get("fill-extrusion-pattern"),
                    R = s.paint.get("fill-extrusion-pattern-cross-fade"), O = k.constantOr(null), V = k.constantOr(1),
                    B = s.paint.get("fill-extrusion-opacity"), G = u.style.enable3dLights(),
                    U = s.paint.get(G && !V ? "fill-extrusion-ambient-occlusion-wall-radius" : "fill-extrusion-ambient-occlusion-radius"),
                    Z = [s.paint.get("fill-extrusion-ambient-occlusion-intensity"), U],
                    Q = s.layout.get("fill-extrusion-edge-radius"),
                    te = Q > 0 && !s.paint.get("fill-extrusion-rounded-roof"), ce = te ? 0 : Q,
                    _e = M.projection.name === "globe" ? o.e5() : 0, ve = M.projection.name === "globe",
                    ue = ve ? o.ah(M.zoom) : 0, he = [o.aD(M.center.lng), o.aH(M.center.lat)],
                    me = s.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default") === "none",
                    Oe = s.paint.get("fill-extrusion-flood-light-color").toNonPremultipliedRenderColor(me ? null : s.lut).toArray01().slice(0, 3),
                    Se = s.paint.get("fill-extrusion-flood-light-intensity"),
                    Xe = s.paint.get("fill-extrusion-vertical-scale"),
                    je = s.paint.get("fill-extrusion-line-width").constantOr(1) !== 0,
                    Ke = s.paint.get("fill-extrusion-height-alignment"),
                    ut = s.paint.get("fill-extrusion-base-alignment"),
                    Fe = Ks(u, s.paint.get("fill-extrusion-cutoff-fade-range")), Te = [];
                let $e;
                ve && Te.push("PROJECTION_GLOBE_VIEW"), Z[0] > 0 && Te.push("FAUX_AO"), te && Te.push("ZERO_ROOF_RADIUS"), b && Te.push("HAS_CENTROID"), Se > 0 && Te.push("FLOOD_LIGHT"), Fe.shouldRenderCutoff && Te.push("RENDER_CUTOFF"), je && Te.push("RENDER_WALL_MODE");
                const Be = u.renderPass === "shadow", tt = u.shadowRenderer, it = Be && !!tt,
                    rt = Be ? Yt.disabled : Yt.backCCW;
                u.shadowRenderer && (u.shadowRenderer.useNormalOffset = !0);
                let gt = [0, 0, 0];
                if (tt) {
                    const St = u.style.directionalLight, Nt = u.style.ambientLight;
                    St && Nt && (gt = Nl(u.style, St, Nt)), Be || (Te.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), tt.useNormalOffset && Te.push("NORMAL_OFFSET")), $e = Te.concat(["SHADOWS_SINGLE_CASCADE"])
                }
                const Ot = it ? "fillExtrusionDepth" : V ? "fillExtrusionPattern" : "fillExtrusion",
                    Ut = s.getLayerRenderingStats();
                for (const St of h) {
                    const Nt = t.getTile(St), Ft = Nt.getBucket(s);
                    if (!Ft || Ft.projection.name !== M.projection.name) continue;
                    let ri = !1;
                    tt && (ri = tt.getMaxCascadeForTile(St.toUnwrapped()) === 0);
                    const di = u.isTileAffectedByFog(St), Si = Ft.programConfigurations.get(s.id);
                    let Ui = !1;
                    if (O && Nt.imageAtlas) {
                        const Hi = Nt.imageAtlas, Xi = o.dZ.from(O),
                            Ei = Xi.getPrimary().scaleSelf(o.q.devicePixelRatio).toString(), rn = Xi.getSecondary(),
                            Wi = Hi.patternPositions.get(Ei),
                            kn = rn ? Hi.patternPositions.get(rn.scaleSelf(o.q.devicePixelRatio).toString()) : null;
                        Ui = !!Wi && !!kn, Wi && Si.setConstantPatternPositions(Wi, kn)
                    }
                    R > 0 && (Ui || Si.getPatternTransitionVertexBuffer("fill-extrusion-pattern")) && Te.push("FILL_EXTRUSION_PATTERN_TRANSITION");
                    const ci = u.getOrCreateProgram(Ot, {config: Si, defines: ri ? $e : Te, overrideFog: di});
                    if (u.terrain && u.terrain.setupElevationDraw(Nt, ci, {useMeterToDem: !0}), !Ft.centroidVertexBuffer) {
                        const Hi = ci.attributes.a_centroid_pos;
                        Hi !== void 0 && P.vertexAttrib2f(Hi, 0, 0)
                    }
                    !Be && tt && tt.setupShadows(Nt.tileID.toUnwrapped(), ci, "vector-tile"), V && (u.context.activeTexture.set(P.TEXTURE0), Nt.imageAtlasTexture && Nt.imageAtlasTexture.bind(P.LINEAR, P.CLAMP_TO_EDGE), Si.updatePaintBuffers());
                    const Gi = s.paint.get("fill-extrusion-vertical-gradient"), qi = 1 / Ft.tileToMeter;
                    let pn;
                    if (Be && tt) {
                        if (Wd(Nt.tileID, Ft.maxHeight, u)) continue;
                        const Hi = tt.calculateShadowPassMatrixFromTile(Nt.tileID.toUnwrapped());
                        pn = oy(Hi, ce, qi, Xe, Ke, ut)
                    } else {
                        const Hi = u.translatePosMatrix(St.expandedProjMatrix, Nt, s.paint.get("fill-extrusion-translate"), s.paint.get("fill-extrusion-translate-anchor")),
                            Xi = M.projection.createInversionMatrix(M, St.canonical);
                        pn = V ? kc(Hi, u, Gi, B, Z, ce, qi, St, Nt, _e, Ke, ut, ue, he, Xi, Oe, Xe, R) : nm(Hi, u, Gi, B, Z, ce, qi, St, _e, Ke, ut, ue, he, Xi, Oe, Xe, Se, gt)
                    }
                    u.uploadCommonUniforms(S, ci, St.toUnwrapped(), null, Fe);
                    let wi = Ft.segments;
                    if (M.projection.name === "mercator" && !Be && (wi = Ft.getVisibleSegments(Nt.tileID, u.terrain, u.transform.getFrustum(0)), !wi.get().length)) continue;
                    if (Ut) if (Be) for (const Hi of wi.get()) Ut.numRenderedVerticesInShadowPass += Hi.primitiveLength; else for (const Hi of wi.get()) Ut.numRenderedVerticesInTransparentPass += Hi.primitiveLength;
                    const $i = [];
                    (u.terrain || b) && $i.push(Ft.centroidVertexBuffer), ve && $i.push(Ft.layoutVertexExtBuffer), je && $i.push(Ft.wallVertexBuffer), ci.draw(u, S.gl.TRIANGLES, m, g, v, rt, pn, s.id, Ft.layoutVertexBuffer, Ft.indexBuffer, wi, s.paint, u.transform.zoom, Si, $i)
                }
                u.shadowRenderer && (u.shadowRenderer.useNormalOffset = !1)
            }

            class xa {
                constructor() {
                    this.translate = [0, 0], this.translateAnchor = "map", this.edgeRadius = 0, this.cutoffFadeRange = 0
                }
            }

            function Co(u, t, s, h, m, g, v, b, S, P, M, k, R, O, V, B, G, U, Z, Q) {
                const te = t.context, ce = te.gl, _e = t.transform, ve = t.transform.zoom, ue = [], he = u.translate,
                    me = u.translateAnchor, Oe = u.edgeRadius, Se = Ks(t, u.cutoffFadeRange);
                M === "clear" ? (ue.push("CLEAR_SUBPASS"), Q && (ue.push("CLEAR_FROM_TEXTURE"), te.activeTexture.set(ce.TEXTURE0), Q.bind(ce.LINEAR, ce.CLAMP_TO_EDGE))) : M === "sdf" && ue.push("SDF_SUBPASS"), U && ue.push("HAS_CENTROID"), Se.shouldRenderCutoff && ue.push("RENDER_CUTOFF");
                const Xe = (je, Ke, ut, Fe, Te) => {
                    const $e = Ke.programConfigurations.get(h.id), Be = t.isTileAffectedByFog(je),
                        tt = t.getOrCreateProgram("fillExtrusionGroundEffect", {
                            config: $e,
                            defines: ue,
                            overrideFog: Be
                        }), it = ((gt, Ot, Ut, St, Nt, Ft, ri, di, Si, Ui, ci) => ({
                            u_matrix: Ot,
                            u_opacity: Ut,
                            u_ao_pass: St ? 1 : 0,
                            u_meter_to_tile: Nt,
                            u_ao: Ft,
                            u_flood_light_intensity: ri,
                            u_flood_light_color: di,
                            u_attenuation: Si,
                            u_edge_radius: Ui,
                            u_fb: 0,
                            u_fb_size: ci,
                            u_dynamic_offset: 1
                        }))(0, Fe, k, P, Te, [R, O * Te], V, B, G, ve >= 17 ? 0 : Oe * Te, Q ? Q.size[0] : 0), rt = [];
                    U && rt.push(Ke.hiddenByLandmarkVertexBuffer), t.uploadCommonUniforms(te, tt, je.toUnwrapped(), null, Se), tt.draw(t, te.gl.TRIANGLES, g, v, b, S, it, h.id, Ke.vertexBuffer, Ke.indexBuffer, ut, h.paint, ve, $e, rt)
                };
                for (const je of m) {
                    const Ke = s.getTile(je), ut = Ke.getBucket(h);
                    if (!ut || ut.projection.name !== _e.projection.name || !ut.groundEffect || ut.groundEffect && !ut.groundEffect.hasData()) continue;
                    const Fe = ut.groundEffect, Te = 1 / ut.tileToMeter;
                    {
                        const $e = t.translatePosMatrix(je.projMatrix, Ke, he, me), Be = Fe.getDefaultSegment();
                        Xe(je, Fe, Be, $e, Te)
                    }
                    if (Z) for (let $e = 0; $e < 4; $e++) {
                        const Be = o.e3[$e](je), tt = s.getTile(Be);
                        if (!tt) continue;
                        const it = tt.getBucket(h);
                        if (!it || it.projection.name !== _e.projection.name || !it.groundEffect || it.groundEffect && !it.groundEffect.hasData()) continue;
                        const rt = it.groundEffect;
                        let gt, Ot;
                        $e === 0 ? (gt = [-o.aj, 0, 0], Ot = 1) : $e === 1 ? (gt = [o.aj, 0, 0], Ot = 0) : $e === 2 ? (gt = [0, -o.aj, 0], Ot = 3) : (gt = [0, o.aj, 0], Ot = 2);
                        const Ut = rt.regionSegments[Ot];
                        if (!Ut) continue;
                        const St = new Float32Array(16);
                        o.bo(St, je.projMatrix, gt), Xe(je, rt, Ut, t.translatePosMatrix(St, Ke, he, me), Te)
                    }
                }
            }

            function Qt(u, t, s, h, m, g, v) {
                h.centroidVertexArray.length === 0 && h.createCentroidsBuffer();
                const b = g ? g.findDEMTileFor(s) : null;
                if (!(b && b.dem || v)) return;
                g && b && b.dem && h.selfDEMTileTimestamp !== b.dem._timestamp && (h.borderDoneWithNeighborZ = [-1, -1, -1, -1], h.selfDEMTileTimestamp = b.dem._timestamp);
                const S = U => new o.P(Math.ceil((U + o.e7) * o.e8), 0), P = U => {
                        const Z = t.getSource().minzoom, Q = ce => {
                            const _e = t.getTileByID(ce);
                            if (_e && _e.hasData()) return _e.getBucket(m)
                        }, te = [0, -1, 1];
                        for (const ce of te) {
                            if (U.overscaledZ + ce < Z) continue;
                            const _e = Q(U.calculateScaledKey(U.overscaledZ + ce));
                            if (_e) return _e
                        }
                    }, M = [0, 0, 0],
                    k = (U, Z) => (M[0] = Math.min(U.min.y, Z.min.y), M[1] = Math.max(U.max.y, Z.max.y), M[2] = o.aj - Z.min.x > U.max.x ? Z.min.x - o.aj : U.max.x, M),
                    R = (U, Z) => (M[0] = Math.min(U.min.x, Z.min.x), M[1] = Math.max(U.max.x, Z.max.x), M[2] = o.aj - Z.min.y > U.max.y ? Z.min.y - o.aj : U.max.y, M),
                    O = [(U, Z) => k(U, Z), (U, Z) => k(Z, U), (U, Z) => R(U, Z), (U, Z) => R(Z, U)],
                    V = (U, Z, Q, te, ce, _e, ve) => {
                        if (!g) return 0;
                        const ue = [[_e ? Q : U, _e ? U : Q, 0], [_e ? Q : Z, _e ? Z : Q, 0]],
                            he = ve < 0 ? o.aj + ve : ve, me = [_e ? he : (U + Z) / 2, _e ? (U + Z) / 2 : he, 0];
                        return Q === 0 && ve < 0 || Q !== 0 && ve > 0 ? g.getForTilePoints(ce, [me], !0, te) : ue.push(me), g.getForTilePoints(s, ue, !0, b), Math.max(ue[0][2], ue[1][2], me[2]) / g.exaggeration()
                    };
                for (let U = 0; U < 4; U++) {
                    const Z = h.borderFeatureIndices[U];
                    if (Z.length === 0) continue;
                    const Q = o.e3[U](s), te = P(Q);
                    if (!(te && te instanceof o.e4)) continue;
                    const ce = g ? g.findDEMTileFor(Q) : null;
                    if (!(ce && ce.dem || v) || (g && ce && ce.dem && h.borderDEMTileTimestamp[U] !== ce.dem._timestamp && (h.borderDoneWithNeighborZ[U] = -1, h.borderDEMTileTimestamp[U] = ce.dem._timestamp), h.borderDoneWithNeighborZ[U] === te.canonical.z)) continue;
                    te.centroidVertexArray.length === 0 && te.createCentroidsBuffer();
                    const _e = (U < 2 ? 1 : 5) - U, ve = te.borderDoneWithNeighborZ[_e] !== h.canonical.z,
                        ue = te.borderFeatureIndices[_e];
                    let he = 0;
                    if (h.canonical.z !== te.canonical.z) {
                        for (const me of Z) h.showCentroid(h.featuresOnBorder[me]);
                        if (ve) for (const me of ue) te.showCentroid(te.featuresOnBorder[me]);
                        h.borderDoneWithNeighborZ[U] = te.canonical.z, te.borderDoneWithNeighborZ[_e] = h.canonical.z
                    }
                    for (const me of Z) {
                        const Oe = h.featuresOnBorder[me], Se = h.centroidData[Oe.centroidDataIndex],
                            Xe = Oe.borders[U];
                        let je;
                        for (; he < ue.length;) {
                            je = te.featuresOnBorder[ue[he]];
                            const Ke = je.borders[_e];
                            if (Ke[1] > Xe[0] + 3 || Ke[0] > Xe[0] - 3) break;
                            te.showCentroid(je), he++
                        }
                        if (je && he < ue.length) {
                            const Ke = he;
                            let ut = 0;
                            for (; !(je.borders[_e][0] > Xe[1] - 3) && (ut++, ++he !== ue.length);) je = te.featuresOnBorder[ue[he]];
                            je = te.featuresOnBorder[ue[Ke]];
                            let Fe = !1;
                            if (ut >= 1) {
                                const Be = je.borders[_e];
                                Math.abs(Xe[0] - Be[0]) < 3 && Math.abs(Xe[1] - Be[1]) < 3 && (ut = 1, Fe = !0, he = Ke + 1)
                            } else if (ut === 0) {
                                h.showCentroid(Oe);
                                continue
                            }
                            const Te = te.centroidData[je.centroidDataIndex];
                            v && Fe && (((B = Se).flags | (G = Te).flags) & o.e6 ? (B.flags |= o.e6, G.flags |= o.e6) : (B.flags &= ~o.e6, G.flags &= ~o.e6));
                            const $e = Oe.intersectsCount() > 1 || je.intersectsCount() > 1;
                            if (ut > 1) he = Ke, Se.centroidXY = Te.centroidXY = new o.P(0, 0); else if (ce && ce.dem && !$e) {
                                const Be = O[U](Se, Te), tt = U % 2 ? o.aj - 1 : 0,
                                    it = V(Be[0], Math.min(o.aj - 1, Be[1]), tt, ce, Q, U < 2, Be[2]);
                                Se.centroidXY = Te.centroidXY = S(it)
                            } else $e ? Se.centroidXY = Te.centroidXY = new o.P(0, 0) : (Se.centroidXY = h.encodeBorderCentroid(Oe), Te.centroidXY = te.encodeBorderCentroid(je));
                            h.writeCentroidToBuffer(Se), te.writeCentroidToBuffer(Te)
                        } else h.showCentroid(Oe)
                    }
                    h.borderDoneWithNeighborZ[U] = te.canonical.z, te.borderDoneWithNeighborZ[_e] = h.canonical.z
                }
                var B, G;
                (h.needsCentroidUpdate || !h.centroidVertexBuffer && h.centroidVertexArray.length !== 0) && h.uploadCentroid(u)
            }

            const mm = [1, 0, 0], n1 = [0, 1, 0], r1 = [0, 0, 1];

            function Wd(u, t, s) {
                const h = s.transform, m = s.shadowRenderer;
                if (!m) return !0;
                const g = u.toUnwrapped(), v = h.tileSize * m._cascades[s.currentShadowCascade].scale;
                let b = t;
                if (h.elevation) {
                    const B = h.elevation.getMinMaxForTile(u);
                    B && (b += B.max)
                }
                const S = [...m.shadowDirection];
                S[2] = -S[2];
                const P = m.computeSimplifiedTileShadowVolume(g, b, v, S);
                if (!P) return !1;
                const M = [mm, n1, r1, S, [S[0], 0, S[2]], [0, S[1], S[2]]], k = h.projection.name === "globe",
                    R = h.scaleZoom(v), O = o.cy.fromInvProjectionMatrix(h.invProjMatrix, h.worldSize, R, !k),
                    V = m.getCurrentCascadeFrustum();
                return O.intersectsPrecise(P.vertices, P.planes, M) === 0 || V.intersectsPrecise(P.vertices, P.planes, M) === 0
            }

            function Zd(u) {
                const {painter: t, source: s, layer: h, coords: m} = u, g = u.defines, v = t.context,
                    b = t.renderPass === "shadow", S = t.renderPass === "light-beam", P = t.shadowRenderer;
                let M;
                P && (M = g.concat(["SHADOWS_SINGLE_CASCADE"]));
                const k = o.e9(t.transform.center.lat, t.transform.zoom);
                for (const R of m) {
                    const O = s.getTile(R), V = O.getBucket(h);
                    if (!V) continue;
                    let B = !1;
                    P && (B = P.getMaxCascadeForTile(R.toUnwrapped()) === 0);
                    const G = V.programConfigurations.get(h.id);
                    let U, Z, Q = t.translatePosMatrix(R.expandedProjMatrix, O, [0, 0], "map");
                    if (Q = o.cP(o.bz(), Q, [1, 1, u.verticalScale]), b && P) {
                        if (Wd(O.tileID, V.maxHeight * k, t)) continue;
                        let te = P.calculateShadowPassMatrixFromTile(O.tileID.toUnwrapped());
                        te = o.cP(o.bz(), te, [1, 1, u.verticalScale]), Z = ly(te), U = t.getOrCreateProgram("buildingDepth", {
                            config: G,
                            defines: B ? M : g,
                            overrideFog: !1
                        })
                    } else if (S) U = t.getOrCreateProgram("buildingBloom", {
                        config: G,
                        defines: B ? M : g,
                        overrideFog: !1
                    }), Z = om(Q); else {
                        const te = t.transform.calculatePosMatrix(R.toUnwrapped(), t.transform.worldSize);
                        o.cP(te, te, [1, 1, u.verticalScale]);
                        const ce = o.bz();
                        o.cP(ce, te, [1, -1, 1 / k]), o.bi(ce, ce), o.ea(ce, ce), Z = rm(Q, ce), U = t.getOrCreateProgram("building", {
                            config: G,
                            defines: B ? M : g,
                            overrideFog: !1
                        }), P && P.setupShadowsFromMatrix(te, U, !0)
                    }
                    if (t.uploadCommonUniforms(v, U, R.toUnwrapped(), null, null), S) {
                        const te = V.bloomGeometry;
                        U.draw(t, v.gl.TRIANGLES, u.depthMode, ei.disabled, u.blendMode, Yt.disabled, Z, h.id, te.layoutVertexBuffer, te.indexBuffer, te.segmentsBucket, h.paint, t.transform.zoom, G, [te.layoutAttenuationBuffer, te.layoutColorBuffer])
                    } else U.draw(t, v.gl.TRIANGLES, u.depthMode, ei.disabled, u.blendMode, b ? Yt.disabled : Yt.backCW, Z, h.id, V.layoutVertexBuffer, V.indexBuffer, V.segments, h.paint, t.transform.zoom, G, [V.layoutNormalBuffer, V.layoutColorBuffer])
                }
            }

            function _y(u) {
                return [u[0] * o.eb, u[1] * o.eb, u[2] * o.eb, 0]
            }

            function Xd(u, t, s, h, m, g, v, b, S) {
                const P = h.getSource(), M = s.globeSharedBuffers;
                if (!M) return;
                let k, R, O;
                if (t && (k = h.getTile(t)), P instanceof o.aP ? (R = P.texture, O = o.dE(0, 0, s.transform)) : k && t && (R = k.texture, O = o.dE(t.canonical.z, t.canonical.x, s.transform)), !R || !O) return;
                u || (O = o.cP(o.bz(), O, [1, -1, 1]));
                const V = s.context, B = V.gl,
                    G = m.paint.get("raster-resampling") === "nearest" ? B.NEAREST : B.LINEAR,
                    U = s.colorModeForDrapableLayerRenderPass(g), Z = v.defines;
                Z.push("GLOBE_POLES");
                const Q = new It(B.LEQUAL, It.ReadWrite, s.depthRangeFor3D),
                    te = Float32Array.from(s.transform.expandedFarZProjMatrix),
                    ce = Float32Array.from(o.bh(o.dD(new o.cA(0, 0, 0))));
                s.terrain && s.terrain.prepareDrawTile(), V.activeTexture.set(B.TEXTURE0), R.bind(G, B.CLAMP_TO_EDGE), V.activeTexture.set(B.TEXTURE1), R.bind(G, B.CLAMP_TO_EDGE), "useMipmap" in R && V.extTextureFilterAnisotropic && s.transform.pitch > 20 && B.texParameterf(B.TEXTURE_2D, V.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, V.extTextureFilterAnisotropicMax);
                const [_e, ve, ue, he] = t ? M.getPoleBuffers(t.canonical.z, !1) : M.getPoleBuffers(0, !0),
                    me = m.paint.get("raster-elevation");
                let Oe;
                u ? (Oe = _e, s.renderDefaultNorthPole = me !== 0) : (Oe = ve, s.renderDefaultSouthPole = me !== 0);
                const Se = _y(v.mix),
                    Xe = ((Ke, ut, Fe, Te, $e, Be, tt, it, rt, gt, Ot, Ut, St) => am(Ke, ut, Fe, new Float32Array(16), new Float32Array(9), [0, 0], Te, [0, 0], [0, 0, 0, 0], 1, {
                        opacity: 1,
                        mix: 0
                    }, Be, [0, 0], it, 2, gt, Ot, Ut, 1, 0, St))(te, ce, O, o.ah(s.transform.zoom), 0, m, 0, me, 0, Se, v.offset, v.range, g),
                    je = s.getOrCreateProgram("raster", {defines: Z});
                s.uploadCommonUniforms(V, je, null), je.draw(s, B.TRIANGLES, Q, S, U, b, Xe, m.id, Oe, ue, he)
            }

            function o1(u) {
                const t = u._nearZ, s = u.projection.farthestPixelDistance(u), h = s - t, m = .2 * u.height, g = t + m;
                return [t, s, (g - m - t) / h, (g - t) / h]
            }

            function s1(u, t, s, h) {
                if (u) return t instanceof qa && u instanceof gc ? t.getTextureDescriptor(u, s, !0) : {
                    texture: u.texture,
                    mix: _y(h.mix),
                    offset: h.offset,
                    buffer: 0,
                    tileSize: 1
                }
            }

            var Oo = o.ec([{name: "a_index", type: "Int16", components: 1}]);

            class gm {
                constructor(t, s, h, m) {
                    const g = {width: h[0], height: h[1], data: null}, v = t.gl;
                    this.targetColorTexture = new o.T(t, g, v.RGBA8, {useMipmap: !1}), this.backgroundColorTexture = new o.T(t, g, v.RGBA8, {useMipmap: !1}), this.context = t, this.updateParticleTexture(s, m), this.lastInvalidatedAt = 0
                }

                updateParticleTexture(t, s) {
                    if (this.particleTextureDimension === s.width) return;
                    (this.particleTexture0 || this.particleTexture1 || this.particleIndexBuffer || this.particleSegment) && (this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleIndexBuffer.destroy(), this.particleSegment.destroy());
                    const h = this.context.gl, m = s.width * s.height;
                    this.particleTexture0 = new o.T(this.context, s, h.RGBA8, {
                        premultiply: !1,
                        useMipmap: !1
                    }), this.particleTexture1 = new o.T(this.context, s, h.RGBA8, {premultiply: !1, useMipmap: !1});
                    const g = new o.ed;
                    g.reserve(m);
                    for (let v = 0; v < m; v++) g.emplaceBack(v);
                    this.particleIndexBuffer = this.context.createVertexBuffer(g, Oo.members, !0), this.particleSegment = o.bd.simpleSegment(0, 0, this.particleIndexBuffer.length, 0), this.particleTextureDimension = s.width
                }

                update(t) {
                    return !(this.lastInvalidatedAt < t && (this.lastInvalidatedAt = o.q.now(), 1))
                }

                destroy() {
                    this.targetColorTexture.destroy(), this.backgroundColorTexture.destroy(), this.particleIndexBuffer.destroy(), this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleSegment.destroy()
                }
            }

            function mo(u, t, s) {
                if (!u) return null;
                const h = t.getTextureDescriptor(u, s, !0);
                if (!h) return null;
                let {texture: m, mix: g, offset: v, tileSize: b, buffer: S, format: P} = h;
                if (!m || !P) return null;
                let M = !1;
                return P === "uint32" && (M = !0, g[3] = 0, g = Vd(o.ee, g, [0, s.paint.get("raster-particle-max-speed")]), v = tl(o.ee, v, [0, s.paint.get("raster-particle-max-speed")])), {
                    texture: m,
                    textureOffset: [S / (b + 2 * S), b / (b + 2 * S)],
                    tileSize: b,
                    scalarData: M,
                    scale: g,
                    offset: v,
                    defines: ["RASTER_ARRAY", {
                        uint8: "DATA_FORMAT_UINT8",
                        uint16: "DATA_FORMAT_UINT16",
                        uint32: "DATA_FORMAT_UINT32"
                    }[P]]
                }
            }

            function al(u) {
                const t = u._nearZ, s = u.projection.farthestPixelDistance(u), h = s - t, m = .2 * u.height, g = t + m;
                return [t, s, (g - m - t) / h, (g - t) / h]
            }

            const yy = new o.am(1, 0, 0, 1), _m = new o.am(0, 1, 0, 1), ym = new o.am(0, 0, 1, 1),
                vm = new o.am(1, 0, 1, 1), vy = new o.am(0, 1, 1, 1);

            function Qs(u, t, s, h, m, g) {
                for (let v = 0; v < s.length; v++) if (m) {
                    const P = new o.am(h.r * .8, h.g * .8, h.b * .8, 1);
                    sn(u, t, s[v], h, -1, -1, g), sn(u, t, s[v], h, -1, 1, g), sn(u, t, s[v], h, 1, 1, g), sn(u, t, s[v], h, 1, -1, g), sn(u, t, s[v], P, 0, 0, g)
                } else sn(u, t, s[v], h, 0, 0, g)
            }

            function sn(u, t, s, h, m, g, v) {
                const b = u.context, S = u.transform, P = b.gl, M = S.projection.name === "globe",
                    k = M ? ["PROJECTION_GLOBE_VIEW"] : [];
                let R = o.bw(s.projMatrix);
                if (M && o.ah(S.zoom) > 0) {
                    const Se = o.bg(s.canonical, S), Xe = o.ef(Se);
                    R = o.az(new Float32Array(16), S.globeMatrix, Xe), o.az(R, S.projMatrix, R)
                }
                const O = o.bz();
                O[12] += 2 * m / (o.q.devicePixelRatio * S.width), O[13] += 2 * g / (o.q.devicePixelRatio * S.height), o.az(R, O, R);
                const V = u.getOrCreateProgram("debug", {defines: k}), B = t.getTileByID(s.key);
                u.terrain && u.terrain.setupElevationDraw(B, V);
                const G = It.disabled, U = ei.disabled, Z = u.colorModeForRenderPass(), Q = "$debug";
                b.activeTexture.set(P.TEXTURE0), u.emptyTexture.bind(P.LINEAR, P.CLAMP_TO_EDGE), M ? B._makeGlobeTileDebugBuffers(u.context, S) : B._makeDebugTileBoundsBuffers(u.context, S.projection);
                const te = B._tileDebugBuffer || u.debugBuffer, ce = B._tileDebugIndexBuffer || u.debugIndexBuffer,
                    _e = B._tileDebugSegments || u.debugSegments;
                if (V.draw(u, P.LINE_STRIP, G, U, Z, Yt.disabled, sm(R, h.toPremultipliedRenderColor(null)), Q, te, ce, _e, null, null, null, [B._globeTileDebugBorderBuffer]), v) {
                    const Se = B.latestRawTileData, Xe = Math.floor((Se && Se.byteLength || 0) / 1024);
                    let je = s.canonical.toString();
                    s.overscaledZ !== s.canonical.z && (je += ` => ${s.overscaledZ}`), je += ` ${B.state}`, je += ` ${Xe}kb`, function (Ke, ut) {
                        Ke.initDebugOverlayCanvas();
                        const Fe = Ke.debugOverlayCanvas, Te = Ke.context.gl,
                            $e = Ke.debugOverlayCanvas.getContext("2d");
                        $e.clearRect(0, 0, Fe.width, Fe.height), $e.shadowColor = "white", $e.shadowBlur = 2, $e.lineWidth = 1.5, $e.strokeStyle = "white", $e.textBaseline = "top", $e.font = "bold 36px Open Sans, sans-serif", $e.fillText(ut, 5, 5), $e.strokeText(ut, 5, 5), Ke.debugOverlayTexture.update(Fe), Ke.debugOverlayTexture.bind(Te.LINEAR, Te.CLAMP_TO_EDGE)
                    }(u, je)
                }
                const ve = t.getTile(s).tileSize, ue = 512 / Math.min(ve, 512) * (s.overscaledZ / S.zoom) * .5,
                    he = B._tileDebugTextBuffer || u.debugBuffer,
                    me = B._tileDebugTextIndexBuffer || u.quadTriangleIndexBuffer,
                    Oe = B._tileDebugTextSegments || u.debugSegments;
                V.draw(u, P.TRIANGLES, G, U, gi.alphaBlended, Yt.disabled, sm(R, o.am.transparent.toPremultipliedRenderColor(null), ue), Q, he, me, Oe, null, null, null, [B._globeTileDebugTextBuffer])
            }

            function vh(u, t, s, h) {
                xh(u, 0, t + s / 2, u.transform.width, s, h)
            }

            function Yd(u, t, s, h) {
                xh(u, t - s / 2, 0, s, u.transform.height, h)
            }

            function xh(u, t, s, h, m, g) {
                const v = u.context, b = v.gl;
                b.enable(b.SCISSOR_TEST), b.scissor(t * o.q.devicePixelRatio, s * o.q.devicePixelRatio, h * o.q.devicePixelRatio, m * o.q.devicePixelRatio), v.clear({color: g}), b.disable(b.SCISSOR_TEST)
            }

            const xy = o.ec([{name: "a_pos_3f", components: 3, type: "Float32"}]), {members: wy} = xy;

            function ll(u, t, s, h) {
                u.emplaceBack(t, s, h)
            }

            class Wl {
                constructor(t) {
                    this.vertexArray = new o.eg, this.indices = new o.a_, ll(this.vertexArray, -1, -1, 1), ll(this.vertexArray, 1, -1, 1), ll(this.vertexArray, -1, 1, 1), ll(this.vertexArray, 1, 1, 1), ll(this.vertexArray, -1, -1, -1), ll(this.vertexArray, 1, -1, -1), ll(this.vertexArray, -1, 1, -1), ll(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t.createVertexBuffer(this.vertexArray, wy), this.indexBuffer = t.createIndexBuffer(this.indices), this.segment = o.bd.simpleSegment(0, 0, 36, 12)
                }
            }

            function Bs(u, t, s, h, m, g) {
                const v = u.context.gl, b = t.paint.get("sky-atmosphere-color"),
                    S = t.paint.get("sky-atmosphere-halo-color"), P = t.paint.get("sky-atmosphere-sun-intensity"),
                    M = ((k, R, O, V, B) => ({
                        u_matrix_3f: k,
                        u_sun_direction: R,
                        u_sun_intensity: O,
                        u_color_tint_r: [V.r, V.g, V.b, V.a],
                        u_color_tint_m: [B.r, B.g, B.b, B.a],
                        u_luminance: 5e-5
                    }))(o.ei(o.dJ(), h), m, P, b.toPremultipliedRenderColor(null), S.toPremultipliedRenderColor(null));
                v.framebufferTexture2D(v.FRAMEBUFFER, v.COLOR_ATTACHMENT0, v.TEXTURE_CUBE_MAP_POSITIVE_X + g, t.skyboxTexture, 0), s.draw(u, v.TRIANGLES, It.disabled, ei.disabled, gi.unblended, Yt.frontCW, M, "skyboxCapture", t.skyboxGeometry.vertexBuffer, t.skyboxGeometry.indexBuffer, t.skyboxGeometry.segment)
            }

            const dt = o.ec([{type: "Float32", name: "a_pos", components: 3}, {
                type: "Float32",
                name: "a_uv",
                components: 2
            }]);

            class Tt {
                constructor(t) {
                    const s = new o.ej;
                    s.emplaceBack(-1, 1, 1, 0, 0), s.emplaceBack(1, 1, 1, 1, 0), s.emplaceBack(1, -1, 1, 1, 1), s.emplaceBack(-1, -1, 1, 0, 1);
                    const h = new o.a_;
                    h.emplaceBack(0, 1, 2), h.emplaceBack(2, 3, 0), this.vertexBuffer = t.createVertexBuffer(s, dt.members), this.indexBuffer = t.createIndexBuffer(h), this.segments = o.bd.simpleSegment(0, 0, 4, 2)
                }

                destroy() {
                    this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy()
                }
            }

            const Fc = o.ec([{type: "Float32", name: "a_pos_3f", components: 3}, {
                type: "Float32",
                name: "a_uv",
                components: 2
            }, {type: "Float32", name: "a_size_scale", components: 1}, {
                type: "Float32",
                name: "a_fade_opacity",
                components: 1
            }]);

            class qn {
                constructor() {
                    this.starsCount = 16e3, this.sizeMultiplier = .15, this.sizeRange = 100, this.intensityRange = 200
                }
            }

            class ze {
                constructor(t) {
                    this.colorModeAlphaBlendedWriteRGB = new gi([1, Bl, 1, Bl], o.am.transparent, [!0, !0, !0, !1]), this.colorModeWriteAlpha = new gi([1, 0, 1, 0], o.am.transparent, [!1, !1, !1, !0]), this.params = new qn, this.updateNeeded = !0, t.tp.registerParameter(this.params, ["Stars"], "starsCount", {
                        min: 100,
                        max: 16e3,
                        step: 1
                    }, () => {
                        this.updateNeeded = !0
                    }), t.tp.registerParameter(this.params, ["Stars"], "sizeMultiplier", {
                        min: .01,
                        max: 2,
                        step: .01
                    }), t.tp.registerParameter(this.params, ["Stars"], "sizeRange", {min: 0, max: 200, step: 1}, () => {
                        this.updateNeeded = !0
                    }), t.tp.registerParameter(this.params, ["Stars"], "intensityRange", {
                        min: 0,
                        max: 200,
                        step: 1
                    }, () => {
                        this.updateNeeded = !0
                    })
                }

                update(t) {
                    const s = t.context;
                    if (!this.atmosphereBuffer || this.updateNeeded) {
                        this.updateNeeded = !1, this.atmosphereBuffer = new Tt(s);
                        const h = this.params.sizeRange, m = this.params.intensityRange, g = function (M) {
                            const k = o.el(30), R = [];
                            for (let O = 0; O < M; ++O) {
                                const V = 2 * Math.PI * k(), B = Math.acos(1 - 2 * k()) - .5 * Math.PI;
                                R.push(o.d2(Math.cos(B) * Math.cos(V), Math.cos(B) * Math.sin(V), Math.sin(B)))
                            }
                            return R
                        }(this.params.starsCount), v = o.el(300), b = new o.ek, S = new o.a_;
                        let P = 0;
                        for (let M = 0; M < g.length; ++M) {
                            const k = o.c1([], g[M], 200), R = Math.max(0, 1 + .01 * h * (1 * v() - .5)),
                                O = Math.max(0, 1 + .01 * m * (1 * v() - .5));
                            b.emplaceBack(k[0], k[1], k[2], -1, -1, R, O), b.emplaceBack(k[0], k[1], k[2], 1, -1, R, O), b.emplaceBack(k[0], k[1], k[2], 1, 1, R, O), b.emplaceBack(k[0], k[1], k[2], -1, 1, R, O), S.emplaceBack(P + 0, P + 1, P + 2), S.emplaceBack(P + 0, P + 2, P + 3), P += 4
                        }
                        this.starsVx = s.createVertexBuffer(b, Fc.members), this.starsIdx = s.createIndexBuffer(S), this.starsSegments = o.bd.simpleSegment(0, 0, b.length, S.length)
                    }
                }

                destroy() {
                    this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy()
                }

                drawAtmosphereGlow(t, s) {
                    const h = t.context, m = h.gl, g = t.transform, v = new It(m.LEQUAL, It.ReadOnly, [0, 1]),
                        b = o.ah(g.zoom), S = t.style.getLut(s.scope),
                        P = s.properties.get("color-use-theme") === "none",
                        M = s.properties.get("color").toNonPremultipliedRenderColor(P ? null : S).toArray01(),
                        k = s.properties.get("high-color-use-theme") === "none",
                        R = s.properties.get("high-color").toNonPremultipliedRenderColor(k ? null : S).toArray01(),
                        O = s.properties.get("space-color-use-theme") === "none",
                        V = s.properties.get("space-color").toNonPremultipliedRenderColor(O ? null : S).toArray01(),
                        B = 5e-4, G = o.em(s.properties.get("horizon-blend"), 0, 1, B, .25),
                        U = o.dy(t, h, g) && G === B ? g.worldSize / (2 * Math.PI * 1.025) - 1 : g.globeRadius,
                        Z = t.frameCounter / 1e3 % 1, Q = o.ae(g.globeCenterInViewSpace),
                        te = Math.sqrt(Math.pow(Q, 2) - Math.pow(U, 2)), ce = Math.acos(te / Q), _e = ve => {
                            const ue = g.projection.name === "globe" ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"];
                            ve && ue.push("ALPHA_PASS");
                            const he = t.getOrCreateProgram("globeAtmosphere", {defines: ue}),
                                me = ((Se, Xe, je, Ke, ut, Fe, Te, $e, Be, tt, it, rt) => ({
                                    u_frustum_tl: Se,
                                    u_frustum_tr: Xe,
                                    u_frustum_br: je,
                                    u_frustum_bl: Ke,
                                    u_horizon: ut,
                                    u_transition: Fe,
                                    u_fadeout_range: Te,
                                    u_color: $e,
                                    u_high_color: Be,
                                    u_space_color: tt,
                                    u_temporal_offset: it,
                                    u_horizon_angle: rt
                                }))(g.frustumCorners.TL, g.frustumCorners.TR, g.frustumCorners.BR, g.frustumCorners.BL, g.frustumCorners.horizon, b, G, M, R, V, Z, ce);
                            t.uploadCommonUniforms(h, he);
                            const Oe = this.atmosphereBuffer;
                            Oe && he.draw(t, m.TRIANGLES, v, ei.disabled, ve ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, Yt.backCW, me, ve ? "atmosphere_glow_alpha" : "atmosphere_glow", Oe.vertexBuffer, Oe.indexBuffer, Oe.segments)
                        };
                    _e(!1), _e(!0)
                }

                drawStars(t, s) {
                    const h = o.ay(s.properties.get("star-intensity"), 0, 1);
                    if (h === 0) return;
                    const m = t.context, g = m.gl, v = t.transform, b = t.getOrCreateProgram("stars"), S = o.c3([]);
                    o.c5(S, S, -v._pitch), o.c4(S, S, -v.angle), o.c5(S, S, o.al(v._center.lat)), o.en(S, S, -o.al(v._center.lng));
                    const P = o.c8(new Float32Array(16), S), M = o.az([], v.starsProjMatrix, P), k = o.ei([], P),
                        R = o.eo([], k), O = [0, 1, 0];
                    o.dL(O, O, R), o.c1(O, O, this.params.sizeMultiplier);
                    const V = [1, 0, 0];
                    o.dL(V, V, R), o.c1(V, V, this.params.sizeMultiplier);
                    const B = (G = O, U = V, Z = h, {
                        u_matrix: Float32Array.from(M),
                        u_up: G,
                        u_right: U,
                        u_intensity_multiplier: Z
                    });
                    var G, U, Z;
                    t.uploadCommonUniforms(m, b), this.starsVx && this.starsIdx && b.draw(t, g.TRIANGLES, It.disabled, ei.disabled, this.colorModeAlphaBlendedWriteRGB, Yt.disabled, B, "atmosphere_stars", this.starsVx, this.starsIdx, this.starsSegments)
                }
            }

            class by {
                constructor() {
                    this.visibleTiles = []
                }

                updateBorders(t, s) {
                    const h = [], m = [], g = t._getRenderableCoordinates(!1, !0);
                    for (const S of g) {
                        const P = t.getTile(S);
                        if (!P.hasData()) continue;
                        const M = P.getBucket(s);
                        M && (M.isEmpty() || (h.push(S.key), m.push({bucket: M, tileID: S.canonical})))
                    }
                    let v = h.length !== this.visibleTiles.length;
                    if (!v) {
                        h.sort();
                        for (let S = 0; S < h.length; S++) if (h[S] !== this.visibleTiles[S]) {
                            v = !0;
                            break
                        }
                    }
                    if (!v) return;
                    const b = new Set;
                    this.visibleTiles = h, m.sort((S, P) => S.tileID.z - P.tileID.z || S.tileID.x - P.tileID.x || S.tileID.y - P.tileID.y);
                    for (const S of m) {
                        const P = new Array, M = new Array, k = S.bucket;
                        for (const R of k.featuresOnBorder) b.has(R.featureId) ? M.push(R.footprintIndex) : (b.add(R.featureId), P.push(R.footprintIndex));
                        k.updateFootprintHiddenFlags(P, o.ep, !1), k.updateFootprintHiddenFlags(M, o.ep, !0)
                    }
                }
            }

            function wh(u, t) {
                const s = [...u], h = t.cameraWorldSizeForFog / t.worldSize, m = o.bx([]);
                return o.cP(m, m, [h, h, 1]), o.az(s, m, s), o.az(s, t.worldToFogMatrix, s), s
            }

            function bh(u, t, s, h, m) {
                const g = s.material, v = h.context, {
                    baseColorTexture: b,
                    metallicRoughnessTexture: S
                } = g.pbrMetallicRoughness, {normalTexture: P, occlusionTexture: M, emissionTexture: k} = g;

                function R(V, B, G) {
                    if (V && (u.push(B), v.activeTexture.set(v.gl.TEXTURE0 + G), V.gfxTexture)) {
                        const {minFilter: U, magFilter: Z, wrapS: Q, wrapT: te} = V.sampler;
                        V.gfxTexture.bindExtraParam(U, Z, Q, te)
                    }
                }

                R(b, "HAS_TEXTURE_u_baseColorTexture", po.BaseColor), R(S, "HAS_TEXTURE_u_metallicRoughnessTexture", po.MetallicRoughness), R(P, "HAS_TEXTURE_u_normalTexture", po.Normal), R(M, "HAS_TEXTURE_u_occlusionTexture", po.Occlusion), R(k, "HAS_TEXTURE_u_emissionTexture", po.Emission), m && (m.texture || (m.texture = new o.et(h.context, m.image, [m.image.height, m.image.height, m.image.height], v.gl.RGBA8)), v.activeTexture.set(v.gl.TEXTURE0 + po.LUT), m.texture && m.texture.bind(v.gl.LINEAR, v.gl.CLAMP_TO_EDGE), u.push("APPLY_LUT_ON_GPU")), s.texcoordBuffer && (u.push("HAS_ATTRIBUTE_a_uv_2f"), t.push(s.texcoordBuffer)), s.colorBuffer && (u.push(s.colorBuffer.itemSize === 12 ? "HAS_ATTRIBUTE_a_color_3f" : "HAS_ATTRIBUTE_a_color_4f"), t.push(s.colorBuffer)), s.normalBuffer && (u.push("HAS_ATTRIBUTE_a_normal_3f"), t.push(s.normalBuffer)), s.pbrBuffer && (u.push("HAS_ATTRIBUTE_a_pbr"), u.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"), t.push(s.pbrBuffer)), g.alphaMode !== "OPAQUE" && g.alphaMode !== "MASK" || u.push("UNPREMULT_TEXTURE_IN_SHADER"), g.defined || u.push("DIFFUSE_SHADED");
                const O = h.shadowRenderer;
                O && (u.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), O.useNormalOffset && u.push("NORMAL_OFFSET"))
            }

            function Bc(u, t, s, h, m, g) {
                const v = s.paint.get("model-opacity").constantOr(1), b = t.context,
                    S = new It(t.context.gl.LEQUAL, It.ReadWrite, t.depthRangeFor3D), P = t.transform, M = u.mesh,
                    k = M.material, R = k.pbrMetallicRoughness, O = t.style.fog;
                let V;
                V = t.transform.projection.zAxisUnit === "pixels" ? [...u.nodeModelMatrix] : o.az([], h.zScaleMatrix, u.nodeModelMatrix), o.az(V, h.negCameraPosMatrix, V);
                const B = o.bi([], V);
                o.ea(B, B);
                const G = s.paint.get("model-color-use-theme").constantOr("default") === "none",
                    U = s.paint.get("model-emissive-strength").constantOr(0),
                    Z = cm(new Float32Array(u.worldViewProjection), new Float32Array(V), new Float32Array(B), null, t, v, R.baseColorFactor, k.emissiveFactor, R.metallicFactor, R.roughnessFactor, k, U, s),
                    Q = {defines: []}, te = [], ce = t.shadowRenderer;
                ce && (ce.useNormalOffset = !1), bh(Q.defines, te, M, t, G ? null : s.lut);
                let _e = null;
                if (O) {
                    const he = wh(u.nodeModelMatrix, t.transform);
                    if (_e = new Float32Array(he), P.projection.name !== "globe") {
                        const me = M.aabb.min,
                            Oe = M.aabb.max, [Se, Xe] = O.getOpacityForBounds(he, me[0], me[1], Oe[0], Oe[1]);
                        Q.overrideFog = Se >= Je || Xe >= Je
                    }
                }
                const ve = Ks(t, s.paint.get("model-cutoff-fade-range"));
                ve.shouldRenderCutoff && Q.defines.push("RENDER_CUTOFF");
                const ue = t.getOrCreateProgram("model", Q);
                t.uploadCommonUniforms(b, ue, null, _e, ve), t.renderPass !== "shadow" && ce && ce.setupShadowsFromMatrix(u.nodeModelMatrix, ue), ue.draw(t, b.gl.TRIANGLES, S, m, g, M.material.doubleSided ? Yt.disabled : Yt.backCCW, Z, s.id, M.vertexBuffer, M.indexBuffer, M.segments, s.paint, t.transform.zoom, void 0, te)
            }

            function xm(u, t, s, h, m, g, v) {
                let b;
                b = u.projection.name === "globe" ? o.er(s, u) : [...s], o.az(b, b, t.matrix);
                const S = o.az([], h, b);
                if (t.meshes) for (const P of t.meshes) {
                    if (P.material.alphaMode !== "BLEND") {
                        v.push({mesh: P, depth: 0, modelIndex: m, worldViewProjection: S, nodeModelMatrix: b});
                        continue
                    }
                    const M = o.ad([], P.centroid, S);
                    !u.isOrthographic && M[2] <= 0 || g.push({
                        mesh: P,
                        depth: M[2],
                        modelIndex: m,
                        worldViewProjection: S,
                        nodeModelMatrix: b
                    })
                }
                if (t.children) for (const P of t.children) xm(u, P, s, h, m, g, v)
            }

            function Kd(u, t, s, h) {
                const m = s.shadowRenderer;
                if (!m) return;
                const g = m.getShadowPassDepthMode(), v = m.getShadowPassColorMode(),
                    b = m.calculateShadowPassMatrixFromMatrix(t), S = py(b);
                s.getOrCreateProgram("modelDepth", {defines: s._shadowMapDebug ? [] : ["DEPTH_TEXTURE"]}).draw(s, s.context.gl.TRIANGLES, g, ei.disabled, v, Yt.backCCW, S, h.id, u.vertexBuffer, u.indexBuffer, u.segments, h.paint, s.transform.zoom, void 0, void 0)
            }

            function Nc(u, t, s) {
                const h = t.updateZoomBasedPaintProperties(), m = function (g, v, b) {
                    let S, P, M, k = g.terrain ? g.terrain.exaggeration() : 0;
                    if (g.terrain && k > 0) {
                        const R = g.terrain, O = R.findDEMTileFor(b);
                        O && O.dem ? S = o.eu.create(R, b, O) : k = 0
                    }
                    if (k === 0 && (v.terrainElevationMin = 0, v.terrainElevationMax = 0), k === v.validForExaggeration && (k === 0 || S && S._demTile && S._demTile.tileID === v.validForDEMTile.id && S._dem._timestamp === v.validForDEMTile.timestamp)) return !1;
                    for (const R in v.instancesPerModel) {
                        const O = v.instancesPerModel[R];
                        for (let V = 0; V < O.instancedDataArray.length; ++V) {
                            const B = (S ? k * S.getElevationAt(0 | O.instancedDataArray.float32[16 * V], 0 | O.instancedDataArray.float32[16 * V + 1], !0, !0) : 0) + O.instancesEvaluatedElevation[V];
                            O.instancedDataArray.float32[16 * V + 6] = B, P = P ? Math.min(v.terrainElevationMin, B) : B, M = M ? Math.max(v.terrainElevationMax, B) : B
                        }
                    }
                    return v.terrainElevationMin = P || 0, v.terrainElevationMax = M || 0, v.validForExaggeration = k, v.validForDEMTile = S && S._demTile ? {
                        id: S._demTile.tileID,
                        timestamp: S._dem._timestamp
                    } : {id: void 0, timestamp: 0}, !0
                }(u, t, s);
                (h || m) && (t.uploaded = !1, t.upload(u.context))
            }

            const Js = {
                shadowUniformsInitialized: !1,
                useSingleShadowCascade: !1,
                tileMatrix: new Float64Array(16),
                shadowTileMatrix: new Float32Array(16),
                aabb: new o.d6([0, 0, 0], [o.aj, o.aj, 0])
            };

            function a1(u, t) {
                const s = 1 << u.canonical.z, h = t.getFreeCameraOptions().position, m = t.elevation,
                    g = u.canonical.x / s, v = (u.canonical.x + 1) / s, b = u.canonical.y / s,
                    S = (u.canonical.y + 1) / s;
                let P = t._centerAltitude;
                if (m) {
                    const O = m.getMinMaxForTile(u);
                    O && O.max > P && (P = O.max)
                }
                const M = o.ay(h.x, g, v) - h.x, k = o.ay(h.y, b, S) - h.y, R = o.cb(P, t.center.lat) - h.z;
                return t._zoomFromMercatorZ(Math.sqrt(M * M + k * k + R * R))
            }

            function wm(u, t, s, h, m, g, v) {
                const b = u.context, S = u.renderPass === "shadow", P = u.shadowRenderer,
                    M = S && P ? P.getShadowPassDepthMode() : new It(b.gl.LEQUAL, It.ReadWrite, u.depthRangeFor3D),
                    k = u.isTileAffectedByFog(g);
                if (s.meshes) for (const R of s.meshes) {
                    const O = ["MODEL_POSITION_ON_GPU"], V = [];
                    let B, G, U;
                    h.instancedDataArray.length > 20 && O.push("INSTANCED_ARRAYS");
                    const Z = Ks(u, t.paint.get("model-cutoff-fade-range"));
                    if (Z.shouldRenderCutoff && O.push("RENDER_CUTOFF"), S && P) B = u.getOrCreateProgram("modelDepth", {defines: O}), G = py(v.shadowTileMatrix, v.shadowTileMatrix, Float32Array.from(s.matrix)), U = P.getShadowPassColorMode(); else {
                        bh(O, V, R, u, t.paint.get("model-color-use-theme").constantOr("default") === "none" ? null : t.lut), B = u.getOrCreateProgram("model", {
                            defines: O,
                            overrideFog: k
                        });
                        const te = R.material, ce = te.pbrMetallicRoughness,
                            _e = t.paint.get("model-opacity").constantOr(1),
                            ve = t.paint.get("model-emissive-strength").constantOr(0);
                        G = cm(g.expandedProjMatrix, Float32Array.from(s.matrix), new Float32Array(16), null, u, _e, ce.baseColorFactor, te.emissiveFactor, ce.metallicFactor, ce.roughnessFactor, te, ve, t, m), P && (v.shadowUniformsInitialized ? B.setShadowUniformValues(b, P.getShadowUniformValues()) : (P.setupShadows(g.toUnwrapped(), B, "model-tile"), v.shadowUniformsInitialized = !0)), U = Z.shouldRenderCutoff || _e < 1 || te.alphaMode !== "OPAQUE" ? gi.alphaBlended : gi.unblended
                    }
                    u.uploadCommonUniforms(b, B, g.toUnwrapped(), null, Z);
                    const Q = R.material.doubleSided ? Yt.disabled : Yt.backCCW;
                    if (h.instancedDataArray.length > 20) V.push(h.instancedDataBuffer), B.draw(u, b.gl.TRIANGLES, M, ei.disabled, U, Q, G, t.id, R.vertexBuffer, R.indexBuffer, R.segments, t.paint, u.transform.zoom, void 0, V, h.instancedDataArray.length); else {
                        const te = S ? "u_instance" : "u_normal_matrix";
                        for (let ce = 0; ce < h.instancedDataArray.length; ++ce) G[te] = new Float32Array(h.instancedDataArray.arrayBuffer, 64 * ce, 16), B.draw(u, b.gl.TRIANGLES, M, ei.disabled, U, Q, G, t.id, R.vertexBuffer, R.indexBuffer, R.segments, t.paint, u.transform.zoom, void 0, V)
                    }
                }
                if (s.children) for (const R of s.children) wm(u, t, R, h, m, g, v)
            }

            const Qd = [1, -1, 1];

            function bm(u, t, s, h) {
                if (!s.modelManager) return !0;
                const m = s.modelManager;
                if (!s.shadowRenderer) return !0;
                const g = s.shadowRenderer, v = t.aabb;
                let b = !0, S = u.maxHeight;
                if (S === 0) {
                    let M = 0;
                    for (const k in u.instancesPerModel) {
                        const R = m.getModel(k, h);
                        R ? M = Math.max(M, Math.max(Math.max(R.aabb.max[0], R.aabb.max[1]), R.aabb.max[2])) : b = !1
                    }
                    S = u.maxScale * M * 1.41 + u.maxVerticalOffset, b && (u.maxHeight = S)
                }
                v.max[2] = S, v.min[2] += u.terrainElevationMin, v.max[2] += u.terrainElevationMax, o.ad(v.min, v.min, t.tileMatrix), o.ad(v.max, v.max, t.tileMatrix);
                const P = v.intersects(g.getCurrentCascadeFrustum());
                return s.currentShadowCascade === 0 && (u.isInsideFirstShadowMapFrustum = P === 2), P === 0
            }

            function Ty(u, t) {
                const s = u.uniformValues.u_cutoff_params[0], h = u.uniformValues.u_cutoff_params[1],
                    m = u.uniformValues.u_cutoff_params[2], g = u.uniformValues.u_cutoff_params[3];
                return h === s || g === m ? 1 : o.ay(((t - s) / (h - s) - m) / (g - m), 0, 1)
            }

            function Sy(u, t, s, h) {
                if (t.pitch < 20) return 1;
                const m = t.getWorldToCameraMatrix();
                o.az(m, m, u);
                const g = o.bR(s.min[0], s.min[1], s.min[2], 1);
                let v = o.aA(o.ev(), g, m), b = v, S = v;
                g[1] = s.max[1], v = o.aA(o.ev(), g, m), b = v[1] < b[1] ? v : b, S = v[1] > S[1] ? v : S, g[0] = s.max[0], v = o.aA(o.ev(), g, m), b = v[1] < b[1] ? v : b, S = v[1] > S[1] ? v : S, g[1] = s.min[1], v = o.aA(o.ev(), g, m), b = v[1] < b[1] ? v : b, S = v[1] > S[1] ? v : S;
                const P = o.ay(h[0], 0, 1), M = 100 * t.pixelsPerMeter * o.ay(h[1], 0, 1), k = o.ay(h[2], 0, 1),
                    R = o.ew(o.ev(), b, S, P), O = Math.tan(.5 * t.fovX), V = -R[2] * O;
                if (M === 0) return R[1] < -Math.abs(V) ? k : 1;
                const B = (-Math.abs(V) - R[1]) / M, G = (Z, Q, te) => (1 - te) * Z + te * Q,
                    U = o.ay(G(1, k, B), k, 1);
                return G(1, U, o.ay((t.pitch - 20) / 20, 0, 1))
            }

            class Jd {
            }

            class Th {
                constructor() {
                    this._storage = new Map
                }

                getLinesFromTrianglesBuffer(t, s, h) {
                    {
                        const k = this._storage.get(s.id);
                        if (k) return k.lastUsedFrameIdx = t, k.buf
                    }
                    const m = h.gl, g = m.getBufferParameter(m.ELEMENT_ARRAY_BUFFER, m.BUFFER_SIZE),
                        v = new ArrayBuffer(g), b = new Int16Array(v);
                    m.getBufferSubData(m.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(v));
                    const S = new o.ey;
                    for (let k = 0; k < g / 2; k += 3) {
                        const R = b[k], O = b[k + 1], V = b[k + 2];
                        S.emplaceBack(R, O), S.emplaceBack(O, V), S.emplaceBack(V, R)
                    }
                    const P = h.bindVertexArrayOES.current, M = new Jd;
                    return M.buf = new rl(h, S), M.lastUsedFrameIdx = t, this._storage.set(s.id, M), h.bindVertexArrayOES.set(P), M.buf
                }

                update(t) {
                    for (const [s, h] of this._storage) t - h.lastUsedFrameIdx > 30 && (h.buf.destroy(), this._storage.delete(s))
                }

                destroy() {
                    for (const [t, s] of this._storage) s.buf.destroy(), this._storage.delete(t)
                }
            }

            class jc {
                constructor(t) {
                    this.occluderSize = 30, this.depthOffset = -1e-4, t.registerParameter(this, ["Occlusion"], "occluderSize", {
                        min: 1,
                        max: 100,
                        step: 1
                    }), t.registerParameter(this, ["Occlusion"], "depthOffset", {min: -.05, max: 0, step: 1e-5})
                }
            }

            const Ey = o.ec([{type: "Float32", name: "a_pos_3f", components: 3}, {
                type: "Float32",
                name: "a_uv",
                components: 2
            }, {type: "Float32", name: "a_rainParticleData", components: 4}]);

            class l1 {
                registerParameter() {
                }

                registerButton() {
                }

                registerBinding() {
                }

                refreshUI() {
                }
            }

            class to {
                constructor(t, s) {
                    this.revealStart = 11, this.revealRange = 2, t.registerParameter(this, [...s, "Reveal"], "revealStart", {
                        min: 0,
                        max: 17,
                        step: .05
                    }), t.registerParameter(this, [...s, "Reveal"], "revealRange", {min: .1, max: 5.1, step: .05})
                }
            }

            const c1 = o.ec([{type: "Float32", name: "a_pos_2f", components: 2}]);

            class Sh {
                destroy() {
                    this.vignetteVx && this.vignetteVx.destroy(), this.vignetteIdx && this.vignetteIdx.destroy()
                }

                draw(t, s) {
                    const h = t.getOrCreateProgram("vignette");
                    if (!this.vignetteVx || !this.vignetteIdx) {
                        const v = new o.ez, b = new o.a_;
                        v.emplaceBack(-1, -1), v.emplaceBack(1, -1), v.emplaceBack(1, 1), v.emplaceBack(-1, 1), b.emplaceBack(0, 1, 2), b.emplaceBack(0, 2, 3), this.vignetteVx = t.context.createVertexBuffer(v, c1.members), this.vignetteIdx = t.context.createIndexBuffer(b)
                    }
                    const m = o.bd.simpleSegment(0, 0, 4, 6);
                    if (this.vignetteVx && this.vignetteIdx) {
                        t.uploadCommonUniforms(t.context, h);
                        const v = {
                            u_vignetteShape: (g = {
                                vignetteShape: [s.start, s.range, Math.pow(10, s.fadePower)],
                                vignetteColor: [s.color.r, s.color.g, s.color.b, s.color.a * s.strength]
                            }).vignetteShape, u_vignetteColor: g.vignetteColor
                        };
                        h.draw(t, t.context.gl.TRIANGLES, It.disabled, ei.disabled, gi.alphaBlended, Yt.disabled, v, "vignette", this.vignetteVx, this.vignetteIdx, m)
                    }
                    var g
                }
            }

            class In {
                constructor() {
                    this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0
                }

                update(t, s) {
                    const h = t.getFreeCameraOptions().position, m = h.toAltitude(), g = h.toLngLat(), v = o.al(g.lng),
                        b = o.al(g.lat), S = t.pixelsPerMeter / s, P = v * o.eB,
                        M = o.eB * Math.log(Math.tan(Math.PI / 4 + b / 2));
                    if (this._offsetXPrev === void 0) this._offsetXPrev = 0, this._offsetYPrev = 0, this._elevationPrev = 0, this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0; else {
                        const k = -this._offsetYPrev + M, R = -this._elevationPrev + m;
                        this._accumulatedOffsetX += (-this._offsetXPrev + P) * S, this._accumulatedOffsetY += k * S, this._accumulatedElevation += R * S, this._offsetXPrev = P, this._offsetYPrev = M, this._elevationPrev = m
                    }
                }

                getPosition() {
                    return [this._accumulatedOffsetX, this._accumulatedOffsetY, this._accumulatedElevation]
                }
            }

            function Fi(u, t) {
                return [-(u[0] - Math.floor(u[0] / t) * t), -(u[1] - Math.floor(u[1] / t) * t), -(u[2] - Math.floor(u[2] / t) * t)]
            }

            function Tm(u) {
                const t = o.el(1323123451230), s = [];
                for (let h = 0; h < u; ++h) {
                    const m = 2 * t() - 1, g = 2 * t() - 1, v = 2 * t() - 1;
                    s.push(o.d2(m, g, v))
                }
                return s
            }

            function Po(u, t, s, h, m) {
                const g = o.ay((m - s) / (h - s), 0, 1);
                return (1 - g) * u + g * t
            }

            class Vc {
                constructor(t) {
                    this._movement = new In, this._accumulatedTimeFromStart = 0, this._prevTime = Date.now() / 1e3, this._vignette = new Sh, this._ppmScaleFactor = t
                }

                destroy() {
                    this.particlesVx && this.particlesVx.destroy(), this.particlesIdx && this.particlesIdx.destroy(), this._vignette && this._vignette.destroy()
                }

                updateOnRender(t, s) {
                    const h = t.transform;
                    this._movement.update(h, this._ppmScaleFactor);
                    const m = h.starsProjMatrix, g = o.c3([]);
                    o.c5(g, g, o.al(90) - h._pitch), o.c4(g, g, -h.angle);
                    const v = o.c8(new Float32Array(16), g), b = o.eA(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1),
                        S = o.ea([], b), P = o.az([], S, v), M = Date.now() / 1e3;
                    return this._accumulatedTimeFromStart += (M - this._prevTime) * s, this._prevTime = M, {
                        projectionMatrix: m,
                        modelviewMatrix: P
                    }
                }
            }

            class Uc extends Vc {
                constructor(t) {
                    super(4.25), this._params = {
                        overrideStyleParameters: !1,
                        intensity: .5,
                        timeFactor: 1,
                        velocityConeAperture: 0,
                        velocity: 300,
                        boxSize: 2500,
                        dropletSizeX: 1,
                        dropletSizeYScale: 10,
                        distortionStrength: 70,
                        screenThinning: {
                            intensity: .57,
                            start: .46,
                            range: 1.17,
                            fadePower: .17,
                            affectedRatio: 1,
                            particleOffset: -.2
                        },
                        color: {r: .66, g: .68, b: .74, a: .7},
                        direction: {x: -50, y: -35},
                        shapeDirPower: 2,
                        shapeNormalPower: 1
                    }, this._revealParams = new to(t.tp, ["Precipitation", "Rain"]), this._vignetteParams = {
                        strength: 1,
                        start: .7,
                        range: 1,
                        fadePower: .4,
                        color: {r: .27, g: .27, b: .27, a: 1}
                    }, this.particlesCount = 16e3
                }

                update(t) {
                    const s = t.context;
                    if (!this.particlesVx) {
                        const h = Tm(this.particlesCount), m = new o.eC, g = new o.a_;
                        let v = 0;
                        const b = o.el(1323123451230);
                        for (let S = 0; S < h.length; ++S) {
                            const P = h[S], M = [2 * b() - 1, b(), b(), b()];
                            m.emplaceBack(P[0], P[1], P[2], -1, -1, ...M), m.emplaceBack(P[0], P[1], P[2], 1, -1, ...M), m.emplaceBack(P[0], P[1], P[2], 1, 1, ...M), m.emplaceBack(P[0], P[1], P[2], -1, 1, ...M), g.emplaceBack(v + 0, v + 1, v + 2), g.emplaceBack(v + 0, v + 2, v + 3), v += 4
                        }
                        this.particlesVx = s.createVertexBuffer(m, Ey.members), this.particlesIdx = s.createIndexBuffer(g)
                    }
                }

                draw(t) {
                    if (!this._params.overrideStyleParameters && !t.style.rain) return;
                    const s = this._params.overrideStyleParameters ? this._revealParams : {
                        revealStart: 0,
                        revealRange: .01
                    }, h = t.transform.zoom;
                    if (s.revealStart > h) return;
                    const m = Po(0, 1, s.revealStart, s.revealStart + s.revealRange, h);
                    if (!this.particlesVx || !this.particlesIdx) return;
                    const g = structuredClone(this._params);
                    let v = [-g.direction.x, g.direction.y, -100];
                    o.au(v, v);
                    const b = structuredClone(this._vignetteParams);
                    b.strength *= m, g.overrideStyleParameters || (g.intensity = t.style.rain.state.density, g.timeFactor = t.style.rain.state.intensity, g.color = structuredClone(t.style.rain.state.color), v = structuredClone(t.style.rain.state.direction), g.screenThinning.intensity = t.style.rain.state.centerThinning, g.dropletSizeX = t.style.rain.state.dropletSize[0], g.dropletSizeYScale = t.style.rain.state.dropletSize[1] / t.style.rain.state.dropletSize[0], g.distortionStrength = 100 * t.style.rain.state.distortionStrength, b.strength = 1, b.color = structuredClone(t.style.rain.state.vignetteColor));
                    const S = this.updateOnRender(t, g.timeFactor), P = t.context, M = P.gl, k = t.transform;
                    this.screenTexture && this.screenTexture.size[0] === t.width && this.screenTexture.size[1] === t.height || (this.screenTexture = new o.T(P, {
                        width: t.width,
                        height: t.height,
                        data: null
                    }, M.RGBA8)), g.distortionStrength > 0 && (P.activeTexture.set(M.TEXTURE0), this.screenTexture.bind(M.LINEAR, M.CLAMP_TO_EDGE), M.copyTexSubImage2D(M.TEXTURE_2D, 0, 0, 0, 0, 0, t.width, t.height));
                    const R = t.getOrCreateProgram("rainParticle");
                    t.uploadCommonUniforms(P, R), P.activeTexture.set(M.TEXTURE0), this.screenTexture.bind(M.LINEAR, M.CLAMP_TO_EDGE);
                    const O = [g.color.r, g.color.g, g.color.b, g.color.a], V = (B, G) => {
                        const U = Fi(this._movement.getPosition(), B), Z = g.dropletSizeX,
                            Q = g.dropletSizeX * g.dropletSizeYScale, te = t.width / 2, ce = t.height / 2,
                            _e = Po(0, g.screenThinning.start, 0, 1, g.screenThinning.intensity),
                            ve = Po(.001, g.screenThinning.range, 0, 1, g.screenThinning.intensity),
                            ue = Po(0, g.screenThinning.particleOffset, 0, 1, g.screenThinning.intensity), he = (me = {
                                modelview: S.modelviewMatrix,
                                projection: S.projectionMatrix,
                                time: this._accumulatedTimeFromStart,
                                camPos: U,
                                velocityConeAperture: g.velocityConeAperture,
                                velocity: g.velocity,
                                boxSize: B,
                                rainDropletSize: [Z, Q],
                                distortionStrength: g.distortionStrength,
                                rainDirection: v,
                                color: O,
                                screenSize: [k.width, k.height],
                                thinningCenterPos: [te, ce],
                                thinningShape: [_e, ve, Math.pow(10, g.screenThinning.fadePower)],
                                thinningAffectedRatio: g.screenThinning.affectedRatio,
                                thinningParticleOffset: ue,
                                shapeDirectionalPower: g.shapeDirPower,
                                shapeNormalPower: g.shapeNormalPower,
                                mode: G ? 0 : 1
                            }, {
                                u_modelview: Float32Array.from(me.modelview),
                                u_projection: Float32Array.from(me.projection),
                                u_time: me.time,
                                u_cam_pos: me.camPos,
                                u_texScreen: 0,
                                u_velocityConeAperture: me.velocityConeAperture,
                                u_velocity: me.velocity,
                                u_boxSize: me.boxSize,
                                u_rainDropletSize: me.rainDropletSize,
                                u_distortionStrength: me.distortionStrength,
                                u_rainDirection: me.rainDirection,
                                u_color: me.color,
                                u_screenSize: me.screenSize,
                                u_thinningCenterPos: me.thinningCenterPos,
                                u_thinningShape: me.thinningShape,
                                u_thinningAffectedRatio: me.thinningAffectedRatio,
                                u_thinningParticleOffset: me.thinningParticleOffset,
                                u_shapeDirectionalPower: me.shapeDirectionalPower,
                                u_shapeNormalPower: me.shapeNormalPower,
                                u_mode: me.mode
                            });
                        var me;
                        const Oe = Math.round(g.intensity * this.particlesCount),
                            Se = o.bd.simpleSegment(0, 0, 4 * Oe, 2 * Oe);
                        R.draw(t, M.TRIANGLES, It.disabled, ei.disabled, gi.alphaBlended, Yt.disabled, he, "rain_particles", this.particlesVx, this.particlesIdx, Se)
                    };
                    g.distortionStrength > 0 && V(g.boxSize, !0), V(g.boxSize, !1), this._vignette.draw(t, b)
                }
            }

            const Zl = o.ec([{type: "Float32", name: "a_pos_3f", components: 3}, {
                type: "Float32",
                name: "a_uv",
                components: 2
            }, {type: "Float32", name: "a_snowParticleData", components: 4}, {
                type: "Float32",
                name: "a_snowParticleDataHorizontalOscillation",
                components: 2
            }]);

            class Sm extends Vc {
                constructor(t) {
                    super(2.25), this._params = {
                        overrideStyleParameters: !1,
                        intensity: .85,
                        timeFactor: .75,
                        velocityConeAperture: 70,
                        velocity: 40,
                        horizontalOscillationRadius: 4,
                        horizontalOscillationRate: 1.5,
                        boxSize: 2e3,
                        billboardSize: 2,
                        shapeFadeStart: .27,
                        shapeFadePower: .21,
                        screenThinning: {
                            intensity: .4,
                            start: .15,
                            range: 1.4,
                            fadePower: .24,
                            affectedRatio: 1,
                            particleOffset: -.2
                        },
                        color: {r: 1, g: 1, b: 1, a: 1},
                        direction: {x: -50, y: -35}
                    }, this._revealParams = new to(t.tp, ["Precipitation", "Snow"]), this._vignetteParams = {
                        strength: .3,
                        start: .78,
                        range: .46,
                        fadePower: .2,
                        color: {r: 1, g: 1, b: 1, a: 1}
                    }, this.particlesCount = 16e3
                }

                update(t) {
                    const s = t.context;
                    if (!this.particlesVx) {
                        const h = Tm(this.particlesCount), m = new o.eD, g = new o.a_;
                        let v = 0;
                        const b = o.el(1323123451230);
                        for (let S = 0; S < h.length; ++S) {
                            const P = h[S], M = b(), k = b(), R = b(), O = [S / h.length, M, k, R], V = [b(), b()];
                            m.emplaceBack(P[0], P[1], P[2], -1, -1, ...O, ...V), m.emplaceBack(P[0], P[1], P[2], 1, -1, ...O, ...V), m.emplaceBack(P[0], P[1], P[2], 1, 1, ...O, ...V), m.emplaceBack(P[0], P[1], P[2], -1, 1, ...O, ...V), g.emplaceBack(v + 0, v + 1, v + 2), g.emplaceBack(v + 0, v + 2, v + 3), v += 4
                        }
                        this.particlesVx = s.createVertexBuffer(m, Zl.members), this.particlesIdx = s.createIndexBuffer(g)
                    }
                }

                draw(t) {
                    if (!this._params.overrideStyleParameters && !t.style.snow) return;
                    const s = structuredClone(this._params);
                    let h = [-s.direction.x, s.direction.y, -100];
                    o.au(h, h);
                    const m = structuredClone(this._vignetteParams),
                        g = s.overrideStyleParameters ? this._revealParams : {revealStart: 0, revealRange: .01},
                        v = t.transform.zoom;
                    if (g.revealStart > v) return;
                    const b = Po(0, 1, g.revealStart, g.revealStart + g.revealRange, v);
                    m.strength *= b, s.overrideStyleParameters || (s.intensity = t.style.snow.state.density, s.timeFactor = t.style.snow.state.intensity, s.color = structuredClone(t.style.snow.state.color), h = structuredClone(t.style.snow.state.direction), s.screenThinning.intensity = t.style.snow.state.centerThinning, s.billboardSize = 2.79 * t.style.snow.state.flakeSize, m.strength = 1, m.color = structuredClone(t.style.snow.state.vignetteColor));
                    const S = this.updateOnRender(t, s.timeFactor);
                    if (!this.particlesVx || !this.particlesIdx) return;
                    const P = t.context, M = P.gl, k = t.transform, R = t.getOrCreateProgram("snowParticle");
                    t.uploadCommonUniforms(P, R), ((O, V, B) => {
                        const G = Fi(this._movement.getPosition(), O), U = k.width / 2, Z = k.height / 2,
                            Q = Po(0, B.screenThinning.start, 0, 1, B.screenThinning.intensity),
                            te = Po(.001, B.screenThinning.range, 0, 1, B.screenThinning.intensity),
                            ce = Po(0, B.screenThinning.particleOffset, 0, 1, B.screenThinning.intensity), _e = (ve = {
                                modelview: S.modelviewMatrix,
                                projection: S.projectionMatrix,
                                time: this._accumulatedTimeFromStart,
                                camPos: G,
                                velocityConeAperture: B.velocityConeAperture,
                                velocity: B.velocity,
                                horizontalOscillationRadius: B.horizontalOscillationRadius,
                                horizontalOscillationRate: B.horizontalOscillationRate,
                                boxSize: O,
                                billboardSize: 1 * B.billboardSize,
                                simpleShapeParameters: [B.shapeFadeStart, B.shapeFadePower],
                                screenSize: [k.width, k.height],
                                thinningCenterPos: [U, Z],
                                thinningShape: [Q, te, Math.pow(10, B.screenThinning.fadePower)],
                                thinningAffectedRatio: B.screenThinning.affectedRatio,
                                thinningParticleOffset: ce,
                                color: [B.color.r, B.color.g, B.color.b, B.color.a],
                                direction: h
                            }, {
                                u_modelview: Float32Array.from(ve.modelview),
                                u_projection: Float32Array.from(ve.projection),
                                u_time: ve.time,
                                u_cam_pos: ve.camPos,
                                u_velocityConeAperture: ve.velocityConeAperture,
                                u_velocity: ve.velocity,
                                u_horizontalOscillationRadius: ve.horizontalOscillationRadius,
                                u_horizontalOscillationRate: ve.horizontalOscillationRate,
                                u_boxSize: ve.boxSize,
                                u_billboardSize: ve.billboardSize,
                                u_simpleShapeParameters: ve.simpleShapeParameters,
                                u_screenSize: ve.screenSize,
                                u_thinningCenterPos: ve.thinningCenterPos,
                                u_thinningShape: ve.thinningShape,
                                u_thinningAffectedRatio: ve.thinningAffectedRatio,
                                u_thinningParticleOffset: ve.thinningParticleOffset,
                                u_particleColor: ve.color,
                                u_direction: ve.direction
                            });
                        var ve;
                        const ue = Math.round(B.intensity * this.particlesCount),
                            he = o.bd.simpleSegment(0, 0, 4 * ue, 2 * ue);
                        this.particlesVx && this.particlesIdx && R.draw(t, M.TRIANGLES, It.disabled, ei.disabled, gi.alphaBlended, Yt.disabled, _e, "snow_particles", this.particlesVx, this.particlesIdx, he)
                    })(s.boxSize, 0, s), this._vignette.draw(t, m)
                }
            }

            const Em = {
                symbol: function (u, t, s, h, m) {
                    if (u.renderPass !== "translucent") return;
                    const g = ei.disabled, v = u.colorModeForRenderPass(), b = s.layout.get("text-variable-anchor"),
                        S = s.layout.get("text-size-scale-range"), P = o.ay(u.scaleFactor, S[0], S[1]);
                    b && function (R, O, V, B, G, U, Z, Q) {
                        const te = O.transform, ce = G === "map", _e = U === "map";
                        for (const ve of R) {
                            const ue = B.getTile(ve), he = ue.getBucket(V);
                            if (!he || !he.text || !he.text.segments.get().length) continue;
                            const me = o.bH(he.textSizeData, te.zoom, Q), Oe = pd(ve, he.getProjection(), te),
                                Se = te.calculatePixelsToTileUnitsMatrix(ue),
                                Xe = eh(Oe, ue.tileID.canonical, _e, ce, te, he.getProjection(), Se),
                                je = he.hasIconTextFit() && he.hasIconData();
                            me && gy(he, ce, _e, Z, te, Xe, ve, Math.pow(2, te.zoom - ue.tileID.overscaledZ), me, je)
                        }
                    }(h, u, s, t, s.layout.get("text-rotation-alignment"), s.layout.get("text-pitch-alignment"), m, P);
                    const M = s.paint.get("icon-opacity").constantOr(1) !== 0,
                        k = s.paint.get("text-opacity").constantOr(1) !== 0;
                    s.layout.get("symbol-sort-key").constantOr(1) !== void 0 && (M || k) ? pm(u, t, s, h, g, v) : (M && pm(u, t, s, h, g, v, {onlyIcons: !0}), k && pm(u, t, s, h, g, v, {onlyText: !0})), t.map.showCollisionBoxes && (dm(u, t, s, h, s.paint.get("text-translate"), s.paint.get("text-translate-anchor"), !0), dm(u, t, s, h, s.paint.get("icon-translate"), s.paint.get("icon-translate-anchor"), !1))
                }, circle: function (u, t, s, h) {
                    if (u.renderPass !== "translucent") return;
                    const m = s.paint.get("circle-opacity"), g = s.paint.get("circle-stroke-width"),
                        v = s.paint.get("circle-stroke-opacity"),
                        b = s.layout.get("circle-sort-key").constantOr(1) !== void 0,
                        S = s.paint.get("circle-emissive-strength");
                    if (m.constantOr(1) === 0 && (g.constantOr(1) === 0 || v.constantOr(1) === 0)) return;
                    const P = u.context, M = P.gl, k = u.transform, R = !(!u.terrain || !u.terrain.enabled),
                        O = s.layout.get("circle-elevation-reference"), V = u.depthModeForSublayer(0, It.ReadOnly),
                        B = new It(u.context.gl.LEQUAL, It.ReadOnly, u.depthRangeFor3D), G = O === "none" || R ? V : B,
                        U = ei.disabled, Z = u.colorModeForDrapableLayerRenderPass(S),
                        Q = k.projection.name === "globe", te = [o.aD(k.center.lng), o.aH(k.center.lat)], ce = [];
                    for (let ve = 0; ve < h.length; ve++) {
                        const ue = h[ve], he = t.getTile(ue), me = he.getBucket(s);
                        if (!me || me.projection.name !== k.projection.name) continue;
                        const Oe = me.programConfigurations.get(s.id), Se = me.layoutVertexBuffer,
                            Xe = me.globeExtVertexBuffer, je = me.indexBuffer, Ke = o.dW(s), ut = [Xe],
                            Fe = u.isTileAffectedByFog(ue);
                        Q && Ke.push("PROJECTION_GLOBE_VIEW"), Ke.push("DEPTH_D24"), u.terrain && k.depthOcclusionForSymbolsAndCircles && Ke.push("DEPTH_OCCLUSION"), me.hasElevation && !u.terrain && (Ke.push("ELEVATED_ROADS"), ut.push(me.elevatedLayoutVertexBuffer));
                        const Te = u.getOrCreateProgram("circle", {config: Oe, defines: Ke, overrideFog: Fe}),
                            $e = k.projection.createInversionMatrix(k, ue.canonical), Be = {
                                programConfiguration: Oe,
                                program: Te,
                                layoutVertexBuffer: Se,
                                dynamicBuffers: ut,
                                indexBuffer: je,
                                uniformValues: o.dX(u, ue, he, $e, te, s),
                                tile: he
                            };
                        if (b) {
                            const tt = me.segments.get();
                            for (const it of tt) ce.push({segments: new o.bd([it]), sortKey: it.sortKey, state: Be})
                        } else ce.push({segments: me.segments, sortKey: 0, state: Be})
                    }
                    b && ce.sort((ve, ue) => ve.sortKey - ue.sortKey);
                    const _e = {useDepthForOcclusion: k.depthOcclusionForSymbolsAndCircles};
                    for (const ve of ce) {
                        const {
                            programConfiguration: ue,
                            program: he,
                            layoutVertexBuffer: me,
                            dynamicBuffers: Oe,
                            indexBuffer: Se,
                            uniformValues: Xe,
                            tile: je
                        } = ve.state, Ke = ve.segments;
                        u.terrain && u.terrain.setupElevationDraw(je, he, _e), u.uploadCommonUniforms(P, he, je.tileID.toUnwrapped()), he.draw(u, M.TRIANGLES, G, U, Z, Yt.disabled, Xe, s.id, me, Se, Ke, s.paint, k.zoom, ue, Oe)
                    }
                }, heatmap: function (u, t, s, h) {
                    if (s.paint.get("heatmap-opacity") !== 0) if (u.renderPass === "offscreen") {
                        const m = u.context, g = m.gl, v = ei.disabled,
                            b = new gi([g.ONE, g.ONE, g.ONE, g.ONE], o.am.transparent, [!0, !0, !0, !0]);
                        (function (O, V, B, G) {
                            const U = O.gl, Z = V.width * G, Q = V.height * G;
                            O.activeTexture.set(U.TEXTURE1), O.viewport.set([0, 0, Z, Q]);
                            let te = B.heatmapFbo;
                            if (!te || te && (te.width !== Z || te.height !== Q)) {
                                te && te.destroy();
                                const ce = U.createTexture();
                                U.bindTexture(U.TEXTURE_2D, ce), U.texParameteri(U.TEXTURE_2D, U.TEXTURE_WRAP_S, U.CLAMP_TO_EDGE), U.texParameteri(U.TEXTURE_2D, U.TEXTURE_WRAP_T, U.CLAMP_TO_EDGE), U.texParameteri(U.TEXTURE_2D, U.TEXTURE_MIN_FILTER, U.LINEAR), U.texParameteri(U.TEXTURE_2D, U.TEXTURE_MAG_FILTER, U.LINEAR), te = B.heatmapFbo = O.createFramebuffer(Z, Q, !0, null), function (_e, ve, ue, he, me, Oe) {
                                    const Se = _e.gl;
                                    Se.texImage2D(Se.TEXTURE_2D, 0, _e.extRenderToTextureHalfFloat ? Se.RGBA16F : Se.RGBA, me, Oe, 0, Se.RGBA, _e.extRenderToTextureHalfFloat ? Se.HALF_FLOAT : Se.UNSIGNED_BYTE, null), he.colorAttachment.set(ue)
                                }(O, 0, ce, te, Z, Q)
                            } else U.bindTexture(U.TEXTURE_2D, te.colorAttachment.get()), O.bindFramebuffer.set(te.framebuffer)
                        })(m, u, s, u.transform.projection.name === "globe" ? .5 : .25), m.clear({color: o.am.transparent});
                        const S = u.transform, P = S.projection.name === "globe",
                            M = P ? ["PROJECTION_GLOBE_VIEW"] : [], k = P ? Yt.frontCCW : Yt.disabled,
                            R = [o.aD(S.center.lng), o.aH(S.center.lat)];
                        for (let O = 0; O < h.length; O++) {
                            const V = h[O];
                            if (t.hasRenderableParent(V)) continue;
                            const B = t.getTile(V), G = B.getBucket(s);
                            if (!G || G.projection.name !== S.projection.name) continue;
                            const U = u.isTileAffectedByFog(V), Z = G.programConfigurations.get(s.id),
                                Q = u.getOrCreateProgram("heatmap", {
                                    config: Z,
                                    defines: M,
                                    overrideFog: U
                                }), {zoom: te} = u.transform;
                            u.terrain && u.terrain.setupElevationDraw(B, Q), u.uploadCommonUniforms(m, Q, V.toUnwrapped());
                            const ce = S.projection.createInversionMatrix(S, V.canonical);
                            Q.draw(u, g.TRIANGLES, It.disabled, v, b, k, uy(u, V, B, ce, R, te, s.paint.get("heatmap-intensity")), s.id, G.layoutVertexBuffer, G.indexBuffer, G.segments, s.paint, u.transform.zoom, Z, P ? [G.globeExtVertexBuffer] : null)
                        }
                        m.viewport.set([0, 0, u.width, u.height])
                    } else u.renderPass === "translucent" && (u.context.setColorMode(u.colorModeForRenderPass()), function (m, g) {
                        const v = m.context, b = v.gl, S = g.heatmapFbo;
                        if (!S) return;
                        v.activeTexture.set(b.TEXTURE0), b.bindTexture(b.TEXTURE_2D, S.colorAttachment.get()), v.activeTexture.set(b.TEXTURE1);
                        let P = g.colorRampTexture;
                        P || (P = g.colorRampTexture = new o.T(v, g.colorRamp, b.RGBA8)), P.bind(b.LINEAR, b.CLAMP_TO_EDGE), m.getOrCreateProgram("heatmapTexture").draw(m, b.TRIANGLES, It.disabled, ei.disabled, m.colorModeForRenderPass(), Yt.disabled, ((M, k, R, O) => ({
                            u_image: 0,
                            u_color_ramp: 1,
                            u_opacity: k.paint.get("heatmap-opacity")
                        }))(0, g), g.id, m.viewportBuffer, m.quadTriangleIndexBuffer, m.viewportSegments, g.paint, m.transform.zoom)
                    }(u, s))
                }, line: function (u, t, s, h) {
                    if (u.renderPass !== "translucent") return;
                    const m = s.paint.get("line-opacity"), g = s.paint.get("line-width");
                    if (m.constantOr(1) === 0 || g.constantOr(1) === 0) return;
                    const v = s.paint.get("line-emissive-strength"), b = s.paint.get("line-occlusion-opacity"),
                        S = s.layout.get("line-elevation-reference"), P = s.layout.get("line-width-unit") === "meters",
                        M = S === "sea", k = !(!u.terrain || !u.terrain.enabled), R = u.context, O = R.gl;
                    if (s.hasElevatedBuckets && u.transform.projection.name === "globe") return;
                    const V = s.layout.get("line-cross-slope"), B = V !== void 0, G = V < 1,
                        U = u.colorModeForDrapableLayerRenderPass(v), Z = u.terrain && u.terrain.renderingToTexture,
                        Q = Z ? 1 : o.q.devicePixelRatio, te = s.paint.get("line-dasharray"), ce = te.constantOr(1),
                        _e = s.layout.get("line-cap"), ve = te.constantOr(null), ue = _e.constantOr(null),
                        he = s.paint.get("line-pattern"), me = he.constantOr(1),
                        Oe = s.paint.get("line-pattern-cross-fade"), Se = he.constantOr(null),
                        Xe = s.paint.get("line-opacity").constantOr(1);
                    let je = !me && Xe !== 1 || u.depthOcclusion && b > 0 && b < 1;
                    const Ke = s.paint.get("line-gradient"), ut = me ? "linePattern" : "line", Fe = o.dY(s);
                    let Te;
                    if (Z && u.terrain && u.terrain.clipOrMaskOverlapStencilType() && (je = !1), b !== 0 && u.depthOcclusion) {
                        const it = s.paint._values["line-opacity"];
                        it && it.value && it.value.kind === "constant" ? Te = it.value : o.w(`Occlusion opacity for layer ${s.id} is supported only when line-opacity isn't data-driven.`)
                    }
                    g.value.kind !== "constant" && g.value.isLineProgressConstant === !1 && Fe.push("VARIABLE_LINE_WIDTH");
                    const $e = (it, rt, gt, Ot, Ut, St) => {
                        for (const Nt of it) {
                            const Ft = t.getTile(Nt);
                            if (me && !Ft.patternsLoaded()) continue;
                            const ri = Ft.getBucket(s);
                            if (!ri || ri.elevationType !== "none" && !Ut || ri.elevationType === "none" && Ut) continue;
                            u.prepareDrawTile();
                            const di = [...rt], Si = u.shadowRenderer,
                                Ui = ri.elevationType === "road" && !!Si && Si.enabled;
                            let ci = [0, 0, 0];
                            if (Ui) {
                                const ji = u.style.directionalLight, Yi = u.style.ambientLight;
                                ji && Yi && (ci = Nl(u.style, ji, Yi)), di.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET")
                            }
                            const Gi = ri.programConfigurations.get(s.id);
                            let qi = !1;
                            if (Se && Ft.imageAtlas) {
                                const ji = o.dZ.from(Se), Yi = ji.getPrimary().scaleSelf(Q).toString(),
                                    hn = Ft.imageAtlas.patternPositions.get(Yi), ir = ji.getSecondary(),
                                    er = ir ? Ft.imageAtlas.patternPositions.get(ir.scaleSelf(Q).toString()) : null;
                                qi = !!hn && !!er, hn && Gi.setConstantPatternPositions(hn, er)
                            }
                            Oe > 0 && (qi || Gi.getPatternTransitionVertexBuffer("line-pattern")) && di.push("LINE_PATTERN_TRANSITION");
                            const pn = u.isTileAffectedByFog(Nt),
                                wi = u.getOrCreateProgram(ut, {config: Gi, defines: di, overrideFog: pn});
                            if (!me && ve && ue && Ft.lineAtlas) {
                                const ji = Ft.lineAtlas.getDash(ve, ue);
                                ji && Gi.setConstantPatternPositions(ji)
                            }
                            Ui && Si.setupShadows(Ft.tileID.toUnwrapped(), wi, "vector-tile");
                            let [$i, Hi] = s.paint.get("line-trim-offset");
                            (ue === "round" || ue === "square") && $i !== Hi && ($i === 0 && ($i -= 1), Hi === 1 && (Hi += 1));
                            const Xi = Z ? Nt.projMatrix : null,
                                Ei = P ? 1 / ri.tileToMeter / o.aw(Ft, 1, u.transform.zoom) : 1,
                                rn = P ? 1 / ri.tileToMeter / o.aw(Ft, 1, Math.floor(u.transform.zoom)) : 1,
                                Wi = me ? o.d_(u, Ft, s, Xi, Q, Ei, rn, [$i, Hi], ci, Oe) : o.d$(u, Ft, s, Xi, ri.lineClipsArray.length, Q, Ei, rn, [$i, Hi], ci);
                            if (Ke) {
                                const ji = ri.gradients[s.id];
                                let Yi = ji.texture;
                                if (s.gradientVersion !== ji.version) {
                                    let hn = 256;
                                    if (s.stepInterpolant) {
                                        const ir = t.getSource().maxzoom,
                                            er = Nt.canonical.z === ir ? Math.ceil(1 << u.transform.maxZoom - Nt.canonical.z) : 1;
                                        hn = o.ay(o.e0(ri.maxLineLength / o.aj * 1024 * er), 256, R.maxTextureSize)
                                    }
                                    ji.gradient = o.e1({
                                        expression: s.gradientExpression(),
                                        evaluationKey: "lineProgress",
                                        resolution: hn,
                                        image: ji.gradient || void 0,
                                        clips: ri.lineClipsArray
                                    }), ji.texture ? ji.texture.update(ji.gradient) : ji.texture = new o.T(R, ji.gradient, O.RGBA8), ji.version = s.gradientVersion, Yi = ji.texture
                                }
                                R.activeTexture.set(O.TEXTURE1), Yi.bind(s.stepInterpolant ? O.NEAREST : O.LINEAR, O.CLAMP_TO_EDGE)
                            }
                            ce && (R.activeTexture.set(O.TEXTURE0), Ft.lineAtlasTexture && Ft.lineAtlasTexture.bind(O.LINEAR, O.REPEAT), Gi.updatePaintBuffers()), me && (R.activeTexture.set(O.TEXTURE0), Ft.imageAtlasTexture && Ft.imageAtlasTexture.bind(O.LINEAR, O.CLAMP_TO_EDGE), Gi.updatePaintBuffers()), Ut && !M && u.terrain.setupElevationDraw(Ft, wi), u.uploadCommonUniforms(R, wi, Nt.toUnwrapped());
                            const kn = ji => {
                                Te != null && (Te.value = Xe * b), wi.draw(u, O.TRIANGLES, gt, ji, U, Yt.disabled, Wi, s.id, ri.layoutVertexBuffer, ri.indexBuffer, ri.segments, s.paint, u.transform.zoom, Gi, [ri.layoutVertexBuffer2, ri.patternVertexBuffer, ri.zOffsetVertexBuffer]), Te != null && (Te.value = Xe)
                            };
                            if (je && !Ut) {
                                const ji = u.stencilModeForClipping(Nt).ref;
                                ji === 0 && Z && R.clear({stencil: 0});
                                const Yi = {func: O.EQUAL, mask: 255};
                                Wi.u_alpha_discard_threshold = .8, kn(new ei(Yi, ji, 255, O.KEEP, O.KEEP, O.INVERT)), Wi.u_alpha_discard_threshold = 0, kn(new ei(Yi, ji, 255, O.KEEP, O.KEEP, O.KEEP))
                            } else Wi.u_alpha_discard_threshold = je && Ut && St ? .8 : 0, kn(Ut ? Ot : u.stencilModeForClipping(Nt))
                        }
                    };
                    let Be = u.depthModeForSublayer(0, It.ReadOnly);
                    const tt = new It(u.depthOcclusion ? O.GREATER : O.LEQUAL, It.ReadOnly, u.depthRangeFor3D);
                    if (s.hasNonElevatedBuckets) {
                        const it = !Z && u.terrain;
                        b !== 0 && it ? o.w(`Occlusion opacity for layer ${s.id} is supported on terrain only if the layer has line-z-offset enabled.`) : it ? o.w(`Cannot render non-elevated lines in immediate mode when terrain is enabled. Layer: ${s.id}.`) : $e(h, Fe, Be, ei.disabled, !1, !0)
                    }
                    if (s.hasElevatedBuckets) {
                        S === "hd-road-markup" ? k || (Be = tt, Fe.push("ELEVATED_ROADS")) : (Fe.push("ELEVATED"), Be = tt, B && Fe.push(G ? "CROSS_SLOPE_HORIZONTAL" : "CROSS_SLOPE_VERTICAL"), M && Fe.push("ELEVATION_REFERENCE_SEA"));
                        const it = je ? u.stencilModeFor3D() : ei.disabled;
                        u.forceTerrainMode = !0, $e(h, Fe, Be, it, !0, !0), je && $e(h, Fe, Be, it, !0, !1), u.forceTerrainMode = !1
                    }
                    je && (u.resetStencilClippingMasks(), Z && R.clear({stencil: 0})), b === 0 || u.depthOcclusion || Z || u.layersWithOcclusionOpacity.push(u.currentLayer)
                }, fill: function (u, t, s, h) {
                    const m = s.paint.get("fill-color"), g = s.paint.get("fill-opacity");
                    if (g.constantOr(1) === 0) return;
                    const v = s.paint.get("fill-emissive-strength"), b = u.colorModeForDrapableLayerRenderPass(v),
                        S = s.paint.get("fill-pattern"),
                        P = u.opaquePassEnabledForLayer() && !S.constantOr(1) && m.constantOr(o.am.transparent).a === 1 && g.constantOr(0) === 1 ? "opaque" : "translucent";
                    let M = "none";
                    s.layout.get("fill-elevation-reference") !== "none" ? M = "road" : s.paint.get("fill-z-offset").constantOr(1) !== 0 && (M = "offset");
                    const k = !(!u.terrain || !u.terrain.enabled), R = {
                        painter: u,
                        sourceCache: t,
                        layer: s,
                        coords: h,
                        colorMode: b,
                        elevationType: M,
                        terrainEnabled: k,
                        pass: P
                    };
                    if (u.renderPass !== "shadow") if (M !== "offset") {
                        if (qd(R, !1), M === "road") {
                            const O = !k && u.renderPass === "translucent";
                            O && Pt(u, t, s, h, "geometry"), qd(R, !0, ei.disabled), O && function (V) {
                                const {painter: B, sourceCache: G, layer: U, coords: Z, colorMode: Q} = V,
                                    te = B.context.gl, ce = V.painter.shadowRenderer, _e = !!ce && ce.enabled,
                                    ve = new It(B.context.gl.LEQUAL, It.ReadOnly, B.depthRangeFor3D);
                                let ue = [0, 0, 0];
                                if (_e) {
                                    const me = B.style.directionalLight, Oe = B.style.ambientLight;
                                    me && Oe && (ue = Nl(B.style, me, Oe))
                                }
                                const he = me => {
                                    for (const Oe of Z) {
                                        const Se = G.getTile(Oe), Xe = Se.getBucket(U);
                                        if (!Xe) continue;
                                        const je = Xe.elevatedStructures;
                                        if (!je) continue;
                                        let Ke, ut;
                                        if (me ? (Ke = je.renderableBridgeSegments, ut = je.bridgeProgramConfigurations.get(U.id)) : (Ke = je.renderableTunnelSegments, ut = je.tunnelProgramConfigurations.get(U.id)), !Ke || Ke.segments[0].primitiveLength === 0) continue;
                                        ut.updatePaintBuffers(), B.prepareDrawTile();
                                        const Fe = B.isTileAffectedByFog(Oe), Te = [];
                                        _e && Te.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET");
                                        const $e = B.getOrCreateProgram("elevatedStructures", {
                                                config: ut,
                                                overrideFog: Fe,
                                                defines: Te
                                            }),
                                            Be = B.translatePosMatrix(Oe.projMatrix, Se, U.paint.get("fill-translate"), U.paint.get("fill-translate-anchor"));
                                        _e && ce.setupShadows(Se.tileID.toUnwrapped(), $e, "vector-tile");
                                        const tt = i1(Be, ue);
                                        B.uploadCommonUniforms(B.context, $e, Oe.toUnwrapped()), $e.draw(B, te.TRIANGLES, ve, ei.disabled, Q, Yt.backCCW, tt, U.id, je.vertexBuffer, je.indexBuffer, Ke, U.paint, B.transform.zoom, ut, [je.vertexBufferNormal])
                                    }
                                };
                                he(!0), he(!1)
                            }(R)
                        }
                    } else qd(R, !1, u.stencilModeFor3D()); else u.shadowRenderer && M === "road" && !k && function (O) {
                        const {painter: V, sourceCache: B, layer: G, coords: U} = O, Z = V.context.gl,
                            Q = O.painter.shadowRenderer;
                        for (const te of U) {
                            const ce = B.getTile(te), _e = ce.getBucket(G);
                            if (!_e) continue;
                            const ve = _e.elevatedStructures;
                            if (!ve || !ve.shadowCasterSegments || ve.shadowCasterSegments.segments[0].primitiveLength === 0) continue;
                            V.prepareDrawTile();
                            const ue = _e.bufferData.programConfigurations.get(G.id), he = V.isTileAffectedByFog(te),
                                me = V.getOrCreateProgram("elevatedStructuresDepth", {config: ue, overrideFog: he}),
                                Oe = Q.calculateShadowPassMatrixFromTile(ce.tileID.toUnwrapped());
                            V.uploadCommonUniforms(V.context, me, te.toUnwrapped());
                            const Se = {u_matrix: Oe, u_depth_bias: 0};
                            me.draw(V, Z.TRIANGLES, Q.getShadowPassDepthMode(), ei.disabled, Q.getShadowPassColorMode(), Yt.disabled, Se, G.id, ve.vertexBuffer, ve.indexBuffer, ve.shadowCasterSegments, G.paint, V.transform.zoom, ue)
                        }
                    }(R)
                }, "fill-extrusion": function (u, t, s, h) {
                    const m = s.paint.get("fill-extrusion-opacity"), g = u.context, v = g.gl, b = u.terrain,
                        S = b && b.renderingToTexture;
                    if (m === 0) return;
                    const P = u.conflationActive && u.style.isLayerClipped(s, t.getSource()),
                        M = u.style.order.indexOf(s.fqid);
                    if (P && function (k, R, O, V, B) {
                        for (const G of V) {
                            const U = R.getTile(G).getBucket(O);
                            U && (U.updateReplacement(G, k.replacementSource, B), U.uploadCentroid(k.context))
                        }
                    }(u, t, s, h, M), b || P) for (const k of h) {
                        const R = t.getTile(k).getBucket(s);
                        R && Qt(u.context, t, k, R, s, b, P)
                    }
                    if (u.renderPass === "shadow" && u.shadowRenderer) {
                        const k = u.shadowRenderer;
                        if (b && m < .65 && s._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof o.ab) return;
                        const R = k.getShadowPassDepthMode(), O = k.getShadowPassColorMode();
                        yh(u, t, s, h, R, ei.disabled, O, P)
                    } else if (u.renderPass === "translucent") {
                        const k = !s.paint.get("fill-extrusion-pattern").constantOr(1),
                            R = s.paint.get("fill-extrusion-color").constantOr(o.am.white);
                        if (!S && R.a !== 0) {
                            const O = new It(u.context.gl.LEQUAL, It.ReadWrite, u.depthRangeFor3D);
                            m === 1 && k ? yh(u, t, s, h, O, ei.disabled, gi.unblended, P) : (yh(u, t, s, h, O, ei.disabled, gi.disabled, P), yh(u, t, s, h, O, u.stencilModeFor3D(), u.colorModeForRenderPass(), P), u.resetStencilClippingMasks())
                        }
                        if (u.style.enable3dLights() && k && (!b && u.transform.projection.name !== "globe" || S)) {
                            const O = s.paint.get("fill-extrusion-opacity"),
                                V = s.paint.get("fill-extrusion-ambient-occlusion-intensity"),
                                B = s.paint.get("fill-extrusion-ambient-occlusion-ground-radius"),
                                G = s.paint.get("fill-extrusion-flood-light-intensity"),
                                U = s.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default") === "none",
                                Z = s.paint.get("fill-extrusion-flood-light-color").toNonPremultipliedRenderColor(U ? null : s.lut).toArray01().slice(0, 3),
                                Q = V > 0 && B > 0, te = G > 0, ce = (ue, he, me) => (1 - me) * ue + me * he,
                                _e = new xa;
                            _e.translate = s.paint.get("fill-extrusion-translate"), _e.translateAnchor = s.paint.get("fill-extrusion-translate-anchor"), _e.edgeRadius = s.layout.get("fill-extrusion-edge-radius"), _e.cutoffFadeRange = s.paint.get("fill-extrusion-cutoff-fade-range");
                            const ve = ue => {
                                const he = u.depthModeForSublayer(1, It.ReadOnly, v.LEQUAL, !0),
                                    me = s.paint.get(ue ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"),
                                    Oe = ce(.1, 3, me), Se = u._showOverdrawInspector;
                                if (!Se) {
                                    const Xe = new ei({func: v.ALWAYS, mask: 255}, 255, 255, v.KEEP, v.KEEP, v.REPLACE),
                                        je = new gi([v.ONE, v.ONE, v.ONE, v.ONE], o.am.transparent, [!1, !1, !1, !0], v.MIN);
                                    Co(_e, u, t, s, h, he, Xe, je, Yt.disabled, ue, "sdf", O, V, B, G, Z, Oe, P, !1)
                                }
                                {
                                    const Xe = Se ? ei.disabled : new ei({
                                            func: v.EQUAL,
                                            mask: 255
                                        }, 255, 255, v.KEEP, v.DECR, v.DECR),
                                        je = Se ? u.colorModeForRenderPass() : new gi([v.ONE_MINUS_DST_ALPHA, v.DST_ALPHA, v.ONE, v.ONE], o.am.transparent, [!0, !0, !0, !0]);
                                    Co(_e, u, t, s, h, he, Xe, je, Yt.disabled, ue, "color", O, V, B, G, Z, Oe, P, !1)
                                }
                            };
                            if (S) {
                                const ue = (he, me, Oe) => {
                                    const Se = u.depthModeForSublayer(1, It.ReadOnly, v.LEQUAL, !1),
                                        Xe = s.paint.get(he ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"),
                                        je = ce(.1, 3, Xe);
                                    {
                                        const Ke = new gi([v.ONE, v.ONE, v.ONE, v.ONE], o.am.transparent, [!1, !1, !1, !0]);
                                        Co(_e, u, t, s, h, Se, ei.disabled, Ke, Yt.disabled, he, "clear", O, V, B, G, Z, je, P, me)
                                    }
                                    {
                                        const Ke = new ei({
                                                func: v.ALWAYS,
                                                mask: 255
                                            }, 255, 255, v.KEEP, v.KEEP, v.REPLACE),
                                            ut = new gi([v.ONE, v.ONE, v.ONE, v.ONE], o.am.transparent, [!1, !1, !1, !0], v.MIN);
                                        Co(_e, u, t, s, h, Se, Ke, ut, Yt.disabled, he, "sdf", O, V, B, G, Z, je, P, me)
                                    }
                                    {
                                        const Ke = he ? v.ZERO : v.ONE_MINUS_DST_ALPHA,
                                            ut = new ei({func: v.EQUAL, mask: 255}, 255, 255, v.KEEP, v.DECR, v.DECR),
                                            Fe = new gi([Ke, v.DST_ALPHA, v.ONE_MINUS_DST_ALPHA, v.ZERO], o.am.transparent, [!0, !0, !0, !0]);
                                        Co(_e, u, t, s, h, Se, ut, Fe, Yt.disabled, he, "color", O, V, B, G, Z, je, P, me)
                                    }
                                    {
                                        const Ke = new gi([v.ONE, v.ONE, v.ONE, he ? v.ZERO : v.ONE], o.am.transparent, [!1, !1, !1, !0], he ? v.FUNC_ADD : v.MAX);
                                        Co(_e, u, t, s, h, Se, ei.disabled, Ke, Yt.disabled, he, "clear", O, V, B, G, Z, je, P, me, Oe)
                                    }
                                };
                                if (Q || te) {
                                    let he;
                                    if (u.prepareDrawTile(), b) {
                                        const me = b.drapeBufferSize[0], Oe = b.drapeBufferSize[1];
                                        he = b.framebufferCopyTexture, he && (!he || he.size[0] === me && he.size[1] === Oe) || (he && he.destroy(), he = b.framebufferCopyTexture = new o.T(g, new o.r({
                                            width: me,
                                            height: Oe
                                        }), v.RGBA8)), he.bind(v.LINEAR, v.CLAMP_TO_EDGE), v.copyTexSubImage2D(v.TEXTURE_2D, 0, 0, 0, 0, 0, me, Oe)
                                    }
                                    Q && ue(!0, !1, he), te && ue(!1, !0, he)
                                }
                            } else Q && ve(!0), te && ve(!1), (Q || te) && u.resetStencilClippingMasks()
                        }
                    }
                }, building: function (u, t, s, h) {
                    u.currentLayer < u.firstLightBeamLayer && (u.firstLightBeamLayer = u.currentLayer);
                    const m = s.paint.get("building-ambient-occlusion-ground-intensity"),
                        g = s.paint.get("building-ambient-occlusion-ground-radius"),
                        v = s.paint.get("building-ambient-occlusion-ground-attenuation");
                    let b = m > 0 && g > 0, S = !0;
                    const P = s.paint.get("building-vertical-scale");
                    P < 1 && (S = !1);
                    const M = u.conflationActive && u.style.isLayerClipped(s, t.getSource()),
                        k = u.style.order.indexOf(s.fqid);
                    if (function (R, O, V, B, G, U) {
                        for (const Z of U) {
                            const Q = O.getTile(Z).getBucket(V);
                            Q && (G && Q.updateReplacement(Z, R.replacementSource, B), Q.uploadUpdatedIndexBuffer(R.context))
                        }
                    }(u, t, s, k, M, h), function (R, O, V, B) {
                        for (const G of B) {
                            const U = O.getTile(G).getBucket(V);
                            U && U.needsEvaluation(R, V) && (U.evaluate(V), U.uploadUpdatedColorBuffer(R.context))
                        }
                    }(u, t, s, h), s.resetLayerRenderingStats(u), u.shadowRenderer && (u.shadowRenderer.useNormalOffset = !0), u.renderPass === "shadow" && u.shadowRenderer) {
                        const R = u.shadowRenderer, O = [], V = R.getShadowPassDepthMode();
                        Zd({
                            painter: u,
                            source: t,
                            layer: s,
                            coords: h,
                            defines: O,
                            blendMode: R.getShadowPassColorMode(),
                            depthMode: V,
                            verticalScale: P
                        })
                    } else if (u.renderPass === "translucent") {
                        b && function (B, G, U, Z, Q, te, ce, _e, ve, ue, he, me, Oe) {
                            const Se = B.context.gl, Xe = B.depthModeForSublayer(1, It.ReadOnly, Se.LEQUAL, !0),
                                je = .1 * (1 - (Ke = he)) + 3 * Ke;
                            var Ke;
                            const ut = B._showOverdrawInspector, Fe = me, Te = new xa;
                            ut || Co(Te, B, G, U, Z, Xe, new ei({
                                func: Se.ALWAYS,
                                mask: 255
                            }, 255, 255, Se.KEEP, Se.KEEP, Se.REPLACE), new gi([Se.ONE, Se.ONE, Se.ONE, Se.ONE], o.am.transparent, [!1, !1, !1, !0], Se.MIN), Yt.disabled, Q, "sdf", 1, ce, _e, 0, ue, je, Fe, !1);
                            {
                                const $e = ut ? ei.disabled : new ei({
                                        func: Se.EQUAL,
                                        mask: 255
                                    }, 255, 255, Se.KEEP, Se.DECR, Se.DECR),
                                    Be = ut ? B.colorModeForRenderPass() : new gi([Se.ONE_MINUS_DST_ALPHA, Se.DST_ALPHA, Se.ONE, Se.ONE], o.am.transparent, [!0, !0, !0, !0]);
                                Co(Te, B, G, U, Z, Xe, $e, Be, Yt.disabled, Q, "color", 1, ce, _e, 0, ue, je, Fe, !1)
                            }
                        }(u, t, s, h, !0, 0, m, g, 0, [0, 0, 0], v, M);
                        let R = ["HAS_ATTRIBUTE_a_part_color_emissive", "LIGHTING_3D_MODE"];
                        S && (R = R.concat("RENDER_SHADOWS", "DEPTH_TEXTURE")), u.shadowRenderer.useNormalOffset && (R = R.concat("NORMAL_OFFSET"));
                        const O = new It(u.context.gl.LEQUAL, It.ReadWrite, u.depthRangeFor3D),
                            V = u.colorModeForRenderPass();
                        Zd({
                            painter: u,
                            source: t,
                            layer: s,
                            coords: h,
                            defines: R,
                            blendMode: V,
                            depthMode: O,
                            verticalScale: P
                        })
                    } else if (u.renderPass === "light-beam") {
                        const R = ["HAS_ATTRIBUTE_a_part_color_emissive", "HAS_ATTRIBUTE_a_bloom_attenuation"],
                            O = new It(u.context.gl.LEQUAL, It.ReadOnly, u.depthRangeFor3D);
                        Zd({
                            painter: u,
                            source: t,
                            layer: s,
                            coords: h,
                            defines: R,
                            blendMode: gi.alphaBlended,
                            depthMode: O,
                            verticalScale: P
                        })
                    }
                    u.shadowRenderer && (u.shadowRenderer.useNormalOffset = !1), u.resetStencilClippingMasks()
                }, hillshade: function (u, t, s, h) {
                    if (u.renderPass !== "offscreen" && u.renderPass !== "translucent" || u.style.disableElevatedTerrain) return;
                    const m = u.context,
                        g = u.terrain && u.terrain.renderingToTexture, [v, b] = u.renderPass !== "translucent" || g ? [{}, h] : u.stencilConfigForOverlap(h);
                    for (const S of b) {
                        const P = t.getTile(S);
                        if (P.needsHillshadePrepare && u.renderPass === "offscreen") Z_(u, P, s); else if (u.renderPass === "translucent") {
                            const M = u.depthModeForSublayer(0, It.ReadOnly),
                                k = s.paint.get("hillshade-emissive-strength"),
                                R = u.colorModeForDrapableLayerRenderPass(k),
                                O = g && u.terrain ? u.terrain.stencilModeForRTTOverlap(S) : v[S.overscaledZ];
                            qx(u, S, P, s, M, O, R)
                        }
                    }
                    m.viewport.set([0, 0, u.width, u.height]), u.resetStencilClippingMasks()
                }, raster: function (u, t, s, h, m, g) {
                    if (u.renderPass !== "translucent" || s.paint.get("raster-opacity") === 0) return;
                    const v = u.transform.projection.name === "globe", b = s.paint.get("raster-elevation") !== 0,
                        S = b && v;
                    if (u.renderElevatedRasterBackface && !S) return;
                    const P = u.context, M = P.gl, k = t.getSource(), R = function (_e, ve, ue, he) {
                        const me = ve.paint.get("raster-color"), Oe = _e.type === "raster-array", Se = [],
                            Xe = ve.paint.get("raster-resampling"), je = ve.paint.get("raster-color-mix");
                        let Ke = ve.paint.get("raster-color-range");
                        const ut = [je[0], je[1], je[2], 0], Fe = je[3];
                        let Te = Xe === "nearest" ? he.NEAREST : he.LINEAR;
                        if (Oe && (Se.push("RASTER_ARRAY"), me || Se.push("RASTER_COLOR"), Xe === "linear" && Se.push("RASTER_ARRAY_LINEAR"), Te = he.NEAREST, !Ke && _e.rasterLayers)) {
                            const $e = _e.rasterLayers.find(({id: Be}) => Be === ve.sourceLayer);
                            $e && $e.fields && $e.fields.range && (Ke = $e.fields.range)
                        }
                        if (Ke = Ke || [0, 1], me) {
                            Se.push("RASTER_COLOR"), ue.activeTexture.set(he.TEXTURE2), ve.updateColorRamp(Ke);
                            let $e = ve.colorRampTexture;
                            $e || ($e = ve.colorRampTexture = new o.T(ue, ve.colorRamp, he.RGBA8)), $e.bind(he.LINEAR, he.CLAMP_TO_EDGE)
                        }
                        return {mix: ut, range: Ke, offset: Fe, defines: Se, resampling: Te}
                    }(k, s, P, M);
                    if (k instanceof o.aP && !h.length && !v) return;
                    const O = s.paint.get("raster-emissive-strength"), V = u.colorModeForDrapableLayerRenderPass(O),
                        B = u.terrain && u.terrain.renderingToTexture, G = !u.options.moving,
                        U = s.paint.get("raster-resampling") === "nearest" ? M.NEAREST : M.LINEAR;
                    if (k instanceof o.aP && !h.length && (k.onNorthPole || k.onSouthPole)) {
                        const _e = b ? u.stencilModeFor3D() : ei.disabled;
                        return void Xd(!!k.onNorthPole, null, u, t, s, O, R, Yt.disabled, _e)
                    }
                    if (!h.length) return;
                    const [Z, Q] = k instanceof o.aP || B ? [{}, h] : u.stencilConfigForOverlap(h),
                        te = Q[Q.length - 1].overscaledZ;
                    S && R.defines.push("PROJECTION_GLOBE_VIEW"), b && R.defines.push("RENDER_CUTOFF");
                    const ce = (_e, ve, ue) => {
                        for (const he of _e) {
                            const me = he.toUnwrapped(), Oe = t.getTile(he);
                            if (B && (!Oe || !Oe.hasData())) continue;
                            P.activeTexture.set(M.TEXTURE0);
                            const Se = s1(Oe, k, s, R);
                            if (!Se || !Se.texture) continue;
                            const {texture: Xe, mix: je, offset: Ke, tileSize: ut, buffer: Fe} = Se;
                            let Te, $e;
                            B ? (Te = It.disabled, $e = he.projMatrix) : b ? (Te = new It(M.LEQUAL, It.ReadWrite, u.depthRangeFor3D), $e = v ? Float32Array.from(u.transform.expandedFarZProjMatrix) : u.transform.calculateProjMatrix(me, G)) : (Te = u.depthModeForSublayer(he.overscaledZ - te, s.paint.get("raster-opacity") === 1 ? It.ReadWrite : It.ReadOnly, M.LESS), $e = u.transform.calculateProjMatrix(me, G));
                            const Be = u.terrain && B ? u.terrain.stencilModeForRTTOverlap(he) : Z[he.overscaledZ],
                                tt = g ? 0 : s.paint.get("raster-fade-duration");
                            Oe.registerFadeDuration(tt);
                            const it = t.findLoadedParent(he, 0), rt = Io(Oe, it, t, u.transform, tt);
                            let gt, Ot;
                            u.terrain && u.terrain.prepareDrawTile(), P.activeTexture.set(M.TEXTURE0), Xe.bind(U, M.CLAMP_TO_EDGE), P.activeTexture.set(M.TEXTURE1), it ? (it.texture && it.texture.bind(U, M.CLAMP_TO_EDGE), gt = Math.pow(2, it.tileID.overscaledZ - Oe.tileID.overscaledZ), Ot = [Oe.tileID.canonical.x * gt % 1, Oe.tileID.canonical.y * gt % 1]) : Xe.bind(U, M.CLAMP_TO_EDGE), "useMipmap" in Xe && P.extTextureFilterAnisotropic && u.transform.pitch > 20 && M.texParameterf(M.TEXTURE_2D, P.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, P.extTextureFilterAnisotropicMax);
                            const Ut = u.transform;
                            let St;
                            const Nt = b ? o1(Ut) : [0, 0, 0, 0];
                            let Ft, ri, di, Si, Ui, ci = 0;
                            if (S && k instanceof o.aP && k.coordinates.length > 3) Ft = Float32Array.from(o.bh(o.dD(new o.cA(0, 0, 0)))), ri = Float32Array.from(Ut.globeMatrix), di = Float32Array.from(o.dz(Ut)), Si = [o.aD(Ut.center.lng), o.aH(Ut.center.lat)], St = k.elevatedGlobePerspectiveTransform, Ui = k.elevatedGlobeGridMatrix || new Float32Array(9); else if (S) {
                                const wi = o.dA(he.canonical);
                                ci = o.dB(wi.getCenter().lat), Ft = Float32Array.from(o.bh(o.dD(he.canonical))), ri = Float32Array.from(Ut.globeMatrix), di = Float32Array.from(o.dz(Ut)), Si = [o.aD(Ut.center.lng), o.aH(Ut.center.lat)], St = [0, 0], Ui = Float32Array.from(o.dC(he.canonical, wi, ci, Ut.worldSize / Ut._pixelsPerMercatorPixel))
                            } else St = k instanceof o.aP ? k.perspectiveTransform : [0, 0], Ft = new Float32Array(16), ri = new Float32Array(9), di = new Float32Array(16), Si = [0, 0], Ui = new Float32Array(9);
                            const Gi = am($e, Ft, ri, di, Ui, Ot || [0, 0], o.ah(u.transform.zoom), Si, Nt, gt || 1, rt, s, St, b ? s.paint.get("raster-elevation") : 0, 2, je, Ke, R.range, ut, Fe, O),
                                qi = u.isTileAffectedByFog(he),
                                pn = u.getOrCreateProgram("raster", {defines: R.defines, overrideFog: qi});
                            if (u.uploadCommonUniforms(P, pn, me), k instanceof o.aP) {
                                const wi = k.elevatedGlobeVertexBuffer, $i = k.elevatedGlobeIndexBuffer;
                                if (B || !v) k.boundsBuffer && k.boundsSegments && pn.draw(u, M.TRIANGLES, Te, ei.disabled, V, Yt.disabled, Gi, s.id, k.boundsBuffer, u.quadTriangleIndexBuffer, k.boundsSegments); else if (wi && $i) {
                                    const Hi = Ut.zoom <= o.cX ? k.elevatedGlobeSegments : k.getSegmentsForLongitude(Ut.center.lng);
                                    Hi && pn.draw(u, M.TRIANGLES, Te, ei.disabled, V, ve, Gi, s.id, wi, $i, Hi)
                                }
                            } else if (S) {
                                Te = new It(M.LEQUAL, It.ReadOnly, u.depthRangeFor3D);
                                const wi = u.globeSharedBuffers;
                                if (wi) {
                                    const [$i, Hi, Xi] = wi.getGridBuffers(ci, !1);
                                    pn.draw(u, M.TRIANGLES, Te, ue || Be, u.colorModeForRenderPass(), ve, Gi, s.id, $i, Hi, Xi)
                                }
                            } else {
                                const {
                                    tileBoundsBuffer: wi,
                                    tileBoundsIndexBuffer: $i,
                                    tileBoundsSegments: Hi
                                } = u.getTileBoundsBuffers(Oe);
                                pn.draw(u, M.TRIANGLES, Te, Be, V, Yt.disabled, Gi, s.id, wi, $i, Hi)
                            }
                        }
                        if (!(k instanceof o.aP) && S) for (const he of _e) {
                            const me = he.canonical.y === (1 << he.canonical.z) - 1;
                            he.canonical.y === 0 && Xd(!0, he, u, t, s, O, R, ve, ue || ei.disabled), me && Xd(!1, he, u, t, s, O, R, ve === Yt.frontCW ? Yt.backCW : Yt.frontCW, ue || ei.disabled)
                        }
                    };
                    S ? ce(Q, u.renderElevatedRasterBackface ? Yt.backCW : Yt.frontCW, u.stencilModeFor3D()) : ce(Q, Yt.disabled, void 0), u.resetStencilClippingMasks()
                }, "raster-particle": function (u, t, s, h, m, g) {
                    u.renderPass === "offscreen" && function (v, b, S, P) {
                        if (!P.length) return;
                        const M = v.context, k = M.gl, R = b.getSource();
                        if (!(R instanceof qa)) return;
                        const O = Math.ceil(Math.sqrt(S.paint.get("raster-particle-count")));
                        let V = S.particlePositionRGBAImage;
                        if (!V || V.width !== O) {
                            const Q = function (te) {
                                const ce = te * te, _e = new Uint8Array(4 * ce), ve = function (he) {
                                    return he |= 0, he = Math.imul(2747636419 ^ he, 2654435769), he = Math.imul(he ^ he >>> 16, 2654435769), ((he = Math.imul(he ^ he >>> 16, 2654435769)) >>> 0) / 4294967296
                                }, ue = 1 / 1.1;
                                for (let he = 0; he < ce; he++) {
                                    const me = ue * (ve(2 * he + 0) + nl), Oe = ue * (ve(2 * he + 1) + nl),
                                        Se = 255 * me % 1, Xe = 255 * Oe % 1, je = Se, Ke = Oe - Xe / 255, ut = Xe;
                                    _e[4 * he + 0] = 255 * (me - Se / 255), _e[4 * he + 1] = 255 * je, _e[4 * he + 2] = 255 * Ke, _e[4 * he + 3] = 255 * ut
                                }
                                return _e
                            }(O);
                            V = S.particlePositionRGBAImage = new o.r({width: O, height: O}, Q)
                        }
                        let B = S.particleFramebuffer;
                        B ? B.width !== O && (B.destroy(), B = S.particleFramebuffer = M.createFramebuffer(O, O, !0, null)) : B = S.particleFramebuffer = M.createFramebuffer(O, O, !0, null);
                        const G = [];
                        for (const Q of P) {
                            const te = b.getTile(Q);
                            if (!(te instanceof gc)) continue;
                            const ce = mo(te, R, S);
                            if (!ce) continue;
                            const _e = [te.tileSize, te.tileSize];
                            let ve = S.tileFramebuffer;
                            ve || (ve = S.tileFramebuffer = M.createFramebuffer(_e[0], _e[1], !0, null));
                            let ue = te.rasterParticleState;
                            ue || (ue = te.rasterParticleState = new gm(M, Q, _e, V));
                            const he = ue.update(S.lastInvalidatedAt);
                            ue.particleTextureDimension !== O && ue.updateParticleTexture(Q, V);
                            const me = ue.targetColorTexture;
                            ue.targetColorTexture = ue.backgroundColorTexture, ue.backgroundColorTexture = me;
                            const Oe = ue.particleTexture0;
                            ue.particleTexture0 = ue.particleTexture1, ue.particleTexture1 = Oe, G.push([Q, ce, ue, he])
                        }
                        if (G.length === 0) return;
                        const U = o.q.now(), Z = S.previousDrawTimestamp ? .001 * (U - S.previousDrawTimestamp) : .0167;
                        if (S.previousDrawTimestamp = U, S.hasColorMap()) {
                            M.activeTexture.set(k.TEXTURE0 + 2);
                            let Q = S.colorRampTexture;
                            Q || (Q = S.colorRampTexture = new o.T(M, S.colorRamp, k.RGBA8)), Q.bind(k.LINEAR, k.CLAMP_TO_EDGE)
                        }
                        M.bindFramebuffer.set(S.tileFramebuffer.framebuffer), function (Q, te, ce) {
                            const _e = Q.context, ve = _e.gl, ue = te.tileFramebuffer;
                            _e.activeTexture.set(ve.TEXTURE0);
                            const he = {
                                u_texture: 0,
                                u_opacity: 1.05 * (Oe = te.paint.get("raster-particle-fade-opacity-factor")) / (Oe + .05)
                            }, me = Q.getOrCreateProgram("rasterParticleTexture", {defines: [], overrideFog: !1});
                            var Oe;
                            for (const Se of ce) {
                                const [, , Xe, je] = Se;
                                ue.colorAttachment.set(Xe.targetColorTexture.texture), _e.viewport.set([0, 0, ue.width, ue.height]), _e.clear({color: o.am.transparent}), je && (Xe.backgroundColorTexture.bind(ve.NEAREST, ve.CLAMP_TO_EDGE), me.draw(Q, ve.TRIANGLES, It.disabled, ei.disabled, gi.alphaBlended, Yt.disabled, he, te.id, Q.viewportBuffer, Q.quadTriangleIndexBuffer, Q.viewportSegments))
                            }
                        }(v, S, G), function (Q, te, ce, _e) {
                            const ve = Q.context, ue = ve.gl, he = ce.tileFramebuffer,
                                me = Q.transform.projection.name === "globe",
                                Oe = ce.paint.get("raster-particle-max-speed");
                            for (const Se of _e) {
                                const [Xe, je, Ke] = Se;
                                ve.activeTexture.set(ue.TEXTURE0 + 0), je.texture.bind(ue.LINEAR, ue.CLAMP_TO_EDGE), he.colorAttachment.set(Ke.targetColorTexture.texture);
                                const ut = Q.getOrCreateProgram("rasterParticleDraw", {
                                    defines: je.defines,
                                    overrideFog: !1
                                });
                                ve.activeTexture.set(ue.TEXTURE0 + 1);
                                const Fe = je.scalarData ? [] : [0, 1, 2, 3].map(Be => o.e3[Be](Xe));
                                Fe.push(Xe);
                                const Te = Xe.canonical.x, $e = Xe.canonical.y;
                                for (const Be of Fe) {
                                    const tt = te.getTile(me ? Be.wrapped() : Be);
                                    if (!tt) continue;
                                    const it = tt.rasterParticleState;
                                    if (!it) continue;
                                    const rt = Be.canonical.x + (1 << Be.canonical.z) * (Be.wrap - Xe.wrap),
                                        gt = Be.canonical.y;
                                    it.particleTexture0.bind(ue.NEAREST, ue.CLAMP_TO_EDGE);
                                    const Ot = hy(1, it.particleTexture0.size[0], [rt - Te, gt - $e], 0, je.texture.size, 2, Oe, je.textureOffset, je.scale, je.offset);
                                    ut.draw(Q, ue.POINTS, It.disabled, ei.disabled, gi.alphaBlended, Yt.disabled, Ot, ce.id, it.particleIndexBuffer, void 0, it.particleSegment)
                                }
                            }
                        }(v, b, S, G), M.bindFramebuffer.set(S.particleFramebuffer.framebuffer), function (Q, te, ce, _e) {
                            const ve = Q.context, ue = ve.gl, he = te.paint.get("raster-particle-max-speed"),
                                me = _e * te.paint.get("raster-particle-speed-factor") * .15, Oe = function (Xe) {
                                    return Math.pow(Xe, 6)
                                }(.01 + 1 * te.paint.get("raster-particle-reset-rate-factor")), Se = te.particleFramebuffer;
                            ve.viewport.set([0, 0, Se.width, Se.height]);
                            for (const Xe of ce) {
                                const [, je, Ke] = Xe;
                                ve.activeTexture.set(ue.TEXTURE0 + 0), je.texture.bind(ue.LINEAR, ue.CLAMP_TO_EDGE), ve.activeTexture.set(ue.TEXTURE0 + 1);
                                const ut = Ke.particleTexture0;
                                ut.bind(ue.NEAREST, ue.CLAMP_TO_EDGE);
                                const Fe = dy(1, ut.size[0], 0, je.texture.size, he, me, Oe, je.textureOffset, je.scale, je.offset);
                                Se.colorAttachment.set(Ke.particleTexture1.texture), ve.clear({color: o.am.transparent}), Q.getOrCreateProgram("rasterParticleUpdate", {defines: je.defines}).draw(Q, ue.TRIANGLES, It.disabled, ei.disabled, gi.unblended, Yt.disabled, Fe, te.id, Q.viewportBuffer, Q.quadTriangleIndexBuffer, Q.viewportSegments)
                            }
                        }(v, S, G, Z)
                    }(u, t, s, h), u.renderPass === "translucent" && (function (v, b, S, P, M) {
                        const k = v.context, R = k.gl, O = b.getSource().tileSize,
                            V = 5 * (1 - o.af(o.cI, o.cI + 1, v.transform.zoom)) * O + S.paint.get("raster-particle-elevation"),
                            B = !v.options.moving, G = v.transform.projection.name === "globe";
                        if (!P.length) return;
                        const [U, Z] = v.stencilConfigForOverlap(P), Q = [];
                        G && Q.push("PROJECTION_GLOBE_VIEW");
                        const te = v.stencilModeFor3D();
                        for (const ce of Z) {
                            const _e = ce.toUnwrapped(), ve = b.getTile(ce);
                            if (!ve.rasterParticleState) continue;
                            const ue = ve.rasterParticleState, he = 100;
                            ve.registerFadeDuration(he);
                            const me = b.findLoadedParent(ce, 0), Oe = Io(ve, me, b, v.transform, he);
                            let Se, Xe;
                            v.terrain && v.terrain.prepareDrawTile(), k.activeTexture.set(R.TEXTURE0), ue.targetColorTexture.bind(R.LINEAR, R.CLAMP_TO_EDGE), k.activeTexture.set(R.TEXTURE1), me && me.rasterParticleState ? (me.rasterParticleState.targetColorTexture.bind(R.LINEAR, R.CLAMP_TO_EDGE), Se = Math.pow(2, me.tileID.overscaledZ - ve.tileID.overscaledZ), Xe = [ve.tileID.canonical.x * Se % 1, ve.tileID.canonical.y * Se % 1]) : ue.targetColorTexture.bind(R.LINEAR, R.CLAMP_TO_EDGE);
                            const je = G ? Float32Array.from(v.transform.expandedFarZProjMatrix) : v.transform.calculateProjMatrix(_e, B),
                                Ke = v.transform, ut = al(Ke), Fe = o.dA(ce.canonical), Te = o.dB(Fe.getCenter().lat);
                            let $e, Be, tt, it, rt;
                            G ? ($e = Float32Array.from(o.bh(o.dD(ce.canonical))), Be = Float32Array.from(Ke.globeMatrix), tt = Float32Array.from(o.dz(Ke)), it = [o.aD(Ke.center.lng), o.aH(Ke.center.lat)], rt = Float32Array.from(o.dC(ce.canonical, Fe, Te, Ke.worldSize / Ke._pixelsPerMercatorPixel))) : ($e = new Float32Array(16), Be = new Float32Array(9), tt = new Float32Array(16), it = [0, 0], rt = new Float32Array(9));
                            const gt = Ud(je, $e, Be, tt, rt, Xe || [0, 0], o.ah(v.transform.zoom), it, ut, Se || 1, Oe, V),
                                Ot = v.isTileAffectedByFog(ce),
                                Ut = v.getOrCreateProgram("rasterParticle", {defines: Q, overrideFog: Ot});
                            if (v.uploadCommonUniforms(k, Ut, _e), G) {
                                const St = new It(R.LEQUAL, It.ReadOnly, v.depthRangeFor3D), Nt = 0,
                                    Ft = v.globeSharedBuffers;
                                if (Ft) {
                                    const [ri, di, Si] = Ft.getGridBuffers(Te, Nt !== 0);
                                    Ut.draw(v, R.TRIANGLES, St, te, gi.alphaBlended, v.renderElevatedRasterBackface ? Yt.frontCCW : Yt.backCCW, gt, S.id, ri, di, Si)
                                }
                            } else {
                                const St = v.depthModeForSublayer(0, It.ReadOnly), Nt = U[ce.overscaledZ], {
                                    tileBoundsBuffer: Ft,
                                    tileBoundsIndexBuffer: ri,
                                    tileBoundsSegments: di
                                } = v.getTileBoundsBuffers(ve);
                                Ut.draw(v, R.TRIANGLES, St, Nt, gi.alphaBlended, Yt.disabled, gt, S.id, Ft, ri, di)
                            }
                        }
                        v.resetStencilClippingMasks()
                    }(u, t, s, h), u.style.map.triggerRepaint())
                }, background: function (u, t, s, h) {
                    const m = s.paint.get("background-color"),
                        g = s.paint.get("background-color-use-theme").constantOr("default") === "none",
                        v = s.paint.get("background-opacity"), b = s.paint.get("background-emissive-strength"),
                        S = s.paint.get("background-pitch-alignment") === "viewport";
                    if (v === 0) return;
                    const P = u.context, M = P.gl, k = u.transform, R = k.tileSize,
                        O = s.paint.get("background-pattern");
                    let V;
                    if (O !== void 0 && (O === null || (V = u.imageManager.getPattern(o.I.from(O.toString()), s.scope, u.style.getLut(s.scope)), !V))) return;
                    const B = !O && m.a === 1 && v === 1 && u.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                    if (u.renderPass !== B) return;
                    const G = ei.disabled, U = u.depthModeForSublayer(0, B === "opaque" ? It.ReadWrite : It.ReadOnly),
                        Z = u.colorModeForDrapableLayerRenderPass(b), Q = O ? "backgroundPattern" : "background";
                    let te, ce = h;
                    if (ce || (te = u.getBackgroundTiles(), ce = Object.values(te).map(_e => _e.tileID)), O && (P.activeTexture.set(M.TEXTURE0), u.imageManager.bind(u.context, s.scope)), S) {
                        const _e = u.getOrCreateProgram(Q, {overrideFog: !1, overrideRtt: !0}),
                            ve = new Float32Array(o.bx([])), ue = new o.aM(0, 0, 0, 0, 0),
                            he = O ? lm(ve, b, v, u, 0, s.scope, V, S, {
                                tileID: ue,
                                tileSize: R
                            }) : fy(ve, b, v, m.toPremultipliedRenderColor(g ? null : s.lut));
                        _e.draw(u, M.TRIANGLES, U, G, Z, Yt.disabled, he, s.id, u.viewportBuffer, u.quadTriangleIndexBuffer, u.viewportSegments)
                    } else for (const _e of ce) {
                        const ve = u.isTileAffectedByFog(_e), ue = u.getOrCreateProgram(Q, {overrideFog: ve}),
                            he = _e.toUnwrapped(), me = h ? _e.projMatrix : u.transform.calculateProjMatrix(he);
                        u.prepareDrawTile();
                        const Oe = t ? t.getTile(_e) : te ? te[_e.key] : new zl(_e, R, k.zoom, u),
                            Se = O ? lm(me, b, v, u, 0, s.scope, V, S, {
                                tileID: _e,
                                tileSize: R
                            }) : fy(me, b, v, m.toPremultipliedRenderColor(g ? null : s.lut));
                        u.uploadCommonUniforms(P, ue, he);
                        const {
                            tileBoundsBuffer: Xe,
                            tileBoundsIndexBuffer: je,
                            tileBoundsSegments: Ke
                        } = u.getTileBoundsBuffers(Oe);
                        ue.draw(u, M.TRIANGLES, U, G, Z, Yt.disabled, Se, s.id, Xe, je, Ke)
                    }
                }, sky: function (u, t, s) {
                    const h = u._atmosphere ? o.ah(u.transform.zoom) : 1, m = s.paint.get("sky-opacity") * h;
                    if (m === 0) return;
                    const g = u.context, v = s.paint.get("sky-type"), b = new It(g.gl.LEQUAL, It.ReadOnly, [0, 1]),
                        S = u.frameCounter / 1e3 % 1;
                    v === "atmosphere" ? u.renderPass === "offscreen" ? s.needsSkyboxCapture(u) && (function (P, M, k, R) {
                        const O = P.context, V = O.gl;
                        let B = M.skyboxFbo;
                        if (!B) {
                            B = M.skyboxFbo = O.createFramebuffer(32, 32, !0, null), M.skyboxGeometry = new Wl(O), M.skyboxTexture = O.gl.createTexture(), V.bindTexture(V.TEXTURE_CUBE_MAP, M.skyboxTexture), V.texParameteri(V.TEXTURE_CUBE_MAP, V.TEXTURE_WRAP_S, V.CLAMP_TO_EDGE), V.texParameteri(V.TEXTURE_CUBE_MAP, V.TEXTURE_WRAP_T, V.CLAMP_TO_EDGE), V.texParameteri(V.TEXTURE_CUBE_MAP, V.TEXTURE_MIN_FILTER, V.LINEAR), V.texParameteri(V.TEXTURE_CUBE_MAP, V.TEXTURE_MAG_FILTER, V.LINEAR);
                            for (let Q = 0; Q < 6; ++Q) V.texImage2D(V.TEXTURE_CUBE_MAP_POSITIVE_X + Q, 0, V.RGBA, 32, 32, 0, V.RGBA, V.UNSIGNED_BYTE, null)
                        }
                        O.bindFramebuffer.set(B.framebuffer), O.viewport.set([0, 0, 32, 32]);
                        const G = M.getCenter(P, !0), U = P.getOrCreateProgram("skyboxCapture"),
                            Z = new Float64Array(16);
                        o.bx(Z), o.eh(Z, Z, .5 * -Math.PI), Bs(P, M, U, Z, G, 0), o.bx(Z), o.eh(Z, Z, .5 * Math.PI), Bs(P, M, U, Z, G, 1), o.bx(Z), o.cR(Z, Z, .5 * -Math.PI), Bs(P, M, U, Z, G, 2), o.bx(Z), o.cR(Z, Z, .5 * Math.PI), Bs(P, M, U, Z, G, 3), o.bx(Z), Bs(P, M, U, Z, G, 4), o.bx(Z), o.eh(Z, Z, Math.PI), Bs(P, M, U, Z, G, 5), O.viewport.set([0, 0, P.width, P.height])
                    }(u, s), s.markSkyboxValid(u)) : u.renderPass === "sky" && function (P, M, k, R, O) {
                        const V = P.context, B = V.gl, G = P.transform, U = P.getOrCreateProgram("skybox");
                        V.activeTexture.set(B.TEXTURE0), B.bindTexture(B.TEXTURE_CUBE_MAP, M.skyboxTexture);
                        const Z = ((Q, te, ce, _e, ve) => ({
                            u_matrix: Q,
                            u_sun_direction: te,
                            u_cubemap: 0,
                            u_opacity: _e,
                            u_temporal_offset: ve
                        }))(G.skyboxMatrix, M.getCenter(P, !1), 0, R, O);
                        P.uploadCommonUniforms(V, U), U.draw(P, B.TRIANGLES, k, ei.disabled, P.colorModeForRenderPass(), Yt.backCW, Z, "skybox", M.skyboxGeometry.vertexBuffer, M.skyboxGeometry.indexBuffer, M.skyboxGeometry.segment)
                    }(u, s, b, m, S) : v === "gradient" && u.renderPass === "sky" && function (P, M, k, R, O) {
                        const V = P.context, B = V.gl, G = P.transform, U = P.getOrCreateProgram("skyboxGradient");
                        M.skyboxGeometry || (M.skyboxGeometry = new Wl(V)), V.activeTexture.set(B.TEXTURE0);
                        let Z = M.colorRampTexture;
                        Z || (Z = M.colorRampTexture = new o.T(V, M.colorRamp, B.RGBA8)), Z.bind(B.LINEAR, B.CLAMP_TO_EDGE);
                        const Q = ((te, ce, _e, ve, ue) => ({
                            u_matrix: te,
                            u_color_ramp: 0,
                            u_center_direction: ce,
                            u_radius: o.al(_e),
                            u_opacity: ve,
                            u_temporal_offset: ue
                        }))(G.skyboxMatrix, M.getCenter(P, !1), M.paint.get("sky-gradient-radius"), R, O);
                        P.uploadCommonUniforms(V, U), U.draw(P, B.TRIANGLES, k, ei.disabled, P.colorModeForRenderPass(), Yt.backCW, Q, "skyboxGradient", M.skyboxGeometry.vertexBuffer, M.skyboxGeometry.indexBuffer, M.skyboxGeometry.segment)
                    }(u, s, b, m, S)
                }, custom: function (u, t, s, h) {
                    const m = u.context, g = s.implementation;
                    if (!u.transform.projection.unsupportedLayers || !u.transform.projection.unsupportedLayers.includes("custom") || u.terrain && (u.terrain.renderingToTexture || u.renderPass === "offscreen") && s.isDraped(t)) {
                        if (u.renderPass === "offscreen") {
                            const v = g.prerender;
                            if (v) {
                                if (u.setCustomLayerDefaults(), m.setColorMode(u.colorModeForRenderPass()), u.transform.projection.name === "globe") {
                                    const b = u.transform.pointMerc;
                                    v.call(g, m.gl, u.transform.customLayerMatrix(), u.transform.getProjection(), u.transform.globeToMercatorMatrix(), o.ah(u.transform.zoom), [b.x, b.y], u.transform.pixelsPerMeterRatio)
                                } else v.call(g, m.gl, u.transform.customLayerMatrix());
                                m.setDirty(), u.setBaseState()
                            }
                        } else if (u.renderPass === "translucent") {
                            if (u.terrain && u.terrain.renderingToTexture) {
                                const b = g.renderToTile;
                                if (b) {
                                    const S = h[0].canonical,
                                        P = {x: S.x + h[0].wrap * (g.wrapTileId ? 0 : 1 << S.z), y: S.y, z: S.z};
                                    m.setDepthMode(It.disabled), m.setStencilMode(ei.disabled), m.setColorMode(u.colorModeForRenderPass()), u.setCustomLayerDefaults(), b.call(g, m.gl, P), m.setDirty(), u.setBaseState()
                                }
                                return
                            }
                            u.setCustomLayerDefaults(), m.setColorMode(u.colorModeForRenderPass()), m.setStencilMode(ei.disabled);
                            const v = g.renderingMode === "3d" ? new It(u.context.gl.LEQUAL, It.ReadWrite, u.depthRangeFor3D) : u.depthModeForSublayer(0, It.ReadOnly);
                            if (m.setDepthMode(v), u.transform.projection.name === "globe") {
                                const b = u.transform.pointMerc;
                                g.render(m.gl, u.transform.customLayerMatrix(), u.transform.getProjection(), u.transform.globeToMercatorMatrix(), o.ah(u.transform.zoom), [b.x, b.y], u.transform.pixelsPerMeterRatio)
                            } else g.render(m.gl, u.transform.customLayerMatrix());
                            m.setDirty(), u.setBaseState(), m.bindFramebuffer.set(null)
                        }
                    } else o.w("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.")
                }, model: function (u, t, s, h) {
                    if (u.renderPass === "opaque") return;
                    const m = s.paint.get("model-opacity").constantOr(1);
                    if (m === 0) return;
                    const g = s.paint.get("model-cast-shadows");
                    if (u.renderPass === "shadow" && (!g || u.terrain && m < .65 && s._transitionablePaint._values["model-opacity"].value.expression instanceof o.ab)) return;
                    const v = u.shadowRenderer, b = s.paint.get("model-receive-shadows");
                    v && (v.useNormalOffset = !0, b || (v.enabled = !1));
                    const S = () => {
                        v && (v.useNormalOffset = !0, b || (v.enabled = !0))
                    }, P = t.getSource();
                    if (u.renderPass === "light-beam" && P.type !== "batched-model") return;
                    if (P.type === "vector" || P.type === "geojson") return function (U, Z, Q, te, ce) {
                        const _e = U.transform;
                        if (_e.projection.name !== "mercator") return void o.w(`Drawing 3D models for ${_e.projection.name} projection is not yet implemented`);
                        const ve = _e.getFreeCameraOptions().position;
                        if (!U.modelManager) return;
                        const ue = U.modelManager;
                        Q.modelManager = ue;
                        const he = U.shadowRenderer;
                        if (!Q._unevaluatedLayout._values.hasOwnProperty("model-id")) return;
                        const me = Q._unevaluatedLayout._values["model-id"],
                            Oe = Object.assign({}, Q.layout.get("model-id").parameters),
                            Se = U.style.order.indexOf(Q.fqid);
                        for (const Xe of te) {
                            const je = Z.getTile(Xe).getBucket(Q);
                            if (!je || je.projection.name !== _e.projection.name) continue;
                            const Ke = je.getModelUris();
                            Ke && !je.modelsRequested && (ue.addModelsFromBucket(Ke, ce), je.modelsRequested = !0);
                            const ut = a1(Xe, _e);
                            Oe.zoom = ut;
                            const Fe = me.possiblyEvaluate(Oe);
                            if (Nc(U, je, Xe), Js.shadowUniformsInitialized = !1, Js.useSingleShadowCascade = !!he && he.getMaxCascadeForTile(Xe.toUnwrapped()) === 0, U.renderPass === "shadow" && he) {
                                if (U.currentShadowCascade === 1 && je.isInsideFirstShadowMapFrustum) continue;
                                const Be = _e.calculatePosMatrix(Xe.toUnwrapped(), _e.worldSize);
                                if (Js.tileMatrix.set(Be), Js.shadowTileMatrix = Float32Array.from(he.calculateShadowPassMatrixFromMatrix(Be)), Js.aabb.min.fill(0), Js.aabb.max[0] = Js.aabb.max[1] = o.aj, Js.aabb.max[2] = 0, bm(je, Js, U, Q.scope)) continue
                            }
                            const Te = 1 << Xe.canonical.z,
                                $e = [((ve.x - Xe.wrap) * Te - Xe.canonical.x) * o.aj, (ve.y * Te - Xe.canonical.y) * o.aj, ve.z * Te * o.aj];
                            U.conflationActive && Object.keys(je.instancesPerModel).length > 0 && U.style.isLayerClipped(Q, Z.getSource()) && je.updateReplacement(Xe, U.replacementSource, Se, ce) && (je.uploaded = !1, je.upload(U.context));
                            for (let Be in je.instancesPerModel) {
                                const tt = je.instancesPerModel[Be];
                                tt.features.length > 0 && (Be = Fe.evaluate(tt.features[0].feature, {}));
                                const it = ue.getModel(Be, ce);
                                if (it || ue.hasURLBeenRequested(Be) || je.modelUris.includes(Be) || (je.modelUris.push(Be), je.modelsRequested = !1), it && it.uploaded) for (const rt of it.nodes) wm(U, Q, rt, tt, $e, Xe, Js)
                            }
                        }
                    }(u, t, s, h, P.type === "vector" ? s.scope : ""), void S();
                    if (!P.loaded()) return;
                    if (P.type === "batched-model") return function (U, Z, Q, te) {
                        Q.resetLayerRenderingStats(U);
                        const ce = U.context, _e = U.transform, ve = U.style.fog, ue = U.shadowRenderer;
                        if (_e.projection.name !== "mercator") return void o.w(`Drawing 3D landmark models for ${_e.projection.name} projection is not yet implemented`);
                        const he = U.transform.getFreeCameraOptions().position,
                            me = o.c1([], [he.x, he.y, he.z], U.transform.worldSize), Oe = o.eq([], me), Se = o.bx([]),
                            Xe = o.e9(_e.center.lat, _e.zoom), je = o.bn([], [1, 1, 1 / Xe]);
                        o.bo(Se, Se, Oe);
                        const Ke = Q.paint.get("model-opacity").constantOr(1),
                            ut = new It(ce.gl.LEQUAL, It.ReadWrite, U.depthRangeFor3D),
                            Fe = new It(ce.gl.LEQUAL, It.ReadOnly, U.depthRangeFor3D),
                            Te = new o.d6([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]),
                            $e = U.renderPass === "shadow",
                            Be = $e && ue ? ue.getCurrentCascadeFrustum() : _e.getFrustum(_e.scaleZoom(_e.worldSize)),
                            tt = Q.paint.get("model-front-cutoff"), it = tt[2] < 1,
                            rt = Ks(U, Q.paint.get("model-cutoff-fade-range")), gt = Q.getLayerRenderingStats();
                        (function (Ot, Ut, St, Nt) {
                            const Ft = Ot.terrain ? Ot.terrain.exaggeration() : 0, ri = Ot.transform.zoom;
                            for (const di of Nt) {
                                const Si = Ut.getTile(di).getBucket(St);
                                Si && (Si.setFilter(St.filter), Ot.conflationActive && Si.updateReplacement(di, Ot.replacementSource), Si.evaluateTransform(Ot, St), Ot.terrain && Ft > 0 && Si.elevationUpdate(Ot.terrain, Ft, di, St.source), Si.needsReEvaluation(Ot, ri, St) && Si.evaluate(St))
                            }
                        })(U, Z, Q, te), function () {
                            let Ot, Ut, St;
                            it ? (Ot = te.length - 1, Ut = -1, St = -1) : (Ot = 0, Ut = te.length, St = 1);
                            const Nt = new Float64Array(16), Ft = o.cx(), ri = new o.P(0, 0);
                            for (let di = Ot; di !== Ut; di += St) {
                                const Si = te[di], Ui = Z.getTile(Si).getBucket(Q);
                                if (!Ui || !Ui.uploaded) continue;
                                let ci = !1;
                                ue && (ci = ue.getMaxCascadeForTile(Si.toUnwrapped()) === 0);
                                const Gi = _e.calculatePosMatrix(Si.toUnwrapped(), _e.worldSize), qi = Ui.modelTraits;
                                !$e && it && (o.bi(Nt, Gi), o.ad(Ft, me, Nt), ri.x = Ft[0], ri.y = Ft[1]);
                                const pn = [];
                                Ui.setFilter(Q.filter);
                                for (const wi of Ui.getNodesInfo()) {
                                    if (wi.hiddenByReplacement || !wi.node.meshes) continue;
                                    const $i = wi.node;
                                    let Hi = 0;
                                    U.terrain && $i.elevation && (Hi = $i.elevation * U.terrain.exaggeration());
                                    const Xi = (() => {
                                        const Rr = wi.aabb;
                                        return Te.min = [...Rr.min], Te.max = [...Rr.max], Te.min[2] += Hi, Te.max[2] += Hi, o.ad(Te.min, Te.min, Gi), o.ad(Te.max, Te.max, Gi), Te
                                    })(), Ei = wi.evaluatedScale;
                                    if (Ei[0] <= 1 && Ei[1] <= 1 && Ei[2] <= 1 && Xi.intersects(Be) === 0) continue;
                                    if (!$e && it) {
                                        const Rr = .16666666666666666;
                                        wi.cameraCollisionOpacity = me[0] > Xi.min[0] && me[0] < Xi.max[0] && me[1] > Xi.min[1] && me[1] < Xi.max[1] && me[2] * Xe < Xi.max[2] && $i.footprint && o.bY(ri, $i.footprint) ? Math.max(wi.cameraCollisionOpacity - Rr, 0) : Math.min(1, wi.cameraCollisionOpacity + Rr)
                                    }
                                    const rn = [...Gi], Wi = 1 / o.d4(Si.canonical), kn = $i.anchor ? $i.anchor[0] : 0,
                                        ji = $i.anchor ? $i.anchor[1] : 0;
                                    o.bo(rn, rn, [kn * (Ei[0] - 1) + wi.evaluatedTranslation[0] * Wi, ji * (Ei[1] - 1) + wi.evaluatedTranslation[1] * Wi, Hi + wi.evaluatedTranslation[2]]), o.cn(Ei, o.es) || o.cP(rn, rn, Ei);
                                    const Yi = o.az([], rn, $i.matrix), hn = o.az([], _e.expandedFarZProjMatrix, Yi),
                                        ir = o.az([], _e.expandedFarZProjMatrix, rn),
                                        er = o.aA([], [kn, ji, Hi, 1], hn)[2];
                                    $i.hidden = !1;
                                    let rr = Ke;
                                    $e || (it && (rr *= wi.cameraCollisionOpacity, rr *= Sy(rn, _e, wi.aabb, tt)), rr *= Ty(rt, er)), rr !== 0 ? pn.push({
                                        nodeInfo: wi,
                                        depth: er,
                                        opacity: rr,
                                        wvpForNode: hn,
                                        wvpForTile: ir,
                                        nodeModelMatrix: Yi,
                                        tileModelMatrix: rn
                                    }) : $i.hidden = !0
                                }
                                $e || pn.sort((wi, $i) => !it || wi.opacity === 1 && $i.opacity === 1 ? wi.depth < $i.depth ? -1 : 1 : wi.opacity === 1 ? -1 : $i.opacity === 1 ? 1 : wi.depth > $i.depth ? -1 : 1);
                                for (const wi of pn) {
                                    const $i = wi.nodeInfo, Hi = $i.node;
                                    let Xi = o.az([], je, wi.tileModelMatrix);
                                    o.az(Xi, Se, Xi);
                                    const Ei = o.bi([], Xi);
                                    o.ea(Ei, Ei), o.cP(Ei, Ei, Qd), Xi = o.az(Xi, Xi, Hi.matrix);
                                    const rn = U.renderPass === "light-beam",
                                        Wi = Q.paint.get("model-color-use-theme").constantOr("default") === "none",
                                        kn = qi & o.ex.HasMapboxMeshFeatures, ji = kn ? 0 : $i.evaluatedRMEA[0][2];
                                    for (let Yi = 0; Yi < Hi.meshes.length; ++Yi) {
                                        const hn = Hi.meshes[Yi], ir = Yi === Hi.lightMeshIndex;
                                        let er = wi.wvpForNode;
                                        if (ir) {
                                            if (!rn && !U.terrain && U.shadowRenderer) {
                                                U.currentLayer < U.firstLightBeamLayer && (U.firstLightBeamLayer = U.currentLayer);
                                                continue
                                            }
                                            er = wi.wvpForTile
                                        } else if (rn) continue;
                                        const rr = {defines: []}, Rr = [];
                                        if (!$e && ue && (ue.useNormalOffset = !!hn.normalBuffer), bh(rr.defines, Rr, hn, U, Wi ? null : Q.lut), kn || rr.defines.push("DIFFUSE_SHADED"), ci && rr.defines.push("SHADOWS_SINGLE_CASCADE"), gt && ($e ? gt.numRenderedVerticesInShadowPass += hn.vertexArray.length : gt.numRenderedVerticesInTransparentPass += hn.vertexArray.length), $e) {
                                            Kd(hn, wi.nodeModelMatrix, U, Q);
                                            continue
                                        }
                                        let Ns = null;
                                        if (ve) {
                                            const Gr = wh(wi.nodeModelMatrix, U.transform);
                                            if (Ns = new Float32Array(Gr), _e.projection.name !== "globe") {
                                                const Yn = hn.aabb.min,
                                                    Un = hn.aabb.max, [gn, ur] = ve.getOpacityForBounds(Gr, Yn[0], Yn[1], Un[0], Un[1]);
                                                rr.overrideFog = gn >= Je || ur >= Je
                                            }
                                        }
                                        const _o = hn.material;
                                        let Fo;
                                        _o.occlusionTexture && _o.occlusionTexture.offsetScale && (Fo = _o.occlusionTexture.offsetScale, rr.defines.push("OCCLUSION_TEXTURE_TRANSFORM"));
                                        const Ur = U.getOrCreateProgram("model", rr);
                                        !$e && ue && ue.setupShadowsFromMatrix(wi.tileModelMatrix, Ur, ue.useNormalOffset), U.uploadCommonUniforms(ce, Ur, null, Ns);
                                        const ts = _o.pbrMetallicRoughness;
                                        ts.metallicFactor = .9, ts.roughnessFactor = .5;
                                        const Ss = cm(new Float32Array(er), new Float32Array(Xi), new Float32Array(Ei), new Float32Array(Hi.matrix), U, wi.opacity, ts.baseColorFactor, _o.emissiveFactor, ts.metallicFactor, ts.roughnessFactor, _o, ji, Q, [0, 0, 0], Fo);
                                        !ir && ($i.hasTranslucentParts || wi.opacity < 1) && Ur.draw(U, ce.gl.TRIANGLES, ut, ei.disabled, gi.disabled, Yt.backCCW, Ss, Q.id, hn.vertexBuffer, hn.indexBuffer, hn.segments, Q.paint, U.transform.zoom, void 0, Rr), Ur.draw(U, ce.gl.TRIANGLES, ir ? Fe : ut, ei.disabled, ir || wi.opacity < 1 || $i.hasTranslucentParts ? gi.alphaBlended : gi.unblended, Yt.backCCW, Ss, Q.id, hn.vertexBuffer, hn.indexBuffer, hn.segments, Q.paint, U.transform.zoom, void 0, Rr)
                                    }
                                }
                            }
                        }()
                    }(u, t, s, h), void S();
                    if (P.type !== "model") return;
                    const M = P.getModels(), k = [], R = u.transform.getFreeCameraOptions().position,
                        O = o.c1([], [R.x, R.y, R.z], u.transform.worldSize);
                    o.eq(O, O);
                    const V = [], B = [];
                    let G = 0;
                    for (const U of M) {
                        const Z = s.paint.get("model-rotation").constantOr(null),
                            Q = s.paint.get("model-scale").constantOr(null),
                            te = s.paint.get("model-translation").constantOr(null);
                        U.computeModelMatrix(u, Z, Q, te, !0, !0, !1);
                        const ce = o.bx([]), _e = o.e9(U.position.lat, u.transform.zoom), ve = o.bn([], [1, 1, 1 / _e]);
                        o.bo(ce, ce, O), k.push({zScaleMatrix: ve, negCameraPosMatrix: ce});
                        for (const ue of U.nodes) xm(u.transform, ue, U.matrix, u.transform.expandedFarZProjMatrix, G, V, B);
                        G++
                    }
                    if (V.sort((U, Z) => Z.depth - U.depth), u.renderPass !== "shadow") {
                        if (m === 1) for (const U of B) Bc(U, u, s, k[U.modelIndex], ei.disabled, u.colorModeForRenderPass()); else {
                            for (const U of B) Bc(U, u, s, k[U.modelIndex], ei.disabled, gi.disabled);
                            for (const U of B) Bc(U, u, s, k[U.modelIndex], u.stencilModeFor3D(), u.colorModeForRenderPass());
                            u.resetStencilClippingMasks()
                        }
                        for (const U of V) Bc(U, u, s, k[U.modelIndex], ei.disabled, u.colorModeForRenderPass());
                        S()
                    } else {
                        for (const U of B) Kd(U.mesh, U.nodeModelMatrix, u, s);
                        for (const U of V) Kd(U.mesh, U.nodeModelMatrix, u, s);
                        S()
                    }
                }
            }, ef = {
                line: function (u, t, s) {
                    if (u.hasElevatedBuckets = !1, u.hasNonElevatedBuckets = !1, u._unevaluatedLayout.getValue("line-elevation-reference") !== void 0 || u._unevaluatedLayout.getValue("line-z-offset") !== void 0) {
                        if (t) {
                            const h = t.getVisibleCoordinates();
                            for (const m of h) {
                                const g = t.getTile(m).getBucket(u);
                                if (g && (g.elevationType !== "none" ? u.hasElevatedBuckets = !0 : u.hasNonElevatedBuckets = !0, u.hasElevatedBuckets && u.hasNonElevatedBuckets)) break
                            }
                        }
                    } else u.hasNonElevatedBuckets = !0
                }, model: function (u, t, s) {
                    const h = t.getSource();
                    if (!h.loaded()) return;
                    if (h.type === "vector" || h.type === "geojson") return void (s.modelManager && s.modelManager.upload(s, h.type === "vector" ? u.scope : ""));
                    if (h.type === "batched-model" || h.type !== "model") return;
                    const m = h.getModels();
                    for (const g of m) g.upload(s.context)
                }, raster: function (u, t, s) {
                    const h = t.getSource();
                    if (!(h instanceof qa && h.loaded())) return;
                    const m = u.sourceLayer || h.rasterLayerIds && h.rasterLayerIds[0];
                    if (!m) return;
                    const g = u.paint.get("raster-array-band") || h.getInitialBand(m);
                    if (g == null) return;
                    const v = t.getIds().map(b => t.getTileByID(b));
                    for (const b of v) b.updateNeeded(u.id, g) && h.prepareTile(b, m, u.id, g)
                }, "raster-particle": function (u, t, s) {
                    const h = t.getSource();
                    if (!(h instanceof qa && h.loaded())) return;
                    const m = u.sourceLayer || h.rasterLayerIds && h.rasterLayerIds[0];
                    if (!m) return;
                    const g = u.paint.get("raster-particle-array-band") || h.getInitialBand(m);
                    if (g == null) return;
                    const v = t.getIds().map(b => t.getTileByID(b));
                    for (const b of v) b.updateNeeded(u.id, g) && h.prepareTile(b, m, u.id, g)
                }
            }, tf = {fill: Pt}, Qo = {
                fill: function (u, t, s, h) {
                    if (!s.layout || s.layout.get("fill-elevation-reference") === "none") return;
                    const m = u.context.gl, g = new It(m.LEQUAL, It.ReadOnly, u.depthRangeFor3D),
                        v = new ei({func: m.ALWAYS, mask: 255}, 255, 255, m.KEEP, m.KEEP, m.REPLACE),
                        b = u.transform.getFreeCameraOptions().position,
                        S = u.getOrCreateProgram("elevatedStructuresDepthReconstruct");
                    for (const P of h) {
                        const M = t.getTile(P), k = M.getBucket(s);
                        if (!k) continue;
                        const R = k.elevatedStructures;
                        if (!R || R.depthSegments.segments[0].primitiveLength === 0) continue;
                        const O = _h(P.toUnwrapped(), b),
                            V = u.translatePosMatrix(P.projMatrix, M, s.paint.get("fill-translate"), s.paint.get("fill-translate-anchor")),
                            B = jd(V, O, 0, 1, 0);
                        S.draw(u, m.TRIANGLES, g, v, gi.disabled, Yt.disabled, B, s.id, R.vertexBuffer, R.indexBuffer, R.depthSegments, s.paint, u.transform.zoom)
                    }
                }
            };

            class cl {
                constructor(t, s, h, m, g, v) {
                    this.context = new Hd(t, s), this.transform = h, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.tp = g, this._timeStamp = o.q.now(), this._averageFPS = 0, this._fpsHistory = [], this._dt = 0, this._debugParams = {
                        forceEnablePrecipitation: !1,
                        showTerrainProxyTiles: !1,
                        fpsWindow: 30,
                        continousRedraw: !1,
                        enabledLayers: {}
                    };
                    const b = ["fill", "line", "symbol", "circle", "heatmap", "fill-extrusion", "building", "raster", "raster-particle", "hillshade", "model", "background", "sky"];
                    for (const P of b) this._debugParams.enabledLayers[P] = !0;
                    g.registerParameter(this._debugParams, ["Terrain"], "showTerrainProxyTiles", {}, () => {
                        this.style.map.triggerRepaint()
                    }), g.registerParameter(this._debugParams, ["Precipitation"], "forceEnablePrecipitation"), g.registerParameter(this._debugParams, ["FPS"], "fpsWindow", {
                        min: 1,
                        max: 100,
                        step: 1
                    }), g.registerBinding(this._debugParams, ["FPS"], "continousRedraw", {
                        readonly: !0,
                        label: "continuous redraw"
                    }), g.registerBinding(this, ["FPS"], "_averageFPS", {
                        readonly: !0,
                        label: "value"
                    }), g.registerBinding(this, ["FPS"], "_averageFPS", {
                        readonly: !0,
                        label: "graph",
                        view: "graph",
                        min: 0,
                        max: 200
                    });
                    for (const P of b) g.registerParameter(this._debugParams.enabledLayers, ["Debug", "Layers"], P);
                    this.occlusionParams = new jc(g), this.setup(), this.numSublayers = Eo.maxUnderzooming + Eo.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = !1, this.replacementSource = new o.eE, this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = !1, this._cachedTileFogOpacities = {}, this._shadowRenderer = new Ux(this), this._wireframeDebugCache = new Th, this.renderDefaultNorthPole = !0, this.renderDefaultSouthPole = !0, this.layersWithOcclusionOpacity = [];
                    const S = new o.r({width: 1, height: 1}, Uint8Array.of(0, 0, 0, 0));
                    this.emptyDepthTexture = new o.T(this.context, S, t.RGBA8), this._clippingActiveLastFrame = !1, this.scaleFactor = m, this.worldview = v
                }

                updateTerrain(t, s) {
                    const h = !!t && !!t.terrain && this.transform.projection.supportsTerrain;
                    if (!(h || this._terrain && this._terrain.enabled)) return;
                    this._terrain || (this._terrain = new Od(this, t));
                    const m = this._terrain;
                    this.transform.elevation = h ? m : null, m.update(t, this.transform, s), this.transform.elevation && !m.enabled && (this.transform.elevation = null)
                }

                _updateFog(t) {
                    const s = t.fog;
                    if (!s || this.transform.projection.name === "globe" || s.getOpacity(this.transform.pitch) < 1 || s.properties.get("horizon-blend") < .03) return void (this.transform.fogCullDistSq = null);
                    const [h, m] = s.getFovAdjustedRange(this.transform._fov);
                    if (h > m) return void (this.transform.fogCullDistSq = null);
                    const g = h + .78 * (m - h);
                    this.transform.fogCullDistSq = g * g
                }

                get terrain() {
                    return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled || this._forceTerrainMode ? this._terrain : null
                }

                get forceTerrainMode() {
                    return this._forceTerrainMode
                }

                set forceTerrainMode(t) {
                    t && !this._terrain && (this._terrain = new Od(this, this.style)), this._forceTerrainMode = t
                }

                get shadowRenderer() {
                    return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null
                }

                get wireframeDebugCache() {
                    return this._wireframeDebugCache
                }

                resize(t, s) {
                    if (this.width = t * o.q.devicePixelRatio, this.height = s * o.q.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const h of this.style.order) this.style._mergedLayers[h].resize()
                }

                setup() {
                    const t = this.context, s = new o.ba;
                    s.emplaceBack(0, 0), s.emplaceBack(o.aj, 0), s.emplaceBack(0, o.aj), s.emplaceBack(o.aj, o.aj), this.tileExtentBuffer = t.createVertexBuffer(s, o.bc.members), this.tileExtentSegments = o.bd.simpleSegment(0, 0, 4, 2);
                    const h = new o.ba;
                    h.emplaceBack(0, 0), h.emplaceBack(o.aj, 0), h.emplaceBack(0, o.aj), h.emplaceBack(o.aj, o.aj), this.debugBuffer = t.createVertexBuffer(h, o.bc.members), this.debugSegments = o.bd.simpleSegment(0, 0, 4, 5);
                    const m = new o.ba;
                    m.emplaceBack(-1, -1), m.emplaceBack(1, -1), m.emplaceBack(-1, 1), m.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(m, o.bc.members), this.viewportSegments = o.bd.simpleSegment(0, 0, 4, 2);
                    const g = new o.aZ;
                    g.emplaceBack(0, 0, 0, 0), g.emplaceBack(o.aj, 0, o.aj, 0), g.emplaceBack(0, o.aj, 0, o.aj), g.emplaceBack(o.aj, o.aj, o.aj, o.aj), this.mercatorBoundsBuffer = t.createVertexBuffer(g, o.bf.members), this.mercatorBoundsSegments = o.bd.simpleSegment(0, 0, 4, 2);
                    const v = new o.a_;
                    v.emplaceBack(0, 1, 2), v.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(v);
                    const b = new o.bb;
                    for (const P of [0, 1, 3, 2, 0]) b.emplaceBack(P);
                    this.debugIndexBuffer = t.createIndexBuffer(b), this.emptyTexture = new o.T(t, new o.r({
                        width: 1,
                        height: 1
                    }, Uint8Array.of(0, 0, 0, 0)), t.gl.RGBA8), this.identityMat = o.bz();
                    const S = this.context.gl;
                    this.stencilClearMode = new ei({
                        func: S.ALWAYS,
                        mask: 0
                    }, 0, 255, S.ZERO, S.ZERO, S.ZERO), this.loadTimeStamps.push(performance.now())
                }

                getMercatorTileBoundsBuffers() {
                    return {
                        tileBoundsBuffer: this.mercatorBoundsBuffer,
                        tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,
                        tileBoundsSegments: this.mercatorBoundsSegments
                    }
                }

                getTileBoundsBuffers(t) {
                    return t._makeTileBoundsBuffers(this.context, this.transform.projection), t._tileBoundsBuffer ? {
                        tileBoundsBuffer: t._tileBoundsBuffer,
                        tileBoundsIndexBuffer: t._tileBoundsIndexBuffer,
                        tileBoundsSegments: t._tileBoundsSegments
                    } : this.getMercatorTileBoundsBuffers()
                }

                clearStencil() {
                    const t = this.context.gl;
                    this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram("clippingMask").draw(this, t.TRIANGLES, It.disabled, this.stencilClearMode, gi.disabled, Yt.disabled, Ld(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
                }

                resetStencilClippingMasks() {
                    this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {})
                }

                _renderTileClippingMasks(t, s, h) {
                    if (!s || this.currentStencilSource === s.id || !t.isTileClipped() || !h || h.length === 0) return;
                    if (this._tileClippingMaskIDs && !this.terrain) {
                        let b = !1;
                        for (const S of h) if (this._tileClippingMaskIDs[S.key] === void 0) {
                            b = !0;
                            break
                        }
                        if (!b) return
                    }
                    this.currentStencilSource = s.id;
                    const m = this.context, g = m.gl;
                    this.nextStencilID + h.length > 256 && this.clearStencil(), m.setColorMode(gi.disabled), m.setDepthMode(It.disabled);
                    const v = this.getOrCreateProgram("clippingMask");
                    this._tileClippingMaskIDs = {};
                    for (const b of h) {
                        const S = s.getTile(b), P = this._tileClippingMaskIDs[b.key] = this.nextStencilID++, {
                            tileBoundsBuffer: M,
                            tileBoundsIndexBuffer: k,
                            tileBoundsSegments: R
                        } = this.getTileBoundsBuffers(S);
                        v.draw(this, g.TRIANGLES, It.disabled, new ei({
                            func: g.ALWAYS,
                            mask: 0
                        }, P, 255, g.KEEP, g.KEEP, g.REPLACE), gi.disabled, Yt.disabled, Ld(b.projMatrix), "$clipping", M, k, R)
                    }
                }

                stencilModeFor3D() {
                    this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
                    const t = this.nextStencilID++, s = this.context.gl;
                    return new ei({func: s.NOTEQUAL, mask: 255}, t, 255, s.KEEP, s.KEEP, s.REPLACE)
                }

                stencilModeForClipping(t) {
                    if (this.terrain) return this.terrain.stencilModeForRTTOverlap(t);
                    const s = this.context.gl;
                    return new ei({
                        func: s.EQUAL,
                        mask: 255
                    }, this._tileClippingMaskIDs[t.key], 0, s.KEEP, s.KEEP, s.REPLACE)
                }

                stencilConfigForOverlap(t) {
                    const s = this.context.gl, h = t.sort((v, b) => b.overscaledZ - v.overscaledZ),
                        m = h[h.length - 1].overscaledZ, g = h[0].overscaledZ - m + 1;
                    if (g > 1) {
                        this.currentStencilSource = void 0, this.nextStencilID + g > 256 && this.clearStencil();
                        const v = {};
                        for (let b = 0; b < g; b++) v[b + m] = new ei({
                            func: s.GEQUAL,
                            mask: 255
                        }, b + this.nextStencilID, 255, s.KEEP, s.KEEP, s.REPLACE);
                        return this.nextStencilID += g, [v, h]
                    }
                    return [{[m]: ei.disabled}, h]
                }

                colorModeForRenderPass() {
                    const t = this.context.gl;
                    return this._showOverdrawInspector ? new gi([t.CONSTANT_COLOR, t.ONE, t.CONSTANT_COLOR, t.ONE], new o.am(.125, .125, .125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? gi.unblended : gi.alphaBlended
                }

                colorModeForDrapableLayerRenderPass(t) {
                    const s = this.context.gl;
                    return this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture && this.renderPass === "translucent" ? new gi([s.ONE, s.ONE_MINUS_SRC_ALPHA, s.CONSTANT_ALPHA, s.ONE_MINUS_SRC_ALPHA], new o.am(0, 0, 0, t === void 0 ? 0 : t), [!0, !0, !0, !0]) : this.colorModeForRenderPass()
                }

                depthModeForSublayer(t, s, h, m = !1) {
                    if (this.depthOcclusion) return new It(this.context.gl.GREATER, It.ReadOnly, this.depthRangeFor3D);
                    if (!this.opaquePassEnabledForLayer() && !m) return It.disabled;
                    const g = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;
                    return new It(h || this.context.gl.LEQUAL, s, [g, g])
                }

                opaquePassEnabledForLayer() {
                    return this.currentLayer < this.opaquePassCutoff
                }

                blitDepth() {
                    const t = this.context.gl, s = Math.ceil(this.width), h = Math.ceil(this.height),
                        m = this.context.bindFramebuffer.get(), g = t.getParameter(t.TEXTURE_BINDING_2D);
                    this.depthFBO && this.depthFBO.width === s && this.depthFBO.height === h || (this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), s !== 0 && h !== 0 && (this.depthFBO = new Hl(this.context, s, h, !1, "texture"), this.depthTexture = new o.T(this.context, {
                        width: s,
                        height: h,
                        data: null
                    }, t.DEPTH24_STENCIL8), this.depthFBO.depthAttachment.set(this.depthTexture.texture))), this.context.bindFramebuffer.set(m), t.bindTexture(t.TEXTURE_2D, g), this.depthFBO && (t.bindFramebuffer(t.READ_FRAMEBUFFER, null), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, this.depthFBO.framebuffer), t.blitFramebuffer(0, 0, s, h, 0, 0, s, h, t.DEPTH_BUFFER_BIT, t.NEAREST), t.bindFramebuffer(t.FRAMEBUFFER, this.context.bindFramebuffer.current))
                }

                updateAverageFPS() {
                    this._fpsHistory.push(this._dt === 0 ? 0 : 1e3 / this._dt), this._fpsHistory.length > this._debugParams.fpsWindow && this._fpsHistory.splice(0, this._fpsHistory.length - this._debugParams.fpsWindow), this._averageFPS = Math.round(this._fpsHistory.reduce((t, s) => t + s / this._fpsHistory.length, 0))
                }

                render(t, s) {
                    const h = o.q.now();
                    this._dt = h - this._timeStamp, this._timeStamp = h, this._wireframeDebugCache.update(this.frameCounter), this._debugParams.continousRedraw = t.map.repaint, this.style = t, this.options = s;
                    const m = this.style._mergedLayers, g = !(!this.terrain || !this.terrain.enabled),
                        v = () => this.style._getOrder(g).filter(Fe => {
                            const Te = m[Fe];
                            return !(Te.type in this._debugParams.enabledLayers) || this._debugParams.enabledLayers[Te.type]
                        });
                    let b = v(), S = !1, P = !1, M = null;
                    for (const Fe of b) {
                        const Te = m[Fe];
                        Te.type === "circle" ? S = !0 : Te.type === "building" ? M = Te : Te.type === "symbol" && (Te.hasInitialOcclusionOpacityProperties ? P = !0 : S = !0)
                    }
                    let k = b.map(Fe => m[Fe]);
                    const R = this.style._mergedSourceCaches;
                    this.imageManager = t.imageManager, this.modelManager = t.modelManager, this.symbolFadeChange = t.placement.symbolFadeChange(o.q.now()), this.imageManager.beginFrame();
                    let O = 0, V = !1;
                    for (const Fe in R) {
                        const Te = R[Fe];
                        Te.used && (Te.prepare(this.context), Te.getSource().usedInConflation && ++O)
                    }
                    let B = !1;
                    for (const Fe of k) Fe.isHidden(this.transform.zoom) || (Fe.type === "clip" && (B = !0), this.prepareLayer(Fe));
                    const G = {}, U = {}, Z = {}, Q = {}, te = {};
                    for (const Fe in R) {
                        const Te = R[Fe];
                        G[Fe] = Te.getVisibleCoordinates(), U[Fe] = G[Fe].slice().reverse(), Z[Fe] = Te.getVisibleCoordinates(!0).reverse(), Q[Fe] = Te.getShadowCasterCoordinates(), te[Fe] = Te.sortCoordinatesByDistance(G[Fe])
                    }
                    const ce = Fe => {
                        const Te = this.style.getLayerSourceCache(Fe);
                        return Te && Te.used ? Te.getSource() : null
                    };
                    if (O || B || this._clippingActiveLastFrame) {
                        const Fe = [], Te = [];
                        let $e = 0;
                        for (const Be of k) this.isSourceForClippingOrConflation(Be, ce(Be)) && (Fe.push(Be), Te.push($e)), $e++;
                        if (Fe && (B || Fe.length > 1) || this._clippingActiveLastFrame) {
                            B = !1;
                            const Be = [];
                            for (let tt = 0; tt < Fe.length; tt++) {
                                const it = Fe[tt], rt = Te[tt], gt = this.style.getLayerSourceCache(it);
                                if (!gt || !gt.used || !gt.getSource().usedInConflation && it.type !== "clip" && it.type !== "building") continue;
                                let Ot = o.eF, Ut = o.bW.None;
                                const St = [];
                                let Nt = !0;
                                if (it.type === "building") Ot = o.eH; else if (it.type === "clip") {
                                    Ot = rt;
                                    for (const Ft of it.layout.get("clip-layer-types")) Ut |= Ft === "model" ? o.bW.Model : Ft === "symbol" ? o.bW.Symbol : o.bW.FillExtrusion;
                                    for (const Ft of it.layout.get("clip-layer-scope")) St.push(Ft);
                                    it.isHidden(this.transform.zoom) ? Nt = !1 : B = !0
                                }
                                Nt && Be.push({layer: it.fqid, cache: gt, order: Ot, clipMask: Ut, clipScope: St})
                            }
                            this.replacementSource.setSources(Be), V = !0
                        }
                    }
                    this._clippingActiveLastFrame = B, V || this.replacementSource.clear(), this.conflationActive = V, this.minCutoffZoom = 0, this.longestCutoffRange = 0, this.opaquePassCutoff = 1 / 0, this._lastOcclusionLayer = -1, this.layersWithOcclusionOpacity = [];
                    for (let Fe = 0; Fe < k.length; Fe++) {
                        const Te = k[Fe], $e = Te.cutoffRange();
                        if (this.longestCutoffRange = Math.max($e, this.longestCutoffRange), $e > 0) {
                            const Be = ce(Te);
                            Be && (this.minCutoffZoom = Math.max(Be.minzoom, this.minCutoffZoom)), Te.minzoom && (this.minCutoffZoom = Math.max(Te.minzoom, this.minCutoffZoom))
                        }
                        Te.is3D(g) && (this.opaquePassCutoff === 1 / 0 && (this.opaquePassCutoff = Fe), this._lastOcclusionLayer = Fe)
                    }
                    const _e = this.style && this.style.fog;
                    _e ? (this._fogVisible = _e.getOpacity(this.transform.pitch) !== 0, this._fogVisible && this.transform.projection.name !== "globe" && (this._fogVisible = _e.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = !1, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(Z), this.opaquePassCutoff = 0, b = v(), k = b.map(Fe => m[Fe]));
                    const ve = this._shadowRenderer;
                    if (ve) {
                        ve.updateShadowParameters(this.transform, this.style.directionalLight);
                        for (const Fe in R) for (const Te of G[Fe]) {
                            let $e = {min: 0, max: 0};
                            this.terrain && ($e = this.terrain.getMinMaxForTile(Te) || $e), ve.addShadowReceiver(Te.toUnwrapped(), $e.min, $e.max)
                        }
                    }
                    this.transform.projection.name !== "globe" || this.globeSharedBuffers || (this.globeSharedBuffers = new o.eG(this.context)), this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new ze(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0);
                    const ue = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.snow),
                        he = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.rain);
                    if (ue && !this._snow && (this._snow = new Sm(this)), !ue && this._snow && (this._snow.destroy(), delete this._snow), he && !this._rain && (this._rain = new Uc(this)), !he && this._rain && (this._rain.destroy(), delete this._rain), this._snow && this._snow.update(this), this._rain && this._rain.update(this), M) {
                        this.buildingTileBorderManager || (this.buildingTileBorderManager = new by);
                        const Fe = this.style.getLayerSourceCache(M);
                        this.buildingTileBorderManager.updateBorders(Fe, M)
                    }
                    if (!Zr.has(this.context.gl)) return;
                    this.renderPass = "offscreen";
                    for (const Fe of k) {
                        const Te = t.getLayerSourceCache(Fe);
                        if (!Fe.hasOffscreenPass() || Fe.isHidden(this.transform.zoom)) continue;
                        const $e = Te ? U[Te.id] : void 0;
                        (Fe.type === "custom" || Fe.type === "raster" || Fe.type === "raster-particle" || Fe.isSky() || $e && $e.length) && this.renderLayer(this, Te, Fe, $e)
                    }
                    this.depthRangeFor3D = [0, 1 - (k.length + 2) * this.numSublayers * this.depthEpsilon], this._shadowRenderer && (this.renderPass = "shadow", this._shadowRenderer.drawShadowPass(this.style, Q)), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);
                    const me = this.transform.projection.name === "globe" || this.transform.isHorizonVisible(),
                        Oe = (() => {
                            if (s.showOverdrawInspector) return o.am.black;
                            const Fe = this.style.fog;
                            if (Fe && this.transform.projection.supportsFog) {
                                const Te = this.style.getLut(Fe.scope);
                                if (!me) {
                                    const $e = Fe.properties.get("color-use-theme") === "none",
                                        Be = Fe.properties.get("color").toNonPremultipliedRenderColor($e ? null : Te).toArray01();
                                    return new o.am(...Be)
                                }
                                if (me) {
                                    const $e = Fe.properties.get("space-color-use-theme") === "none",
                                        Be = Fe.properties.get("space-color").toNonPremultipliedRenderColor($e ? null : Te).toArray01();
                                    return new o.am(...Be)
                                }
                            }
                            return o.am.transparent
                        })();
                    if (this.context.clear({
                        color: Oe,
                        depth: 1
                    }), this.clearStencil(), this._showOverdrawInspector = s.showOverdrawInspector, this.renderPass = "opaque", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && me && this._atmosphere.drawStars(this, this.style.fog), !this.terrain) for (this.currentLayer = b.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                        const Fe = k[this.currentLayer], Te = t.getLayerSourceCache(Fe);
                        if (Fe.isSky()) continue;
                        const $e = Te ? (Fe.is3D(g) ? te : U)[Te.id] : void 0;
                        this._renderTileClippingMasks(Fe, Te, $e), this.renderLayer(this, Te, Fe, $e)
                    }
                    if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && me && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = "sky", (!this._atmosphere || o.ah(this.transform.zoom) > 0) && (this.transform.projection.name === "globe" || this.transform.isHorizonVisible())) for (this.currentLayer = 0; this.currentLayer < b.length; this.currentLayer++) {
                        const Fe = k[this.currentLayer], Te = t.getLayerSourceCache(Fe);
                        Fe.isSky() && this.renderLayer(this, Te, Fe, Te ? U[Te.id] : void 0)
                    }

                    function Se(Fe, Te) {
                        let $e;
                        return Te && ($e = (Fe.type === "symbol" ? Z : Fe.is3D(g) ? te : U)[Te.id]), $e
                    }

                    if (this.renderPass = "translucent", this.transform.projection.name === "globe") {
                        for (this.renderElevatedRasterBackface = !0, this.currentLayer = 0; this.currentLayer < b.length;) {
                            const Fe = k[this.currentLayer];
                            if (Fe.type === "raster" || Fe.type === "raster-particle") {
                                const Te = t.getLayerSourceCache(Fe);
                                this.renderLayer(this, Te, Fe, Se(Fe, Te))
                            }
                            ++this.currentLayer
                        }
                        this.renderElevatedRasterBackface = !1
                    }
                    this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;
                    let Xe = 0;
                    ve && (Xe = ve.getShadowCastingLayerCount());
                    let je = !1, Ke = -1;
                    for (let Fe = 0; Fe < b.length; ++Fe) {
                        const Te = k[Fe];
                        Te.isHidden(this.transform.zoom) || Te.is3D(g) && (Ke = Fe)
                    }
                    P && Ke === -1 && (S = !0);
                    let ut = !1;
                    for (; this.currentLayer < b.length;) {
                        const Fe = k[this.currentLayer], Te = t.getLayerSourceCache(Fe);
                        if (Fe.isSky()) ++this.currentLayer; else if (this.terrain && this.style.isLayerDraped(Fe)) {
                            if (Fe.isHidden(this.transform.zoom)) {
                                ++this.currentLayer;
                                continue
                            }
                            this.currentLayer = this.terrain.renderBatch(this.currentLayer), this._lastOcclusionLayer = Math.max(this.currentLayer, this._lastOcclusionLayer)
                        } else {
                            if (!ut && Fe.is3D(g) && !g) {
                                const $e = this.currentLayer, Be = tt => {
                                    for (this.currentLayer = 0; this.currentLayer < k.length; this.currentLayer++) {
                                        const it = k[this.currentLayer];
                                        if (tf[it.type]) {
                                            const rt = this.style.getLayerSourceCache(it);
                                            tf[it.type](this, rt, it, Se(it, rt), tt)
                                        }
                                    }
                                };
                                Be("initialize"), Be("reset"), this.currentLayer = $e, ut = !0
                            }
                            if (S && !je && this.terrain && !this.transform.isOrthographic && (je = !0, this.blitDepth()), P && Ke !== -1 && this.currentLayer === Ke + 1 && !this.transform.isOrthographic && this.blitDepth(), this.terrain || this._renderTileClippingMasks(Fe, Te, Te ? G[Te.id] : void 0), this.renderLayer(this, Te, Fe, Se(Fe, Te)), !this.terrain && ve && Xe > 0 && Fe.hasShadowPass() && --Xe == 0) {
                                {
                                    this.clearStencil(), this.resetStencilClippingMasks();
                                    const $e = this.currentLayer;
                                    for (this.currentLayer = 0; this.currentLayer < k.length; this.currentLayer++) {
                                        const Be = k[this.currentLayer];
                                        if (Qo[Be.type]) {
                                            const tt = this.style.getLayerSourceCache(Be);
                                            Qo[Be.type](this, tt, Be, Se(Be, tt))
                                        }
                                    }
                                    this.currentLayer = $e
                                }
                                if (ve.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer) {
                                    const $e = this.currentLayer;
                                    for (this.renderPass = "light-beam", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= $e; this.currentLayer++) {
                                        const Be = k[this.currentLayer];
                                        if (!Be.hasLightBeamPass()) continue;
                                        const tt = t.getLayerSourceCache(Be);
                                        this.renderLayer(this, tt, Be, tt ? U[tt.id] : void 0)
                                    }
                                    this.currentLayer = $e, this.renderPass = "translucent"
                                }
                            }
                            if (this.currentLayer >= this._lastOcclusionLayer && this.layersWithOcclusionOpacity.length > 0) {
                                const $e = this.currentLayer;
                                this.depthOcclusion = !0;
                                for (const Be of this.layersWithOcclusionOpacity) {
                                    this.currentLayer = Be;
                                    const tt = k[this.currentLayer], it = t.getLayerSourceCache(tt),
                                        rt = it ? U[it.id] : void 0;
                                    this.terrain || this._renderTileClippingMasks(tt, it, it ? G[it.id] : void 0), this.renderLayer(this, it, tt, rt)
                                }
                                this.depthOcclusion = !1, this.currentLayer = $e, this.renderPass = "translucent", this.layersWithOcclusionOpacity = []
                            }
                            ++this.currentLayer
                        }
                    }
                    if (this.terrain && this.terrain.postRender(), this._snow && this._snow.draw(this), this._rain && this._rain.draw(this), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
                        let Fe = null;
                        k.forEach(Te => {
                            const $e = t.getLayerSourceCache(Te);
                            $e && !Te.isHidden(this.transform.zoom) && $e.getVisibleCoordinates().length && (!Fe || Fe.getSource().maxzoom < $e.getSource().maxzoom) && (Fe = $e)
                        }), Fe && this.options.showTileBoundaries && Qs(this, Fe, Fe.getVisibleCoordinates(), o.am.red, !1, this.options.showParseStatus)
                    }
                    this.terrain && this._debugParams.showTerrainProxyTiles && Qs(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new o.am(1, .8, .1, 1), !0, this.options.showParseStatus), this.options.showPadding && function (Fe) {
                        const Te = Fe.transform.padding;
                        vh(Fe, Fe.transform.height - (Te.top || 0), 3, yy), vh(Fe, Te.bottom || 0, 3, _m), Yd(Fe, Te.left || 0, 3, ym), Yd(Fe, Fe.transform.width - (Te.right || 0), 3, vm);
                        const $e = Fe.transform.centerPoint;
                        (function (Be, tt, it, rt) {
                            xh(Be, tt - 1, it - 10, 2, 20, rt), xh(Be, tt - 10, it - 1, 20, 2, rt)
                        })(Fe, $e.x, Fe.transform.height - $e.y, vy)
                    }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), V || (this.conflationActive = !1)
                }

                prepareLayer(t) {
                    this.gpuTimingStart(t);
                    const {unsupportedLayers: s} = this.transform.projection, h = !s || !s.includes(t.type);
                    if (ef[t.type] && (h || this.terrain && t.type === "custom")) {
                        const m = this.style.getLayerSourceCache(t);
                        ef[t.type](t, m, this)
                    }
                    this.gpuTimingEnd()
                }

                renderLayer(t, s, h, m) {
                    h.isHidden(this.transform.zoom) || (h.type === "background" || h.type === "sky" || h.type === "custom" || h.type === "model" || h.type === "raster" || h.type === "raster-particle" || m && m.length) && (this.id = h.id, this.gpuTimingStart(h), t.transform.projection.unsupportedLayers && t.transform.projection.unsupportedLayers.includes(h.type) && (!t.terrain || h.type !== "custom") || h.type === "clip" || Em[h.type](t, s, h, m, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd())
                }

                gpuTimingStart(t) {
                    if (!this.options.gpuTiming) return;
                    const s = this.context.extTimerQuery, h = this.context.gl;
                    let m = this.gpuTimers[t.id];
                    m || (m = this.gpuTimers[t.id] = {
                        calls: 0,
                        cpuTime: 0,
                        query: h.createQuery()
                    }), m.calls++, h.beginQuery(s.TIME_ELAPSED_EXT, m.query)
                }

                gpuTimingDeferredRenderStart() {
                    if (this.options.gpuTimingDeferredRender) {
                        const t = this.context.extTimerQuery, s = this.context.gl, h = s.createQuery();
                        this.deferredRenderGpuTimeQueries.push(h), s.beginQuery(t.TIME_ELAPSED_EXT, h)
                    }
                }

                gpuTimingDeferredRenderEnd() {
                    this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT)
                }

                gpuTimingEnd() {
                    this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT)
                }

                collectGpuTimers() {
                    const t = this.gpuTimers;
                    return this.gpuTimers = {}, t
                }

                collectDeferredRenderGpuQueries() {
                    const t = this.deferredRenderGpuTimeQueries;
                    return this.deferredRenderGpuTimeQueries = [], t
                }

                queryGpuTimers(t) {
                    const s = {};
                    for (const h in t) {
                        const m = t[h], g = this.context.extTimerQuery,
                            v = g.getQueryParameter(m.query, this.context.gl.QUERY_RESULT) / 1e6;
                        g.deleteQueryEXT(m.query), s[h] = v
                    }
                    return s
                }

                queryGpuTimeDeferredRender(t) {
                    if (!this.options.gpuTimingDeferredRender) return 0;
                    const s = this.context.gl;
                    let h = 0;
                    for (const m of t) h += s.getQueryParameter(m, s.QUERY_RESULT) / 1e6, s.deleteQuery(m);
                    return h
                }

                translatePosMatrix(t, s, h, m, g) {
                    if (!h[0] && !h[1]) return t;
                    const v = g ? m === "map" ? this.transform.angle : 0 : m === "viewport" ? -this.transform.angle : 0;
                    if (v) {
                        const P = Math.sin(v), M = Math.cos(v);
                        h = [h[0] * M - h[1] * P, h[0] * P + h[1] * M]
                    }
                    const b = [g ? h[0] : o.aw(s, h[0], this.transform.zoom), g ? h[1] : o.aw(s, h[1], this.transform.zoom), 0],
                        S = new Float32Array(16);
                    return o.bo(S, t, b), S
                }

                saveTileTexture(t) {
                    if (t.context !== this.context) return;
                    const s = t.size[0], h = this._tileTextures[s];
                    h ? h.push(t) : this._tileTextures[s] = [t]
                }

                getTileTexture(t) {
                    const s = this._tileTextures[t];
                    return s && s.length > 0 ? s.pop() : null
                }

                terrainRenderModeElevated() {
                    return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture || this.forceTerrainMode
                }

                linearFloatFilteringSupported() {
                    return this.context.extTextureFloatLinear != null
                }

                currentGlobalDefines(t, s, h) {
                    const m = h === void 0 ? this.terrain && this.terrain.renderingToTexture : h, g = [];
                    return this.style && this.style.enable3dLights() && (t === "globeRaster" || t === "terrainRaster" ? (g.push("LIGHTING_3D_MODE"), g.push("LIGHTING_3D_ALPHA_EMISSIVENESS")) : m || g.push("LIGHTING_3D_MODE")), this.renderPass === "shadow" && (this._shadowMapDebug || g.push("DEPTH_TEXTURE")), this.terrainRenderModeElevated() && (g.push("TERRAIN"), this.linearFloatFilteringSupported() && g.push("TERRAIN_DEM_FLOAT_FORMAT")), this.transform.projection.name === "globe" && g.push("GLOBE"), !this._fogVisible || m || s !== void 0 && !s || g.push("FOG", "FOG_DITHERING"), m && g.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && g.push("OVERDRAW_INSPECTOR"), g
                }

                getOrCreateProgram(t, s) {
                    this.cache = this.cache || {};
                    const h = s && s.defines || [], m = s && s.config,
                        g = this.currentGlobalDefines(t, s && s.overrideFog, s && s.overrideRtt).concat(h),
                        v = Bd.cacheKey(dh[t], t, g, m);
                    return this.cache[v] || (this.cache[v] = new Bd(this.context, t, dh[t], m, my[t], g)), this.cache[v]
                }

                setCustomLayerDefaults() {
                    this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault()
                }

                setBaseState() {
                    const t = this.context.gl;
                    this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t.FUNC_ADD)
                }

                initDebugOverlayCanvas() {
                    this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new o.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA8))
                }

                destroy() {
                    this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy(), this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), this.emptyDepthTexture && this.emptyDepthTexture.destroy()
                }

                prepareDrawTile() {
                    this.terrain && this.terrain.prepareDrawTile()
                }

                uploadCommonLightUniforms(t, s) {
                    if (this.style.enable3dLights()) {
                        const h = this.style.directionalLight, m = this.style.ambientLight;
                        if (h && m) {
                            const g = ((v, b, S) => {
                                const P = v.properties.get("direction"),
                                    M = v.properties.get("color-use-theme") === "none",
                                    k = v.properties.get("color").toNonPremultipliedRenderColor(M ? null : S.getLut(v.scope)).toArray01(),
                                    R = v.properties.get("intensity"),
                                    O = b.properties.get("color-use-theme") === "none",
                                    V = b.properties.get("color").toNonPremultipliedRenderColor(O ? null : S.getLut(b.scope)).toArray01(),
                                    B = b.properties.get("intensity"), G = [P.x, P.y, P.z], U = o.dI(V, B),
                                    Z = o.dI(k, R);
                                return {
                                    u_lighting_ambient_color: U,
                                    u_lighting_directional_dir: G,
                                    u_lighting_directional_color: Z,
                                    u_ground_radiance: em(G, Z, U)
                                }
                            })(h, m, this.style);
                            s.setLightsUniformValues(t, g)
                        }
                    }
                }

                uploadCommonUniforms(t, s, h, m, g) {
                    if (this.uploadCommonLightUniforms(t, s), this.terrain && this.terrain.renderingToTexture) return;
                    const v = this.style.fog;
                    if (v) {
                        const b = v.getOpacity(this.transform.pitch), S = ((P, M, k, R, O, V, B, G, U, Z, Q, te) => {
                            const ce = P.transform, _e = M.properties.get("color-use-theme") === "none",
                                ve = M.properties.get("color").toNonPremultipliedRenderColor(_e ? null : P.style.getLut(M.scope)).toArray01();
                            ve[3] = R;
                            const ue = P.frameCounter / 1e3 % 1, [he, me] = M.properties.get("vertical-range");
                            return {
                                u_fog_matrix: k ? ce.calculateFogTileMatrix(k) : te || P.identityMat,
                                u_fog_range: M.getFovAdjustedRange(ce._fov),
                                u_fog_color: ve,
                                u_fog_horizon_blend: M.properties.get("horizon-blend"),
                                u_fog_vertical_limit: [Math.min(he, me), me],
                                u_fog_temporal_offset: ue,
                                u_frustum_tl: O,
                                u_frustum_tr: V,
                                u_frustum_br: B,
                                u_frustum_bl: G,
                                u_globe_pos: U,
                                u_globe_radius: Z,
                                u_viewport: Q,
                                u_globe_transition: o.ah(ce.zoom),
                                u_is_globe: +(ce.projection.name === "globe")
                            }
                        })(this, v, h, b, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * o.q.devicePixelRatio, this.transform.height * o.q.devicePixelRatio], m);
                        s.setFogUniformValues(t, S)
                    }
                    g && s.setCutoffUniformValues(t, g.uniformValues)
                }

                setTileLoadedFlag(t) {
                    this.tileLoaded = t
                }

                saveCanvasCopy() {
                    const t = this.canvasCopy();
                    t && (this.frameCopies.push(t), this.tileLoaded = !1)
                }

                canvasCopy() {
                    const t = this.context.gl, s = t.createTexture();
                    return t.bindTexture(t.TEXTURE_2D, s), t.copyTexImage2D(t.TEXTURE_2D, 0, t.RGBA, 0, 0, t.drawingBufferWidth, t.drawingBufferHeight, 0), s
                }

                getCanvasCopiesAndTimestamps() {
                    return {canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps}
                }

                averageElevationNeedsEasing() {
                    if (!this.transform._elevation) return !1;
                    const t = this.style && this.style.fog;
                    return !!t && t.getOpacity(this.transform.pitch) !== 0
                }

                getBackgroundTiles() {
                    const t = this._backgroundTiles, s = this._backgroundTiles = {},
                        h = this.transform.coveringTiles({tileSize: 512});
                    for (const m of h) s[m.key] = t[m.key] || new zl(m, 512, this.transform.tileZoom, this, void 0, this.worldview);
                    return s
                }

                clearBackgroundTiles() {
                    this._backgroundTiles = {}
                }

                isSourceForClippingOrConflation(t, s) {
                    return !(!t.is3D(!(!this.terrain || !this.terrain.enabled)) || t.type !== "clip" && t.type !== "building" && (t.minzoom && t.minzoom > this.transform.zoom || (this.style._clipLayerPresent || t.sourceLayer !== "building" && t.sourceLayer !== "procedural_buildings") && (!s || s.type !== "batched-model")))
                }

                isTileAffectedByFog(t) {
                    if (!this.style || !this.style.fog) return !1;
                    if (this.transform.projection.name === "globe") return !0;
                    let s = this._cachedTileFogOpacities[t.key];
                    return s || (this._cachedTileFogOpacities[t.key] = s = this.style.fog.getOpacityForTile(t)), s[0] >= Je || s[1] >= Je
                }

                setupDepthForOcclusion(t, s, h) {
                    const m = this.context, g = m.gl, v = !!h;
                    var b;
                    h || (h = {
                        u_dem: 2,
                        u_dem_prev: 4,
                        u_dem_tl: [0, 0],
                        u_dem_tl_prev: [0, 0],
                        u_dem_scale: 0,
                        u_dem_scale_prev: 0,
                        u_dem_size: 0,
                        u_dem_lerp: 1,
                        u_depth: 3,
                        u_depth_size_inv: [0, 0],
                        u_depth_range_unpack: [0, 1],
                        u_occluder_half_size: 16,
                        u_occlusion_depth_offset: -1e-4,
                        u_exaggeration: 0
                    }), m.activeTexture.set(g.TEXTURE3), t && this.depthFBO && this.depthTexture ? (this.depthTexture.bind(g.NEAREST, g.CLAMP_TO_EDGE), h.u_depth_size_inv = [1 / this.depthFBO.width, 1 / this.depthFBO.height], h.u_depth_range_unpack = [2 / ((b = this.depthRangeFor3D)[1] - b[0]), -1 - 2 * b[0] / (b[1] - b[0])], h.u_occluder_half_size = .5 * this.occlusionParams.occluderSize, h.u_occlusion_depth_offset = this.occlusionParams.depthOffset) : this.emptyDepthTexture.bind(g.NEAREST, g.CLAMP_TO_EDGE), m.activeTexture.set(g.TEXTURE0), v || s.setTerrainUniformValues(m, h)
                }
            }

            function Gc(u, t) {
                let s = !1, h = null;
                const m = () => {
                    h = null, s && (u(), h = setTimeout(m, t), s = !1)
                };
                return () => (s = !0, h || m(), h)
            }

            class nf {
                constructor(t) {
                    this._hashName = t && encodeURIComponent(t), o.aV(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Gc(this._updateHashUnthrottled.bind(this), 300)
                }

                addTo(t) {
                    return this._map = t, window.addEventListener("hashchange", this._onHashChange, !1), t.on("moveend", this._updateHash), this
                }

                remove() {
                    return this._map ? (this._map.off("moveend", this._updateHash), window.removeEventListener("hashchange", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this
                }

                getHashString() {
                    const t = this._map;
                    if (!t) return "";
                    const s = rf(t);
                    if (this._hashName) {
                        const h = this._hashName;
                        let m = !1;
                        const g = location.hash.slice(1).split("&").map(v => {
                            const b = v.split("=")[0];
                            return b === h ? (m = !0, `${b}=${s}`) : v
                        }).filter(v => v);
                        return m || g.push(`${h}=${s}`), `#${g.join("&")}`
                    }
                    return `#${s}`
                }

                _getCurrentHash() {
                    const t = location.hash.replace("#", "");
                    if (this._hashName) {
                        let s;
                        return t.split("&").map(h => h.split("=")).forEach(h => {
                            h[0] === this._hashName && (s = h)
                        }), (s && s[1] || "").split("/")
                    }
                    return t.split("/")
                }

                _onHashChange() {
                    const t = this._map;
                    if (!t) return !1;
                    const s = this._getCurrentHash();
                    if (s.length >= 3 && !s.some(h => isNaN(Number(h)))) {
                        const h = t.dragRotate.isEnabled() && t.touchZoomRotate.isEnabled() ? +(s[3] || 0) : t.getBearing();
                        return t.jumpTo({center: [+s[2], +s[1]], zoom: +s[0], bearing: h, pitch: +(s[4] || 0)}), !0
                    }
                    return !1
                }

                _updateHashUnthrottled() {
                    history.replaceState(history.state, "", location.href.replace(/(#.+)?$/, this.getHashString()))
                }
            }

            function rf(u, t) {
                const s = u.getCenter(), h = Math.round(100 * u.getZoom()) / 100,
                    m = Math.ceil((h * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), g = Math.pow(10, m),
                    v = Math.round(s.lng * g) / g, b = Math.round(s.lat * g) / g, S = u.getBearing(), P = u.getPitch();
                let M = t ? `/${v}/${b}/${h}` : `${h}/${b}/${v}`;
                return (S || P) && (M += "/" + Math.round(10 * S) / 10), P && (M += `/${Math.round(P)}`), M
            }

            const $c = {linearity: .3, easing: o.eI(0, 0, .3, 1)}, ul = o.h({deceleration: 2500, maxSpeed: 1400}, $c),
                Am = o.h({deceleration: 20, maxSpeed: 1400}, $c), ea = o.h({deceleration: 1e3, maxSpeed: 360}, $c),
                Im = o.h({deceleration: 1e3, maxSpeed: 90}, $c);

            class of {
                constructor(t) {
                    this._map = t, this.clear()
                }

                clear() {
                    this._inertiaBuffer = []
                }

                record(t) {
                    this._drainInertiaBuffer(), this._inertiaBuffer.push({time: o.q.now(), settings: t})
                }

                _drainInertiaBuffer() {
                    const t = this._inertiaBuffer, s = o.q.now();
                    for (; t.length > 0 && s - t[0].time > 160;) t.shift()
                }

                _onMoveEnd(t) {
                    if (this._map._prefersReducedMotion() || (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)) return;
                    const s = {zoom: 0, bearing: 0, pitch: 0, pan: new o.P(0, 0), pinchAround: void 0, around: void 0};
                    for (const {settings: g} of this._inertiaBuffer) s.zoom += g.zoomDelta || 0, s.bearing += g.bearingDelta || 0, s.pitch += g.pitchDelta || 0, g.panDelta && s.pan._add(g.panDelta), g.around && (s.around = g.around), g.pinchAround && (s.pinchAround = g.pinchAround);
                    const h = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,
                        m = {};
                    if (s.pan.mag()) {
                        const g = qc(s.pan.mag(), h, o.h({}, ul, t || {}));
                        m.offset = s.pan.mult(g.amount / s.pan.mag()), m.center = this._map.transform.center, Hc(m, g)
                    }
                    if (s.zoom) {
                        const g = qc(s.zoom, h, Am);
                        m.zoom = this._map.transform.zoom + g.amount, Hc(m, g)
                    }
                    if (s.bearing) {
                        const g = qc(s.bearing, h, ea);
                        m.bearing = this._map.transform.bearing + o.ay(g.amount, -179, 179), Hc(m, g)
                    }
                    if (s.pitch) {
                        const g = qc(s.pitch, h, Im);
                        m.pitch = this._map.transform.pitch + g.amount, Hc(m, g)
                    }
                    if (m.zoom || m.bearing) {
                        const g = s.pinchAround === void 0 ? s.around : s.pinchAround;
                        m.around = g ? this._map.unproject(g) : this._map.getCenter()
                    }
                    return this.clear(), m.noMoveStart = !0, m
                }
            }

            function Hc(u, t) {
                (!u.duration || u.duration < t.duration) && (u.duration = t.duration, u.easing = t.easing)
            }

            function qc(u, t, s) {
                const {maxSpeed: h, linearity: m, deceleration: g} = s, v = o.ay(u * m / (t / 1e3), -h, h),
                    b = Math.abs(v) / (g * m);
                return {easing: s.easing, duration: 1e3 * b, amount: v * (b / 2)}
            }

            class Mn extends o.A {
                preventDefault() {
                    this._defaultPrevented = !0
                }

                get defaultPrevented() {
                    return this._defaultPrevented
                }

                constructor(t, s, h, m = {}) {
                    const g = Mt(s.getCanvasContainer(), h), v = s.unproject(g);
                    super(t, o.h({
                        point: g,
                        lngLat: v,
                        originalEvent: h
                    }, m)), this._defaultPrevented = !1, this.target = s
                }
            }

            class Wc extends o.A {
                preventDefault() {
                    this._defaultPrevented = !0
                }

                get defaultPrevented() {
                    return this._defaultPrevented
                }

                constructor(t, s, h) {
                    const m = t === "touchend" ? h.changedTouches : h.touches, g = Xt(s.getCanvasContainer(), m),
                        v = g.map(S => s.unproject(S)),
                        b = g.reduce((S, P, M, k) => S.add(P.div(k.length)), new o.P(0, 0));
                    super(t, {
                        points: g,
                        point: b,
                        lngLats: v,
                        lngLat: s.unproject(b),
                        originalEvent: h
                    }), this._defaultPrevented = !1
                }
            }

            class Cm extends o.A {
                preventDefault() {
                    this._defaultPrevented = !0
                }

                get defaultPrevented() {
                    return this._defaultPrevented
                }

                constructor(t, s) {
                    super("wheel", {originalEvent: s}), this._defaultPrevented = !1
                }
            }

            class Pm {
                constructor(t, s) {
                    this._map = t, this._clickTolerance = s.clickTolerance
                }

                reset() {
                    this._mousedownPos = void 0
                }

                wheel(t) {
                    return this._firePreventable(new Cm(this._map, t))
                }

                mousedown(t, s) {
                    return this._mousedownPos = s, this._firePreventable(new Mn(t.type, this._map, t))
                }

                mouseup(t) {
                    this._map.fire(new Mn(t.type, this._map, t))
                }

                preclick(t) {
                    const s = o.h({}, t);
                    s.type = "preclick", this._map.fire(new Mn(s.type, this._map, s))
                }

                click(t, s) {
                    this._mousedownPos && this._mousedownPos.dist(s) >= this._clickTolerance || (this.preclick(t), this._map.fire(new Mn(t.type, this._map, t)))
                }

                dblclick(t) {
                    return this._firePreventable(new Mn(t.type, this._map, t))
                }

                mouseover(t) {
                    this._map.fire(new Mn(t.type, this._map, t))
                }

                mouseout(t) {
                    this._map.fire(new Mn(t.type, this._map, t))
                }

                touchstart(t) {
                    return this._firePreventable(new Wc(t.type, this._map, t))
                }

                touchmove(t) {
                    this._map.fire(new Wc(t.type, this._map, t))
                }

                touchend(t) {
                    this._map.fire(new Wc(t.type, this._map, t))
                }

                touchcancel(t) {
                    this._map.fire(new Wc(t.type, this._map, t))
                }

                _firePreventable(t) {
                    if (this._map.fire(t), t.defaultPrevented) return {}
                }

                isEnabled() {
                    return !0
                }

                isActive() {
                    return !1
                }

                enable() {
                }

                disable() {
                }
            }

            class Xl {
                constructor(t) {
                    this._map = t
                }

                reset() {
                    this._delayContextMenu = !1, this._contextMenuEvent = void 0
                }

                mousemove(t) {
                    this._map.fire(new Mn(t.type, this._map, t))
                }

                mousedown() {
                    this._delayContextMenu = !0
                }

                mouseup() {
                    this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Mn("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent)
                }

                contextmenu(t) {
                    this._delayContextMenu ? this._contextMenuEvent = t : this._map.fire(new Mn(t.type, this._map, t)), this._map.listens("contextmenu") && t.preventDefault()
                }

                isEnabled() {
                    return !0
                }

                isActive() {
                    return !1
                }

                enable() {
                }

                disable() {
                }
            }

            class Mm {
                constructor(t, s) {
                    this._map = t, this._el = t.getCanvasContainer(), this._container = t.getContainer(), this._clickTolerance = s.clickTolerance || 1
                }

                isEnabled() {
                    return !!this._enabled
                }

                isActive() {
                    return !!this._active
                }

                enable() {
                    this.isEnabled() || (this._enabled = !0)
                }

                disable() {
                    this.isEnabled() && (this._enabled = !1)
                }

                mousedown(t, s) {
                    this.isEnabled() && t.shiftKey && t.button === 0 && (Ue(), this._startPos = this._lastPos = s, this._active = !0)
                }

                mousemoveWindow(t, s) {
                    if (!this._active) return;
                    const h = s, m = this._startPos, g = this._lastPos;
                    if (!m || !g || g.equals(h) || !this._box && h.dist(m) < this._clickTolerance) return;
                    this._lastPos = h, this._box || (this._box = fe("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", t));
                    const v = Math.min(m.x, h.x), b = Math.max(m.x, h.x), S = Math.min(m.y, h.y),
                        P = Math.max(m.y, h.y);
                    this._map._requestDomTask(() => {
                        this._box && (this._box.style.transform = `translate(${v}px,${S}px)`, this._box.style.width = b - v + "px", this._box.style.height = P - S + "px")
                    })
                }

                mouseupWindow(t, s) {
                    if (!this._active) return;
                    const h = this._startPos, m = s;
                    if (h && t.button === 0) {
                        if (this.reset(), xt(), h.x !== m.x || h.y !== m.y) return this._map.fire(new o.A("boxzoomend", {originalEvent: t})), {cameraAnimation: g => g.fitScreenCoordinates(h, m, this._map.getBearing(), {linear: !1})};
                        this._fireEvent("boxzoomcancel", t)
                    }
                }

                keydown(t) {
                    this._active && t.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", t))
                }

                blur() {
                    this.reset()
                }

                reset() {
                    this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), et(), delete this._startPos, delete this._lastPos
                }

                _fireEvent(t, s) {
                    return this._map.fire(new o.A(t, {originalEvent: s}))
                }
            }

            function Eh(u, t) {
                const s = {};
                for (let h = 0; h < u.length; h++) s[u[h].identifier] = t[h];
                return s
            }

            class Rm {
                constructor(t) {
                    this.reset(), this.numTouches = t.numTouches
                }

                reset() {
                    this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1
                }

                touchstart(t, s, h) {
                    (this.centroid || h.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === 0 && (this.startTime = t.timeStamp), h.length === this.numTouches && (this.centroid = function (m) {
                        const g = new o.P(0, 0);
                        for (const v of m) g._add(v);
                        return g.div(m.length)
                    }(s), this.touches = Eh(h, s)))
                }

                touchmove(t, s, h) {
                    if (this.aborted || !this.centroid) return;
                    const m = Eh(h, s);
                    for (const g in this.touches) {
                        const v = m[g];
                        (!v || v.dist(this.touches[g]) > 30) && (this.aborted = !0)
                    }
                }

                touchend(t, s, h) {
                    if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0), h.length === 0) {
                        const m = !this.aborted && this.centroid;
                        if (this.reset(), m) return m
                    }
                }
            }

            class hl {
                constructor(t) {
                    this.singleTap = new Rm(t), this.numTaps = t.numTaps, this.reset()
                }

                reset() {
                    this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset()
                }

                touchstart(t, s, h) {
                    this.singleTap.touchstart(t, s, h)
                }

                touchmove(t, s, h) {
                    this.singleTap.touchmove(t, s, h)
                }

                touchend(t, s, h) {
                    const m = this.singleTap.touchend(t, s, h);
                    if (m) {
                        const g = t.timeStamp - this.lastTime < 500, v = !this.lastTap || this.lastTap.dist(m) < 30;
                        if (g && v || this.reset(), this.count++, this.lastTime = t.timeStamp, this.lastTap = m, this.count === this.numTaps) return this.reset(), m
                    }
                }
            }

            class zm {
                constructor() {
                    this._zoomIn = new hl({numTouches: 1, numTaps: 2}), this._zoomOut = new hl({
                        numTouches: 2,
                        numTaps: 1
                    }), this.reset()
                }

                reset() {
                    this._active = !1, this._zoomIn.reset(), this._zoomOut.reset()
                }

                touchstart(t, s, h) {
                    this._zoomIn.touchstart(t, s, h), this._zoomOut.touchstart(t, s, h)
                }

                touchmove(t, s, h) {
                    this._zoomIn.touchmove(t, s, h), this._zoomOut.touchmove(t, s, h)
                }

                touchend(t, s, h) {
                    const m = this._zoomIn.touchend(t, s, h), g = this._zoomOut.touchend(t, s, h);
                    return m ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), {
                        cameraAnimation: v => v.easeTo({
                            duration: 300,
                            zoom: v.getZoom() + 1,
                            around: v.unproject(m)
                        }, {originalEvent: t})
                    }) : g ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), {
                        cameraAnimation: v => v.easeTo({
                            duration: 300,
                            zoom: v.getZoom() - 1,
                            around: v.unproject(g)
                        }, {originalEvent: t})
                    }) : void 0
                }

                touchcancel() {
                    this.reset()
                }

                enable() {
                    this._enabled = !0
                }

                disable() {
                    this._enabled = !1, this.reset()
                }

                isEnabled() {
                    return this._enabled
                }

                isActive() {
                    return this._active
                }
            }

            const Dm = {0: 1, 2: 2}, sf = {Control: "ctrlKey", Alt: "altKey", Shift: "shiftKey", Meta: "metaKey"};

            class Zc {
                constructor(t) {
                    this.reset(), this._clickTolerance = t.clickTolerance || 1
                }

                blur() {
                    this.reset()
                }

                reset() {
                    this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0
                }

                _correctButton(t, s) {
                    return !1
                }

                _move(t, s) {
                    return {}
                }

                mousedown(t, s) {
                    if (this._lastPoint) return;
                    const h = Zt(t);
                    this._correctButton(t, h) && (this._lastPoint = s, this._eventButton = h)
                }

                mousemoveWindow(t, s) {
                    const h = this._lastPoint;
                    if (h) {
                        if (t.preventDefault(), this._eventButton != null && function (m, g) {
                            const v = Dm[g];
                            return m.buttons === void 0 || (m.buttons & v) !== v
                        }(t, this._eventButton)) this.reset(); else if (this._moved || !(s.dist(h) < this._clickTolerance)) return this._moved = !0, this._lastPoint = s, this._move(h, s)
                    }
                }

                mouseupWindow(t) {
                    this._lastPoint && Zt(t) === this._eventButton && (this._moved && xt(), this.reset())
                }

                enable() {
                    this._enabled = !0
                }

                disable() {
                    this._enabled = !1, this.reset()
                }

                isEnabled() {
                    return this._enabled
                }

                isActive() {
                    return this._active
                }
            }

            class Lm extends Zc {
                mousedown(t, s) {
                    super.mousedown(t, s), this._lastPoint && (this._active = !0)
                }

                _correctButton(t, s) {
                    return s === 0 && !t.ctrlKey
                }

                _move(t, s) {
                    return {around: s, panDelta: s.sub(t)}
                }
            }

            class af extends Zc {
                constructor(t) {
                    super(t), this._pitchRotateKey = t.pitchRotateKey ? sf[t.pitchRotateKey] : void 0
                }

                _correctButton(t, s) {
                    return this._pitchRotateKey ? s === 0 && t[this._pitchRotateKey] : s === 0 && t.ctrlKey || s === 2
                }

                _move(t, s) {
                    const h = .8 * (s.x - t.x);
                    if (h) return this._active = !0, {bearingDelta: h}
                }

                contextmenu(t) {
                    this._pitchRotateKey || t.preventDefault()
                }
            }

            class km extends Zc {
                constructor(t) {
                    super(t), this._pitchRotateKey = t.pitchRotateKey ? sf[t.pitchRotateKey] : void 0
                }

                _correctButton(t, s) {
                    return this._pitchRotateKey ? s === 0 && t[this._pitchRotateKey] : s === 0 && t.ctrlKey || s === 2
                }

                _move(t, s) {
                    const h = -.5 * (s.y - t.y);
                    if (h) return this._active = !0, {pitchDelta: h}
                }

                contextmenu(t) {
                    this._pitchRotateKey || t.preventDefault()
                }
            }

            class Ay {
                constructor(t, s) {
                    this._map = t, this._el = t.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = s.clickTolerance || 1, this.reset(), o.aV(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this)
                }

                reset() {
                    this._active = !1, this._touches = {}, this._sum = new o.P(0, 0)
                }

                touchstart(t, s, h) {
                    return this._calculateTransform(t, s, h)
                }

                touchmove(t, s, h) {
                    if (this._active && !(h.length < this._minTouches)) {
                        if (this._map._cooperativeGestures && !this._map.isMoving()) {
                            if (h.length === 1 && !o.eJ()) return void this._showTouchPanBlockerAlert();
                            this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer))
                        }
                        return t.cancelable && t.preventDefault(), this._calculateTransform(t, s, h)
                    }
                }

                touchend(t, s, h) {
                    this._calculateTransform(t, s, h), this._active && h.length < this._minTouches && this.reset()
                }

                touchcancel() {
                    this.reset()
                }

                _calculateTransform(t, s, h) {
                    h.length > 0 && (this._active = !0);
                    const m = Eh(h, s), g = new o.P(0, 0), v = new o.P(0, 0);
                    let b = 0;
                    for (const P in m) {
                        const M = m[P], k = this._touches[P];
                        k && (g._add(M), v._add(M.sub(k)), b++, m[P] = M)
                    }
                    if (this._touches = m, b < this._minTouches || !v.mag()) return;
                    const S = v.div(b);
                    return this._sum._add(S), this._sum.mag() < this._clickTolerance ? void 0 : {
                        around: g.div(b),
                        panDelta: S
                    }
                }

                enable() {
                    this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"))
                }

                disable() {
                    this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset()
                }

                isEnabled() {
                    return !!this._enabled
                }

                isActive() {
                    return !!this._active
                }

                _addTouchPanBlocker() {
                    this._map && !this._alertContainer && (this._alertContainer = fe("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`)
                }

                _showTouchPanBlockerAlert() {
                    this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {
                        this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.removeAttribute("role")
                    }, 500)
                }
            }

            class lf {
                constructor() {
                    this.reset()
                }

                reset() {
                    this._active = !1, this._firstTwoTouches = void 0
                }

                _start(t) {
                }

                _move(t, s, h) {
                    return {}
                }

                touchstart(t, s, h) {
                    this._firstTwoTouches || h.length < 2 || (this._firstTwoTouches = [h[0].identifier, h[1].identifier], this._start([s[0], s[1]]))
                }

                touchmove(t, s, h) {
                    const m = this._firstTwoTouches;
                    if (!m) return;
                    t.preventDefault();
                    const [g, v] = m, b = Ah(h, s, g), S = Ah(h, s, v);
                    if (!b || !S) return;
                    const P = this._aroundCenter ? null : b.add(S).div(2);
                    return this._move([b, S], P, t)
                }

                touchend(t, s, h) {
                    if (!this._firstTwoTouches) return;
                    const [m, g] = this._firstTwoTouches, v = Ah(h, s, m), b = Ah(h, s, g);
                    v && b || (this._active && xt(), this.reset())
                }

                touchcancel() {
                    this.reset()
                }

                enable(t) {
                    this._enabled = !0, this._aroundCenter = !!t && t.around === "center"
                }

                disable() {
                    this._enabled = !1, this.reset()
                }

                isEnabled() {
                    return this._enabled
                }

                isActive() {
                    return this._active
                }
            }

            function Ah(u, t, s) {
                for (let h = 0; h < u.length; h++) if (u[h].identifier === s) return t[h]
            }

            function Om(u, t) {
                return Math.log(u / t) / Math.LN2
            }

            class Iy extends lf {
                reset() {
                    super.reset(), this._distance = 0, this._startDistance = 0
                }

                _start(t) {
                    this._startDistance = this._distance = t[0].dist(t[1])
                }

                _move(t, s) {
                    const h = this._distance;
                    if (this._distance = t[0].dist(t[1]), this._active || !(Math.abs(Om(this._distance, this._startDistance)) < .1)) return this._active = !0, {
                        zoomDelta: Om(this._distance, h),
                        pinchAround: s
                    }
                }
            }

            function Fm(u, t) {
                return 180 * u.angleWith(t) / Math.PI
            }

            class Cy extends lf {
                reset() {
                    super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0
                }

                _start(t) {
                    this._startVector = this._vector = t[0].sub(t[1]), this._minDiameter = t[0].dist(t[1])
                }

                _move(t, s) {
                    const h = this._vector;
                    if (this._vector = t[0].sub(t[1]), h && (this._active || !this._isBelowThreshold(this._vector))) return this._active = !0, {
                        bearingDelta: Fm(this._vector, h),
                        pinchAround: s
                    }
                }

                _isBelowThreshold(t) {
                    this._minDiameter = Math.min(this._minDiameter, t.mag());
                    const s = 25 / (Math.PI * this._minDiameter) * 360, h = this._startVector;
                    if (!h) return !1;
                    const m = Fm(t, h);
                    return Math.abs(m) < s
                }
            }

            function cf(u) {
                return Math.abs(u.y) > Math.abs(u.x)
            }

            class Py extends lf {
                constructor(t) {
                    super(), this._map = t
                }

                reset() {
                    super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0
                }

                _start(t) {
                    this._lastPoints = t, cf(t[0].sub(t[1])) && (this._valid = !1)
                }

                _move(t, s, h) {
                    const m = this._lastPoints;
                    if (!m) return;
                    const g = t[0].sub(m[0]), v = t[1].sub(m[1]);
                    return this._map._cooperativeGestures && !o.eJ() && h.touches.length < 3 || (this._valid = this.gestureBeginsVertically(g, v, h.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t, this._active = !0, {pitchDelta: (g.y + v.y) / 2 * -.5})
                }

                gestureBeginsVertically(t, s, h) {
                    if (this._valid !== void 0) return this._valid;
                    const m = t.mag() >= 2, g = s.mag() >= 2;
                    if (!m && !g) return;
                    if (!m || !g) return this._firstMove == null && (this._firstMove = h), h - this._firstMove < 100 && void 0;
                    const v = t.y > 0 == s.y > 0;
                    return cf(t) && cf(s) && v
                }
            }

            const My = {panStep: 100, bearingStep: 15, pitchStep: 10};

            class Ry {
                constructor() {
                    const t = My;
                    this._panStep = t.panStep, this._bearingStep = t.bearingStep, this._pitchStep = t.pitchStep, this._rotationDisabled = !1
                }

                blur() {
                    this.reset()
                }

                reset() {
                    this._active = !1
                }

                keydown(t) {
                    if (t.altKey || t.ctrlKey || t.metaKey) return;
                    let s = 0, h = 0, m = 0, g = 0, v = 0;
                    switch (t.keyCode) {
                        case 61:
                        case 107:
                        case 171:
                        case 187:
                            s = 1;
                            break;
                        case 189:
                        case 109:
                        case 173:
                            s = -1;
                            break;
                        case 37:
                            t.shiftKey ? h = -1 : (t.preventDefault(), g = -1);
                            break;
                        case 39:
                            t.shiftKey ? h = 1 : (t.preventDefault(), g = 1);
                            break;
                        case 38:
                            t.shiftKey ? m = 1 : (t.preventDefault(), v = -1);
                            break;
                        case 40:
                            t.shiftKey ? m = -1 : (t.preventDefault(), v = 1);
                            break;
                        default:
                            return
                    }
                    return this._rotationDisabled && (h = 0, m = 0), {
                        cameraAnimation: b => {
                            const S = b.getZoom();
                            b.easeTo({
                                duration: 300,
                                easeId: "keyboardHandler",
                                easing: zy,
                                zoom: s ? Math.round(S) + s * (t.shiftKey ? 2 : 1) : S,
                                bearing: b.getBearing() + h * this._bearingStep,
                                pitch: b.getPitch() + m * this._pitchStep,
                                offset: [-g * this._panStep, -v * this._panStep],
                                center: b.getCenter()
                            }, {originalEvent: t})
                        }
                    }
                }

                enable() {
                    this._enabled = !0
                }

                disable() {
                    this._enabled = !1, this.reset()
                }

                isEnabled() {
                    return this._enabled
                }

                isActive() {
                    return this._active
                }

                disableRotation() {
                    this._rotationDisabled = !0
                }

                enableRotation() {
                    this._rotationDisabled = !1
                }
            }

            function zy(u) {
                return u * (2 - u)
            }

            const Dy = 4.000244140625, u1 = 1 / 450;

            class h1 {
                constructor(t, s) {
                    this._map = t, this._el = t.getCanvasContainer(), this._handler = s, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = u1, o.aV(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this)
                }

                setZoomRate(t) {
                    this._defaultZoomRate = t
                }

                setWheelZoomRate(t) {
                    this._wheelZoomRate = t
                }

                isEnabled() {
                    return !!this._enabled
                }

                isActive() {
                    return this._active || this._finishTimeout !== void 0
                }

                isZooming() {
                    return !!this._zooming
                }

                enable(t) {
                    this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!t && t.around === "center", this._map._cooperativeGestures && this._addScrollZoomBlocker())
                }

                disable() {
                    this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()))
                }

                wheel(t) {
                    if (!this.isEnabled()) return;
                    if (this._map._cooperativeGestures) {
                        if (!(t.ctrlKey || t.metaKey || this.isZooming() || o.eJ())) return void this._showBlockerAlert();
                        this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer))
                    }
                    let s = t.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;
                    const h = o.q.now(), m = h - (this._lastWheelEventTime || 0);
                    this._lastWheelEventTime = h, s !== 0 && s % Dy == 0 ? this._type = "wheel" : s !== 0 && Math.abs(s) < 4 ? this._type = "trackpad" : m > 400 ? (this._type = null, this._lastValue = s, this._timeout = window.setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(m * s) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, s += this._lastValue)), t.shiftKey && s && (s /= 4), this._type && (this._lastWheelEvent = t, this._delta -= s, this._active || this._start(t)), t.preventDefault()
                }

                _onTimeout(t) {
                    this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t)
                }

                _start(t) {
                    if (!this._delta) return;
                    this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
                    const s = Mt(this._el, t);
                    this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : s, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame())
                }

                renderFrame() {
                    if (!this._frameId || (this._frameId = null, !this.isActive())) return;
                    const t = this._map.transform;
                    this._type === "wheel" && t.projection.wrap && (t._center.lng >= 180 || t._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
                    const s = () => t._terrainEnabled() && this._aroundCoord ? t.computeZoomRelativeTo(this._aroundCoord) : t.zoom;
                    if (this._delta !== 0) {
                        const P = this._type === "wheel" && Math.abs(this._delta) > Dy ? this._wheelZoomRate : this._defaultZoomRate;
                        let M = 2 / (1 + Math.exp(-Math.abs(this._delta * P)));
                        this._delta < 0 && M !== 0 && (M = 1 / M);
                        const k = s(), R = Math.pow(2, k),
                            O = typeof this._targetZoom == "number" ? t.zoomScale(this._targetZoom) : R;
                        this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(O * M))), this._type === "wheel" && (this._startZoom = k, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0
                    }
                    const h = typeof this._targetZoom == "number" ? this._targetZoom : s(), m = this._startZoom,
                        g = this._easing;
                    let v, b = !1;
                    if (this._type === "wheel" && m && g) {
                        const P = Math.min((o.q.now() - this._lastWheelEventTime) / 200, 1), M = g(P);
                        v = o.ai(m, h, M), P < 1 ? this._frameId || (this._frameId = !0) : b = !0
                    } else v = h, b = !0;
                    this._active = !0, b && (this._active = !1, this._finishTimeout = window.setTimeout(() => {
                        this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout
                    }, 200));
                    let S = v - s();
                    return S * this._lastDelta < 0 && (S = 0), {
                        noInertia: !0,
                        needsRenderFrame: !b,
                        zoomDelta: S,
                        around: this._aroundPoint,
                        aroundCoord: this._aroundCoord,
                        originalEvent: this._lastWheelEvent
                    }
                }

                _smoothOutEasing(t) {
                    let s = o.eK;
                    if (this._prevEase) {
                        const h = this._prevEase, m = (o.q.now() - h.start) / h.duration,
                            g = h.easing(m + .01) - h.easing(m), v = .27 / Math.sqrt(g * g + 1e-4) * .01,
                            b = Math.sqrt(.0729 - v * v);
                        s = o.eI(v, b, .25, 1)
                    }
                    return this._prevEase = {start: o.q.now(), duration: t, easing: s}, s
                }

                blur() {
                    this.reset()
                }

                reset() {
                    this._active = !1
                }

                _addScrollZoomBlocker() {
                    this._map && !this._alertContainer && (this._alertContainer = fe("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`)
                }

                _showBlockerAlert() {
                    this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {
                        this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.removeAttribute("role")
                    }, 200)
                }
            }

            class Ln {
                constructor(t, s) {
                    this._clickZoom = t, this._tapZoom = s
                }

                enable() {
                    this._clickZoom.enable(), this._tapZoom.enable()
                }

                disable() {
                    this._clickZoom.disable(), this._tapZoom.disable()
                }

                isEnabled() {
                    return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
                }

                isActive() {
                    return this._clickZoom.isActive() || this._tapZoom.isActive()
                }
            }

            class Ly {
                constructor() {
                    this.reset()
                }

                reset() {
                    this._active = !1
                }

                blur() {
                    this.reset()
                }

                dblclick(t, s) {
                    return t.preventDefault(), {
                        cameraAnimation: h => {
                            h.easeTo({
                                duration: 300,
                                zoom: h.getZoom() + (t.shiftKey ? -1 : 1),
                                around: h.unproject(s)
                            }, {originalEvent: t})
                        }
                    }
                }

                enable() {
                    this._enabled = !0
                }

                disable() {
                    this._enabled = !1, this.reset()
                }

                isEnabled() {
                    return this._enabled
                }

                isActive() {
                    return this._active
                }
            }

            class d1 {
                constructor() {
                    this._tap = new hl({numTouches: 1, numTaps: 1}), this.reset()
                }

                reset() {
                    this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset()
                }

                touchstart(t, s, h) {
                    this._swipePoint || (this._tapTime && t.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? h.length > 0 && (this._swipePoint = s[0], this._swipeTouch = h[0].identifier) : this._tap.touchstart(t, s, h))
                }

                touchmove(t, s, h) {
                    if (this._tapTime) {
                        if (this._swipePoint) {
                            if (h[0].identifier !== this._swipeTouch) return;
                            const m = s[0], g = m.y - this._swipePoint.y;
                            return this._swipePoint = m, t.preventDefault(), this._active = !0, {zoomDelta: g / 128}
                        }
                    } else this._tap.touchmove(t, s, h)
                }

                touchend(t, s, h) {
                    this._tapTime ? this._swipePoint && h.length === 0 && this.reset() : this._tap.touchend(t, s, h) && (this._tapTime = t.timeStamp)
                }

                touchcancel() {
                    this.reset()
                }

                enable() {
                    this._enabled = !0
                }

                disable() {
                    this._enabled = !1, this.reset()
                }

                isEnabled() {
                    return this._enabled
                }

                isActive() {
                    return this._active
                }
            }

            class Bm {
                constructor(t, s, h) {
                    this._el = t, this._mousePan = s, this._touchPan = h
                }

                enable(t) {
                    this._inertiaOptions = t || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan")
                }

                disable() {
                    this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan")
                }

                isEnabled() {
                    return this._mousePan.isEnabled() && this._touchPan.isEnabled()
                }

                isActive() {
                    return this._mousePan.isActive() || this._touchPan.isActive()
                }
            }

            class f1 {
                constructor(t, s, h) {
                    this._pitchWithRotate = t.pitchWithRotate, this._mouseRotate = s, this._mousePitch = h
                }

                enable() {
                    this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable()
                }

                disable() {
                    this._mouseRotate.disable(), this._mousePitch.disable()
                }

                isEnabled() {
                    return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled())
                }

                isActive() {
                    return this._mouseRotate.isActive() || this._mousePitch.isActive()
                }
            }

            class Ih {
                constructor(t, s, h, m) {
                    this._el = t, this._touchZoom = s, this._touchRotate = h, this._tapDragZoom = m, this._rotationDisabled = !1, this._enabled = !0
                }

                enable(t) {
                    this._touchZoom.enable(t), this._rotationDisabled || this._touchRotate.enable(t), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate")
                }

                disable() {
                    this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate")
                }

                isEnabled() {
                    return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
                }

                isActive() {
                    return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
                }

                disableRotation() {
                    this._rotationDisabled = !0, this._touchRotate.disable()
                }

                enableRotation() {
                    this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable()
                }
            }

            const Ch = u => u.zoom || u.drag || u.pitch || u.rotate;

            class Nm extends o.A {
            }

            class uf {
                constructor() {
                    this.constants = [1, 1, .01], this.radius = 0
                }

                setup(t, s) {
                    const h = o.at([], s, t);
                    this.radius = o.ae(h[2] < 0 ? o.eM([], h, this.constants) : [h[0], h[1], 0])
                }

                projectRay(t) {
                    o.eM(t, t, this.constants), o.au(t, t), o.eN(t, t, this.constants);
                    const s = o.c1([], t, this.radius);
                    if (s[2] > 0) {
                        const h = o.c1([], [0, 0, 1], o.bG(s, [0, 0, 1])),
                            m = o.c1([], o.au([], [s[0], s[1], 0]), this.radius),
                            g = o.d5([], s, o.c1([], o.at([], o.d5([], m, h), s), 2));
                        s[0] = g[0], s[1] = g[1]
                    }
                    return s
                }
            }

            function bs(u) {
                return u.panDelta && u.panDelta.mag() || u.zoomDelta || u.bearingDelta || u.pitchDelta
            }

            class hf {
                constructor(t, s) {
                    this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new of(t), this._bearingSnap = s.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new uf, this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(s), o.aV(["handleEvent", "handleWindowEvent"], this);
                    const h = this._el;
                    this._listeners = [[h, "touchstart", {passive: !0}], [h, "touchmove", {passive: !1}], [h, "touchend", void 0], [h, "touchcancel", void 0], [h, "mousedown", void 0], [h, "mousemove", void 0], [h, "mouseup", void 0], [document, "mousemove", {capture: !0}], [document, "mouseup", void 0], [h, "mouseover", void 0], [h, "mouseout", void 0], [h, "dblclick", void 0], [h, "click", void 0], [h, "keydown", {capture: !1}], [h, "keyup", void 0], [h, "wheel", {passive: !1}], [h, "contextmenu", void 0], [window, "blur", void 0]];
                    for (const [m, g, v] of this._listeners) {
                        const b = m === document ? this.handleWindowEvent : this.handleEvent;
                        m.addEventListener(g, b, v)
                    }
                }

                destroy() {
                    for (const [t, s, h] of this._listeners) {
                        const m = t === document ? this.handleWindowEvent : this.handleEvent;
                        t.removeEventListener(s, m, h)
                    }
                }

                _addDefaultHandlers(t) {
                    const s = this._map, h = s.getCanvasContainer();
                    this._add("mapEvent", new Pm(s, t));
                    const m = s.boxZoom = new Mm(s, t);
                    this._add("boxZoom", m);
                    const g = new zm, v = new Ly;
                    s.doubleClickZoom = new Ln(v, g), this._add("tapZoom", g), this._add("clickZoom", v);
                    const b = new d1;
                    this._add("tapDragZoom", b);
                    const S = s.touchPitch = new Py(s);
                    this._add("touchPitch", S);
                    const P = new af(t), M = new km(t);
                    s.dragRotate = new f1(t, P, M), this._add("mouseRotate", P, ["mousePitch"]), this._add("mousePitch", M, ["mouseRotate"]);
                    const k = new Lm(t), R = new Ay(s, t);
                    s.dragPan = new Bm(h, k, R), this._add("mousePan", k), this._add("touchPan", R, ["touchZoom", "touchRotate"]);
                    const O = new Cy, V = new Iy;
                    s.touchZoomRotate = new Ih(h, V, O, b), this._add("touchRotate", O, ["touchPan", "touchZoom"]), this._add("touchZoom", V, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new Xl(s));
                    const B = s.scrollZoom = new h1(s, this);
                    this._add("scrollZoom", B, ["mousePan"]);
                    const G = s.keyboard = new Ry;
                    this._add("keyboard", G);
                    for (const U of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]) t.interactive && t[U] && s[U].enable(t[U])
                }

                _add(t, s, h) {
                    this._handlers.push({handlerName: t, handler: s, allowed: h}), this._handlersById[t] = s
                }

                stop(t) {
                    if (!this._updatingCamera) {
                        for (const {handler: s} of this._handlers) s.reset();
                        this._inertia.clear(), this._fireEvents({}, {}, t), this._changes = [], this._originalZoom = void 0
                    }
                }

                isActive() {
                    for (const {handler: t} of this._handlers) if (t.isActive()) return !0;
                    return !1
                }

                isZooming() {
                    return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
                }

                isRotating() {
                    return !!this._eventsInProgress.rotate
                }

                isMoving() {
                    return !!Ch(this._eventsInProgress) || this.isZooming()
                }

                _isDragging() {
                    return !!this._eventsInProgress.drag
                }

                _blockedByActive(t, s, h) {
                    for (const m in t) if (m !== h && (!s || s.indexOf(m) < 0)) return !0;
                    return !1
                }

                handleWindowEvent(t) {
                    this.handleEvent(t, `${t.type}Window`)
                }

                _getMapTouches(t) {
                    const s = [];
                    for (const h of t) this._el.contains(h.target) && s.push(h);
                    return s
                }

                handleEvent(t, s) {
                    this._updatingCamera = !0;
                    const h = t.type === "renderFrame", m = h ? void 0 : t, g = {needsRenderFrame: !1}, v = {}, b = {},
                        S = t.touches ? this._getMapTouches(t.touches) : void 0,
                        P = S ? Xt(this._el, S) : h ? void 0 : Mt(this._el, t);
                    for (const {handlerName: R, handler: O, allowed: V} of this._handlers) {
                        if (!O.isEnabled()) continue;
                        let B;
                        this._blockedByActive(b, V, R) ? O.reset() : O[s || t.type] && (B = O[s || t.type](t, P, S), this.mergeHandlerResult(g, v, B, R, m), B && B.needsRenderFrame && this._triggerRenderFrame()), (B || O.isActive()) && (b[R] = O)
                    }
                    const M = {};
                    for (const R in this._previousActiveHandlers) b[R] || (M[R] = m);
                    this._previousActiveHandlers = b, (Object.keys(M).length || bs(g)) && (this._changes.push([g, v, M]), this._triggerRenderFrame()), (Object.keys(b).length || bs(g)) && this._map._stop(!0), this._updatingCamera = !1;
                    const {cameraAnimation: k} = g;
                    k && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], k(this._map))
                }

                mergeHandlerResult(t, s, h, m, g) {
                    if (!h) return;
                    o.h(t, h);
                    const v = {handlerName: m, originalEvent: h.originalEvent || g};
                    h.zoomDelta !== void 0 && (s.zoom = v), h.panDelta !== void 0 && (s.drag = v), h.pitchDelta !== void 0 && (s.pitch = v), h.bearingDelta !== void 0 && (s.rotate = v)
                }

                _applyChanges() {
                    const t = {}, s = {}, h = {};
                    for (const [m, g, v] of this._changes) m.panDelta && (t.panDelta = (t.panDelta || new o.P(0, 0))._add(m.panDelta)), m.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + m.zoomDelta), m.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + m.bearingDelta), m.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + m.pitchDelta), m.around !== void 0 && (t.around = m.around), m.aroundCoord !== void 0 && (t.aroundCoord = m.aroundCoord), m.pinchAround !== void 0 && (t.pinchAround = m.pinchAround), m.noInertia && (t.noInertia = m.noInertia), o.h(s, g), o.h(h, v);
                    this._updateMapTransform(t, s, h), this._changes = []
                }

                _updateMapTransform(t, s, h) {
                    const m = this._map, g = m.transform, v = Z => [Z.x, Z.y, Z.z];
                    if ((Z => {
                        const Q = this._eventsInProgress.drag;
                        return Q && !this._handlersById[Q.handlerName].isActive()
                    })() && !bs(t)) {
                        const Z = g.zoom;
                        g.cameraElevationReference = "sea", this._originalZoom != null && g._orthographicProjectionAtLowPitch && g.projection.name !== "globe" && g.pitch === 0 ? (g.cameraElevationReference = "ground", g.zoom = this._originalZoom) : (g.recenterOnTerrain(), g.cameraElevationReference = "ground"), Z !== g.zoom && this._map._update(!0)
                    }
                    if (g._isCameraConstrained && m._stop(!0), !bs(t)) return void this._fireEvents(s, h, !0);
                    let {
                        panDelta: b,
                        zoomDelta: S,
                        bearingDelta: P,
                        pitchDelta: M,
                        around: k,
                        aroundCoord: R,
                        pinchAround: O
                    } = t;
                    g._isCameraConstrained && (S > 0 && (S = 0), g._isCameraConstrained = !1), O !== void 0 && (k = O), (S || (Z => s[Z] && !this._eventsInProgress[Z])("drag")) && k && (this._dragOrigin = v(g.pointCoordinate3D(k)), this._originalZoom = g.zoom, this._trackingEllipsoid.setup(g._camera.position, this._dragOrigin)), g.cameraElevationReference = "sea", m._stop(!0), k = k || m.transform.centerPoint, P && (g.bearing += P), M && (g.pitch += M), g._updateCameraState();
                    const V = [0, 0, 0];
                    if (b) if (g.projection.name === "mercator") {
                        const Z = this._trackingEllipsoid.projectRay(g.screenPointToMercatorRay(k).dir),
                            Q = this._trackingEllipsoid.projectRay(g.screenPointToMercatorRay(k.sub(b)).dir);
                        V[0] = Q[0] - Z[0], V[1] = Q[1] - Z[1]
                    } else {
                        const Z = g.pointCoordinate(k);
                        if (g.projection.name === "globe") {
                            b = b.rotate(-g.angle);
                            const Q = g._pixelsPerMercatorPixel / g.worldSize;
                            V[0] = -b.x * o.eL(o.aY(Z.y)) * Q, V[1] = -b.y * o.eL(g.center.lat) * Q
                        } else {
                            const Q = g.pointCoordinate(k.sub(b));
                            Z && Q && (V[0] = Q.x - Z.x, V[1] = Q.y - Z.y)
                        }
                    }
                    const B = g.zoom, G = [0, 0, 0];
                    if (S) {
                        const Z = v(R || g.pointCoordinate3D(k)), Q = {dir: o.au([], o.at([], Z, g._camera.position))};
                        if (Q.dir[2] < 0) {
                            const te = g.zoomDeltaToMovement(Z, S);
                            o.c1(G, Q.dir, te)
                        }
                    }
                    const U = o.d5(V, V, G);
                    g._translateCameraConstrained(U), S && Math.abs(g.zoom - B) > 1e-4 && g.recenterOnTerrain(), g.cameraElevationReference = "ground", this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(s, h, !0)
                }

                _fireEvents(t, s, h) {
                    const m = Ch(this._eventsInProgress), g = Ch(t), v = {};
                    for (const M in t) {
                        const {originalEvent: k} = t[M];
                        this._eventsInProgress[M] || (v[`${M}start`] = k), this._eventsInProgress[M] = t[M]
                    }
                    !m && g && this._fireEvent("movestart", g.originalEvent);
                    for (const M in v) this._fireEvent(M, v[M]);
                    g && this._fireEvent("move", g.originalEvent);
                    for (const M in t) {
                        const {originalEvent: k} = t[M];
                        this._fireEvent(M, k)
                    }
                    const b = {};
                    let S;
                    for (const M in this._eventsInProgress) {
                        const {handlerName: k, originalEvent: R} = this._eventsInProgress[M];
                        this._handlersById[k].isActive() || (delete this._eventsInProgress[M], S = s[k] || R, b[`${M}end`] = S)
                    }
                    for (const M in b) this._fireEvent(M, b[M]);
                    const P = Ch(this._eventsInProgress);
                    if (h && (m || g) && !P) {
                        this._updatingCamera = !0;
                        const M = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),
                            k = R => R !== 0 && -this._bearingSnap < R && R < this._bearingSnap;
                        M ? (k(M.bearing || this._map.getBearing()) && (M.bearing = 0), this._map.easeTo(M, {originalEvent: S})) : (this._map.fire(new o.A("moveend", {originalEvent: S})), k(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1
                    }
                }

                _fireEvent(t, s) {
                    this._map.fire(new o.A(t, s ? {originalEvent: s} : {}))
                }

                _requestFrame() {
                    return this._map.triggerRepaint(), this._map._renderTaskQueue.add(t => {
                        this._frameId = void 0, this.handleEvent(new Nm("renderFrame", {timeStamp: t})), this._applyChanges()
                    })
                }

                _triggerRenderFrame() {
                    this._frameId === void 0 && (this._frameId = this._requestFrame())
                }
            }

            const tr = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";

            class ta extends o.E {
                constructor(t, s) {
                    super(), this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = s.bearingSnap, this._respectPrefersReducedMotion = s.respectPrefersReducedMotion !== !1, o.aV(["_renderFrameCallback"], this)
                }

                getCenter() {
                    return new o.ci(this.transform.center.lng, this.transform.center.lat)
                }

                setCenter(t, s) {
                    return this.jumpTo({center: t}, s)
                }

                panBy(t, s, h) {
                    return t = o.P.convert(t).mult(-1), this.panTo(this.transform.center, o.h({offset: t}, s), h)
                }

                panTo(t, s, h) {
                    return this.easeTo(o.h({center: t}, s), h)
                }

                getZoom() {
                    return this.transform.zoom
                }

                setZoom(t, s) {
                    return this.jumpTo({zoom: t}, s), this
                }

                zoomTo(t, s, h) {
                    return this.easeTo(o.h({zoom: t}, s), h)
                }

                zoomIn(t, s) {
                    return this.zoomTo(this.getZoom() + 1, t, s), this
                }

                zoomOut(t, s) {
                    return this.zoomTo(this.getZoom() - 1, t, s), this
                }

                getBearing() {
                    return this.transform.bearing
                }

                setBearing(t, s) {
                    return this.jumpTo({bearing: t}, s), this
                }

                getPadding() {
                    return this.transform.padding
                }

                setPadding(t, s) {
                    return this.jumpTo({padding: t}, s), this
                }

                rotateTo(t, s, h) {
                    return this.easeTo(o.h({bearing: t}, s), h)
                }

                resetNorth(t, s) {
                    return this.rotateTo(0, o.h({duration: 1e3}, t), s), this
                }

                resetNorthPitch(t, s) {
                    return this.easeTo(o.h({bearing: 0, pitch: 0, duration: 1e3}, t), s), this
                }

                snapToNorth(t, s) {
                    return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, s) : this
                }

                getPitch() {
                    return this.transform.pitch
                }

                setPitch(t, s) {
                    return this.jumpTo({pitch: t}, s), this
                }

                cameraForBounds(t, s) {
                    t = o.aG.convert(t);
                    const h = s && s.bearing || 0, m = s && s.pitch || 0, g = t.getNorthWest(), v = t.getSouthEast();
                    return this._cameraForBounds(this.transform, g, v, h, m, s)
                }

                _extendPadding(t) {
                    const s = {top: 0, right: 0, bottom: 0, left: 0};
                    return t == null ? o.h({}, s, this.transform.padding) : typeof t == "number" ? {
                        top: t,
                        bottom: t,
                        right: t,
                        left: t
                    } : o.h({}, s, t)
                }

                _extendCameraOptions(t) {
                    return (t = o.h({
                        offset: [0, 0],
                        maxZoom: this.transform.maxZoom
                    }, t)).padding = this._extendPadding(t.padding), t
                }

                _minimumAABBFrustumDistance(t, s) {
                    const h = s.max[0] - s.min[0], m = s.max[1] - s.min[1];
                    return h / m > t.aspect ? h / (2 * Math.tan(.5 * t.fovX) * t.aspect) : m / (2 * Math.tan(.5 * t.fovY) * t.aspect)
                }

                _cameraForBoundsOnGlobe(t, s, h, m, g, v) {
                    const b = t.clone(), S = this._extendCameraOptions(v);
                    b.bearing = m, b.pitch = g;
                    const P = o.ci.convert(s), M = o.ci.convert(h), k = .5 * (P.lat + M.lat), R = .5 * (P.lng + M.lng),
                        O = o.eO(k, R), V = o.au([], O), B = o.au([], o.bF([], V, [0, 1, 0])), G = o.bF([], B, V),
                        U = [B[0], B[1], B[2], 0, G[0], G[1], G[2], 0, V[0], V[1], V[2], 0, 0, 0, 0, 1],
                        Z = [O, o.eO(P.lat, P.lng), o.eO(M.lat, P.lng), o.eO(M.lat, M.lng), o.eO(P.lat, M.lng), o.eO(k, P.lng), o.eO(k, M.lng), o.eO(P.lat, R), o.eO(M.lat, R)];
                    let Q = o.d6.fromPoints(Z.map(Be => [o.bG(B, Be), o.bG(G, Be), o.bG(V, Be)]));
                    const te = o.ad([], Q.center, U);
                    o.eP(te) === 0 && o.eQ(te, 0, 0, 1), o.au(te, te), o.c1(te, te, o.aB), b.center = o.eR(te);
                    const ce = b.getWorldToCameraMatrix(), _e = o.bi(new Float64Array(16), ce);
                    Q = o.d6.applyTransform(Q, o.az([], ce, U));
                    const ve = this._extendAABB(Q, b, S, m);
                    if (!ve) return void o.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
                    Q = ve, o.ad(te, te, ce);
                    const ue = .5 * (Q.max[2] - Q.min[2]), he = this._minimumAABBFrustumDistance(b, Q),
                        me = o.c1([], [0, 0, 1], ue), Oe = o.d5(me, te, me),
                        Se = he + (b.pitch === 0 ? 0 : o.bD(te, Oe)), Xe = b.globeCenterInViewSpace,
                        je = o.at([], te, [Xe[0], Xe[1], Xe[2]]);
                    o.au(je, je), o.c1(je, je, Se);
                    const Ke = o.d5([], te, je);
                    o.ad(Ke, Ke, _e);
                    const ut = o.eB / o.aB, Fe = o.ae(Ke), Te = o.cb(Math.max(Fe * ut - o.eB, Number.EPSILON), 0),
                        $e = Math.min(b.zoomFromMercatorZAdjusted(Te), S.maxZoom);
                    return $e > .5 * (o.cX + o.cI) ? (b.setProjection({name: "mercator"}), b.zoom = $e, this._cameraForBounds(b, s, h, m, g, v)) : {
                        center: b.center,
                        zoom: $e,
                        bearing: m,
                        pitch: g
                    }
                }

                _extendAABB(t, s, h, m) {
                    const g = .5 * ((h.padding.left || 0) + (h.padding.right || 0)),
                        v = .5 * ((h.padding.top || 0) + (h.padding.bottom || 0)), b = v, S = g, P = g, M = v,
                        k = s.width - (S + P), R = s.height - (b + M), O = o.at([], t.max, t.min),
                        V = Math.min(k / O[0], R / O[1]), B = Math.min(s.scaleZoom(s.scale * V), h.maxZoom);
                    if (isNaN(B)) return null;
                    const G = s.scale / s.zoomScale(B),
                        U = new o.d6([t.min[0] - S * G, t.min[1] - M * G, t.min[2]], [t.max[0] + P * G, t.max[1] + b * G, t.max[2]]),
                        Z = (typeof h.offset.x == "number" && typeof h.offset.y == "number" ? new o.P(h.offset.x, h.offset.y) : o.P.convert(h.offset)).rotate(-o.al(m));
                    return U.center[0] -= Z.x * G, U.center[1] += Z.y * G, U
                }

                queryTerrainElevation(t, s) {
                    const h = this.transform.elevation;
                    return h ? (s = o.h({}, {exaggerated: !0}, s), h.getAtPoint(o.ac.fromLngLat(t), null, s.exaggerated)) : null
                }

                _cameraForBounds(t, s, h, m, g, v) {
                    if (t.projection.name === "globe") return this._cameraForBoundsOnGlobe(t, s, h, m, g, v);
                    const b = t.clone(), S = this._extendCameraOptions(v);
                    b.bearing = m, b.pitch = g;
                    const P = o.ci.convert(s), M = o.ci.convert(h), k = new o.ci(P.lng, M.lat),
                        R = new o.ci(M.lng, P.lat), O = b.project(P), V = b.project(M),
                        B = this.queryTerrainElevation(P), G = this.queryTerrainElevation(M),
                        U = this.queryTerrainElevation(k), Z = this.queryTerrainElevation(R),
                        Q = [[O.x, O.y, Math.min(B || 0, G || 0, U || 0, Z || 0)], [V.x, V.y, Math.max(B || 0, G || 0, U || 0, Z || 0)]];
                    let te = o.d6.fromPoints(Q);
                    const ce = b.getWorldToCameraMatrix(), _e = o.bi(new Float64Array(16), ce);
                    te = o.d6.applyTransform(te, ce);
                    const ve = this._extendAABB(te, b, S, m);
                    if (!ve) return void o.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
                    te = ve;
                    const ue = .5 * o.at([], te.max, te.min)[2], he = this._minimumAABBFrustumDistance(b, te),
                        me = [0, 0, 1, 0];
                    o.aA(me, me, ce), o.eS(me, me);
                    const Oe = o.c1([], me, he + ue), Se = o.d5([], te.center, Oe);
                    o.ad(te.center, te.center, _e), o.ad(Se, Se, _e);
                    const Xe = b.unproject(new o.P(te.center[0], te.center[1])), je = o.eT(b.projection, Xe),
                        Ke = Math.pow(2, je),
                        ut = Math.min(b._zoomFromMercatorZ(Se[2] * b.pixelsPerMeter * Ke / b.worldSize), S.maxZoom);
                    return b.mercatorFromTransition && ut < .5 * (o.cX + o.cI) ? (b.setProjection({name: "globe"}), b.zoom = ut, this._cameraForBounds(b, s, h, m, g, v)) : {
                        center: Xe,
                        zoom: ut,
                        bearing: m,
                        pitch: g
                    }
                }

                fitBounds(t, s, h) {
                    const m = this.cameraForBounds(t, s);
                    return this._fitInternal(m, s, h)
                }

                fitScreenCoordinates(t, s, h, m, g) {
                    const v = o.P.convert(t), b = o.P.convert(s), S = new o.P(Math.min(v.x, b.x), Math.min(v.y, b.y)),
                        P = new o.P(Math.max(v.x, b.x), Math.max(v.y, b.y));
                    if (this.transform.projection.name === "mercator" && this.transform.anyCornerOffEdge(v, b)) return this;
                    const M = this.transform.pointLocation3D(S), k = this.transform.pointLocation3D(P),
                        R = this.transform.pointLocation3D(new o.P(S.x, P.y)),
                        O = this.transform.pointLocation3D(new o.P(P.x, S.y)),
                        V = [Math.min(M.lng, k.lng, R.lng, O.lng), Math.min(M.lat, k.lat, R.lat, O.lat)],
                        B = [Math.max(M.lng, k.lng, R.lng, O.lng), Math.max(M.lat, k.lat, R.lat, O.lat)],
                        G = m && m.pitch ? m.pitch : this.getPitch(),
                        U = this._cameraForBounds(this.transform, V, B, h, G, m);
                    return this._fitInternal(U, m, g)
                }

                _fitInternal(t, s, h) {
                    return t ? (s = o.h(t, s)).linear ? this.easeTo(s, h) : this.flyTo(s, h) : this
                }

                jumpTo(t, s) {
                    this.stop();
                    const h = t.preloadOnly ? this.transform.clone() : this.transform;
                    let m = !1, g = !1, v = !1;
                    "zoom" in t && h.zoom !== +t.zoom && (m = !0, h.zoom = +t.zoom), t.center !== void 0 && (h.center = o.ci.convert(t.center)), "bearing" in t && h.bearing !== +t.bearing && (g = !0, h.bearing = +t.bearing), "pitch" in t && h.pitch !== +t.pitch && (v = !0, h.pitch = +t.pitch);
                    const b = typeof t.padding == "number" ? this._extendPadding(t.padding) : t.padding;
                    if (t.padding != null && !h.isPaddingEqual(b)) if (t.retainPadding === !1) {
                        const S = h.clone();
                        S.padding = b, h.setLocationAtPoint(h.center, S.centerPoint)
                    } else h.padding = b;
                    return t.preloadOnly ? (this._preloadTiles(h), this) : (this.fire(new o.A("movestart", s)).fire(new o.A("move", s)), m && this.fire(new o.A("zoomstart", s)).fire(new o.A("zoom", s)).fire(new o.A("zoomend", s)), g && this.fire(new o.A("rotatestart", s)).fire(new o.A("rotate", s)).fire(new o.A("rotateend", s)), v && this.fire(new o.A("pitchstart", s)).fire(new o.A("pitch", s)).fire(new o.A("pitchend", s)), this.fire(new o.A("moveend", s)))
                }

                getFreeCameraOptions() {
                    return this.transform.projection.supportsFreeCamera || o.w(tr), this.transform.getFreeCameraOptions()
                }

                setFreeCameraOptions(t, s) {
                    const h = this.transform;
                    if (!h.projection.supportsFreeCamera) return o.w(tr), this;
                    this.stop();
                    const m = h.zoom, g = h.pitch, v = h.bearing;
                    h.setFreeCameraOptions(t);
                    const b = m !== h.zoom, S = g !== h.pitch, P = v !== h.bearing;
                    return this.fire(new o.A("movestart", s)).fire(new o.A("move", s)), b && this.fire(new o.A("zoomstart", s)).fire(new o.A("zoom", s)).fire(new o.A("zoomend", s)), P && this.fire(new o.A("rotatestart", s)).fire(new o.A("rotate", s)).fire(new o.A("rotateend", s)), S && this.fire(new o.A("pitchstart", s)).fire(new o.A("pitch", s)).fire(new o.A("pitchend", s)), this.fire(new o.A("moveend", s)), this
                }

                easeTo(t, s) {
                    this._stop(!1, t.easeId), ((t = o.h({
                        offset: [0, 0],
                        duration: 500,
                        easing: o.eK
                    }, t)).animate === !1 || this._prefersReducedMotion(t)) && (t.duration = 0);
                    const h = this.transform, m = this.getZoom(), g = this.getBearing(), v = this.getPitch(),
                        b = this.getPadding(), S = "zoom" in t ? +t.zoom : m,
                        P = "bearing" in t ? this._normalizeBearing(t.bearing, g) : g, M = "pitch" in t ? +t.pitch : v,
                        k = this._extendPadding(t.padding), R = o.P.convert(t.offset);
                    let O, V, B;
                    if (h.projection.name === "globe") {
                        const me = o.ac.fromLngLat(h.center), Oe = R.rotate(-h.angle);
                        me.x += Oe.x / h.worldSize, me.y += Oe.y / h.worldSize;
                        const Se = me.toLngLat(), Xe = o.ci.convert(t.center || Se);
                        this._normalizeCenter(Xe), O = h.centerPoint.add(Oe), V = new o.P(me.x, me.y).mult(h.worldSize), B = new o.P(o.aD(Xe.lng), o.aH(Xe.lat)).mult(h.worldSize).sub(V)
                    } else {
                        O = h.centerPoint.add(R);
                        const me = h.pointLocation(O), Oe = o.ci.convert(t.center || me);
                        this._normalizeCenter(Oe), V = h.project(me), B = h.project(Oe).sub(V)
                    }
                    const G = h.zoomScale(S - m);
                    let U, Z;
                    t.around && (U = o.ci.convert(t.around), Z = h.locationPoint(U));
                    const Q = this._zooming || S !== m, te = this._rotating || g !== P, ce = this._pitching || M !== v,
                        _e = !h.isPaddingEqual(k), ve = t.retainPadding === !1 ? h.clone() : h, ue = me => Oe => {
                            if (Q && (me.zoom = o.ai(m, S, Oe)), te && (me.bearing = o.ai(g, P, Oe)), ce && (me.pitch = o.ai(v, M, Oe)), _e && (ve.interpolatePadding(b, k, Oe), O = ve.centerPoint.add(R)), U) me.setLocationAtPoint(U, Z); else {
                                const Se = me.zoomScale(me.zoom - m), Xe = S > m ? Math.min(2, G) : Math.max(.5, G),
                                    je = Math.pow(Xe, 1 - Oe), Ke = me.unproject(V.add(B.mult(Oe * je)).mult(Se));
                                me.setLocationAtPoint(me.renderWorldCopies ? Ke.wrap() : Ke, O)
                            }
                            return t.preloadOnly || this._fireMoveEvents(s), me
                        };
                    if (t.preloadOnly) {
                        const me = this._emulate(ue, t.duration, h);
                        return this._preloadTiles(me), this
                    }
                    const he = {
                        moving: this._moving,
                        zooming: this._zooming,
                        rotating: this._rotating,
                        pitching: this._pitching
                    };
                    return this._zooming = Q, this._rotating = te, this._pitching = ce, this._padding = _e, this._easeId = t.easeId, this._prepareEase(s, t.noMoveStart, he), this._ease(ue(h), me => {
                        h.cameraElevationReference === "sea" && h.recenterOnTerrain(), this._afterEase(s, me)
                    }, t), this
                }

                _prepareEase(t, s, h = {}) {
                    this._moving = !0, this.transform.cameraElevationReference = "sea", this.transform._orthographicProjectionAtLowPitch && this.transform.pitch === 0 && this.transform.projection.name !== "globe" && (this.transform.cameraElevationReference = "ground"), s || h.moving || this.fire(new o.A("movestart", t)), this._zooming && !h.zooming && this.fire(new o.A("zoomstart", t)), this._rotating && !h.rotating && this.fire(new o.A("rotatestart", t)), this._pitching && !h.pitching && this.fire(new o.A("pitchstart", t))
                }

                _fireMoveEvents(t) {
                    this.fire(new o.A("move", t)), this._zooming && this.fire(new o.A("zoom", t)), this._rotating && this.fire(new o.A("rotate", t)), this._pitching && this.fire(new o.A("pitch", t))
                }

                _afterEase(t, s) {
                    if (this._easeId && s && this._easeId === s) return;
                    this._easeId = void 0, this.transform.cameraElevationReference = "ground";
                    const h = this._zooming, m = this._rotating, g = this._pitching;
                    this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, h && this.fire(new o.A("zoomend", t)), m && this.fire(new o.A("rotateend", t)), g && this.fire(new o.A("pitchend", t)), this.fire(new o.A("moveend", t))
                }

                flyTo(t, s) {
                    if (this._prefersReducedMotion(t)) {
                        const Be = o.aF(t, ["center", "zoom", "bearing", "pitch", "around", "padding", "retainPadding"]);
                        return this.jumpTo(Be, s)
                    }
                    this.stop(), t = o.h({offset: [0, 0], speed: 1.2, curve: 1.42, easing: o.eK}, t);
                    const h = this.transform, m = this.getZoom(), g = this.getBearing(), v = this.getPitch(),
                        b = this.getPadding(), S = "zoom" in t ? o.ay(+t.zoom, h.minZoom, h.maxZoom) : m,
                        P = "bearing" in t ? this._normalizeBearing(t.bearing, g) : g, M = "pitch" in t ? +t.pitch : v,
                        k = this._extendPadding(t.padding), R = h.zoomScale(S - m), O = o.P.convert(t.offset);
                    let V = h.centerPoint.add(O);
                    const B = h.pointLocation(V), G = o.ci.convert(t.center || B);
                    this._normalizeCenter(G);
                    const U = h.project(B), Z = h.project(G).sub(U);
                    let Q = t.curve;
                    const te = Math.max(h.width, h.height), ce = te / R, _e = Z.mag();
                    if ("minZoom" in t) {
                        const Be = o.ay(Math.min(t.minZoom, m, S), h.minZoom, h.maxZoom), tt = te / h.zoomScale(Be - m);
                        Q = Math.sqrt(tt / _e * 2)
                    }
                    const ve = Q * Q;

                    function ue(Be) {
                        const tt = (ce * ce - te * te + (Be ? -1 : 1) * ve * ve * _e * _e) / (2 * (Be ? ce : te) * ve * _e);
                        return Math.log(Math.sqrt(tt * tt + 1) - tt)
                    }

                    function he(Be) {
                        return (Math.exp(Be) - Math.exp(-Be)) / 2
                    }

                    function me(Be) {
                        return (Math.exp(Be) + Math.exp(-Be)) / 2
                    }

                    const Oe = ue(0);
                    let Se = function (Be) {
                        return me(Oe) / me(Oe + Q * Be)
                    }, Xe = function (Be) {
                        return te * ((me(Oe) * (he(tt = Oe + Q * Be) / me(tt)) - he(Oe)) / ve) / _e;
                        var tt
                    }, je = (ue(1) - Oe) / Q;
                    if (Math.abs(_e) < 1e-6 || !isFinite(je)) {
                        if (Math.abs(te - ce) < 1e-6) return this.easeTo(t, s);
                        const Be = ce < te ? -1 : 1;
                        je = Math.abs(Math.log(ce / te)) / Q, Xe = function () {
                            return 0
                        }, Se = function (tt) {
                            return Math.exp(Be * Q * tt)
                        }
                    }
                    t.duration = "duration" in t ? +t.duration : 1e3 * je / ("screenSpeed" in t ? +t.screenSpeed / Q : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0);
                    const Ke = g !== P, ut = M !== v, Fe = !h.isPaddingEqual(k),
                        Te = t.retainPadding === !1 ? h.clone() : h, $e = Be => tt => {
                            const it = tt * je, rt = 1 / Se(it);
                            Be.zoom = tt === 1 ? S : m + Be.scaleZoom(rt), Ke && (Be.bearing = o.ai(g, P, tt)), ut && (Be.pitch = o.ai(v, M, tt)), Fe && (Te.interpolatePadding(b, k, tt), V = Te.centerPoint.add(O));
                            const gt = tt === 1 ? G : Be.unproject(U.add(Z.mult(Xe(it))).mult(rt));
                            return Be.setLocationAtPoint(Be.renderWorldCopies ? gt.wrap() : gt, V), Be._updateCameraOnTerrain(), t.preloadOnly || this._fireMoveEvents(s), Be
                        };
                    if (t.preloadOnly) {
                        const Be = this._emulate($e, t.duration, h);
                        return this._preloadTiles(Be), this
                    }
                    return this._zooming = !0, this._rotating = Ke, this._pitching = ut, this._padding = Fe, this._prepareEase(s, !1), this._ease($e(h), () => this._afterEase(s), t), this
                }

                isEasing() {
                    return !!this._easeFrameId
                }

                stop() {
                    return this._stop()
                }

                _requestRenderFrame(t) {
                }

                _cancelRenderFrame(t) {
                }

                _stop(t, s) {
                    if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
                        const h = this._onEaseEnd;
                        this._onEaseEnd = void 0, h.call(this, s)
                    }
                    if (!t) {
                        const h = this.handlers;
                        h && h.stop(!1)
                    }
                    return this
                }

                _ease(t, s, h) {
                    h.animate === !1 || h.duration === 0 ? (t(1), s()) : (this._easeStart = o.q.now(), this._easeOptions = h, this._onEaseFrame = t, this._onEaseEnd = s, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
                }

                _renderFrameCallback() {
                    const t = Math.min((o.q.now() - this._easeStart) / this._easeOptions.duration, 1),
                        s = this._onEaseFrame;
                    s && s(this._easeOptions.easing(t)), t < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
                }

                _normalizeBearing(t, s) {
                    t = o.bQ(t, -180, 180);
                    const h = Math.abs(t - s);
                    return Math.abs(t - 360 - s) < h && (t -= 360), Math.abs(t + 360 - s) < h && (t += 360), t
                }

                _normalizeCenter(t) {
                    const s = this.transform;
                    if (s.maxBounds || s.projection.name !== "globe" && !s.renderWorldCopies) return;
                    const h = t.lng - s.center.lng;
                    t.lng += h > 180 ? -360 : h < -180 ? 360 : 0
                }

                _prefersReducedMotion(t) {
                    return this._respectPrefersReducedMotion && o.q.prefersReducedMotion && !(t && t.essential)
                }

                _emulate(t, s, h) {
                    const m = Math.ceil(15 * s / 1e3), g = [], v = t(h.clone());
                    for (let b = 0; b <= m; b++) {
                        const S = v(b / m);
                        g.push(S.clone())
                    }
                    return g
                }

                _preloadTiles(t, s) {
                }
            }

            class Xc {
                constructor(t = {}) {
                    this.options = t, o.aV(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this)
                }

                getDefaultPosition() {
                    return "bottom-right"
                }

                onAdd(t) {
                    const s = this.options && this.options.compact,
                        h = t._getUIString("AttributionControl.ToggleAttribution");
                    this._map = t, this._container = fe("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = fe("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._compactButton.setAttribute("aria-label", h);
                    const m = fe("span", "mapboxgl-ctrl-icon", this._compactButton);
                    return m.setAttribute("aria-hidden", "true"), m.setAttribute("title", h), this._innerContainer = fe("div", "mapboxgl-ctrl-attrib-inner", this._container), s && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), s === void 0 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container
                }

                onRemove() {
                    this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0
                }

                _toggleAttribution() {
                    this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"))
                }

                _updateEditLink() {
                    let t = this._editLink;
                    t || (t = this._editLink = this._container.querySelector(".mapbox-improve-map"));
                    const s = [{key: "owner", value: this.styleOwner}, {
                        key: "id",
                        value: this.styleId
                    }, {key: "access_token", value: this._map._requestManager._customAccessToken || o.e.ACCESS_TOKEN}];
                    if (t) {
                        const h = s.reduce((m, g, v) => (g.value && (m += `${g.key}=${g.value}${v < s.length - 1 ? "&" : ""}`), m), "?");
                        t.href = `${o.e.FEEDBACK_URL}/${h}#${rf(this._map, !0)}`, t.rel = "noopener nofollow"
                    }
                }

                _updateData(t) {
                    !t || t.sourceDataType !== "metadata" && t.sourceDataType !== "visibility" && t.dataType !== "style" || (this._updateAttributions(), this._updateEditLink())
                }

                _updateAttributions() {
                    if (!this._map.style) return;
                    let t = [];
                    if (this._map.style.stylesheet) {
                        const m = this._map.style.stylesheet;
                        this.styleOwner = m.owner, this.styleId = m.id
                    }
                    const s = this._map.style._mergedSourceCaches;
                    for (const m in s) {
                        const g = s[m];
                        if (g.used) {
                            const v = g.getSource();
                            v.attribution && t.indexOf(v.attribution) < 0 && t.push(v.attribution)
                        }
                    }
                    t.sort((m, g) => m.length - g.length), t = t.filter((m, g) => {
                        for (let v = g + 1; v < t.length; v++) if (t[v].indexOf(m) >= 0) return !1;
                        return !0
                    }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = [...this.options.customAttribution, ...t] : t.unshift(this.options.customAttribution));
                    const h = t.join(" | ");
                    h !== this._attribHTML && (this._attribHTML = h, t.length ? (this._innerContainer.innerHTML = h, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null)
                }

                _updateCompact() {
                    this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show")
                }
            }

            class Ph {
                constructor() {
                    o.aV(["_updateLogo", "_updateCompact"], this)
                }

                onAdd(t) {
                    this._map = t, this._container = fe("div", "mapboxgl-ctrl");
                    const s = fe("a", "mapboxgl-ctrl-logo");
                    return s.target = "_blank", s.rel = "noopener nofollow", s.href = "https://www.mapbox.com/", s.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), s.setAttribute("rel", "noopener nofollow"), this._container.appendChild(s), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container
                }

                onRemove() {
                    this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact)
                }

                getDefaultPosition() {
                    return "bottom-left"
                }

                _updateLogo(t) {
                    t && t.sourceDataType !== "metadata" || (this._container.style.display = this._logoRequired() ? "block" : "none")
                }

                _logoRequired() {
                    if (!this._map.style) return !0;
                    const t = this._map.style._sourceCaches;
                    if (Object.entries(t).length === 0) return !0;
                    for (const s in t) {
                        const h = t[s].getSource();
                        if (h.hasOwnProperty("mapbox_logo") && !h.mapbox_logo) return !1
                    }
                    return !0
                }

                _updateCompact() {
                    const t = this._container.children;
                    if (t.length) {
                        const s = t[0];
                        this._map.getCanvasContainer().offsetWidth < 250 ? s.classList.add("mapboxgl-compact") : s.classList.remove("mapboxgl-compact")
                    }
                }
            }

            class jm {
                constructor() {
                    o.aV(["_onIndoorUpdate"], this)
                }

                onAdd(t) {
                    return this._map = t, this._container = fe("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._map.indoor.on("indoorupdate", s => this._onIndoorUpdate({
                        selectedFloorId: s.selectedFloorId,
                        floors: s.floors
                    })), this._container
                }

                _createButton(t, s) {
                    const h = fe("button", t, this._container);
                    return h.type = "button", h.addEventListener("click", s), h
                }

                _setButtonTitle(t, s) {
                    this._map && (t.setAttribute("aria-label", s), t.innerHTML = `<strong>${s}</strong>`, t.firstElementChild && t.firstElementChild.setAttribute("title", s))
                }

                onRemove() {
                    this._container && this._container.remove(), this._map && this._map.indoor && (this._map.indoor.off("indoorupdate", this._onIndoorUpdate), this._map = null)
                }

                getDefaultPosition() {
                    return "right"
                }

                _onIndoorUpdate(t) {
                    if (!t || !t.floors) return void (this._container.style.display = "none");
                    const s = this._model;
                    this._model = t, this._container.style.display = "inline-block";
                    const h = t.floors.sort((m, g) => m.levelOrder - g.levelOrder);
                    s ? (Array.from(this._container.children).forEach(m => m.remove()), this.addCurrentFloors(h)) : this.addCurrentFloors(h)
                }

                addCurrentFloors(t) {
                    for (const s of t) {
                        const h = this._createButton("mapboxgl-ctrl-level-button", () => {
                            this._map._selectIndoorFloor(s.id), Array.from(this._container.children).forEach(m => {
                                m.classList.remove("mapboxgl-ctrl-level-button-selected")
                            }), h.classList.add("mapboxgl-ctrl-level-button-selected")
                        });
                        this._setButtonTitle(h, s.shortName), this._model && s.id === this._model.selectedFloorId && (this._map._selectIndoorFloor(s.id), h.classList.add("mapboxgl-ctrl-level-button-selected")), this._container.append(h)
                    }
                }
            }

            class ky {
                constructor() {
                    this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1
                }

                add(t) {
                    const s = ++this._id;
                    return this._queue.push({callback: t, id: s, cancelled: !1}), s
                }

                remove(t) {
                    const s = this._currentlyRunning, h = s ? this._queue.concat(s) : this._queue;
                    for (const m of h) if (m.id === t) return void (m.cancelled = !0)
                }

                run(t = 0) {
                    const s = this._currentlyRunning = this._queue;
                    this._queue = [];
                    for (const h of s) if (!h.cancelled && (h.callback(t), this._cleared)) break;
                    this._cleared = !1, this._currentlyRunning = !1
                }

                clear() {
                    this._currentlyRunning && (this._cleared = !0), this._queue = []
                }
            }

            class Mh {
                constructor(t) {
                    this.jumpTo(t)
                }

                getValue(t) {
                    if (t <= this._startTime) return this._start;
                    if (t >= this._endTime) return this._end;
                    const s = o.dx((t - this._startTime) / (this._endTime - this._startTime));
                    return this._start * (1 - s) + this._end * s
                }

                isEasing(t) {
                    return t >= this._startTime && t <= this._endTime
                }

                jumpTo(t) {
                    this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = t, this._end = t
                }

                easeTo(t, s, h) {
                    this._start = this.getValue(s), this._end = t, this._startTime = s, this._endTime = s + h
                }
            }

            const p1 = {
                "AttributionControl.ToggleAttribution": "Toggle attribution",
                "FullscreenControl.Enter": "Enter fullscreen",
                "FullscreenControl.Exit": "Exit fullscreen",
                "GeolocateControl.FindMyLocation": "Find my location",
                "GeolocateControl.LocationNotAvailable": "Location not available",
                "LogoControl.Title": "Mapbox homepage",
                "Map.Title": "Map",
                "NavigationControl.ResetBearing": "Reset bearing to north",
                "NavigationControl.ZoomIn": "Zoom in",
                "NavigationControl.ZoomOut": "Zoom out",
                "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map",
                "ScrollZoomBlocker.CmdMessage": "Use ⌘ + scroll to zoom the map",
                "TouchPanBlocker.Message": "Use two fingers to move the map"
            };

            class Oy extends o.A {
                constructor(t, s, h, m) {
                    const {point: g, lngLat: v, originalEvent: b, target: S} = t;
                    super(t.type, {point: g, lngLat: v, originalEvent: b, target: S}), this.preventDefault = () => {
                        t.preventDefault()
                    }, this.id = s, this.interaction = h, this.feature = m
                }
            }

            class Vm {
                constructor(t) {
                    this.map = t, this.interactionsByType = new Map, this.delegatedInteractions = new Map, this.typeById = new Map, this.filters = new Map, this.handleType = this.handleType.bind(this), this.handleMove = this.handleMove.bind(this), this.handleOut = this.handleOut.bind(this), this.hoveredFeatures = new Map, this.prevHoveredFeatures = new Map
                }

                add(t, s) {
                    if (this.typeById.has(t)) throw new Error(`Interaction id "${t}" already exists.`);
                    const h = s.filter;
                    let m = s.type;
                    h && this.filters.set(t, o.b3(h)), m === "mouseover" && (m = "mouseenter"), m === "mouseout" && (m = "mouseleave");
                    const g = this.interactionsByType.get(m) || new Map;
                    m === "mouseenter" || m === "mouseleave" ? (this.delegatedInteractions.size === 0 && (this.map.on("mousemove", this.handleMove), this.map.on("mouseout", this.handleOut)), this.delegatedInteractions.set(t, s)) : g.size === 0 && this.map.on(m, this.handleType), g.size === 0 && this.interactionsByType.set(m, g), g.set(t, s), this.typeById.set(t, m)
                }

                get(t) {
                    const s = this.typeById.get(t);
                    if (!s) return;
                    const h = this.interactionsByType.get(s);
                    return h ? h.get(t) : void 0
                }

                remove(t) {
                    const s = this.typeById.get(t);
                    if (!s) return;
                    this.typeById.delete(t), this.filters.delete(t);
                    const h = this.interactionsByType.get(s);
                    h && (h.delete(t), s === "mouseenter" || s === "mouseleave" ? (this.delegatedInteractions.delete(t), this.delegatedInteractions.size === 0 && (this.map.off("mousemove", this.handleMove), this.map.off("mouseout", this.handleOut))) : h.size === 0 && this.map.off(s, this.handleType))
                }

                queryTargets(t, s) {
                    const h = [];
                    for (const [m, g] of s) g.target && h.push({
                        targetId: m,
                        target: g.target,
                        filter: this.filters.get(m)
                    });
                    return this.map.style.queryRenderedTargets(t, h, this.map.transform)
                }

                handleMove(t) {
                    this.prevHoveredFeatures = this.hoveredFeatures, this.hoveredFeatures = new Map;
                    const s = this.queryTargets(t.point, Array.from(this.delegatedInteractions).reverse());
                    s.length && (t.type = "mouseenter", this.handleType(t, s));
                    const h = new Map;
                    for (const [m, {feature: g}] of this.prevHoveredFeatures) this.hoveredFeatures.has(m) || h.set(g.id, g);
                    h.size && (t.type = "mouseleave", this.handleType(t, Array.from(h.values())))
                }

                handleOut(t) {
                    const s = Array.from(this.hoveredFeatures.values()).map(({feature: h}) => h);
                    s.length && (t.type = "mouseleave", this.handleType(t, s)), this.hoveredFeatures.clear()
                }

                handleType(t, s) {
                    const h = t.type === "mouseenter";
                    if (h && !this.interactionsByType.has(t.type)) return void o.w("mouseenter interaction required for mouseleave to work.");
                    const m = Array.from(this.interactionsByType.get(t.type)).reverse(), g = !!s;
                    s = s || this.queryTargets(t.point, m);
                    let v = !1;
                    const b = new Set;
                    for (const S of s) {
                        for (const [P, M] of m) {
                            if (!M.target) continue;
                            const k = S.variants ? S.variants[P] : null;
                            if (k) {
                                for (const R of k) {
                                    if (ud(R, S, b, P)) continue;
                                    const O = new o.dr(S, R), V = Hu(R, S, P);
                                    g && (O.state = this.map.getFeatureState(O));
                                    const B = h ? this.prevHoveredFeatures.get(V) : null, G = new Oy(t, P, M, O),
                                        U = B ? B.stop : M.handler(G);
                                    if (h && this.hoveredFeatures.set(V, {feature: S, stop: U}), U !== !1) {
                                        v = !0;
                                        break
                                    }
                                }
                                if (v) break
                            }
                        }
                        if (v) break
                    }
                    if (!v) for (const [S, P] of m) {
                        const {handler: M, target: k} = P;
                        if (!k && M(new Oy(t, S, P, null)) !== !1) break
                    }
                }
            }

            function Um(u, t) {
                if (Array.isArray(u) && Array.isArray(t)) {
                    const s = new Set(u), h = new Set(t);
                    return s.size === h.size && u.every(m => h.has(m))
                }
                return o.bv(u, t)
            }

            const Rh = {
                center: [0, 0],
                zoom: 0,
                bearing: 0,
                pitch: 0,
                minZoom: -2,
                maxZoom: 22,
                minPitch: 0,
                maxPitch: 85,
                interactive: !0,
                scrollZoom: !0,
                boxZoom: !0,
                dragRotate: !0,
                dragPan: !0,
                keyboard: !0,
                doubleClickZoom: !0,
                touchZoomRotate: !0,
                touchPitch: !0,
                cooperativeGestures: !1,
                performanceMetricsCollection: !0,
                bearingSnap: 7,
                clickTolerance: 3,
                pitchWithRotate: !0,
                hash: !1,
                attributionControl: !0,
                antialias: !1,
                failIfMajorPerformanceCaveat: !1,
                preserveDrawingBuffer: !1,
                trackResize: !0,
                renderWorldCopies: !0,
                refreshExpiredTiles: !0,
                minTileCacheSize: null,
                maxTileCacheSize: null,
                localIdeographFontFamily: "sans-serif",
                localFontFamily: null,
                transformRequest: null,
                accessToken: null,
                fadeDuration: 300,
                respectPrefersReducedMotion: !0,
                crossSourceCollisions: !0,
                collectResourceTiming: !1,
                testMode: !1,
                precompilePrograms: !0,
                scaleFactor: 1,
                spriteFormat: "auto"
            }, Yc = {showCompass: !0, showZoom: !0, visualizePitch: !1};

            class wa {
                constructor(t, s, h = !1) {
                    this._clickTolerance = 10, this.element = s, this.mouseRotate = new af({clickTolerance: t.dragRotate._mouseRotate._clickTolerance}), this.map = t, h && (this.mousePitch = new km({clickTolerance: t.dragRotate._mousePitch._clickTolerance})), o.aV(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), s.addEventListener("mousedown", this.mousedown), s.addEventListener("touchstart", this.touchstart, {passive: !1}), s.addEventListener("touchmove", this.touchmove), s.addEventListener("touchend", this.touchend), s.addEventListener("touchcancel", this.reset)
                }

                down(t, s) {
                    this.mouseRotate.mousedown(t, s), this.mousePitch && this.mousePitch.mousedown(t, s), Ue()
                }

                move(t, s) {
                    const h = this.map, m = this.mouseRotate.mousemoveWindow(t, s), g = m && m.bearingDelta;
                    if (g && h.setBearing(h.getBearing() + g), this.mousePitch) {
                        const v = this.mousePitch.mousemoveWindow(t, s), b = v && v.pitchDelta;
                        b && h.setPitch(h.getPitch() + b)
                    }
                }

                off() {
                    const t = this.element;
                    t.removeEventListener("mousedown", this.mousedown), t.removeEventListener("touchstart", this.touchstart), t.removeEventListener("touchmove", this.touchmove), t.removeEventListener("touchend", this.touchend), t.removeEventListener("touchcancel", this.reset), this.offTemp()
                }

                offTemp() {
                    et(), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup)
                }

                mousedown(t) {
                    this.down(o.h({}, t, {
                        ctrlKey: !0,
                        preventDefault: () => t.preventDefault()
                    }), Mt(this.element, t)), window.addEventListener("mousemove", this.mousemove), window.addEventListener("mouseup", this.mouseup)
                }

                mousemove(t) {
                    this.move(t, Mt(this.element, t))
                }

                mouseup(t) {
                    this.mouseRotate.mouseupWindow(t), this.mousePitch && this.mousePitch.mouseupWindow(t), this.offTemp()
                }

                touchstart(t) {
                    t.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = Xt(this.element, t.targetTouches)[0], this.down({
                        type: "mousedown",
                        button: 0,
                        ctrlKey: !0,
                        preventDefault: () => t.preventDefault()
                    }, this._startPos))
                }

                touchmove(t) {
                    t.targetTouches.length !== 1 ? this.reset() : (this._lastPos = Xt(this.element, t.targetTouches)[0], this.move({preventDefault: () => t.preventDefault()}, this._lastPos))
                }

                touchend(t) {
                    t.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset()
                }

                reset() {
                    this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp()
                }
            }

            function Ts(u, t, s) {
                if (u = new o.ci(u.lng, u.lat), t) {
                    const h = new o.ci(u.lng - 360, u.lat), m = new o.ci(u.lng + 360, u.lat),
                        g = 360 * Math.ceil(Math.abs(u.lng - s.center.lng) / 360), v = s.locationPoint3D(u).distSqr(t),
                        b = t.x < 0 || t.y < 0 || t.x > s.width || t.y > s.height;
                    s.locationPoint3D(h).distSqr(t) < v && (b || Math.abs(h.lng - s.center.lng) < g) ? u = h : s.locationPoint3D(m).distSqr(t) < v && (b || Math.abs(m.lng - s.center.lng) < g) && (u = m)
                }
                for (; Math.abs(u.lng - s.center.lng) > 180;) {
                    const h = s.locationPoint3D(u);
                    if (h.x >= 0 && h.y >= 0 && h.x <= s.width && h.y <= s.height) break;
                    u.lng > s.center.lng ? u.lng -= 360 : u.lng += 360
                }
                return u
            }

            const Jo = {
                center: "translate(-50%,-50%)",
                top: "translate(-50%,0)",
                "top-left": "translate(0,0)",
                "top-right": "translate(-100%,0)",
                bottom: "translate(-50%,-100%)",
                "bottom-left": "translate(0,-100%)",
                "bottom-right": "translate(-100%,-100%)",
                left: "translate(0,-50%)",
                right: "translate(-100%,-50%)"
            }, go = {rotation: 0, rotationAlignment: "auto", pitchAlignment: "auto", occludedOpacity: .2, altitude: 0};

            class es extends o.E {
                constructor(t, s) {
                    super(), (t instanceof HTMLElement || s) && (t = o.h({element: t}, s)), o.aV(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this);
                    const {
                        anchor: h = "center",
                        color: m = "#3FB1CE",
                        scale: g = 1,
                        draggable: v = !1,
                        clickTolerance: b = 0,
                        rotation: S = go.rotation,
                        rotationAlignment: P = go.rotationAlignment,
                        pitchAlignment: M = go.pitchAlignment,
                        occludedOpacity: k = go.occludedOpacity,
                        altitude: R = go.altitude
                    } = t || {};
                    this._anchor = h, this._color = m, this._scale = g, this._draggable = v, this._clickTolerance = b, this._rotation = S, this._rotationAlignment = P, this._pitchAlignment = M, this._occludedOpacity = k, this._altitude = R, this._state = "inactive", this._isDragging = !1, this._updateMoving = () => this._update(!0), t && t.element ? (this._element = t.element, this._offset = o.P.convert(t && t.offset || [0, 0])) : (this._defaultMarker = !0, this._element = this._createDefaultMarker(), this._offset = o.P.convert(t && t.offset || [0, -14])), this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.hasAttribute("role") || this._element.setAttribute("role", "img"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", B => {
                        B.preventDefault()
                    }), this._element.addEventListener("mousedown", B => {
                        B.preventDefault()
                    });
                    const O = this._element.classList;
                    for (const B in Jo) O.remove(`mapboxgl-marker-anchor-${B}`);
                    O.add(`mapboxgl-marker-anchor-${this._anchor}`);
                    const V = t && t.className ? t.className.trim().split(/\s+/) : [];
                    O.add(...V), this._popup = null
                }

                _createDefaultMarker() {
                    const t = fe("div"), s = Me("svg", {
                        display: "block",
                        height: 41 * this._scale + "px",
                        width: 27 * this._scale + "px",
                        viewBox: "0 0 27 41"
                    }, t);
                    if (this._altitude === 0) {
                        const h = Me("radialGradient", {id: "shadowGradient"}, Me("defs", {}, s));
                        Me("stop", {offset: "10%", "stop-opacity": .4}, h), Me("stop", {
                            offset: "100%",
                            "stop-opacity": .05
                        }, h), Me("ellipse", {cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)"}, s)
                    }
                    return Me("path", {
                        fill: this._color,
                        d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z"
                    }, s), Me("path", {
                        opacity: .25,
                        d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z"
                    }, s), Me("circle", {fill: "white", cx: 13.5, cy: 13.5, r: 5.5}, s), t
                }

                addTo(t) {
                    return t === this._map || (this.remove(), this._map = t, t.getCanvasContainer().appendChild(this._element), t.on("move", this._updateMoving), t.on("moveend", this._update), t.on("remove", this._clearFadeTimer), t._addMarker(this), this.setDraggable(this._draggable), this._update(), t.on("click", this._onMapClick)), this
                }

                remove() {
                    const t = this._map;
                    return t && (t.off("click", this._onMapClick), t.off("move", this._updateMoving), t.off("moveend", this._update), t.off("mousedown", this._addDragHandler), t.off("touchstart", this._addDragHandler), t.off("mouseup", this._onUp), t.off("touchend", this._onUp), t.off("mousemove", this._onMove), t.off("touchmove", this._onMove), t.off("remove", this._clearFadeTimer), t._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this
                }

                getLngLat() {
                    return this._lngLat
                }

                setLngLat(t) {
                    return this._lngLat = o.ci.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this
                }

                setAltitude(t) {
                    return t === this._altitude || (this._defaultMarker && (this._altitude === 0 && t !== 0 || this._altitude !== 0 && t === 0) && (this._element = this._createDefaultMarker()), this._altitude = t || go.altitude, this._update()), this
                }

                getAltitude() {
                    return this._altitude
                }

                getElement() {
                    return this._element
                }

                setPopup(t) {
                    if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t) {
                        if (!("offset" in t.options)) {
                            const m = Math.sqrt(Math.pow(13.5, 2) / 2);
                            t.options.offset = this._defaultMarker ? {
                                top: [0, 0],
                                "top-left": [0, 0],
                                "top-right": [0, 0],
                                bottom: [0, -38.1],
                                "bottom-left": [m, -1 * (38.1 - 13.5 + m)],
                                "bottom-right": [-m, -1 * (38.1 - 13.5 + m)],
                                left: [13.5, -1 * (38.1 - 13.5)],
                                right: [-13.5, -1 * (38.1 - 13.5)]
                            } : this._offset
                        }
                        this._popup = t, t._marker = this, t._altitude = this._altitude, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false")
                    }
                    return this
                }

                _onKeyPress(t) {
                    const s = t.code, h = t.charCode || t.keyCode;
                    s !== "Space" && s !== "Enter" && h !== 32 && h !== 13 || this.togglePopup()
                }

                _onMapClick(t) {
                    const s = t.originalEvent.target, h = this._element;
                    this._popup && (s === h || h.contains(s)) && this.togglePopup()
                }

                getPopup() {
                    return this._popup
                }

                togglePopup() {
                    const t = this._popup;
                    return t ? (t.isOpen() ? (t.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (t.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this
                }

                _behindTerrain() {
                    const t = this._map, s = this._pos;
                    if (!t || !s) return !1;
                    const h = t.unproject(s, this._altitude), m = t.getFreeCameraOptions();
                    if (!m.position) return !1;
                    const g = m.position.toLngLat();
                    return g.distanceTo(h) < .9 * g.distanceTo(this._lngLat)
                }

                _evaluateOpacity() {
                    const t = this._map;
                    if (!t) return;
                    const s = this._pos;
                    if (!s || s.x < 0 || s.x > t.transform.width || s.y < 0 || s.y > t.transform.height) return void this._clearFadeTimer();
                    const h = t.unproject(s, this._altitude);
                    let m;
                    t._showingGlobe() && o.eW(t.transform, this._lngLat) ? m = 0 : (m = 1 - t._queryFogOpacity(h), t.transform._terrainEnabled() && t.getTerrain() && this._behindTerrain() && (m *= this._occludedOpacity)), this._element.style.opacity = `${m}`, this._element.style.pointerEvents = m > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(m), this._fadeTimer = null
                }

                _clearFadeTimer() {
                    this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null)
                }

                _updateDOM() {
                    const t = this._pos;
                    if (!t || !this._map) return;
                    const s = this._offset.mult(this._scale);
                    this._element.style.transform = `
            translate(${t.x}px,${t.y}px)
            ${Jo[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${s.x}px,${s.y}px)
        `
                }

                _calculateXYTransform() {
                    const t = this._pos, s = this._map, h = this.getPitchAlignment();
                    if (!s || !t || h !== "map") return "";
                    if (!s._showingGlobe()) {
                        const S = s.getPitch();
                        return S ? `rotateX(${S}deg)` : ""
                    }
                    const m = o.cU(o.eX(s.transform, this._lngLat)), g = t.sub(o.eY(s.transform)),
                        v = Math.abs(g.x) + Math.abs(g.y);
                    if (v === 0) return "";
                    const b = m / v;
                    return `rotateX(${-g.y * b}deg) rotateY(${g.x * b}deg)`
                }

                _calculateZTransform() {
                    const t = this._pos, s = this._map;
                    if (!s || !t) return "";
                    let h = 0;
                    const m = this.getRotationAlignment();
                    if (m === "map") if (s._showingGlobe()) {
                        const g = s.project(new o.ci(this._lngLat.lng, this._lngLat.lat + .001), this._altitude),
                            v = s.project(new o.ci(this._lngLat.lng, this._lngLat.lat - .001), this._altitude).sub(g);
                        h = o.cU(Math.atan2(v.y, v.x)) - 90
                    } else h = -s.getBearing(); else if (m === "horizon") {
                        const g = o.af(4, 6, s.getZoom()), v = o.eY(s.transform);
                        v.y += g * s.transform.height;
                        const b = t.sub(v), S = o.cU(Math.atan2(b.y, b.x));
                        h = (S > 90 ? S - 270 : S + 90) * (1 - g)
                    }
                    return h += this._rotation, h ? `rotateZ(${h}deg)` : ""
                }

                _update(t) {
                    cancelAnimationFrame(this._updateFrameId);
                    const s = this._map;
                    s && (s.transform.renderWorldCopies && (this._lngLat = Ts(this._lngLat, this._pos, s.transform)), this._pos = s.project(this._lngLat, this._altitude), t === !0 ? this._updateFrameId = requestAnimationFrame(() => {
                        this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM())
                    }) : this._pos = this._pos.round(), s._requestDomTask(() => {
                        this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (s._showingGlobe() || s.getTerrain() || s.getFog()) && !this._fadeTimer && (this._fadeTimer = window.setTimeout(this._evaluateOpacity.bind(this), 60)))
                    }))
                }

                getOffset() {
                    return this._offset
                }

                setOffset(t) {
                    return this._offset = o.P.convert(t), this._update(), this
                }

                addClassName(t) {
                    return this._element.classList.add(t), this
                }

                removeClassName(t) {
                    return this._element.classList.remove(t), this
                }

                toggleClassName(t) {
                    return this._element.classList.toggle(t)
                }

                _onMove(t) {
                    const s = this._map;
                    if (!s) return;
                    const h = this._pointerdownPos, m = this._positionDelta;
                    if (h && m) {
                        if (!this._isDragging) {
                            const g = this._clickTolerance || s._clickTolerance;
                            if (t.point.dist(h) < g) return;
                            this._isDragging = !0
                        }
                        this._pos = t.point.sub(m), this._lngLat = s.unproject(this._pos, this._altitude), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new o.A("dragstart"))), this.fire(new o.A("drag"))
                    }
                }

                _onUp() {
                    this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;
                    const t = this._map;
                    t && (t.off("mousemove", this._onMove), t.off("touchmove", this._onMove)), this._state === "active" && this.fire(new o.A("dragend")), this._state = "inactive"
                }

                _addDragHandler(t) {
                    const s = this._map, h = this._pos;
                    s && h && this._element.contains(t.originalEvent.target) && (t.preventDefault(), this._positionDelta = t.point.sub(h), this._pointerdownPos = t.point, this._state = "pending", s.on("mousemove", this._onMove), s.on("touchmove", this._onMove), s.once("mouseup", this._onUp), s.once("touchend", this._onUp))
                }

                setDraggable(t) {
                    this._draggable = !!t;
                    const s = this._map;
                    return s && (t ? (s.on("mousedown", this._addDragHandler), s.on("touchstart", this._addDragHandler)) : (s.off("mousedown", this._addDragHandler), s.off("touchstart", this._addDragHandler))), this
                }

                isDraggable() {
                    return this._draggable
                }

                setRotation(t) {
                    return this._rotation = t || go.rotation, this._update(), this
                }

                getRotation() {
                    return this._rotation
                }

                setRotationAlignment(t) {
                    return this._rotationAlignment = t || go.rotationAlignment, this._update(), this
                }

                getRotationAlignment() {
                    return this._rotationAlignment === "auto" || this._rotationAlignment === "horizon" && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment
                }

                setPitchAlignment(t) {
                    return this._pitchAlignment = t || go.pitchAlignment, this._update(), this
                }

                getPitchAlignment() {
                    return this._pitchAlignment === "auto" ? this.getRotationAlignment() : this._pitchAlignment
                }

                setOccludedOpacity(t) {
                    return this._occludedOpacity = t || go.occludedOpacity, this._update(), this
                }

                getOccludedOpacity() {
                    return this._occludedOpacity
                }
            }

            const m1 = {
                    positionOptions: {enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3},
                    fitBoundsOptions: {maxZoom: 15},
                    trackUserLocation: !1,
                    showAccuracyCircle: !0,
                    showUserLocation: !0,
                    showUserHeading: !1
                }, g1 = {maxWidth: 100, unit: "metric"},
                _1 = {kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm"}, y1 = {
                    closeButton: !0,
                    closeOnClick: !0,
                    focusAfterOpen: !0,
                    className: "",
                    maxWidth: "240px",
                    altitude: 0
                },
                Fy = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");

            function io(u = new o.P(0, 0), t = "bottom") {
                if (typeof u == "number") {
                    const s = Math.round(Math.sqrt(.5 * Math.pow(u, 2)));
                    switch (t) {
                        case"top":
                            return new o.P(0, u);
                        case"top-left":
                            return new o.P(s, s);
                        case"top-right":
                            return new o.P(-s, s);
                        case"bottom":
                            return new o.P(0, -u);
                        case"bottom-left":
                            return new o.P(s, -s);
                        case"bottom-right":
                            return new o.P(-s, -s);
                        case"left":
                            return new o.P(u, 0);
                        case"right":
                            return new o.P(-u, 0)
                    }
                    return new o.P(0, 0)
                }
                return u instanceof o.P || Array.isArray(u) ? o.P.convert(u) : o.P.convert(u[t] || [0, 0])
            }

            return {
                version: j,
                supported: Re.supported,
                setRTLTextPlugin: o.f0,
                getRTLTextPluginStatus: o.e$,
                Map: class extends ta {
                    constructor(u) {
                        ee.mark(q.create);
                        const t = u;
                        if ((u = o.h({}, Rh, u)).minZoom != null && u.maxZoom != null && u.minZoom > u.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
                        if (u.minPitch != null && u.maxPitch != null && u.minPitch > u.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
                        if (u.minPitch != null && u.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
                        if (u.maxPitch != null && u.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
                        if (u.antialias && o.eU(window) && (u.antialias = !1, o.w("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Op(u.minZoom, u.maxZoom, u.minPitch, u.maxPitch, u.renderWorldCopies, null, null), u), this._repaint = !!u.repaint, this._interactive = u.interactive, this._minTileCacheSize = u.minTileCacheSize, this._maxTileCacheSize = u.maxTileCacheSize, this._failIfMajorPerformanceCaveat = u.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = u.preserveDrawingBuffer, this._antialias = u.antialias, this._trackResize = u.trackResize, this._bearingSnap = u.bearingSnap, this._refreshExpiredTiles = u.refreshExpiredTiles, this._fadeDuration = u.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = u.crossSourceCollisions, this._collectResourceTiming = u.collectResourceTiming, this._language = this._parseLanguage(u.language), this._worldview = u.worldview, this._renderTaskQueue = new ky, this._domRenderTaskQueue = new ky, this._controls = [], this._markers = [], this._popups = [], this._mapId = o.a$(), this._locale = o.h({}, p1, u.locale), this._clickTolerance = u.clickTolerance, this._cooperativeGestures = u.cooperativeGestures, this._performanceMetricsCollection = u.performanceMetricsCollection, this._tessellationStep = u.tessellationStep, this._containerWidth = 0, this._containerHeight = 0, this._showParseStatus = !0, this._precompilePrograms = u.precompilePrograms, this._scaleFactorChanged = !1, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new Mh(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._frameId = 0, this._scaleFactor = u.scaleFactor, this._requestManager = new $t(u.transformRequest, u.accessToken, u.testMode), this._silenceAuthErrors = !!u.testMode, this._contextCreateOptions = u.contextCreateOptions ? Object.assign({}, u.contextCreateOptions) : {}, typeof u.container == "string") {
                            const s = document.getElementById(u.container);
                            if (!s) throw new Error(`Container '${u.container.toString()}' not found.`);
                            this._container = s
                        } else {
                            if (!(u.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                            this._container = u.container
                        }
                        if (this._container.childNodes.length > 0 && o.w("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), u.maxBounds && this.setMaxBounds(u.maxBounds), this._spriteFormat = u.spriteFormat, o.aV(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._tp || (this._tp = new l1), this._tp.registerParameter(this, ["Debug"], "showOverdrawInspector"), this._tp.registerParameter(this, ["Debug"], "showTileBoundaries"), this._tp.registerParameter(this, ["Debug"], "showParseStatus"), this._tp.registerParameter(this, ["Debug"], "repaint"), this._tp.registerParameter(this, ["Debug"], "showTileAABBs"), this._tp.registerParameter(this, ["Debug"], "showPadding"), this._tp.registerParameter(this, ["Debug"], "showCollisionBoxes", {noSave: !0}), this._tp.registerParameter(this.transform, ["Debug"], "freezeTileCoverage", {noSave: !0}, () => {
                            this._update()
                        }), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showTerrainWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers2DWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers3DWireframe"), this._tp.registerParameter(this, ["Scaling"], "_scaleFactor", {
                            min: .1,
                            max: 10,
                            step: .1
                        }, () => {
                            this.setScaleFactor(this._scaleFactor)
                        }), this._setupPainter(), this.painter === void 0) throw new Error("Failed to initialize WebGL.");
                        if (this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), this._fullscreenchangeEvent = "onfullscreenchange" in document ? "fullscreenchange" : "webkitfullscreenchange", window.addEventListener("online", this._onWindowOnline, !1), window.addEventListener("resize", this._onWindowResize, !1), window.addEventListener("orientationchange", this._onWindowResize, !1), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.addEventListener("visibilitychange", this._onVisibilityChange, !1), this.handlers = new hf(this, u), this._localFontFamily = u.localFontFamily, this._localIdeographFontFamily = u.localIdeographFontFamily, (u.style || !u.testMode) && this.setStyle(u.style || o.e.DEFAULT_STYLE, {
                            config: u.config,
                            localFontFamily: this._localFontFamily,
                            localIdeographFontFamily: this._localIdeographFontFamily
                        }), u.projection && this.setProjection(u.projection), this.indoor = new $x(this), u.hash && (this._hash = new nf(typeof u.hash == "string" && u.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {
                            t.center == null && t.zoom == null || (this.transform._unmodified = !1), this.jumpTo({
                                center: u.center,
                                zoom: u.zoom,
                                bearing: u.bearing,
                                pitch: u.pitch
                            });
                            const s = u.bounds;
                            s && (this.resize(), this.fitBounds(s, o.h({}, u.fitBoundsOptions, {duration: 0})))
                        }
                        this.resize(), u.attributionControl && this.addControl(new Xc({customAttribution: u.customAttribution})), this._logoControl = new Ph, this.addControl(this._logoControl, u.logoPosition), this.on("style.load", () => {
                            this.transform.unmodified && this.jumpTo(this.style.stylesheet), this._postStyleLoadEvent()
                        }), this.on("data", s => {
                            this._update(s.dataType === "style"), this.fire(new o.A(`${s.dataType}data`, s))
                        }), this.on("dataloading", s => {
                            this.fire(new o.A(`${s.dataType}dataloading`, s))
                        }), this._interactions = new Vm(this)
                    }

                    _getMapId() {
                        return this._mapId
                    }

                    addControl(u, t) {
                        if (t === void 0 && (t = u.getDefaultPosition ? u.getDefaultPosition() : "top-right"), !u || !u.onAdd) return this.fire(new o.z(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
                        const s = u.onAdd(this);
                        this._controls.push(u);
                        const h = this._controlPositions[t];
                        return t.indexOf("bottom") !== -1 ? h.insertBefore(s, h.firstChild) : h.appendChild(s), this
                    }

                    removeControl(u) {
                        if (!u || !u.onRemove) return this.fire(new o.z(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
                        const t = this._controls.indexOf(u);
                        return t > -1 && this._controls.splice(t, 1), u.onRemove(this), this
                    }

                    hasControl(u) {
                        return this._controls.indexOf(u) > -1
                    }

                    getContainer() {
                        return this._container
                    }

                    getCanvasContainer() {
                        return this._canvasContainer
                    }

                    getCanvas() {
                        return this._canvas
                    }

                    resize(u) {
                        if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;
                        this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
                        const t = !this._moving;
                        return t && this.fire(new o.A("movestart", u)).fire(new o.A("move", u)), this.fire(new o.A("resize", u)), t && this.fire(new o.A("moveend", u)), this
                    }

                    getBounds() {
                        return this.transform.getBounds()
                    }

                    getMaxBounds() {
                        return this.transform.getMaxBounds() || null
                    }

                    setMaxBounds(u) {
                        return this.transform.setMaxBounds(o.aG.convert(u)), this._update()
                    }

                    setMinZoom(u) {
                        if ((u = u ?? -2) >= -2 && u <= this.transform.maxZoom) return this.transform.minZoom = u, this._update(), this.getZoom() < u ? this.setZoom(u) : this.fire(new o.A("zoomstart")).fire(new o.A("zoom")).fire(new o.A("zoomend")), this;
                        throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
                    }

                    getMinZoom() {
                        return this.transform.minZoom
                    }

                    setMaxZoom(u) {
                        if ((u = u ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = u, this._update(), this.getZoom() > u ? this.setZoom(u) : this.fire(new o.A("zoomstart")).fire(new o.A("zoom")).fire(new o.A("zoomend")), this;
                        throw new Error("maxZoom must be greater than the current minZoom")
                    }

                    getMaxZoom() {
                        return this.transform.maxZoom
                    }

                    setMinPitch(u) {
                        if ((u = u ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
                        if (u >= 0 && u <= this.transform.maxPitch) return this.transform.minPitch = u, this._update(), this.getPitch() < u ? this.setPitch(u) : this.fire(new o.A("pitchstart")).fire(new o.A("pitch")).fire(new o.A("pitchend")), this;
                        throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
                    }

                    getMinPitch() {
                        return this.transform.minPitch
                    }

                    setMaxPitch(u) {
                        if ((u = u ?? 85) > 85) throw new Error("maxPitch must be less than or equal to 85");
                        if (u >= this.transform.minPitch) return this.transform.maxPitch = u, this._update(), this.getPitch() > u ? this.setPitch(u) : this.fire(new o.A("pitchstart")).fire(new o.A("pitch")).fire(new o.A("pitchend")), this;
                        throw new Error("maxPitch must be greater than or equal to minPitch")
                    }

                    getMaxPitch() {
                        return this.transform.maxPitch
                    }

                    getScaleFactor() {
                        return this._scaleFactor
                    }

                    setScaleFactor(u) {
                        return this._scaleFactor = u, this.painter.scaleFactor = u, this._tp.refreshUI(), this._scaleFactorChanged = !0, this.style._updateFilteredLayers(t => t.type === "symbol"), this._update(!0), this
                    }

                    getRenderWorldCopies() {
                        return this.transform.renderWorldCopies
                    }

                    setRenderWorldCopies(u) {
                        return this.transform.renderWorldCopies = u, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update()
                    }

                    getLanguage() {
                        return this._language
                    }

                    _parseLanguage(u) {
                        return u === "auto" ? navigator.language : Array.isArray(u) ? u.length === 0 ? void 0 : u.map(t => t === "auto" ? navigator.language : t) : u
                    }

                    setLanguage(u) {
                        const t = this._parseLanguage(u);
                        if (!this.style || t === this._language) return this;
                        this._language = t, this.style.reloadSources();
                        for (const s of this._controls) s._setLanguage && s._setLanguage(this._language);
                        return this
                    }

                    getWorldview() {
                        return this._worldview
                    }

                    setWorldview(u) {
                        return this.style && u !== this._worldview ? (this._worldview = u, this._styleDirty = !0, this.style.reloadSources(), this) : this
                    }

                    getProjection() {
                        return this.transform.mercatorFromTransition ? {
                            name: "globe",
                            center: [0, 0]
                        } : this.transform.getProjection()
                    }

                    _showingGlobe() {
                        return this.transform.projection.name === "globe"
                    }

                    setProjection(u) {
                        return this._lazyInitEmptyStyle(), u ? typeof u == "string" && (u = {name: u}) : u = null, this._useExplicitProjection = !!u, this._prioritizeAndUpdateProjection(u, this.style.projection)
                    }

                    _updateProjectionTransition() {
                        if (this.getProjection().name !== "globe") return;
                        const u = this.transform, t = u.projection.name;
                        let s;
                        t === "globe" && u.zoom >= o.cI ? (u.setMercatorFromTransition(), s = !0) : t === "mercator" && u.zoom < o.cI && (u.setProjection({name: "globe"}), s = !0), s && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate(), this._update(!0))
                    }

                    _prioritizeAndUpdateProjection(u, t) {
                        return this._updateProjection(u || t || {name: "mercator"})
                    }

                    _updateProjection(u) {
                        let t;
                        return t = u.name === "globe" && this.transform.zoom >= o.cI ? this.transform.setMercatorFromTransition() : this.transform.setProjection(u), this.style.applyProjectionUpdate(), t && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(!0), this._forceMarkerAndPopupUpdate(!0)), this
                    }

                    project(u, t) {
                        return this.transform.locationPoint3D(o.ci.convert(u), t)
                    }

                    unproject(u, t) {
                        return this.transform.pointLocation3D(o.P.convert(u), t)
                    }

                    isMoving() {
                        return this._moving || this.handlers && this.handlers.isMoving() || !1
                    }

                    isZooming() {
                        return this._zooming || this.handlers && this.handlers.isZooming() || !1
                    }

                    isRotating() {
                        return this._rotating || this.handlers && this.handlers.isRotating() || !1
                    }

                    _isDragging() {
                        return this.handlers && this.handlers._isDragging() || !1
                    }

                    _createDelegatedListener(u, t, s) {
                        const h = m => {
                            let g = [];
                            if (Array.isArray(t)) {
                                const v = t.filter(b => this.getLayer(b));
                                g = v.length ? this.queryRenderedFeatures(m, {layers: v}) : []
                            } else g = this.queryRenderedFeatures(m, {target: t});
                            return g
                        };
                        if (u === "mouseenter" || u === "mouseover") {
                            let m = !1;
                            return {
                                listener: s, targets: t, delegates: {
                                    mousemove: v => {
                                        const b = h(v.point);
                                        b.length ? m || (m = !0, s.call(this, new Mn(u, this, v.originalEvent, {features: b}))) : m = !1
                                    }, mouseout: () => {
                                        m = !1
                                    }
                                }
                            }
                        }
                        if (u === "mouseleave" || u === "mouseout") {
                            let m = !1;
                            return {
                                listener: s, targets: t, delegates: {
                                    mousemove: b => {
                                        h(b.point).length ? m = !0 : m && (m = !1, s.call(this, new Mn(u, this, b.originalEvent)))
                                    }, mouseout: b => {
                                        m && (m = !1, s.call(this, new Mn(u, this, b.originalEvent)))
                                    }
                                }
                            }
                        }
                        {
                            const m = g => {
                                const v = h(g.point);
                                v.length && (g.features = v, s.call(this, g), delete g.features)
                            };
                            return {listener: s, targets: t, delegates: {[u]: m}}
                        }
                    }

                    on(u, t, s) {
                        if (typeof t == "function" || s === void 0) return super.on(u, t);
                        if (typeof t == "string" && (t = [t]), !this._areTargetsValid(t)) return this;
                        const h = this._createDelegatedListener(u, t, s);
                        this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[u] = this._delegatedListeners[u] || [], this._delegatedListeners[u].push(h);
                        for (const m in h.delegates) this.on(m, h.delegates[m]);
                        return this
                    }

                    once(u, t, s) {
                        if (typeof t == "function" || s === void 0) return super.once(u, t);
                        if (typeof t == "string" && (t = [t]), !this._areTargetsValid(t)) return this;
                        const h = this._createDelegatedListener(u, t, s);
                        for (const m in h.delegates) this.once(m, h.delegates[m]);
                        return this
                    }

                    off(u, t, s) {
                        if (typeof t == "function" || s === void 0) return super.off(u, t);
                        if (typeof t == "string" && (t = [t]), !this._areTargetsValid(t)) return this;
                        const h = this._delegatedListeners ? this._delegatedListeners[u] : void 0;
                        return h && (m => {
                            for (let g = 0; g < m.length; g++) {
                                const v = m[g];
                                if (v.listener === s && Um(v.targets, t)) {
                                    for (const b in v.delegates) this.off(b, v.delegates[b]);
                                    return m.splice(g, 1), this
                                }
                            }
                        })(h), this
                    }

                    queryRenderedFeatures(u, t) {
                        if (!this.style) return [];
                        if (u === void 0 || u instanceof o.P || Array.isArray(u) || t !== void 0 || (t = u, u = void 0), u = u || [[0, 0], [this.transform.width, this.transform.height]], !t) {
                            const g = this.style.queryRenderedFeatures(u, void 0, this.transform),
                                v = this.style.queryRenderedFeatureset(u, void 0, this.transform);
                            return g.concat(v)
                        }
                        let s = !0;
                        if (t.target && (s = this._isTargetValid(t.target), s && !t.layers)) return this.style.queryRenderedFeatureset(u, t, this.transform);
                        let h = !0;
                        if (t.layers && Array.isArray(t.layers)) {
                            for (const g of t.layers) if (!this._isValidId(g)) {
                                h = !1;
                                break
                            }
                            if (h && !t.target) return this.style.queryRenderedFeatures(u, t, this.transform)
                        }
                        let m = [];
                        return h && (m = m.concat(this.style.queryRenderedFeatures(u, t, this.transform))), s && (m = m.concat(this.style.queryRenderedFeatureset(u, t, this.transform))), m
                    }

                    querySourceFeatures(u, t) {
                        return !u || typeof u == "string" && !this._isValidId(u) ? [] : this.style.querySourceFeatures(u, t)
                    }

                    isPointOnSurface(u) {
                        const {name: t} = this.transform.projection;
                        return t !== "globe" && t !== "mercator" && o.w(`${t} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(o.P.convert(u))
                    }

                    addInteraction(u, t) {
                        return this._interactions.add(u, t), this
                    }

                    removeInteraction(u) {
                        return this._interactions.remove(u), this
                    }

                    getCooperativeGestures() {
                        return this._cooperativeGestures
                    }

                    setCooperativeGestures(u) {
                        return this._cooperativeGestures = u, this
                    }

                    setStyle(u, t) {
                        return t = o.h({}, {
                            localIdeographFontFamily: this._localIdeographFontFamily,
                            localFontFamily: this._localFontFamily
                        }, t), this.style && u && t.diff !== !1 && t.localFontFamily === this._localFontFamily && t.localIdeographFontFamily === this._localIdeographFontFamily && !t.config ? (this.style._diffStyle(u, (s, h) => {
                            if (s) {
                                const m = typeof s == "string" ? s : s instanceof Error ? s.message : s.error;
                                o.w(`Unable to perform style diff: ${m}. Rebuilding the style from scratch.`), this._updateStyle(u, t)
                            } else h && this._update(!0)
                        }, () => this._postStyleLoadEvent()), this) : (this._localIdeographFontFamily = t.localIdeographFontFamily, this._localFontFamily = t.localFontFamily, this._updateStyle(u, t))
                    }

                    _getUIString(u) {
                        const t = this._locale[u];
                        if (t == null) throw new Error(`Missing UI string '${u}'`);
                        return t
                    }

                    _updateStyle(u, t) {
                        if (this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), u) {
                            const s = o.h({}, t);
                            t && t.config && (s.initialConfig = t.config, delete s.config), this.style = new xs(this, s).load(u), this.style.setEventedParent(this, {style: this.style})
                        }
                        return this._updateTerrain(), this
                    }

                    _lazyInitEmptyStyle() {
                        this.style || (this.style = new xs(this, {}), this.style.setEventedParent(this, {style: this.style}), this.style.loadEmpty())
                    }

                    getStyle() {
                        if (this.style) return this.style.serialize()
                    }

                    isStyleLoaded() {
                        return this.style ? this.style.loaded() : (o.w("There is no style added to the map."), !1)
                    }

                    _isValidId(u) {
                        return u == null ? (this.fire(new o.z(new Error("IDs can't be empty."))), !1) : !o.dk(u) || (this.fire(new o.z(new Error(`IDs can't contain special symbols: "${u}".`))), !1)
                    }

                    _isTargetValid(u) {
                        return "featuresetId" in u ? this._isValidId("importId" in u ? u.importId : u.featuresetId) : "layerId" in u && this._isValidId(u.layerId)
                    }

                    _areTargetsValid(u) {
                        if (Array.isArray(u)) {
                            for (const t of u) if (!this._isValidId(t)) return !1;
                            return !0
                        }
                        return this._isTargetValid(u)
                    }

                    addSource(u, t) {
                        return this._isValidId(u) ? (this._lazyInitEmptyStyle(), this.style.addSource(u, t), this._update(!0)) : this
                    }

                    isSourceLoaded(u) {
                        return !!this._isValidId(u) && !!this.style && this.style._isSourceCacheLoaded(u)
                    }

                    areTilesLoaded() {
                        return this.style.areTilesLoaded()
                    }

                    addSourceType(u, t, s) {
                        this._lazyInitEmptyStyle(), this.style.addSourceType(u, t, s)
                    }

                    removeSource(u) {
                        return this._isValidId(u) ? (this.style.removeSource(u), this._updateTerrain(), this._update(!0)) : this
                    }

                    getSource(u) {
                        return this._isValidId(u) ? this.style.getOwnSource(u) : null
                    }

                    addImage(u, t, {pixelRatio: s = 1, sdf: h = !1, stretchX: m, stretchY: g, content: v} = {}) {
                        this._lazyInitEmptyStyle();
                        const b = o.I.from(u);
                        if (t instanceof HTMLImageElement || ImageBitmap && t instanceof ImageBitmap) {
                            const {width: S, height: P, data: M} = o.q.getImageData(t);
                            this.style.addImage(b, {
                                data: new o.r({width: S, height: P}, M),
                                pixelRatio: s,
                                stretchX: m,
                                stretchY: g,
                                content: v,
                                sdf: h,
                                version: 0,
                                usvg: !1
                            })
                        } else if (t.width === void 0 || t.height === void 0) this.fire(new o.z(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))); else {
                            const {width: S, height: P} = t, M = t;
                            this.style.addImage(b, {
                                data: new o.r({width: S, height: P}, new Uint8Array(M.data)),
                                pixelRatio: s,
                                stretchX: m,
                                stretchY: g,
                                content: v,
                                sdf: h,
                                usvg: !1,
                                version: 0,
                                userImage: M
                            }), M.onAdd && M.onAdd(this, u)
                        }
                    }

                    updateImage(u, t) {
                        this._lazyInitEmptyStyle();
                        const s = o.I.from(u), h = this.style.getImage(s);
                        if (!h) return void this.fire(new o.z(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                        const m = t instanceof HTMLImageElement || ImageBitmap && t instanceof ImageBitmap ? o.q.getImageData(t) : t, {
                            width: g,
                            height: v,
                            data: b
                        } = m;
                        if (g === void 0 || v === void 0) return void this.fire(new o.z(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                        if (g !== (h.usvg ? h.icon.usvg_tree.width : h.data.width) || v !== (h.usvg ? h.icon.usvg_tree.height : h.data.height)) return void this.fire(new o.z(new Error(`The width and height of the updated image (${g}, ${v})
                must be that same as the previous version of the image
                (${h.data.width}, ${h.data.height})`)));
                        const S = !(t instanceof HTMLImageElement || ImageBitmap && t instanceof ImageBitmap);
                        let P = !1;
                        h.usvg ? (h.data = new o.r({
                            width: g,
                            height: v
                        }, new Uint8Array(b)), h.usvg = !1, h.icon = void 0, P = !0) : h.data.replace(b, S), this.style.updateImage(s, h, P)
                    }

                    hasImage(u) {
                        return u ? !!this.style && !!this.style.getImage(o.I.from(u)) : (this.fire(new o.z(new Error("Missing required image id"))), !1)
                    }

                    removeImage(u) {
                        this.style.removeImage(o.I.from(u))
                    }

                    loadImage(u, t) {
                        o.o(this._requestManager.transformRequest(u, o.R.Image), (s, h) => {
                            t(s, h instanceof HTMLImageElement ? o.q.getImageData(h) : h)
                        })
                    }

                    listImages() {
                        return this.style.listImages().map(u => u.name)
                    }

                    addModel(u, t) {
                        this._lazyInitEmptyStyle(), this.style.addModel(u, t)
                    }

                    hasModel(u) {
                        return u ? this.style.hasModel(u) : (this.fire(new o.z(new Error("Missing required model id"))), !1)
                    }

                    removeModel(u) {
                        this.style.removeModel(u)
                    }

                    listModels() {
                        return this.style.listModels()
                    }

                    addLayer(u, t) {
                        return this._isValidId(u.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(u, t), this._update(!0)) : this
                    }

                    getSlot(u) {
                        const t = this.getLayer(u);
                        return t && t.slot || null
                    }

                    setSlot(u, t) {
                        return this.style.setSlot(u, t), this.style.mergeLayers(), this._update(!0)
                    }

                    addImport(u, t) {
                        return this.style.addImport(u, t).catch(s => this.fire(new o.z(new Error("Failed to add import", s)))), this
                    }

                    updateImport(u, t) {
                        return typeof t != "string" && t.id !== u ? (this.removeImport(u), this.addImport(t)) : (this.style.updateImport(u, t), this._update(!0))
                    }

                    removeImport(u) {
                        return this.style.removeImport(u), this
                    }

                    moveImport(u, t) {
                        return this.style.moveImport(u, t), this._update(!0)
                    }

                    moveLayer(u, t) {
                        return this._isValidId(u) ? (this.style.moveLayer(u, t), this._update(!0)) : this
                    }

                    removeLayer(u) {
                        return this._isValidId(u) ? (this.style.removeLayer(u), this._update(!0)) : this
                    }

                    getLayer(u) {
                        if (!this._isValidId(u)) return null;
                        const t = this.style.getOwnLayer(u);
                        return t ? t.type === "custom" ? t.implementation : t.serialize() : void 0
                    }

                    getSlots() {
                        return this.style.getSlots()
                    }

                    setLayerZoomRange(u, t, s) {
                        return this._isValidId(u) ? (this.style.setLayerZoomRange(u, t, s), this._update(!0)) : this
                    }

                    setFilter(u, t, s = {}) {
                        return this._isValidId(u) ? (this.style.setFilter(u, t, s), this._update(!0)) : this
                    }

                    getFilter(u) {
                        return this._isValidId(u) ? this.style.getFilter(u) : null
                    }

                    setPaintProperty(u, t, s, h = {}) {
                        return this._isValidId(u) ? (this.style.setPaintProperty(u, t, s, h), this._update(!0)) : this
                    }

                    getPaintProperty(u, t) {
                        return this._isValidId(u) ? this.style.getPaintProperty(u, t) : null
                    }

                    setLayoutProperty(u, t, s, h = {}) {
                        return this._isValidId(u) ? (this.style.setLayoutProperty(u, t, s, h), this._update(!0)) : this
                    }

                    getLayoutProperty(u, t) {
                        return this._isValidId(u) ? this.style.getLayoutProperty(u, t) : null
                    }

                    getGlyphsUrl() {
                        return this.style.getGlyphsUrl()
                    }

                    setGlyphsUrl(u) {
                        return this.style.setGlyphsUrl(u), this._update(!0)
                    }

                    getSchema(u) {
                        return this.style.getSchema(u)
                    }

                    setSchema(u, t) {
                        return this.style.setSchema(u, t), this._update(!0)
                    }

                    getConfig(u) {
                        return this.style.getConfig(u)
                    }

                    setConfig(u, t) {
                        return this.style.setConfig(u, t), this._update(!0)
                    }

                    getConfigProperty(u, t) {
                        return this.style.getConfigProperty(u, t)
                    }

                    setConfigProperty(u, t, s) {
                        return this.style.setConfigProperty(u, t, s), this._update(!0)
                    }

                    getFeaturesetDescriptors(u) {
                        return this.style.getFeaturesetDescriptors(u)
                    }

                    setLights(u) {
                        if (this._lazyInitEmptyStyle(), u && u.length === 1 && u[0].type === "flat") {
                            const t = u[0];
                            t.properties ? this.style.setFlatLight(t.properties, t.id, {}) : this.style.setFlatLight({}, "flat")
                        } else this.style.setLights(u), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = !0);
                        return this._update(!0)
                    }

                    getLights() {
                        const u = this.style.getLights() || [];
                        return u.length === 0 && u.push({
                            id: this.style.light.id,
                            type: "flat",
                            properties: this.style.getFlatLight()
                        }), u
                    }

                    setLight(u, t = {}) {
                        return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."), this.setLights([{
                            id: "flat",
                            type: "flat",
                            properties: u
                        }])
                    }

                    getLight() {
                        return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."), this.style.getFlatLight()
                    }

                    setTerrain(u) {
                        return this._lazyInitEmptyStyle(), !u && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(u), this._averageElevationLastSampledAt = -1 / 0, this._update(!0)
                    }

                    getTerrain() {
                        return this.style ? this.style.getTerrain() : null
                    }

                    setFog(u) {
                        return this._lazyInitEmptyStyle(), this.style.setFog(u), this._update(!0)
                    }

                    getFog() {
                        return this.style ? this.style.getFog() : null
                    }

                    setSnow(u) {
                        return this._lazyInitEmptyStyle(), this.style.setSnow(u), this._update(!0)
                    }

                    getSnow() {
                        return this.style ? this.style.getSnow() : null
                    }

                    setRain(u) {
                        return this._lazyInitEmptyStyle(), this.style.setRain(u), this._update(!0)
                    }

                    getRain() {
                        return this.style ? this.style.getRain() : null
                    }

                    setColorTheme(u) {
                        return this._lazyInitEmptyStyle(), this.style.setColorTheme(u), this._update(!0)
                    }

                    setImportColorTheme(u, t) {
                        return this._lazyInitEmptyStyle(), this.style.setImportColorTheme(u, t), this._update(!0)
                    }

                    setCamera(u) {
                        return this.style.setCamera(u), this._triggerCameraUpdate(u)
                    }

                    _triggerCameraUpdate(u) {
                        return this._update(this.transform.setOrthographicProjectionAtLowPitch(u["camera-projection"] === "orthographic"))
                    }

                    getCamera() {
                        return this.style.camera
                    }

                    _queryFogOpacity(u) {
                        return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(o.ci.convert(u), this.transform) : 0
                    }

                    setFeatureState(u, t) {
                        return u.source && !this._isValidId(u.source) ? this : (this.style.setFeatureState(u, t), this._update())
                    }

                    removeFeatureState(u, t) {
                        return u.source && !this._isValidId(u.source) ? this : (this.style.removeFeatureState(u, t), this._update())
                    }

                    getFeatureState(u) {
                        return u.source && !this._isValidId(u.source) ? null : this.style.getFeatureState(u)
                    }

                    _selectIndoorFloor(u) {
                        this.indoor.selectFloor(u)
                    }

                    _addIndoorControl() {
                        this._indoorControl || (this._indoorControl = new jm), this.addControl(this._indoorControl, "right")
                    }

                    _removeIndoorControl() {
                        this._indoorControl && this.removeControl(this._indoorControl)
                    }

                    _updateContainerDimensions() {
                        if (!this._container) return;
                        const u = this._container.getBoundingClientRect().width || 400,
                            t = this._container.getBoundingClientRect().height || 300;
                        let s, h, m, g = this._container;
                        for (; g && (!h || !m);) {
                            const v = window.getComputedStyle(g).transform;
                            v && v !== "none" && (s = v.match(/matrix.*\((.+)\)/)[1].split(", "), s[0] && s[0] !== "0" && s[0] !== "1" && (h = s[0]), s[3] && s[3] !== "0" && s[3] !== "1" && (m = s[3])), g = g.parentElement
                        }
                        this._containerWidth = h ? Math.abs(u / h) : u, this._containerHeight = m ? Math.abs(t / m) : t
                    }

                    _detectMissingCSS() {
                        window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") !== "rgb(250, 128, 114)" && o.w("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.")
                    }

                    _setupContainer() {
                        const u = this._container;
                        u.classList.add("mapboxgl-map"), (this._missingCSSCanary = fe("div", "mapboxgl-canary", u)).style.visibility = "hidden", this._detectMissingCSS();
                        const t = this._canvasContainer = fe("div", "mapboxgl-canvas-container", u);
                        this._canvas = fe("canvas", "mapboxgl-canvas", t), this._interactive && (t.classList.add("mapboxgl-interactive"), this._canvas.setAttribute("tabindex", "0")), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
                        const s = this._controlContainer = fe("div", "mapboxgl-control-container", u),
                            h = this._controlPositions = {};
                        ["top-left", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left"].forEach(m => {
                            h[m] = fe("div", `mapboxgl-ctrl-${m}`, s)
                        }), this._container.addEventListener("scroll", this._onMapScroll, !1)
                    }

                    _resizeCanvas(u, t) {
                        const s = o.q.devicePixelRatio || 1;
                        this._canvas.width = s * Math.ceil(u), this._canvas.height = s * Math.ceil(t), this._canvas.style.width = `${u}px`, this._canvas.style.height = `${t}px`
                    }

                    _addMarker(u) {
                        this._markers.push(u)
                    }

                    _removeMarker(u) {
                        const t = this._markers.indexOf(u);
                        t !== -1 && this._markers.splice(t, 1)
                    }

                    _addPopup(u) {
                        this._popups.push(u)
                    }

                    _removePopup(u) {
                        const t = this._popups.indexOf(u);
                        t !== -1 && this._popups.splice(t, 1)
                    }

                    _setupPainter() {
                        const u = o.h({}, Re.supported.webGLContextAttributes, {
                            failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
                            preserveDrawingBuffer: this._preserveDrawingBuffer,
                            antialias: this._antialias || !1
                        }), t = this._canvas.getContext("webgl2", u);
                        t ? (wo(t, !0), this.painter = new cl(t, this._contextCreateOptions, this.transform, this._scaleFactor, this._tp, this._worldview), this.on("data", s => {
                            s.dataType === "source" && this.painter.setTileLoadedFlag(!0)
                        }), o.l.testSupport(t)) : this.fire(new o.z(new Error("Failed to initialize WebGL")))
                    }

                    _contextLost(u) {
                        u.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new o.A("webglcontextlost", {originalEvent: u}))
                    }

                    _contextRestored(u) {
                        this._setupPainter(), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight)), this._updateTerrain(), this.style && (this.style.clearLayers(), this.style.imageManager.destroyAtlasTextures(), this.style.reloadModels(), this.style.clearSources()), this._update(), this.fire(new o.A("webglcontextrestored", {originalEvent: u}))
                    }

                    _onMapScroll(u) {
                        if (u.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1
                    }

                    idle() {
                        return !this.isMoving() && this.loaded()
                    }

                    loaded() {
                        return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
                    }

                    frameReady() {
                        return this.loaded() && !this._placementDirty
                    }

                    _update(u) {
                        return this.style ? (this._styleDirty = this._styleDirty || u, this._sourcesDirty = !0, this.triggerRepaint(), this) : this
                    }

                    _requestRenderFrame(u) {
                        return this._update(), this._renderTaskQueue.add(u)
                    }

                    _cancelRenderFrame(u) {
                        this._renderTaskQueue.remove(u)
                    }

                    _requestDomTask(u) {
                        !this.loaded() || this.loaded() && !this.isMoving() ? u() : this._domRenderTaskQueue.add(u)
                    }

                    _render(u) {
                        let t;
                        this.fire(new o.A("renderstart")), ++this._frameId;
                        const s = this.painter.context.extTimerQuery, h = o.q.now(), m = this.painter.context.gl;
                        if (this.listens("gpu-timing-frame") && (t = m.createQuery(), m.beginQuery(s.TIME_ELAPSED_EXT, t)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(u), this._domRenderTaskQueue.run(u), this._removed) return;
                        this._updateProjectionTransition();
                        const g = this._isInitialLoad ? 0 : this._fadeDuration;
                        if (this.style && this._styleDirty) {
                            this._styleDirty = !1;
                            const P = this.transform.zoom, M = this.transform.pitch, k = o.q.now(), R = new o.aa(P, {
                                now: k,
                                fadeDuration: g,
                                pitch: M,
                                transition: this.style.transition,
                                worldview: this._worldview
                            });
                            this.style.update(R)
                        }
                        this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);
                        let v = !1;
                        this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), v = this._updateAverageElevation(h), this.style.updateSources(this.transform), this.style.updateImageProviders(), this.isMoving() || this._forceMarkerAndPopupUpdate()) : v = this._updateAverageElevation(h);
                        const b = this.style && this.style._updatePlacement(this.painter, this.painter.transform, this.showCollisionBoxes, g, this._crossSourceCollisions, this.painter.replacementSource, this._scaleFactorChanged);
                        if (this._scaleFactorChanged && (this._scaleFactorChanged = !1), b && (this._placementDirty = b.needsRerender), this.style && this.painter.render(this.style, {
                            showTileBoundaries: this.showTileBoundaries,
                            showParseStatus: this.showParseStatus,
                            wireframe: {
                                terrain: this.showTerrainWireframe,
                                layers2D: this.showLayers2DWireframe,
                                layers3D: this.showLayers3DWireframe
                            },
                            showOverdrawInspector: this._showOverdrawInspector,
                            showQueryGeometry: !!this._showQueryGeometry,
                            showTileAABBs: this.showTileAABBs,
                            rotating: this.isRotating(),
                            zooming: this.isZooming(),
                            moving: this.isMoving(),
                            fadeDuration: g,
                            isInitialLoad: this._isInitialLoad,
                            showPadding: this.showPadding,
                            gpuTiming: !!this.listens("gpu-timing-layer"),
                            gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"),
                            speedIndexTiming: this.speedIndexTiming
                        }), this.fire(new o.A("render")), this.loaded() && !this._loaded && (this._loaded = !0, ee.mark(q.load), this.fire(new o.A("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && (this.style.snow || this.style.rain) && (this._styleDirty = !0), this.style && this.style.imageManager.hasPatternsInFlight() && (this._styleDirty = !0), this.style && !this.style.modelManager.isLoaded() && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), t) {
                            const P = o.q.now() - h;
                            m.endQuery(s.TIME_ELAPSED_EXT), setTimeout(() => {
                                const M = m.getQueryParameter(t, m.QUERY_RESULT) / 1e6;
                                m.deleteQuery(t), this.fire(new o.A("gpu-timing-frame", {cpuTime: P, gpuTime: M}))
                            }, 50)
                        }
                        if (this.listens("gpu-timing-layer")) {
                            const P = this.painter.collectGpuTimers();
                            setTimeout(() => {
                                const M = this.painter.queryGpuTimers(P);
                                this.fire(new o.A("gpu-timing-layer", {layerTimes: M}))
                            }, 50)
                        }
                        if (this.listens("gpu-timing-deferred-render")) {
                            const P = this.painter.collectDeferredRenderGpuQueries();
                            setTimeout(() => {
                                const M = this.painter.queryGpuTimeDeferredRender(P);
                                this.fire(new o.A("gpu-timing-deferred-render", {gpuTime: M}))
                            }, 50)
                        }
                        const S = this._sourcesDirty || this._styleDirty || this._placementDirty || v;
                        if (S || this._repaint) this.triggerRepaint(); else {
                            const P = this.idle();
                            if (P && (v = this._updateAverageElevation(h, !0)), v) this.triggerRepaint(); else if (this._triggerFrame(!1), P && (this.fire(new o.A("idle")), this._isInitialLoad = !1, this.speedIndexTiming)) {
                                const M = this._calculateSpeedIndex();
                                this.fire(new o.A("speedindexcompleted", {speedIndex: M})), this.speedIndexTiming = !1
                            }
                        }
                        !this._loaded || this._fullyLoaded || S || (this._fullyLoaded = !0, ee.mark(q.fullLoad), this._performanceMetricsCollection && Bn(this._requestManager._customAccessToken, {
                            width: this.painter.width,
                            height: this.painter.height,
                            interactionRange: this._interactionRange,
                            visibilityHidden: this._visibilityHidden,
                            terrainEnabled: !!this.painter.style.getTerrain(),
                            fogEnabled: !!this.painter.style.getFog(),
                            projection: this.getProjection().name,
                            zoom: this.transform.zoom,
                            renderer: this.painter.context.renderer,
                            vendor: this.painter.context.vendor
                        }), this._authenticate())
                    }

                    _forceMarkerAndPopupUpdate(u) {
                        for (const t of this._markers) u && !this.getRenderWorldCopies() && (t._lngLat = t._lngLat.wrap()), t._update();
                        for (const t of this._popups) !u || this.getRenderWorldCopies() || t._trackPointer || (t._lngLat = t._lngLat.wrap()), t._update()
                    }

                    _updateAverageElevation(u, t = !1) {
                        const s = m => (this.transform.averageElevation = m, this._update(!1), !0);
                        if (!this.painter.averageElevationNeedsEasing()) return this.transform.averageElevation !== 0 && s(0);
                        const h = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;
                        if (h || (t || u - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(u)) {
                            const m = this.transform.averageElevation;
                            let g = this.transform.sampleAverageElevation();
                            this.transform.elevation != null && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(g) ? g = 0 : this._averageElevationLastSampledAt = u;
                            const v = Math.abs(m - g);
                            if (v > 1) {
                                if (this._isInitialLoad || h) return this._averageElevation.jumpTo(g), s(g);
                                this._averageElevation.easeTo(g, u, 300)
                            } else if (v > 1e-4) return this._averageElevation.jumpTo(g), s(g)
                        }
                        return !!this._averageElevation.isEasing(u) && s(this._averageElevation.getValue(u))
                    }

                    _authenticate() {
                        An(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, u => {
                            if (u && (u.message === Mi || u.status === 401)) {
                                const t = this.painter.context.gl;
                                wo(t, !1), this._logoControl instanceof Ph && this._logoControl._updateLogo(), t && t.clear(t.DEPTH_BUFFER_BIT | t.COLOR_BUFFER_BIT | t.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new o.z(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")))
                            }
                        }), cn(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
                        })
                    }

                    _postStyleLoadEvent() {
                        this.style.globalId && Bi(this._requestManager._customAccessToken, {
                            map: this,
                            style: this.style.globalId,
                            importedStyles: this.style.getImportGlobalIds()
                        })
                    }

                    _updateTerrain() {
                        const u = this._isDragging();
                        this.painter.updateTerrain(this.style, u)
                    }

                    _calculateSpeedIndex() {
                        const u = this.painter.canvasCopy(), t = this.painter.getCanvasCopiesAndTimestamps();
                        t.timeStamps.push(performance.now());
                        const s = this.painter.context.gl, h = s.createFramebuffer();

                        function m(g) {
                            s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, g, 0);
                            const v = new Uint8Array(s.drawingBufferWidth * s.drawingBufferHeight * 4);
                            return s.readPixels(0, 0, s.drawingBufferWidth, s.drawingBufferHeight, s.RGBA, s.UNSIGNED_BYTE, v), v
                        }

                        return s.bindFramebuffer(s.FRAMEBUFFER, h), this._canvasPixelComparison(m(u), t.canvasCopies.map(m), t.timeStamps)
                    }

                    _canvasPixelComparison(u, t, s) {
                        let h = s[1] - s[0];
                        const m = u.length / 4;
                        for (let g = 0; g < t.length; g++) {
                            const v = t[g];
                            let b = 0;
                            for (let S = 0; S < v.length; S += 4) v[S] === u[S] && v[S + 1] === u[S + 1] && v[S + 2] === u[S + 2] && v[S + 3] === u[S + 3] && (b += 1);
                            h += (s[g + 2] - s[g + 1]) * (1 - b / m)
                        }
                        return h
                    }

                    remove() {
                        this._hash && this._hash.remove();
                        for (const t of this._controls) t.onRemove(this);
                        this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.indoor.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener("resize", this._onWindowResize, !1), window.removeEventListener("orientationchange", this._onWindowResize, !1), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.removeEventListener("online", this._onWindowOnline, !1), window.removeEventListener("visibilitychange", this._onVisibilityChange, !1);
                        const u = this.painter.context.gl.getExtension("WEBGL_lose_context");
                        u && u.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, !1), Zr.delete(this.painter.context.gl), ar.remove(), nn.remove(), this._removed = !0, this.fire(new o.A("remove"))
                    }

                    triggerRepaint() {
                        this._triggerFrame(!0)
                    }

                    _triggerFrame(u) {
                        this._renderNextFrame = this._renderNextFrame || u, this.style && !this._frame && (this._frame = o.q.frame(t => {
                            const s = !!this._renderNextFrame;
                            this._frame = null, this._renderNextFrame = null, s && this._render(t)
                        }))
                    }

                    _preloadTiles(u) {
                        const t = this.style ? this.style.getSourceCaches() : [];
                        return o.bt(t, (s, h) => s._preloadTiles(u, h), () => {
                            this.triggerRepaint()
                        }), this
                    }

                    _onWindowOnline() {
                        this._update()
                    }

                    _onWindowResize(u) {
                        this._trackResize && this.resize({originalEvent: u})._update()
                    }

                    _onVisibilityChange() {
                        document.visibilityState === "hidden" && this._visibilityHidden++
                    }

                    get showTileBoundaries() {
                        return !!this._showTileBoundaries
                    }

                    set showTileBoundaries(u) {
                        this._showTileBoundaries !== u && (this._showTileBoundaries = u, this._tp.refreshUI(), this._update())
                    }

                    get showParseStatus() {
                        return !!this._showParseStatus
                    }

                    set showParseStatus(u) {
                        this._showParseStatus !== u && (this._showParseStatus = u, this._tp.refreshUI(), this._update())
                    }

                    get showTerrainWireframe() {
                        return !!this._showTerrainWireframe
                    }

                    set showTerrainWireframe(u) {
                        this._showTerrainWireframe !== u && (this._showTerrainWireframe = u, this._tp.refreshUI(), this._update())
                    }

                    get showLayers2DWireframe() {
                        return !!this._showLayers2DWireframe
                    }

                    set showLayers2DWireframe(u) {
                        this._showLayers2DWireframe !== u && (this._showLayers2DWireframe = u, this._tp.refreshUI(), this._update())
                    }

                    get showLayers3DWireframe() {
                        return !!this._showLayers3DWireframe
                    }

                    set showLayers3DWireframe(u) {
                        this._showLayers3DWireframe !== u && (this._showLayers3DWireframe = u, this._tp.refreshUI(), this._update())
                    }

                    get speedIndexTiming() {
                        return !!this._speedIndexTiming
                    }

                    set speedIndexTiming(u) {
                        this._speedIndexTiming !== u && (this._speedIndexTiming = u, this._update())
                    }

                    get showPadding() {
                        return !!this._showPadding
                    }

                    set showPadding(u) {
                        this._showPadding !== u && (this._showPadding = u, this._tp.refreshUI(), this._update())
                    }

                    get showCollisionBoxes() {
                        return !!this._showCollisionBoxes
                    }

                    set showCollisionBoxes(u) {
                        this._showCollisionBoxes !== u && (this._showCollisionBoxes = u, this._tp.refreshUI(), u ? this.style._generateCollisionBoxes() : this._update())
                    }

                    get showOverdrawInspector() {
                        return !!this._showOverdrawInspector
                    }

                    set showOverdrawInspector(u) {
                        this._showOverdrawInspector !== u && (this._showOverdrawInspector = u, this._tp.refreshUI(), this._update())
                    }

                    get repaint() {
                        return !!this._repaint
                    }

                    set repaint(u) {
                        this._repaint !== u && (this._repaint = u, this._tp.refreshUI(), this.triggerRepaint())
                    }

                    get vertices() {
                        return !!this._vertices
                    }

                    set vertices(u) {
                        this._vertices = u, this._update()
                    }

                    get showTileAABBs() {
                        return !!this._showTileAABBs
                    }

                    set showTileAABBs(u) {
                        this._showTileAABBs !== u && (this._showTileAABBs = u, this._tp.refreshUI(), u && this._update())
                    }

                    _setCacheLimits(u, t) {
                        o.eV(u, t)
                    }

                    get version() {
                        return j
                    }
                },
                NavigationControl: class {
                    constructor(u = {}) {
                        this.options = o.h({}, Yc, u), this._container = fe("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", t => t.preventDefault()), this.options.showZoom && (o.aV(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", t => {
                            this._map && this._map.zoomIn({}, {originalEvent: t})
                        }), fe("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", t => {
                            this._map && this._map.zoomOut({}, {originalEvent: t})
                        }), fe("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (o.aV(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", t => {
                            const s = this._map;
                            s && (this.options.visualizePitch ? s.resetNorthPitch({}, {originalEvent: t}) : s.resetNorth({}, {originalEvent: t}))
                        }), this._compassIcon = fe("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"))
                    }

                    _updateZoomButtons() {
                        const u = this._map;
                        if (!u) return;
                        const t = u.getZoom(), s = t === u.getMaxZoom(), h = t === u.getMinZoom();
                        this._zoomInButton.disabled = s, this._zoomOutButton.disabled = h, this._zoomInButton.setAttribute("aria-disabled", s.toString()), this._zoomOutButton.setAttribute("aria-disabled", h.toString())
                    }

                    _rotateCompassArrow() {
                        const u = this._map;
                        if (!u) return;
                        const t = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(u.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${u.transform.pitch}deg) rotateZ(${u.transform.angle * (180 / Math.PI)}deg)` : `rotate(${u.transform.angle * (180 / Math.PI)}deg)`;
                        u._requestDomTask(() => {
                            this._compassIcon && (this._compassIcon.style.transform = t)
                        })
                    }

                    onAdd(u) {
                        return this._map = u, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), u.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && u.on("pitch", this._rotateCompassArrow), u.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new wa(u, this._compass, this.options.visualizePitch)), this._container
                    }

                    onRemove() {
                        const u = this._map;
                        u && (this._container.remove(), this.options.showZoom && u.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && u.off("pitch", this._rotateCompassArrow), u.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0)
                    }

                    _createButton(u, t) {
                        const s = fe("button", u, this._container);
                        return s.type = "button", s.addEventListener("click", t), s
                    }

                    _setButtonTitle(u, t) {
                        if (!this._map) return;
                        const s = this._map._getUIString(`NavigationControl.${t}`);
                        u.setAttribute("aria-label", s), u.firstElementChild && u.firstElementChild.setAttribute("title", s)
                    }
                },
                GeolocateControl: class extends o.E {
                    constructor(u = {}) {
                        super();
                        const t = navigator.geolocation;
                        this.options = o.h({geolocation: t}, m1, u), o.aV(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = Gc(this._updateMarkerRotation, 20), this._numberOfWatches = 0
                    }

                    onAdd(u) {
                        return this._map = u, this._container = fe("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container
                    }

                    onRemove() {
                        this._geolocationWatchID !== void 0 && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1
                    }

                    _checkGeolocationSupport(u) {
                        const t = (s = !!this.options.geolocation) => {
                            this._supportsGeolocation = s, u(s)
                        };
                        this._supportsGeolocation !== void 0 ? u(this._supportsGeolocation) : navigator.permissions !== void 0 ? navigator.permissions.query({name: "geolocation"}).then(s => t(s.state !== "denied")).catch(() => t()) : t()
                    }

                    _isOutOfMapMaxBounds(u) {
                        const t = this._map.getMaxBounds(), s = u.coords;
                        return !!t && (s.longitude < t.getWest() || s.longitude > t.getEast() || s.latitude < t.getSouth() || s.latitude > t.getNorth())
                    }

                    _setErrorState() {
                        switch (this._watchState) {
                            case"WAITING_ACTIVE":
                                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                                break;
                            case"ACTIVE_LOCK":
                                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                                break;
                            case"BACKGROUND":
                                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting")
                        }
                    }

                    _onSuccess(u) {
                        if (this._map) {
                            if (this._isOutOfMapMaxBounds(u)) return this._setErrorState(), this.fire(new o.A("outofmaxbounds", u)), this._updateMarker(), void this._finish();
                            if (this.options.trackUserLocation) switch (this._lastKnownPosition = u, this._watchState) {
                                case"WAITING_ACTIVE":
                                case"ACTIVE_LOCK":
                                case"ACTIVE_ERROR":
                                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                    break;
                                case"BACKGROUND":
                                case"BACKGROUND_ERROR":
                                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background")
                            }
                            this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(u), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(u), this.options.showUserLocation && this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"), this.fire(new o.A("geolocate", u)), this._finish()
                        }
                    }

                    _updateCamera(u) {
                        const t = new o.ci(u.coords.longitude, u.coords.latitude), s = u.coords.accuracy,
                            h = this._map.getBearing(), m = o.h({bearing: h}, this.options.fitBoundsOptions);
                        this._map.fitBounds(t.toBounds(s), m, {geolocateSource: !0})
                    }

                    _updateMarker(u) {
                        if (u) {
                            const t = new o.ci(u.coords.longitude, u.coords.latitude);
                            this._accuracyCircleMarker.setLngLat(t).addTo(this._map), this._userLocationDotMarker.setLngLat(t).addTo(this._map), this._accuracy = u.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                        } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove()
                    }

                    _updateCircleRadius() {
                        const u = this._map.transform, t = o.cb(1, u._center.lat) * u.worldSize,
                            s = Math.ceil(2 * this._accuracy * t);
                        this._circleElement.style.width = `${s}px`, this._circleElement.style.height = `${s}px`
                    }

                    _onZoom() {
                        this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                    }

                    _updateMarkerRotation() {
                        this._userLocationDotMarker && typeof this._heading == "number" ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")) : (this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0))
                    }

                    _onError(u) {
                        if (this._map) {
                            if (this.options.trackUserLocation) if (u.code === 1) {
                                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                                const t = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                this._geolocateButton.setAttribute("aria-label", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t), this._geolocationWatchID !== void 0 && this._clearWatch()
                            } else {
                                if (u.code === 3 && this._noTimeout) return;
                                this._setErrorState()
                            }
                            this._watchState !== "OFF" && this.options.showUserLocation && this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"), this.fire(new o.A("error", u)), this._finish()
                        }
                    }

                    _finish() {
                        this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0
                    }

                    _setupUI(u) {
                        if (this._map !== void 0) {
                            if (this._container.addEventListener("contextmenu", t => t.preventDefault()), this._geolocateButton = fe("button", "mapboxgl-ctrl-geolocate", this._container), fe("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", u === !1) {
                                o.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                                const t = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute("aria-label", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t)
                            } else {
                                const t = this._map._getUIString("GeolocateControl.FindMyLocation");
                                this._geolocateButton.setAttribute("aria-label", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t)
                            }
                            this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = fe("div", "mapboxgl-user-location"), this._dotElement.appendChild(fe("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(fe("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new es({
                                element: this._dotElement,
                                rotationAlignment: "map",
                                pitchAlignment: "map"
                            }), this._circleElement = fe("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new es({
                                element: this._circleElement,
                                pitchAlignment: "map"
                            }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", t => {
                                t.geolocateSource || this._watchState !== "ACTIVE_LOCK" || t.originalEvent && t.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new o.A("trackuserlocationend")))
                            })
                        }
                    }

                    _onDeviceOrientation(u) {
                        this._userLocationDotMarker && (u.webkitCompassHeading ? this._heading = u.webkitCompassHeading : u.absolute === !0 && (this._heading = -1 * u.alpha), this._updateMarkerRotationThrottled())
                    }

                    trigger() {
                        if (!this._setup) return o.w("Geolocate control triggered before added to a map"), !1;
                        if (this.options.trackUserLocation) {
                            switch (this._watchState) {
                                case"OFF":
                                    this._watchState = "WAITING_ACTIVE", this.fire(new o.A("trackuserlocationstart"));
                                    break;
                                case"WAITING_ACTIVE":
                                case"ACTIVE_LOCK":
                                case"ACTIVE_ERROR":
                                case"BACKGROUND_ERROR":
                                    this._numberOfWatches--, this._noTimeout = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new o.A("trackuserlocationend"));
                                    break;
                                case"BACKGROUND":
                                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new o.A("trackuserlocationstart"))
                            }
                            switch (this._watchState) {
                                case"WAITING_ACTIVE":
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                    break;
                                case"ACTIVE_LOCK":
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                    break;
                                case"ACTIVE_ERROR":
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                                    break;
                                case"BACKGROUND":
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                                    break;
                                case"BACKGROUND_ERROR":
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error")
                            }
                            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch(); else if (this._geolocationWatchID === void 0) {
                                let u;
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (u = {
                                    maximumAge: 6e5,
                                    timeout: 0
                                }, this._noTimeout = !0) : (u = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, u), this.options.showUserHeading && this._addDeviceOrientationListener()
                            }
                        } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = window.setTimeout(this._finish, 1e4);
                        return !0
                    }

                    _addDeviceOrientationListener() {
                        const u = () => {
                            "ondeviceorientationabsolute" in window ? window.addEventListener("deviceorientationabsolute", this._onDeviceOrientation) : window.addEventListener("deviceorientation", this._onDeviceOrientation)
                        };
                        typeof DeviceMotionEvent < "u" && typeof DeviceMotionEvent.requestPermission == "function" ? DeviceOrientationEvent.requestPermission().then(t => {
                            t === "granted" && u()
                        }).catch(console.error) : u()
                    }

                    _clearWatch() {
                        this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener("deviceorientation", this._onDeviceOrientation), window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null)
                    }
                },
                AttributionControl: Xc,
                ScaleControl: class {
                    constructor(u = {}) {
                        this.options = o.h({}, g1, u), this._isNumberFormatSupported = function () {
                            try {
                                return new Intl.NumberFormat("en", {
                                    style: "unit",
                                    unitDisplay: "short",
                                    unit: "meter"
                                }), !0
                            } catch {
                                return !1
                            }
                        }(), o.aV(["_update", "_setScale", "setUnit"], this)
                    }

                    getDefaultPosition() {
                        return "bottom-left"
                    }

                    _update() {
                        const u = this.options.maxWidth || 100, t = this._map, s = t._containerHeight / 2,
                            h = t._containerWidth / 2 - u / 2, m = t.unproject([h, s]), g = t.unproject([h + u, s]),
                            v = m.distanceTo(g);
                        if (this.options.unit === "imperial") {
                            const b = 3.2808 * v;
                            b > 5280 ? this._setScale(u, b / 5280, "mile") : this._setScale(u, b, "foot")
                        } else this.options.unit === "nautical" ? this._setScale(u, v / 1852, "nautical-mile") : v >= 1e3 ? this._setScale(u, v / 1e3, "kilometer") : this._setScale(u, v, "meter")
                    }

                    _setScale(u, t, s) {
                        this._map._requestDomTask(() => {
                            const h = function (g) {
                                const v = Math.pow(10, `${Math.floor(g)}`.length - 1);
                                let b = g / v;
                                return b = b >= 10 ? 10 : b >= 5 ? 5 : b >= 3 ? 3 : b >= 2 ? 2 : b >= 1 ? 1 : function (S) {
                                    const P = Math.pow(10, Math.ceil(-Math.log(S) / Math.LN10));
                                    return Math.round(S * P) / P
                                }(b), v * b
                            }(t), m = h / t;
                            this._container.innerHTML = this._isNumberFormatSupported && s !== "nautical-mile" ? new Intl.NumberFormat(this._language, {
                                style: "unit",
                                unitDisplay: "short",
                                unit: s
                            }).format(h) : `${h}&nbsp;${_1[s]}`, this._container.style.width = u * m + "px"
                        })
                    }

                    onAdd(u) {
                        return this._map = u, this._language = u.getLanguage(), this._container = fe("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", u.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container
                    }

                    onRemove() {
                        this._container.remove(), this._map.off("move", this._update), this._map = void 0
                    }

                    _setLanguage(u) {
                        this._language = u, this._update()
                    }

                    setUnit(u) {
                        this.options.unit = u, this._update()
                    }
                },
                FullscreenControl: class {
                    constructor(u = {}) {
                        this._fullscreen = !1, u && u.container && (u.container instanceof HTMLElement ? this._container = u.container : o.w("Full screen control 'container' must be a DOM element.")), o.aV(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in document && (this._fullscreenchange = "webkitfullscreenchange")
                    }

                    onAdd(u) {
                        return this._map = u, this._container || (this._container = this._map.getContainer()), this._controlContainer = fe("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", o.w("This device does not support fullscreen mode.")), this._controlContainer
                    }

                    onRemove() {
                        this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon)
                    }

                    _checkFullscreenSupport() {
                        return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled)
                    }

                    _setupUI() {
                        const u = this._fullscreenButton = fe("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
                        fe("span", "mapboxgl-ctrl-icon", u).setAttribute("aria-hidden", "true"), u.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon)
                    }

                    _updateTitle() {
                        const u = this._getTitle();
                        this._fullscreenButton.setAttribute("aria-label", u), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", u)
                    }

                    _getTitle() {
                        return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
                    }

                    _isFullscreen() {
                        return this._fullscreen
                    }

                    _changeIcon() {
                        (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle())
                    }

                    _onClickFullscreen() {
                        this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen()
                    }
                },
                IndoorControl: jm,
                Popup: class extends o.E {
                    constructor(u) {
                        super(), this.options = o.h(Object.create(y1), u), this._altitude = this.options.altitude, o.aV(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(u && u.className ? u.className.trim().split(/\s+/) : [])
                    }

                    addTo(u) {
                        return this._map && this.remove(), this._map = u, this.options.closeOnClick && u.on("preclick", this._onClose), this.options.closeOnMove && u.on("move", this._onClose), u.on("remove", this.remove), this._update(), u._addPopup(this), this._focusFirstElement(), this._trackPointer ? (u.on("mousemove", this._onMouseEvent), u.on("mouseup", this._onMouseEvent), u._canvasContainer.classList.add("mapboxgl-track-pointer")) : u.on("move", this._update), this.fire(new o.A("open")), this
                    }

                    isOpen() {
                        return !!this._map
                    }

                    remove() {
                        this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
                        const u = this._map;
                        return u && (u.off("move", this._update), u.off("move", this._onClose), u.off("preclick", this._onClose), u.off("click", this._onClose), u.off("remove", this.remove), u.off("mousemove", this._onMouseEvent), u.off("mouseup", this._onMouseEvent), u.off("drag", this._onMouseEvent), u._canvasContainer && u._canvasContainer.classList.remove("mapboxgl-track-pointer"), u._removePopup(this), this._map = void 0), this.fire(new o.A("close")), this
                    }

                    getLngLat() {
                        return this._lngLat
                    }

                    setLngLat(u) {
                        this._lngLat = o.ci.convert(u), this._pos = null, this._trackPointer = !1, this._update();
                        const t = this._map;
                        return t && (t.on("move", this._update), t.off("mousemove", this._onMouseEvent), t._canvasContainer.classList.remove("mapboxgl-track-pointer")), this
                    }

                    getAltitude() {
                        return this._altitude
                    }

                    setAltitude(u) {
                        return this._altitude = u, this._update(), this
                    }

                    trackPointer() {
                        this._trackPointer = !0, this._pos = null, this._update();
                        const u = this._map;
                        return u && (u.off("move", this._update), u.on("mousemove", this._onMouseEvent), u.on("drag", this._onMouseEvent), u._canvasContainer.classList.add("mapboxgl-track-pointer")), this
                    }

                    getElement() {
                        return this._container
                    }

                    setText(u) {
                        return this.setDOMContent(document.createTextNode(u))
                    }

                    setHTML(u) {
                        const t = document.createDocumentFragment(), s = document.createElement("body");
                        let h;
                        for (s.innerHTML = u; h = s.firstChild, h;) t.appendChild(h);
                        return this.setDOMContent(t)
                    }

                    getMaxWidth() {
                        return this._container && this._container.style.maxWidth
                    }

                    setMaxWidth(u) {
                        return this.options.maxWidth = u, this._update(), this
                    }

                    setDOMContent(u) {
                        let t = this._content;
                        if (t) for (; t.hasChildNodes();) t.firstChild && t.removeChild(t.firstChild); else t = this._content = fe("div", "mapboxgl-popup-content", this._container || void 0);
                        if (t.appendChild(u), this.options.closeButton) {
                            const s = this._closeButton = fe("button", "mapboxgl-popup-close-button", t);
                            s.type = "button", s.setAttribute("aria-label", "Close popup"), s.innerHTML = '<span aria-hidden="true">&#215;</span>', s.addEventListener("click", this._onClose)
                        }
                        return this._update(), this._focusFirstElement(), this
                    }

                    addClassName(u) {
                        return this._classList.add(u), this._updateClassList(), this
                    }

                    removeClassName(u) {
                        return this._classList.delete(u), this._updateClassList(), this
                    }

                    setOffset(u) {
                        return this.options.offset = u, this._update(), this
                    }

                    toggleClassName(u) {
                        let t;
                        return this._classList.delete(u) ? t = !1 : (this._classList.add(u), t = !0), this._updateClassList(), t
                    }

                    _onMouseEvent(u) {
                        this._update(u.point)
                    }

                    _getAnchor(u) {
                        if (this.options.anchor) return this.options.anchor;
                        const t = this._map, s = this._container, h = this._pos;
                        if (!t || !s || !h) return "bottom";
                        const m = s.offsetWidth, g = s.offsetHeight, v = h.x < m / 2,
                            b = h.x > t.transform.width - m / 2;
                        if (h.y + u < g) return v ? "top-left" : b ? "top-right" : "top";
                        if (h.y > t.transform.height - g) {
                            if (v) return "bottom-left";
                            if (b) return "bottom-right"
                        }
                        return v ? "left" : b ? "right" : "bottom"
                    }

                    _updateClassList() {
                        const u = this._container;
                        if (!u) return;
                        const t = [...this._classList];
                        t.push("mapboxgl-popup"), this._anchor && t.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t.push("mapboxgl-popup-track-pointer"), u.className = t.join(" ")
                    }

                    _update(u) {
                        const t = this._map, s = this._content;
                        if (!t || !this._lngLat && !this._trackPointer || !s) return;
                        let h = this._container;
                        if (h || (h = this._container = fe("div", "mapboxgl-popup", t.getContainer()), this._tip = fe("div", "mapboxgl-popup-tip", h), h.appendChild(s)), this.options.maxWidth && h.style.maxWidth !== this.options.maxWidth && (h.style.maxWidth = this.options.maxWidth), t.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Ts(this._lngLat, this._pos, t.transform)), !this._trackPointer || u) {
                            const m = this._pos = this._trackPointer && u instanceof o.P ? u : t.project(this._lngLat, this._altitude),
                                g = io(this.options.offset), v = this._anchor = this._getAnchor(g.y),
                                b = io(this.options.offset, v), S = m.add(b).round();
                            t._requestDomTask(() => {
                                this._container && v && (this._container.style.transform = `${Jo[v]} translate(${S.x}px,${S.y}px)`)
                            })
                        }
                        if (!this._marker && t._showingGlobe()) {
                            const m = o.eW(t.transform, this._lngLat) ? 0 : 1;
                            this._setOpacity(m)
                        }
                        this._updateClassList()
                    }

                    _focusFirstElement() {
                        if (!this.options.focusAfterOpen || !this._container) return;
                        const u = this._container.querySelector(Fy);
                        u && u.focus()
                    }

                    _onClose() {
                        this.remove()
                    }

                    _setOpacity(u) {
                        this._container && (this._container.style.opacity = `${u}`), this._content && (this._content.style.pointerEvents = u ? "auto" : "none")
                    }
                },
                Marker: es,
                Style: xs,
                LngLat: o.ci,
                LngLatBounds: o.aG,
                Point: o.P,
                MercatorCoordinate: o.ac,
                FreeCameraOptions: V_,
                Evented: o.E,
                config: o.e,
                prewarm: o.e_,
                clearPrewarmedResources: o.eZ,
                get accessToken() {
                    return o.e.ACCESS_TOKEN
                },
                set accessToken(u) {
                    o.e.ACCESS_TOKEN = u
                },
                get baseApiUrl() {
                    return o.e.API_URL
                },
                set baseApiUrl(u) {
                    o.e.API_URL = u
                },
                get workerCount() {
                    return o.f7.workerCount
                },
                set workerCount(u) {
                    o.f7.workerCount = u
                },
                get maxParallelImageRequests() {
                    return o.e.MAX_PARALLEL_IMAGE_REQUESTS
                },
                set maxParallelImageRequests(u) {
                    o.e.MAX_PARALLEL_IMAGE_REQUESTS = u
                },
                clearStorage(u) {
                    o.f6(u)
                },
                get workerUrl() {
                    return o.f5.workerUrl
                },
                set workerUrl(u) {
                    o.f5.workerUrl = u
                },
                get workerClass() {
                    return o.f5.workerClass
                },
                set workerClass(u) {
                    o.f5.workerClass = u
                },
                get workerParams() {
                    return o.f5.workerParams
                },
                set workerParams(u) {
                    o.f5.workerParams = u
                },
                get dracoUrl() {
                    return o.f4()
                },
                set dracoUrl(u) {
                    o.f3(u)
                },
                get meshoptUrl() {
                    return o.f2()
                },
                set meshoptUrl(u) {
                    o.f1(u)
                },
                setNow: o.q.setNow,
                restoreNow: o.q.restoreNow
            }
        });
        var D = T;
        return D
    })
})(_L);
var r8 = _L.exports;
const yb = vp(r8), o8 = ({token: r}) => {
    const l = Ce.useRef(null), p = Ce.useRef(null);
    return Ce.useEffect(() => {
        if (!l.current || !r) return;
        yb.accessToken = r, p.current = new yb.Map({
            container: l.current,
            style: "mapbox://styles/mapbox/light-v11",
            projection: "globe",
            zoom: 1.5,
            center: [78.9629, 20.5937],
            pitch: 45
        }), p.current.addControl(new yb.NavigationControl({visualizePitch: !0}), "top-right"), p.current.scrollZoom.disable(), p.current.on("style.load", () => {
            var q;
            (q = p.current) == null || q.setFog({
                color: "rgb(255, 255, 255)",
                "high-color": "rgb(200, 200, 225)",
                "horizon-blend": .2
            })
        });
        const y = 240, T = 5, A = 3;
        let D = !1, o = null;

        function j() {
            if (!p.current) return;
            const q = p.current.getZoom();
            if (!D && q < T) {
                let ee = 360 / y;
                if (q > A) {
                    const de = (T - q) / (T - A);
                    ee *= de
                }
                const oe = p.current.getCenter();
                oe.lng -= ee, p.current.easeTo({center: oe, duration: 1e3, easing: de => de})
            }
            o = requestAnimationFrame(j)
        }

        return p.current.on("mousedown", () => {
            D = !0
        }), p.current.on("dragstart", () => {
            D = !0
        }), p.current.on("mouseup", () => {
            D = !1
        }), p.current.on("touchend", () => {
            D = !1
        }), p.current.on("moveend", () => {
            o || j()
        }), j(), () => {
            var q;
            o && cancelAnimationFrame(o), (q = p.current) == null || q.remove()
        }
    }, [r]), K.jsxs("div", {
        className: "relative w-full h-[380px]",
        children: [!r && K.jsx("div", {
            className: "absolute inset-0 z-10 flex items-center justify-center bg-background/70",
            children: K.jsx("p", {
                className: "text-sm text-muted-foreground px-4 text-center",
                children: "Enter your Mapbox public token above to preview the map."
            })
        }), K.jsx("div", {
            ref: l,
            className: "absolute inset-0"
        }), K.jsx("div", {className: "absolute inset-0 pointer-events-none bg-gradient-to-b from-transparent to-background/10"})]
    })
}, s8 = () => {
    const r = typeof window < "u" ? window.location.href : "/contact", {toast: l} = rz(), [p, y] = Ce.useState("");

    function T(A) {
        A.preventDefault(), l({
            title: "Message sent",
            description: "Thanks! We’ll get back to you shortly."
        }), A.currentTarget.reset()
    }

    return K.jsxs("main", {
        className: "min-h-screen",
        children: [K.jsxs(kx, {
            children: [K.jsx("title", {children: "Contact Surajna Group | Business Setup & Trademark"}), K.jsx("meta", {
                name: "description",
                content: "Get in touch for company registration, trademark services, and corporate compliance support."
            }), K.jsx("link", {rel: "canonical", href: r})]
        }), K.jsxs("section", {
            className: "container py-16 grid gap-12 md:grid-cols-2",
            children: [K.jsxs("div", {
                children: [K.jsx("h1", {
                    className: "font-display text-4xl md:text-5xl mb-4",
                    children: "We’re here to help"
                }), K.jsx("p", {
                    className: "text-muted-foreground mb-6",
                    children: "We’re just one call away from your business success!"
                }), K.jsxs("form", {
                    onSubmit: T,
                    className: "space-y-4",
                    children: [K.jsxs("div", {
                        className: "grid grid-cols-1 md:grid-cols-2 gap-4",
                        children: [K.jsx(Gg, {
                            name: "name",
                            placeholder: "Name",
                            required: !0,
                            "aria-label": "Name"
                        }), K.jsx(Gg, {
                            name: "email",
                            type: "email",
                            placeholder: "Email",
                            required: !0,
                            "aria-label": "Email"
                        })]
                    }), K.jsx(Gg, {
                        name: "phone",
                        placeholder: "Phone",
                        "aria-label": "Phone"
                    }), K.jsx(gL, {
                        name: "message",
                        placeholder: "Message",
                        required: !0,
                        "aria-label": "Message"
                    }), K.jsx(yp, {type: "submit", className: "w-full md:w-auto", children: "Send Message"})]
                }), K.jsxs("div", {
                    className: "mt-8 text-sm space-y-1",
                    children: [K.jsx("p", {children: "Email: contact@surajnagroup.in"}), K.jsx("p", {children: "Phone: +91-00000-00000"}), K.jsx("p", {children: "WhatsApp: to be provided"})]
                })]
            }), K.jsxs("div", {
                children: [K.jsx("div", {
                    className: "mb-3 text-sm text-muted-foreground",
                    children: "For production, add your Mapbox public token in Supabase Edge Function Secrets. For now, enter a temporary token to preview the map."
                }), K.jsx(Gg, {
                    value: p,
                    onChange: A => y(A.target.value),
                    placeholder: "Mapbox public token",
                    "aria-label": "Mapbox public token"
                }), K.jsx("div", {
                    className: "mt-4 rounded-lg overflow-hidden border",
                    children: K.jsx(o8, {token: p})
                })]
            })]
        })]
    })
}, a8 = () => {
    const r = Cp();
    return Ce.useEffect(() => {
        console.error("404 Error: User attempted to access non-existent route:", r.pathname)
    }, [r.pathname]), K.jsx("div", {
        className: "min-h-screen flex items-center justify-center bg-gray-100",
        children: K.jsxs("div", {
            className: "text-center",
            children: [K.jsx("h1", {
                className: "text-4xl font-bold mb-4",
                children: "404"
            }), K.jsx("p", {
                className: "text-xl text-gray-600 mb-4",
                children: "Oops! Page not found"
            }), K.jsx("a", {
                href: "/",
                className: "text-blue-500 hover:text-blue-700 underline",
                children: "Return to Home"
            })]
        })
    })
}, l8 = new ZV, c8 = () => K.jsx(YV, {
    client: l8,
    children: K.jsx(SV, {
        children: K.jsxs(KD, {
            children: [K.jsx(o4, {}), K.jsx(F4, {}), K.jsxs(WU, {
                children: [K.jsx(I6, {}), K.jsxs(NU, {
                    children: [K.jsx(Rf, {
                        path: "/",
                        element: K.jsx(t8, {})
                    }), K.jsx(Rf, {path: "/about", element: K.jsx(i8, {})}), K.jsx(Rf, {
                        path: "/blog",
                        element: K.jsx(n8, {})
                    }), K.jsx(Rf, {path: "/contact", element: K.jsx(s8, {})}), K.jsx(Rf, {
                        path: "*",
                        element: K.jsx(a8, {})
                    })]
                }), K.jsx(C6, {})]
            })]
        })
    })
});
nz(document.getElementById("root")).render(K.jsx(c8, {}));
